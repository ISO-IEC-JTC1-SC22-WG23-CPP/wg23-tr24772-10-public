<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>parts/6.02.TypeSystem-IHN.md</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">parts/6.02.TypeSystem-IHN.md</h1>
</header>
<h2 id="IHN">6.2 Type System [IHN]</h2>
<h3 id="applicability-to-language">6.2.1 Applicability to language</h3>
<p>C++ is a statically typed language. In some ways, C++ is both strongly and weakly typed, as it requires all objects/expressions to have a type, but allows for some implicit conversions of values from one type to another type. The following cases require special consideration:</p>
<ul>
<li><p>Most notably are the implicit conversions between arithmetic types (including <code class="sourceCode cpp"><span class="dt">bool</span></code>) that silently might truncate values or have loss of precision (for details see <a href="#FLC">Conversion Errors [FLC]</a>). This shared vulnerability includes <em>integral promotion</em> from small (unsigned) integer types (e.g. <code class="sourceCode cpp"><span class="dt">unsigned</span> <span class="dt">char</span></code>) to the signed integer type <code class="sourceCode cpp"><span class="dt">int</span></code> that can lead to operations with undefined behavior, where unsigned arithmetic is defined with modulo semantics.</p></li>
<li><p>The standard types used to represent text characters ( <code>char</code>, <code>char8_t</code>, <code>wchar_t</code>, <code>char16_t</code>, <code>char32_t</code>) are treated as arithmetic types even when used to represent text and thus are subject to implicit conversions to and from other arithmetic types. Using values of character types in arithmetic expressions, especially together with other types can be confusing. Furthermore, using values of such types or sequences of such values with their corresponding string types with relational operators might not provide an expected sorting order, depending on the language or the encoding the text represents. Libraries for text processing might take such locale-specific or text-representation-specific behavior into account, whereas the built-in operators of the language don’t.</p></li>
<li><p>C++ considers implicit conversions during function overload resolution, when there is not a direct match of argument type with parameter type. Sometimes such conversions lead to ambiguities, which result in a compile error. But there can also be a single best matching overload that does not correspond to developer’s expectation including conversion of argument types (see <a href="#YOW">Identifier Name Reuse [YOW]</a>). Even where the code presently corresponds to programmer expectation, a later addition of code can create a new “better match”, potentially resulting in a silent change of behaviour (see <a href="#BJL">Namespace issues [BJL]</a>, and <a href="#FLC">Conversion Errors [FLC]</a>).</p></li>
<li><p>Values of an unscoped enumeration convert to their underlying integral type in arithmetic expressions (see <a href="#CCB">Enumerator Issues [CCB]</a>).</p></li>
<li><p>Built-in array types as well as function types will decay to a pointer type. For array types this is problematic, because the array’s extent is lost (see <a href="#XYZ">Unchecked Array Indexing [XYZ]</a> and <a href="#RVG">Pointer Arithmetic [RVG]</a>)</p></li>
<li><p>Pointer types implicitly convert to pointer-to-void (see <a href="#HFC">Pointer Type Conversions [HFC]</a>).</p></li>
<li><p>Pointer and reference types referring a derived class object can implicitly convert to a pointer or reference to one of its public base classes respectively (see <a href="#BKK">Polymorphic Variables [BKK]</a>).</p></li>
<li><p>User-defined class types can define conversion operators and converting constructors that can be called with a single argument. If these member functions are not declared with the keyword <code class="sourceCode cpp"><span class="kw">explicit</span></code> they are eligible for use in implicit conversions.</p></li>
<li><p>Implicit conversions from an arithmetic type to <code class="sourceCode cpp"><span class="dt">bool</span></code> often indicate a missing comparison. Conversions from <code class="sourceCode cpp"><span class="dt">bool</span></code> in arithmetic expression can obfuscate code. For example, the following code relies on <code class="sourceCode cpp"><span class="kw">false</span></code> converting to/from zero and <code class="sourceCode cpp"><span class="kw">true</span></code> to one and from non-zero:</p></li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> fluxcompensation(<span class="dt">double</span> flux, <span class="dt">bool</span> compensate){</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (flux) { <span class="co">// double to bool conversion</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> delta = compute_delta();</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="at">const</span> compensate_v = <span class="fl">1.4</span>;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> flux + delta * compensate; <span class="co">// bool to double conversion</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  } </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="fl">1.</span>;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<ul>
<li>In a boolean context, conversions that would not occur implicily can take place, specifically, a pointer-to-bool conversion and the application of an <code class="sourceCode cpp"><span class="kw">explicit</span> <span class="kw">operator</span> <span class="dt">bool</span>()</code> conversion operator. These conversions are idiomatic C++ in boolean contexts; however, some prefer explicit tests to show intent, for example, <code class="sourceCode cpp"><span class="cf">if</span> (p) { *p = <span class="dv">42</span>; }</code> vs. <code class="sourceCode cpp"><span class="cf">if</span> (p != <span class="kw">nullptr</span>) { *p = <span class="dv">42</span>; }</code>.</li>
</ul>
<p>Note that type aliases (<code class="sourceCode cpp"><span class="kw">using</span></code>, <code class="sourceCode cpp"><span class="kw">typedef</span></code>) do not define a different type from their alias just a different name and thus do not incur any conversion between the alias and the aliased type.</p>
<p>Instead of using the built-in arithmetic types or generic library types such as <code class="sourceCode cpp"><span class="bu">std::</span>string</code> for your domain values, C++ allows to wrap them in user-defined-class types as so-called <em>strong types</em>. For integral values, <code class="sourceCode cpp"><span class="kw">enum</span> <span class="kw">class</span></code> types can also be used. Strong types provide only those operator overloads and conversions for each such type that make sense in the application domain. User-defined-literal operators help with providing constants of appropriate strong types. Such strong types provide full control of conversions and operations available, avoiding semantically unsound operations that the built-in or other generic types might provide.</p>
<p>For example, a very simple strong type representation of temperature values can be implemented as follows:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Celsius {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> value;</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Fahrenheit {</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> value;</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>Fahrenheit convert_to_fahrenheit(Celsius c){</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> { <span class="dv">9</span>*c.value/<span class="dv">5</span>+<span class="dv">32</span>};</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">//...</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>Celsius wrong = convert_to_fahrenheit({<span class="fl">20.</span>}); <span class="co">// doesn&#39;t compile</span></span></code></pre></div>
<p>In a realistic scenario using a library for strong type support eases the definition and use of strong types.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.2.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can: - Use the avoidance mechanisms of ISO/IEC TR 24772-1:2019, 6.2.5. and the guidance provided in the different related sections of this document.</p>
<ul>
<li><p>Be aware of the rules of the type system, overload resolution, and implicit conversions to avoid vulnerabilities.</p></li>
<li><p>Enable compiler warnings regarding implicit conversions and/or use static analysis tools that provide such warnings.</p></li>
<li><p>Define any constructor of a class that can be called with a single argument of a different type as <code class="sourceCode cpp"><span class="kw">explicit</span></code>.</p></li>
<li><p>Define any conversion operator as <code class="sourceCode cpp"><span class="kw">explicit</span></code></p></li>
<li><p>Use strong types for domain values instead of the built-in types. On system boundaries, e.g., for input, convert a read value immediately to the appropriate strong type.</p></li>
<li><p>When defining variables of arithmetic type, use a braced-initializer to prevent a potential narrowing conversion from the initial value’s type.</p></li>
<li><p>Avoid the use of the following text-representing character types, <code>char</code>, <code>char8_t</code>, <code>wchar_t</code>, <code>char16_t</code> and <code>char32_t</code>, in arithmetic or relational expressions. Use an appropriate text processing library instead for character classification, conversion, comparison, and further processing.</p></li>
<li><p>Use a consistent style in a project with respect to implicit pointer conversions in boolean contexts.</p></li>
</ul>
</body>
</html>
