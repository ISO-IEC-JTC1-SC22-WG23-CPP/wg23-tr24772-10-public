<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>parts/6.02.TypeSystem-IHN.md</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">parts/6.02.TypeSystem-IHN.md</h1>
</header>
<h2 id="type-system-ihn">6.2 Type System [IHN]</h2>
<h3 id="applicability-to-language">6.2.1 Applicability to language</h3>
<p>C++ allows (silent) implicit conversions between values of a source type to a corresponding value of a destination type under the following circumstances:</p>
<ol type="1">
<li><p>when the destination type is <code class="sourceCode cpp"><span class="dt">bool</span></code> (<em>contextual conversion to bool</em>), for example, when assigning to a bool variable, in the condition of the ternary operator, an <code>if</code> statement, or a loop statement, or with non-overloaded logical operators.</p>
<ul>
<li>from a class type with a conversion operator bool()</li>
<li>from a class type with a non-<code class="sourceCode cpp"><span class="kw">explicit</span></code> conversion operator to a built-in type convertible to bool</li>
<li>from a object or function pointer</li>
<li>from a function name/function reference</li>
<li>from an array name/array reference</li>
<li>from a pointer to member</li>
<li>from an integral type</li>
<li>from a floating point type</li>
<li>from <code class="sourceCode cpp"><span class="dt">nullptr_t</span></code></li>
<li>from an unscoped enumeration</li>
</ul></li>
<li><p>Further implicit conversions with the destination of a built-in type happen:</p>
<ul>
<li>in arithmetic and bitwise expressions combining different built-in types, including unscoped enumeration types. Here, the <em>usual arithmetic conversions</em> including <em>integral promotion</em> happen.</li>
<li>in an assignment, when passing a function argument, or when returning a value from a different built-in type (including <code>bool</code>), from an unscoped enumeration type, or from a class type with a non-<code class="sourceCode cpp"><span class="kw">explicit</span></code> conversion operator to a built-in type.</li>
</ul></li>
<li><p>For class types, implicit conversions can occur with constructors callable with a single argument and by applying conversion operators.</p></li>
<li><p>For references and pointer to class types, implicit conversion to public base class references and pointers respectively is often a desired feature, but it can also lead to changing the type by slicing a value to become a value of one of its base classes. Only when the base class declares virtual member functions, the dynamic type of the object behind a reference or pointer, i.e., the most derived type, remains accessible via calling a virtual member function or via <code>dynamic_cast</code>.</p></li>
<li><p>Furthermore, implicit <em>pointer decay</em> occurs when an array or function object is passed by value as an argument to a function.</p></li>
</ol>
<p>Implicit conversions in expressions can surprise programmers, lead to unwanted function overloads being called and can be a symptom of poor modeling of the application domain.</p>
<p>Explicit conversions can be achieved by type casts. The following C++-specific cast operations are defined by the language:</p>
<ul>
<li><code class="sourceCode cpp"><span class="kw">static_cast</span>&lt;destination&gt;(source)</code> : changes the type by applying implicit or explicit conversion operations available. Usually a safe operation if allowed by the compiler.</li>
<li><code class="sourceCode cpp"><span class="kw">const_cast</span>&lt;destination&gt;(source)</code> : allows adding/removing <code>const</code> (or <code>volatile</code>) qualification from the type of source. Unsafe, if <code>const</code> is removed from the type of an immutable object, which causes undefined behavior.</li>
<li><code class="sourceCode cpp"><span class="kw">dynamic_cast</span>&lt;destination&gt;(source_ref_or_ptr)</code> : allows casting “down” a polymorphic class hierarchy by towards the dynamic type of the object referrenced by the argument.</li>
<li><code class="sourceCode cpp"><span class="kw">reinterpret_cast</span>&lt;destination&gt;(source_value)</code> : potentially dangerous re-interpretation of bits in source_value as type destination. Note, fewer valid re-interpretations of data types than in C exist, because C++ does not allow the structural equivalence of C.</li>
<li><em>C-style casts</em> <code>(destination)source</code> : depending on destination, all of the above casts might happen, therefore, potentially dangerous.</li>
<li>*constructor-….</li>
</ul>
<p><strong>TODO</strong> explicit conversion, further deletion of notes, take MISRA ratinales?</p>
<p>It is possible to use a single type to define two distinct sets of values, e.g., a double could be used to store the distance in kilometers or miles.:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> miles = <span class="fl">5.67</span>;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> km    = <span class="fl">13.88</span>;</span></code></pre></div>
<p>If the same underlying type is used then one risks manipulating such without properly converting the units first, e.g.,</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> distance_travelled = miles + km; <span class="co">// =19.55 (what?)</span></span></code></pre></div>
<p>which will produce an incorrect result. Instead one must define user-defined types with constructors and/or cast operator definitions that will use the type system to correctly convert units. For this example we will use temperatures in Celsius and Fahrenheit.</p>
<!-- the following code is not C++ (confused, Peter) -->
<pre><code>t1 : Celsius := -40.0;
t2 : Fahrenheit := 32.0;</code></pre>
<p>ASIDE: This code works but needs discussion and brevity.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> miles { <span class="dt">double</span> m; };</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> kilometer { <span class="dt">double</span> km; };</span></code></pre></div>
<!-- code example to be reworked by Paul: -->
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> celsius;</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> fahrenheit;</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> celsius</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> val;</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  celsius() : val{} { }</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>  celsius(celsius <span class="at">const</span>&amp;) = <span class="cf">default</span>;            </span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  celsius&amp; <span class="kw">operator</span> =(celsius <span class="at">const</span>&amp;) = <span class="cf">default</span>;</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">explicit</span> celsius(<span class="dt">double</span> <span class="at">const</span>&amp; v) : val{v} { }</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> <span class="at">const</span>&amp; value() <span class="at">const</span> { <span class="cf">return</span> val; }</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>  celsius(fahrenheit <span class="at">const</span>&amp; f);     <span class="co">// permits implicit casts</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">operator</span> fahrenheit() <span class="at">const</span>;      <span class="co">// permits implicit casts</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> fahrenheit</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">// The code for fahrenheit is repeated from celsius with “fahrenheit” </span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>  <span class="co">// replacing “celsius”</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">// and missing the last two declarations. </span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>celsius::celsius(fahrenheit <span class="at">const</span>&amp; f) :</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>  val{ (f.value() - <span class="fl">32.0</span>) * <span class="fl">5.0</span> / <span class="fl">9.0</span> }         <span class="co">// constructor to celsuis</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>celsius::<span class="kw">operator</span> fahrenheit() <span class="at">const</span>    <span class="co">// cast operator to Fahrenheit!!</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> fahrenheit{ (<span class="kw">this</span>-&gt;val * <span class="fl">9.0</span>) / <span class="fl">5.0</span> + <span class="fl">32.0</span> };</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>celsius <span class="kw">operator</span> <span class="st">&quot;&quot;</span> _C(<span class="dt">long</span> <span class="dt">double</span> temp)</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>  { <span class="cf">return</span> celsius(temp); }        <span class="co">// explicit construction w/double</span></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>fahrenheit <span class="kw">operator</span> <span class="st">&quot;&quot;</span> _F(<span class="dt">long</span> <span class="dt">double</span> temp)</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>  { <span class="cf">return</span> fahrenheit(temp); }      <span class="co">// explicit construction w/double</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main()</span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> fp = <span class="fl">0.0</span><span class="dv">_C</span>; <span class="co">// Celsius</span></span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> bp = <span class="fl">212.0</span><span class="dv">_F</span>; <span class="co">// Fahrenheit</span></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>  fahrenheit fp_F = fp; <span class="co">// implicit conversion</span></span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>  celsius bp_C = bp;    <span class="co">// implicit conversion</span></span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>  bp = fp;  <span class="co">// prohibited  ??  See [over.match.best] in C++ standard</span></span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>  fp = bp;  <span class="co">// prohibited </span></span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (fp == bp)…  <span class="co">// is this equality defined??</span></span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>cout &lt;&lt; <span class="st">&quot;Freezing pt: &quot;</span> &lt;&lt; fp &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; fahrenheit{fp} &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; fp_F &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>  cout &lt;&lt; <span class="st">&quot;Boiling pt: &quot;</span> &lt;&lt; celsius{bp} &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; bp_C &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; bp &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>C++ enumeration and class types distinguishes different types with identical structure. In contrast to C, where structural equivalence allows to cast a value from one type as another type with a compatible structure, C++ does have a few cases, (union types, reinterpret_cast) where structurally equivalent types play a role, but those situations come with their own set of vulnerabilities (note: needs section) and should be avoided. Other cases, where C-style casts can be used to reinterpret values as another type, are managed by the use of appropriate C++-style casts (static, const, dynamic, reinterpret), These named casts eliminate many of the issues associated with C-style casts. See clauses 6.6 and 6.37 for a discussion of C++ conversion capabilities and errors.</p>
<p>Note that C++ aliasing mechanisms for types and templates (using, typedef) do not provide new types or templates and thus a type alias is considered identical to its original type.</p>
<p>In addition to user-defined class types (<code class="sourceCode cpp"><span class="kw">struct</span></code>, <code class="sourceCode cpp"><span class="kw">union</span></code>, <code class="sourceCode cpp"><span class="kw">class</span></code>), C++ allows the definition of enumeration types and the construction of reference types, pointer types, array types and function types from other types.</p>
<p>Templates and the use of the keyword <code class="sourceCode cpp"><span class="kw">auto</span></code> permits type-agnostic code that determines free type parameters to be deduced or, additionally in the case of templates, to be specified. C++20 concepts further allow easier formulation of syntactic restrictions on the parameters (see 6.39 Templates and generics).</p>
<p>Forming class hierarchies with virtual member functions in the base class and corresponding overrides in derived classes introduce dynamic typing that can be employed and checked at run-time, when the corresponding object is passed by reference or pointer to one of its base classes (see section <em>(inheritance, polymorphism)</em>). Note, that in constructors and destructors the object pointed to <code class="sourceCode cpp"><span class="kw">this</span></code> is always statically typed.</p>
<p>Since C++ inherits some of the type system of C (arithmetic types and pointers), it suffers similar vulnerabilities, such as those caused by integral promotion, implicit numeric conversion, pointer arithmetic and pointer casts. User-defined class types are vulnerable to unexpected conversions due to implicitly applied converting constructors and conversion operators (see “type conversions”).</p>
<p>On the other hand, C++ provides mechanisms to define strong domain types (without runtime overhead) that allow appropriate operators through overloading, value range control through constructors and encapsulation of data, without implicit or surprising conversions.</p>
<p>There exist a few holes in the type system, often for backward compatibility. See clause …</p>
<blockquote>
<p>AI – Peter, help by Paul – Write up the introduction to this clause following Erhard’s outline.</p>
</blockquote>
<p>C++-style casts eliminate many of the issues associated with C-style casts. See clauses 6.6 and 6.37 for a discussion of C++ conversion capabilities and errors.</p>
<p><em>Material from Richard)</em></p>
<p>Holes in the type system</p>
<p>Shadow type system (explain) – Thoughts. – exception specification don’t participate in a functions types, until they are invoked. (Michael to provide some text in an email). This is only an issue before C++ 17. Fixed by using noexecpt and avoiding throw.</p>
<p>Don't write exception specifications on your functions unless you're forced to (because other code you can't change has already introduced them and/or you are in pre C++17 when dynamic exception was banned or C++20 when empty throw specification was banned to be replaced by noexcept)</p>
<p>A specific issue exists with exceptions in that exception specifications aren't part of a function's type, except when they are. They form a shadow type system whereby writing an exception specification can be:</p>
<ul>
<li><p>Illegal: In a typedef for a pointer to function.</p></li>
<li><p>Allowed: In the identical code without the typedef.</p></li>
<li><p>Required: In the declaration of a virtual function that overrides a base class virtual function that has an exception specification.</p></li>
<li><p>Implicit and automatic: In the declaration of the constructors, assignment operators, and destructors when they are implicitly generated by the compiler.</p></li>
</ul>
<p>A common but incorrect belief is that exception specifications statically guarantee that functions will throw only listed exceptions (possibly none), and will enable compiler optimizations based on that knowledge. Instead, exceptions cause the compiler to inject additional run-time overhead in the form of implicit try/catch blocks around the function body to enforce via run-time checking that the function does in fact emit only listed exceptions (possibly none), unless the compiler can statically prove that the exception specification can never be violated in which case it is free to optimize the checking away. In addition, exception specifications can both enable and prevent further compiler optimizations (besides the inherent overhead already described); for example, some compilers refuse to inline functions that have exception specifications.</p>
<p>When these rules are violated, by default they immediately terminate your program.<span data-custom-style="apple-converted-space"></span></p>
<p>You generally can't write useful exception specifications for function templates anyway, because you generally can't tell what exceptions the types they operate on might throw.</p>
<p>Exceptions : - see 6.36</p>
<p>Incomplete types and operations on incomplete types – usually checked by the compiler but some holes exist, for example when a virtual function is invoked from within a class constructor or destructor.</p>
<p>Mitigation, don’t overload unary <code>&amp;</code> or <code>,</code>, don’t delete an object of an incomplete class type,</p>
<blockquote>
<p>AI – Paul – explain.</p>
</blockquote>
<p>don’t invoke virtual functions in constructors and destructors</p>
<p>High level issues</p>
<p>Note: discuss the problems with unions.</p>
<p><em>NOTE: Ensure that the above explicit text is put into the relevant sections and generalize or forward reference in this section.</em></p>
<p>C++ overloading of operators can cause significant issues. See clause 6.23.</p>
<p>C++ does not enforce consistent <code class="sourceCode cpp"><span class="at">const</span></code> along all access paths to an object. See clause 6.65.</p>
<p><em>13 Feb 2020 - Issue moved here</em> <em>from 6.41(?) Templates and Generics- Templates take a hit because it is possible to invoke a template with a type that does not have all of the operations necessary to correctly execute the operations. For example, if an instantiation of a template type parameter does not implement “&lt;” (or is it “less”?) and the underlying code executes a “sort”, the sort will call whatever “&lt;” it can use. If a “&lt;” had been defined for a related type, then that “&lt;” will be called. The experts at meeting 67 say that this is not exclusive to templates, so the problem should be assigned here and referenced from templates.</em></p>
<p><em>13 Feb 2020 – Another issue appears</em> <em>to be that some primitive types have operations that are inappropriate for the type. For example, the basic type for characters include operators “+”, “-”, “&lt;”, “*” which operate on the underlying integer representation. Passing such types into templates or into a class can result in the fundamental integer operation being called instead of a higher-level operation to perform, for example, comparison on a ISO 8859 character set. The only work-around appears to be to define classes with the fundamental type and legal operations as the only operators.</em></p>
<p><em>Question – how does the “.” Operator interact with such types?(Maybe this comma operator?)</em></p>
<p><em>A recommendation for future revisions of the language could be to provide a way to remove basic operations from types such as enumeration types or characters.</em></p>
<p>References</p>
<ul>
<li><p>CERT section OOP (AI – Aaron to provide others), (note that some of these will likely migrate to other vulnerabilities)x</p>
<ul>
<li><pre><code>  DCL52-CPP. Never qualify a reference type with const or</code></pre>
<p>volatile<br />
(this one is odd because the language makes this an error, but some<br />
compilers like MSVC only warn on it, but will still translate the<br />
source somehow)</p></li>
<li><pre><code>  EXP55-CPP. Do not access a cv-qualified object through a</code></pre>
<p>cv-unqualified type</p></li>
<li><pre><code>  EXP47-C. Do not call va_arg with an argument of the incorrect</code></pre>
<p>type</p></li>
<li><pre><code>  OOP51-CPP. Do not slice derived objects</code></pre></li>
</ul></li>
<li><p>AI – Lisa – look at C++ Core Guidelines for “casts” (-&gt; 6.6)</p>
<ul>
<li></li>
</ul></li>
<li><p>AUTOSAR (AI Peter to work with AUTOSAR to provide references)</p></li>
</ul>
<h3 id="guidance-to-language-users">6.2.2 Guidance to language users</h3>
<p><strong>TODO</strong> consolidate guidance</p>
<p>For specific types discussed in this document, such as floating point types, see the respective clauses.</p>
<p>ADVICE: Prefer to define <code class="sourceCode cpp"><span class="kw">explicit</span></code> constructors and cast operators except in cases where it would be safe and meaningful to permit implicit conversions.</p>
<ul>
<li><p>Be aware of the rules for typing and conversions with fundamental types (i.e., built-in language types) and operators to avoid vulnerabilities.</p>
<ul>
<li><pre><code>  To help aid correctness of code, couple all scalar values (e.g.,</code></pre>
<p><code>double</code>, <code>int</code>, etc.) that have units (e.g., metres, grams, litres, etc.) with suitable types representing those units. This will allow the compiler to generate errors with scalar-with-unit-type-values when they are used with operations that are incompatible.</p></li>
<li><pre><code>  User-defined literals</code></pre>
<p>(This lets you define 15_C and 15_F)</p>
<ul>
<li><pre><code>      *(AI -- Paul -- Write up)*</code></pre></li>
</ul></li>
</ul></li>
<li><p>Make converting constructors and conversion functions <code class="sourceCode cpp"><span class="kw">explicit</span></code> to avoid them being used implicitly or in unexpected ways. (<em>Move to 6.6)</em></p></li>
<li><p>Do not use union without an associated indicator as to which member it holds, alternatively wrap a union in a class with a type field or use C++:17 std::variant (see clause 23.7 of ISO/IEC 14882:2017)</p></li>
<li><p>Use unsigned integer types when manipulating integral values' bits.</p></li>
<li><p>Use one of (not both!) unsigned or signed integral types within expressions to help avoid programming mistakes, consistently</p></li>
<li><p>Treat explicit casts as candidates for code refactoring, i.e., ideally explicit casts should not be required in the code.</p></li>
<li><p>Avoid casting away <code class="sourceCode cpp"><span class="at">const</span></code>:. Doing so can result in undefined behaviour that may not be detectable by the compiler or other tools. Refactor code so that it handles <code class="sourceCode cpp"><span class="at">const</span></code> and non-<code class="sourceCode cpp"><span class="at">const</span></code> types properly. See clause 6.65.</p></li>
<li><p>don’t overload unary ‘<code>&amp;</code>’ or “<code>,</code>”,</p></li>
<li><p>don’t delete an incomplete class type,</p></li>
<li><p>don’t invoke virtual functions in constructors and destructors. See clause 6.43.</p></li>
</ul>
<blockquote>
<p>[+ the guidance already in the document as WG23 decides (or moves to another section or otherwise edits) --there are a lot of items listed]</p>
</blockquote>
<div data-custom-style="Normal (Web)">
<p>From Part 1. The Part 1 guidelines were accepted but are left here for review.</p>
</div>
<ul>
<li><p>Take advantage of any facility offered by the programming language to declare distinct types and use any mechanism provided by the language processor and related tools to check for or enforce type compatibility.</p></li>
<li><p>Use available language and tools facilities to preclude or detect the occurrence of implicit type conversions, such as those in mixed type arithmetic. If it is not possible, use human review to assist in searching for implicit conversions.</p></li>
<li><p>Avoid explicit type conversion of data values except when there is no alternative. Document such occurrences so that the justification is made available to maintainers.</p></li>
<li><p>Use the most restricted data type that suffices to accomplish the job. For example, use an enumeration type to select from a limited set of choices (such as, a switch statement or the discriminant of a union type) rather than a more general type, such as integer. This will make it possible for tooling to check if all possible choices have been covered.</p></li>
<li><p>Always respect the implied unit systems, when converting explicitly from one numeric type to another.</p></li>
</ul>
<p>(Explicit C++ guidance for unit-based types.</p>
<ul>
<li><p>Follow the guidance of TR 24772-1 clause 6.2.5.</p></li>
<li><p>Use distinct C++ types for unit systems if available or define explicit unit-based types.)</p></li>
</ul>
<!-- -->
<ul>
<li><p>Treat every compiler, tool, or run-time diagnostic concerning type compatibility as a serious issue. Do not resolve the problem by modifying the code to include an explicit conversion, without further analysis; instead examine the underlying design to determine if the type error is a symptom of a deeper problem.</p></li>
<li><p><em>Never ignore instances of implicit type conversion; if the conversion is necessary, change it to an explicit conversion and document the rationale for use by maintainers.</em> <em>– narrowing conversions and loss of precision</em></p></li>
<li><p>Analyze the problem to be solved to learn the magnitudes and/or the precisions of the quantities needed as auxiliary variables, partial results and final results.</p></li>
<li><p>Create types that more accurately model the problem domain, with corresponding safe operations and conversions in lieu of using primitive types.</p></li>
<li><p>Minimize use of predefined numeric types whose ranges and precisions are implementation defined. Instead, use types whose ranges and precision are guaranteed.</p></li>
<li><p><em>C++ Issue – Use syntax that forces the compiler to Issue diagnostics on narrowing – need example.</em></p></li>
<li><p>Treat every explicit cast as a candidate for refactoring.</p></li>
<li><p>Use C++ casts rather than C-style casts, as they provide more compile-time checking and are more restrictive in what they can change, - rationale – syntactic distinction – in C++ obvious.</p></li>
<li><p><em>Make class member functions that can be static, ‘<code class="sourceCode cpp"><span class="at">static</span></code>’. Make class member functions that cannot be ‘<code class="sourceCode cpp"><span class="at">static</span></code>’, but can be ‘<code class="sourceCode cpp"><span class="at">const</span></code>’, ‘<code class="sourceCode cpp"><span class="at">const</span></code>’</em></p></li>
<li><p><em>The ‘<code class="sourceCode cpp"><span class="at">mutable</span></code>’ keyword for class member variables should be used sparingly</em></p></li>
<li><p>Don't mix signed and unsigned types in arithmetic</p></li>
<li><p>Follow the advice provided in TR 24772-3 clause 6.2.2. when using C-style numeric types, and implicit conversions. *<br />
</p>
<ul>
<li></li>
</ul></li>
</ul>
</body>
</html>
