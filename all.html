<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>tr24772-10-C++</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div data-custom-style="zzCover">
<p>ISO/IEC JTC 1/SC 22/WG23 N1012</p>
</div>
<div data-custom-style="zzCover">
<p>Date: 2020-11-23</p>
</div>
<div data-custom-style="zzCover">
<p>ISO/IEC TR 24772–10<br />
Notes on this document</p>
</div>
<p>Effective 23 November 2020, this document is being moved to “github”. Contact <span data-custom-style="Hyperlink">Stephen.michell@maurya.on.ca</span> to gain access.</p>
<p>This document is a draft of a Guidance to avoiding programming language vulnerabilities in C++.</p>
<p>At this point in time, the following clauses are essentially completed first pass.</p>
<ul>
<li><pre><code>6.2 type system</code></pre></li>
<li><pre><code>6.3 Bit representation</code></pre></li>
<li><pre><code>6.4 Floating Point</code></pre></li>
<li><pre><code>6.5 Enumerator issues \[CCB\],</code></pre></li>
<li><pre><code>6.6 Conversion errors</code></pre></li>
<li><pre><code>6.7 String termination</code></pre></li>
<li><pre><code>6.8 Buffer boundary violation</code></pre></li>
<li><pre><code>6.9 Unchecked array indexing</code></pre></li>
<li><pre><code>6.10 Unchecked array copying (needs to be revisited)</code></pre></li>
<li><pre><code>6.11 Pointer type conversions</code></pre></li>
<li><pre><code>6.12 Pointer arithmetic</code></pre></li>
<li><pre><code>6.13 Null pointer dereference \[XYH\],</code></pre></li>
<li><pre><code>6.14 Dangling reference to heap</code></pre></li>
<li><pre><code>6.15 Arithmetic wrap-around error</code></pre></li>
<li><pre><code>6.16 Using shift operations for multiplication and division</code></pre></li>
<li><pre><code>6.17 Choice of clear names \[NAI\]</code></pre></li>
<li><pre><code>6.18 Dead Store</code></pre></li>
<li><pre><code>6.19 Unused variables</code></pre></li>
<li><pre><code>6.20 Identifier name reuse</code></pre></li>
<li><pre><code>6.21 Namespace Issues</code></pre></li>
<li><pre><code>6.22 Initialization of variables \[LAV\]</code></pre></li>
<li><pre><code>6.23 Operator precedence and associativity</code></pre></li>
<li><pre><code>6.24 Side effects and order of evaluation</code></pre></li>
<li><pre><code>6.25 Likely incorrect expression</code></pre></li>
<li><pre><code>6.26 Dead store,</code></pre></li>
<li><pre><code>6.27 Switch statements and static analysis</code></pre></li>
<li><pre><code>6.28 Demarcation of control flow</code></pre></li>
<li><pre><code>6.29 Loop control variables</code></pre></li>
<li><pre><code>6.30 Off-by-one errors</code></pre></li>
<li><pre><code>6.31 Structured programming</code></pre></li>
<li><pre><code>6.32 Passing parameters and return values</code></pre></li>
<li><pre><code>6.33 Dangling references to stack frames</code></pre></li>
<li><pre><code>6.34 Subprogram signature mismatch</code></pre></li>
<li><pre><code>6.35 Recursion</code></pre></li>
<li><pre><code>6.36 Ignored error status and unhandled exceptions</code></pre></li>
<li><pre><code>6.37 Type breaking reinterpretation of data</code></pre></li>
<li><pre><code>6.38 Deep vs shallow copying \[YAN\]</code></pre></li>
<li><pre><code>6.39 Memory leak and heap fragmentation</code></pre></li>
<li><pre><code>6.41 Inheritance</code></pre></li>
<li><pre><code>6.42 Violations of the Liskov substitution principle</code></pre></li>
<li><pre><code>6.43 Redispatching</code></pre></li>
<li><pre><code>6.44 Polymorphic variables</code></pre></li>
<li><pre><code>6.45 Extra intrinsics</code></pre></li>
<li><pre><code>6.46 Argument passing to library functions</code></pre></li>
<li><pre><code>6.47 Inter-language calling</code></pre></li>
<li><pre><code>6.48 Dynamically-linked code and self-modifying code \[NYY\]</code></pre></li>
<li><pre><code>6.49 Library Signature</code></pre></li>
<li><pre><code>6.50 Unanticipated exceptions from library routines</code></pre></li>
<li><pre><code>6.51 Pre-processor directives</code></pre></li>
<li><pre><code>6.52 Suppression of language-defined run-time checking</code></pre></li>
<li><pre><code>6.53 Provision of inherently unsafe operations</code></pre></li>
<li><pre><code>6.54 Obscure language features</code></pre></li>
<li><pre><code>6.55 Unspecified behaviour</code></pre></li>
<li><pre><code>6.56 Undefined behaviour</code></pre></li>
<li><pre><code>6.57 Implementation-defined behaviour</code></pre></li>
<li><pre><code>6.58 Deprecated language features</code></pre></li>
<li><pre><code>6.59 Concurrency \-- Activation</code></pre></li>
<li><pre><code>6.60 Concurrency -- Directed termination</code></pre></li>
<li><pre><code>6.64 Uncontrolled format string</code></pre></li>
</ul>
<div data-custom-style="Normal (Web)">
<p>TBD</p>
</div>
<ul>
<li><pre><code>6.2 Type system -- issues being fed from 6.40 and elsewhere</code></pre></li>
<li><pre><code>6.61 Concurrent data access</code></pre></li>
<li><pre><code>6.62 Concurrency -- Premature termination</code></pre></li>
<li><pre><code>6.63 Protocol lock errors</code></pre></li>
</ul>
<div data-custom-style="Normal (Web)">
<p>Participants at meeting 23 November 2020</p>
</div>
<p>Stephen Michell</p>
<p>Paul Preney</p>
<p>Peter Sommerlad</p>
<p>Richard Corden</p>
<p>Erhard Ploedereder</p>
<p>Clive Pygott</p>
<p>Michael Wong</p>
<!-- Here we include stuff... with pandoc-include filter -->
<div data-custom-style="zzCover">
<p>Edition 1</p>
</div>
<div data-custom-style="zzCover">
<p>ISO/IEC JTC 1/SC 22/WG 23</p>
</div>
<div data-custom-style="zzCover">
<p>Secretariat: ANSI</p>
</div>
<div data-custom-style="Bibliography1">
<p>Information Technology — Programming languages — Guidance to avoiding vulnerabilities in programming languages – Part 10 – Vulnerability descriptions for the programming language C++</p>
</div>
<div data-custom-style="zzCover">
<p>Document type: International standard</p>
</div>
<div data-custom-style="zzCover">
<p>Document subtype: if applicable</p>
</div>
<div data-custom-style="zzCover">
<p>Document stage: (10) development stage</p>
</div>
<div data-custom-style="zzCover">
<p>Document language: E</p>
</div>
<p><em>Élément introductif — Élément principal — Partie n: Titre de la partie</em></p>
<div data-custom-style="zzCover">
<p>Warning</p>
</div>
<div data-custom-style="zzCover">
<p>This document is not an ISO International Standard. It is distributed for review and comment. It is subject to change without notice and may not be referred to as an International Standard.</p>
</div>
<div data-custom-style="zzCover">
<p>Recipients of this draft are invited to submit, with their comments, notification of any relevant patent rights of which they are aware and to provide supporting documentation.</p>
</div>
<div data-custom-style="zzCopyright">
<p><strong>Copyright notice</strong></p>
</div>
<div data-custom-style="zzCopyright">
<p>This ISO document is a working draft or committee draft and is copyright-protected by ISO. While the reproduction of working drafts or committee drafts in any form for use by participants in the ISO standards development process is permitted without prior permission from ISO, neither this document nor any extract from it may be reproduced, stored or transmitted in any form for any other purpose without prior written permission from ISO.</p>
</div>
<div data-custom-style="zzCopyright">
<p>Requests for permission to reproduce this document for the purpose of selling it should be addressed as shown below or to ISO’s member body in the country of the requester:</p>
</div>
<div data-custom-style="zzCopyright">
<p><em>ISO copyright office</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>Case postale 56, CH-1211 Geneva 20</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>Tel. + 41 22 749 01 11</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>Fax + 41 22 749 09 47</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>E-mail copyright@iso.org</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>Web www.iso.org</em></p>
</div>
<div data-custom-style="zzCopyright">
<p>Reproduction for sales purposes may be subject to royalty payments or a licensing agreement.</p>
</div>
<div data-custom-style="zzCopyright">
<p>Violators may be prosecuted.</p>
</div>
<div data-custom-style="zzContents">
<p>Contents Page</p>
</div>
<div data-custom-style="toc 1">
<p><a href="#foreword"><span data-custom-style="Hyperlink">Foreword</span> vii</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#introduction"><span data-custom-style="Hyperlink">Introduction</span> viii</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#scope"><span data-custom-style="Hyperlink">1. Scope</span> 1</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#normative-references"><span data-custom-style="Hyperlink">2. Normative references</span> 1</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#terms-and-definitions-symbols-and-conventions"><span data-custom-style="Hyperlink">3. Terms and definitions, symbols and conventions</span> 1</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#terms-and-definitions"><span data-custom-style="Hyperlink">3.1 Terms and definitions</span> 1</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#language-concepts"><span data-custom-style="Hyperlink">4. Language concepts</span> 4</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#section"><span data-custom-style="Hyperlink">5. Avoiding programming language vulnerabilities in C++</span> 4</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#specific-guidance-for-c-vulnerabilities"><span data-custom-style="Hyperlink">6. Specific Guidance for C++ Vulnerabilities</span> 6</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#general"><span data-custom-style="Hyperlink">6.1 General</span> 6</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#type-system-ihn"><span data-custom-style="Hyperlink">6.2 Type System [IHN]</span> 6</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#bit-representations-str"><span data-custom-style="Hyperlink">6.3 Bit Representations [STR]</span> 7</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#floating-point-arithmetic-plf"><span data-custom-style="Hyperlink">6.4 Floating-point Arithmetic [PLF]</span> 8</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#enumerator-issues-ccb"><span data-custom-style="Hyperlink">6.5 Enumerator Issues [CCB]</span> 8</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc1165233"><span data-custom-style="Hyperlink">6.6 Conversion Errors [FLC]</span> 9</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#string-termination-cjm"><span data-custom-style="Hyperlink">6.7 String Termination [CJM]</span> 10</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc1165235"><span data-custom-style="Hyperlink">•</span> <span data-custom-style="Hyperlink">Use std::string or similar, in preference to C-style arrays of chars</span> 11</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#buffer-boundary-violation-hcb"><span data-custom-style="Hyperlink">6.8 Buffer Boundary Violation [HCB]</span> 11</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unchecked-array-indexing-xyz"><span data-custom-style="Hyperlink">6.9 Unchecked Array Indexing [XYZ]</span> 12</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unchecked-array-copying-xyw"><span data-custom-style="Hyperlink">6.10 Unchecked Array Copying [XYW]</span> 13</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#pointer-type-conversions-hfc"><span data-custom-style="Hyperlink">6.11 Pointer Type Conversions [HFC]</span> 13</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#pointer-arithmetic-rvg"><span data-custom-style="Hyperlink">6.12 Pointer Arithmetic [RVG]</span> 15</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#null-pointer-dereference-xyh"><span data-custom-style="Hyperlink">6.13 NULL Pointer Dereference [XYH]</span> 16</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dangling-reference-to-heap-xyk"><span data-custom-style="Hyperlink">6.14 Dangling Reference to Heap [XYK]</span> 16</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#arithmetic-wrap-around-error-fif"><span data-custom-style="Hyperlink">6.15 Arithmetic Wrap-around Error [FIF]</span> 18</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#using-shift-operations-for-multiplication-and-division-pik"><span data-custom-style="Hyperlink">6.16 Using Shift Operations for Multiplication and Division [PIK]</span> 18</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#choice-of-clear-names-nai"><span data-custom-style="Hyperlink">6.17 Choice of Clear Names [NAI]</span> 19</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dead-store-wxq"><span data-custom-style="Hyperlink">6.18 Dead Store [WXQ]</span> 19</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unused-variable-yzs"><span data-custom-style="Hyperlink">6.19 Unused Variable [YZS]</span> 20</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#identifier-name-reuse-yow"><span data-custom-style="Hyperlink">6.20 Identifier Name Reuse [YOW]</span> 20</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc310518176"><span data-custom-style="Hyperlink">6.21 Namespace Issues [BJL]</span> 21</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#initialization-of-variables-lav"><span data-custom-style="Hyperlink">6.22 Initialization of Variables [LAV]</span> 21</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#operator-precedence-and-associativity-jcw"><span data-custom-style="Hyperlink">6.23 Operator Precedence and Associativity [JCW]</span> 21</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#side-effects-and-order-of-evaluation-of-operands-sam"><span data-custom-style="Hyperlink">6.24 Side-effects and Order of Evaluation of Operands [SAM]</span> 21</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#likely-incorrect-expression-koa"><span data-custom-style="Hyperlink">6.25 Likely Incorrect Expression [KOA]</span> 22</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dead-and-deactivated-code-xyq"><span data-custom-style="Hyperlink">6.26 Dead and Deactivated Code [XYQ]</span> 24</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#switch-statements-and-static-analysis-cll"><span data-custom-style="Hyperlink">6.27 Switch Statements and Static Analysis [CLL]</span> 24</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#demarcation-of-control-flow-eoj"><span data-custom-style="Hyperlink">6.28 Demarcation of Control Flow [EOJ]</span> 25</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#loop-control-variables-tex"><span data-custom-style="Hyperlink">6.29 Loop Control Variables [TEX]</span> 26</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#off-by-one-error-xzh"><span data-custom-style="Hyperlink">6.30 Off-by-one Error [XZH]</span> 27</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#structured-programming-ewd"><span data-custom-style="Hyperlink">6.31 Structured Programming [EWD]</span> 28</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#passing-parameters-and-return-values-csj"><span data-custom-style="Hyperlink">6.32 Passing Parameters and Return Values [CSJ]</span> 28</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dangling-references-to-stack-frames-dcm"><span data-custom-style="Hyperlink">6.33 Dangling References to Stack Frames [DCM]</span> 29</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#subprogram-signature-mismatch-otr"><span data-custom-style="Hyperlink">6.34 Subprogram Signature Mismatch [OTR]</span> 30</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#recursion-gdl"><span data-custom-style="Hyperlink">6.35 Recursion [GDL]</span> 31</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#ignored-error-status-and-unhandled-exceptions-oyb"><span data-custom-style="Hyperlink">6.36 Ignored Error Status and Unhandled Exceptions [OYB]</span> 31</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#type-breaking-reinterpretation-of-data-amv"><span data-custom-style="Hyperlink">6.37 Type-breaking Reinterpretation of Data [AMV]</span> 32</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#deep-vs.-shallow-copying-yan"><span data-custom-style="Hyperlink">6.38 Deep vs. Shallow Copying [YAN]</span> 33</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#memory-leak-and-heap-fragmentation-xyl"><span data-custom-style="Hyperlink">6.39 Memory Leak and Heap Fragmentation [XYL]</span> 33</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#templates-and-generics-sym"><span data-custom-style="Hyperlink">6.40 Templates and Generics [SYM]</span> 34</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#inheritance-rip"><span data-custom-style="Hyperlink">6.41 Inheritance [RIP]</span> 35</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#applicability-to-language-39"><span data-custom-style="Hyperlink">6.41.1 Applicability to language</span> 35</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-37"><span data-custom-style="Hyperlink">6.41.2 Guidance to language users</span> 37</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#violations-of-the-liskov-substitution-principle-or-the-contract-model-blp"><span data-custom-style="Hyperlink">6.42 Violations of the Liskov Substitution Principle or the Contract Model [BLP]</span> 37</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#applicability-to-language-40"><span data-custom-style="Hyperlink">6.42.1 Applicability to language</span> 37</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-38"><span data-custom-style="Hyperlink">6.42.2 Guidance to language users</span> 38</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#redispatching-pph"><span data-custom-style="Hyperlink">6.43 Redispatching [PPH]</span> 38</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#applicability-to-language-41"><span data-custom-style="Hyperlink">6.43.1 Applicability to language</span> 38</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-39"><span data-custom-style="Hyperlink">6.43.2 Guidance to language users</span> 39</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#polymorphic-variables-bkk"><span data-custom-style="Hyperlink">6.44 Polymorphic variables [BKK]</span> 39</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#applicability-to-language-42"><span data-custom-style="Hyperlink">6.44.1 Applicability to language</span> 40</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-40"><span data-custom-style="Hyperlink">6.44.2 Guidance to language users</span> 41</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#extra-intrinsics-lrm"><span data-custom-style="Hyperlink">6.45 Extra Intrinsics [LRM]</span> 42</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#argument-passing-to-library-functions-trj"><span data-custom-style="Hyperlink">6.46 Argument Passing to Library Functions [TRJ]</span> 42</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#inter-language-calling-djs"><span data-custom-style="Hyperlink">6.47 Inter-language Calling [DJS]</span> 42</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dynamically-linked-code-and-self-modifying-code-nyy"><span data-custom-style="Hyperlink">6.48 Dynamically-linked Code and Self-modifying Code [NYY]</span> 45</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#library-signature-nsq"><span data-custom-style="Hyperlink">6.49 Library Signature [NSQ]</span> 46</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unanticipated-exceptions-from-library-routines-hjw"><span data-custom-style="Hyperlink">6.50</span> <span data-custom-style="Hyperlink">Unanticipated Exceptions from Library Routines [HJW]</span> 47</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#pre-processor-directives-nmp"><span data-custom-style="Hyperlink">6.51 Pre-processor Directives [NMP]</span> 48</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#suppression-of-language-defined-run-time-checking-mxb"><span data-custom-style="Hyperlink">6.52 Suppression of Language-defined Run-time Checking [MXB]</span> 49</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#provision-of-inherently-unsafe-operations-skl"><span data-custom-style="Hyperlink">6.53 Provision of Inherently Unsafe Operations [SKL]</span> 49</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#obscure-language-features-brs"><span data-custom-style="Hyperlink">6.54 Obscure Language Features [BRS]</span> 49</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unspecified-behaviour-bqf"><span data-custom-style="Hyperlink">6.55 Unspecified Behaviour [BQF]</span> 50</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#undefined-behaviour-ewf"><span data-custom-style="Hyperlink">6.56 Undefined Behaviour [EWF]</span> 50</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#implementationdefined-behaviour-fab"><span data-custom-style="Hyperlink">6.57 Implementation–defined Behaviour [FAB]</span> 51</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#deprecated-language-features-mem"><span data-custom-style="Hyperlink">6.58 Deprecated Language Features [MEM]</span> 52</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#concurrency-activation-cga"><span data-custom-style="Hyperlink">6.59 Concurrency – Activation [CGA]</span> 52</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#concurrency-directed-termination-cgt"><span data-custom-style="Hyperlink">6.60 Concurrency – Directed termination [CGT]</span> 52</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc1165297"><span data-custom-style="Hyperlink">6.60.1 Applicability to language</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-55"><span data-custom-style="Hyperlink">6.60.2 Guidance to language users</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc1165299"><span data-custom-style="Hyperlink">6.61 Concurrent Data Access [CGX]</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#concurrency-premature-termination-cgs"><span data-custom-style="Hyperlink">6.62 Concurrency – Premature Termination [CGS]</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#protocol-lock-errors-cgm"><span data-custom-style="Hyperlink">6.63 Protocol Lock Errors [CGM]</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#uncontrolled-format-string-shl"><span data-custom-style="Hyperlink">6.64 Uncontrolled Format String [SHL]</span> 54</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#language-specific-vulnerabilities-for-c"><span data-custom-style="Hyperlink">7. Language specific vulnerabilities for C</span> 54</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#implications-for-standardization"><span data-custom-style="Hyperlink">8. Implications for standardization</span> 54</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#bibliography"><span data-custom-style="Hyperlink">Bibliography</span> 57</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#index"><span data-custom-style="Hyperlink">Index</span> 60</a></p>
</div>
<h1 id="foreword">Foreword</h1>
<p>ISO (the International Organization for Standardization) and IEC (the International Electrotechnical Commission) form the specialized system for worldwide standardization. National bodies that are members of ISO or IEC participate in the development of International Standards through technical committees established by the respective organization to deal with particular fields of technical activity. ISO and IEC technical committees collaborate in fields of mutual interest. Other international organizations, governmental and non-governmental, in liaison with ISO and IEC, also take part in the work. In the field of information technology, ISO and IEC have established a joint technical committee, ISO/IEC JTC 1.</p>
<p>International Standards are drafted in accordance with the rules given in the ISO/IEC Directives, Part 2.</p>
<p>The main task of the joint technical committee is to prepare International Standards. Draft International Standards adopted by the joint technical committee are circulated to national bodies for voting. Publication as an International Standard requires approval by at least 75 % of the national bodies casting a vote.</p>
<p>In exceptional circumstances, when the joint technical committee has collected data of a different kind from that which is normally published as an International Standard (“state of the art”, for example), it may decide to publish a Technical Report. A Technical Report is entirely informative in nature and shall be subject to review every five years in the same manner as an International Standard.</p>
<p>Attention is drawn to the possibility that some of the elements of this document may be the subject of patent rights. ISO and IEC shall not be held responsible for identifying any or all such patent rights.</p>
<p>ISO/IEC TR 24772-10, was prepared by Joint Technical Committee ISO/IEC JTC 1, <em>Information technology</em>, Subcommittee SC 22, <em>Programming languages, their environments and system software interfaces</em>.</p>
<h1 id="introduction">Introduction</h1>
<div data-custom-style="zzHelp">
<p>This Technical Report provides guidance for the programming language C++, so that application developers using or considering C++ will be better able to avoid the programming constructs that lead to vulnerabilities in software written in the C++ language and their attendant consequences. This guidance can also be used by developers to select source code evaluation tools that can discover and eliminate some constructs that could lead to vulnerabilities in their software. This report can also be used in comparison with companion Technical Reports and with the language-independent report, TR 24772–1, to select a programming language that provides the appropriate level of confidence that anticipated problems can be avoided.</p>
</div>
<div data-custom-style="zzHelp">
<p>This technical report part is intended to be used with TR 24772–1, which discusses programming language vulnerabilities in a language independent fashion. It is also intended to be used with TR 24772-3, which discusses how the vulnerabilities introduced in TR 24772-1 are manifested in C, which is a subset of C++.</p>
</div>
<p>It should be noted that this Technical Report is inherently incomplete. It is not possible to provide a complete list of programming language vulnerabilities because new weaknesses are discovered continually. Any such report can only describe those that have been found, characterized, and determined to have sufficient probability and consequence.</p>
<div data-custom-style="Bibliography1">
<p><strong>Information Technology — Programming Languages — Guidance to avoiding vulnerabilities in programming languages — Vulnerability descriptions for the programming language C++</strong></p>
</div>
<h1 id="scope">1. Scope</h1>
<p>This Technical Report specifies software programming language vulnerabilities to be avoided in the development of systems where assured behaviour is required for security, safety, mission-critical and business-critical software. In general, this guidance is applicable to the software developed, reviewed, or maintained for any application.</p>
<p>Vulnerabilities described in this Technical Report document the way that the vulnerability described in the language-independent TR 24772–1 are manifested in C++.</p>
<h1 id="normative-references">2. Normative references</h1>
<p>The following referenced documents are indispensable for the application of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.</p>
<p>ISO/IEC 14882:2014 — <em>Programming Languages—C</em> ++</p>
<p>ISO/IEC TR24772–3 -- Information Technology — Programming Languages — Guidance to avoiding vulnerabilities in programming languages — Vulnerability descriptions for the programming language C</p>
<h1 id="terms-and-definitions-symbols-and-conventions">3. Terms and definitions, symbols and conventions</h1>
<h2 id="terms-and-definitions">3.1 Terms and definitions</h2>
<!-- TODO: needs formatting adjustment as of ISO word template document -->
<p>For the purposes of this document, the terms and definitions given in ISO/IEC 2382, in TR 24772–1, in 14882:2014 and the following apply. Other terms are defined where they appear in <em>italic</em> type.</p>
<p>The following terms are in alphabetical order, with general topics referencing the relevant specific terms.</p>
<p><u>3.1.1</u></p>
<p><u>TBD</u></p>
<p><u>3.1.2</u></p>
<p><u>access</u>:</p>
<p>An execution-time action, to read or modify the value of an object.</p>
<blockquote>
<p>Note 1: Where only one of two actions is meant, read or modify. Modify includes the case where the new value being stored is the same as the previous value. Expressions that are not evaluated do not access objects</p>
</blockquote>
<p><strong><u>3.1.3</u></strong></p>
<p>access protection</p>
<p><strong><u>ADL</u></strong><br />
</p>
<p>argument dependent lookup</p>
<p><strong><u>alignment</u></strong><br />
requirement that objects of a particular type be located on storage boundaries with addresses that are particular multiples of a byte address</p>
<p><strong><u>3.1.3</u></strong></p>
<p><strong><u>argument</u></strong><br />
the expression in the comma-separated list bounded by the parentheses in a function call expression, or a sequence of preprocessing tokens in the comma-separated list bounded by the parentheses in a function-like macro invocation</p>
<blockquote>
<p>Note 1: Also called actual argument</p>
<p>Note 2: An argument replaces a <em>formal parameter</em> as the call is realized.</p>
</blockquote>
<p><strong><u>3.??</u></strong></p>
<p>argument dependent lookup</p>
<p>lookup that finds additional overloads from the namespaces of the types of the arguments used in unqualified function calls</p>
<p><strong><u>3.1.4</u></strong></p>
<p><strong><u>behaviour</u></strong><br />
an external appearance or action [recommend removal - standard comp sci term]</p>
<p><strong><u>3.1.5</u></strong></p>
<p><strong><u>bit</u></strong><br />
the unit of data storage in the execution environment large enough to hold an object that may have one of two values</p>
<p>Note: It need not be possible to express the address of each individual bit of an object [recommend removal - standard comp sci term]</p>
<p><strong><u>3.1.6</u></strong></p>
<p><strong><u>byte</u></strong><br />
the addressable unit of data storage large enough to hold any member of the basic character set of the execution environment</p>
<blockquote>
<p>Note: It is possible to express the address of each individual byte of an object uniquely. A byte is composed of a contiguous sequence of bits, the number of which is implementation-defined. The least significant bit is called the low-order bit; the most significant bit is called the high-order bit. [recommend removal - standard comp sci term]</p>
</blockquote>
<p><strong><u>3.1.7</u></strong></p>
<p><strong><u>character</u></strong><br />
abstract member of a set of elements used for the organization, control, or representation of data and ideally when treated sequentially represents text</p>
<p><strong><u>correctly rounded result</u></strong><br />
representation in the result format that is nearest in value, subject to the current rounding mode, to what the result would be given unlimited range and precision</p>
<p><strong><u>3.1.8</u></strong></p>
<p><strong><u>class</u></strong><br />
a user-defined type declared with the class-key ‘class’ or ‘struct’ {.ul}</p>
<p><strong><u>3.1.9</u></strong></p>
<p><strong><u>concrete</u></strong><br />
</p>
<p>Recommend deletion, only used in 6.40 Templates and Generics</p>
<p><strong><u>3.1.10</u></strong></p>
<p><strong><u>diagnostic message</u></strong><br />
</p>
<p>informational message that is either an error or warning about an issue detected by the implementation</p>
<p><strong>[3.1.11]</strong>{.ul}**<br />
</p>
<p><strong><u>dynamic dispatch</u></strong><br />
</p>
<p>[recommend removal] {.ul}</p>
<p>3.1.12</p>
<p><strong><u>encapsulation</u></strong><br />
</p>
<p><u>recommend removal - all usages in the document satisfy standard English use of encapsulate</u></p>
<p><strong><u>3.1.13</u></strong><br />
</p>
<p><strong><u>formal parameter</u></strong><br />
</p>
<p>object declared as part of a function declaration or definition that acquires a value on entry to the function, or an identifier from the comma-separated list bounded by the parentheses immediately following the macro name in a function-like macro definition.</p>
<p><strong>[3.1.xx] friend{.ul}</strong><br />
</p>
<p>function or class that can access the private and protected members of a specific class</p>
<p><strong>[3.1.xx] hidden friend{.ul}</strong><br />
</p>
<p>friend function that is only declared within a class or class template definition and hence is only found by ADL</p>
<p><strong><u>3.1.xx</u></strong><br />
</p>
<p><strong><u>Implementation</u></strong><br />
</p>
<p>toolchain that is used to build and support the execution of the C++ program</p>
<p><strong><u>3.1.15</u></strong><br />
</p>
<p><strong><u>implementation-defined behaviour</u></strong><br />
</p>
<p>behaviour, for a well-formed program construct and correct data, that depends on the implementation and that each implementation documents</p>
<p><strong><u>3.1.16</u></strong><br />
<strong><u>implementation-defined value</u></strong><br />
</p>
<p>unspecified value where each implementation documents how the choice for the value is selected. [recommend removal - term not use other than note(s)]</p>
<p><strong><u>3.1.17</u></strong><br />
</p>
<p><strong><u>implementation limit</u></strong><br />
</p>
<p>restriction imposed upon programs by the implementation.</p>
<p><strong><u>3.1.18</u></strong><br />
</p>
<p><strong><u>indeterminate value</u></strong><br />
</p>
<p>unspecified value or a trap representation</p>
<p><strong><u>3.1.19</u></strong><br />
<strong><u>indeterminately sequenced</u></strong><br />
</p>
<p>sequenced in a way that one of two evaluations will be executed before the other but in an unspecified order</p>
<p><strong><u>3.1.20</u></strong><br />
</p>
<p><strong><u>Inheritance</u></strong><br />
</p>
<p>TBD [recommend removal - well understood in OO languages]</p>
<p><strong><u>3.1.21</u></strong><br />
</p>
<p><strong><u>language type</u></strong><br />
</p>
<p>see block-structured language, comb-structured language (Non-responsive) [recommended removal - inadequate relevancy]</p>
<p><strong><u>3.1.21</u></strong><br />
</p>
<p><strong><u>locale-specific behaviour</u></strong><br />
</p>
<p>behaviour that depends on local conventions of nationality, culture, and language that each implementation documents</p>
<p><strong><u>3.1.22</u></strong><br />
</p>
<p><strong><u>memory location</u></strong><br />
</p>
<p>an object of scalar type or a maximal sequence of adjacent bit-fields all having nonzero width [recommend removal and move to 6.3]</p>
<p><strong><u>3.23</u></strong><br />
<strong><u>multibyte character</u></strong><br />
</p>
<p>sequence of one or more bytes representing a member of the extended character set of either the source or the execution environment.</p>
<p>Note: The extended character set is a superset of the basic character set. [Recommend removal - not used]</p>
<p><strong><u>3.1.24</u></strong><br />
<strong><u>namespace</u></strong><br />
optionally-named entity that can contain scoped declarations of any kind of entity [ensure that this is put into clause 4 on general concepts]</p>
<p><strong><u>3.25</u></strong><br />
</p>
<p><strong><u>object</u></strong><br />
</p>
<p>region of data storage in the execution environment, the contents of which can represent values and that can be interpreted as having a particular type</p>
<p><strong><u>3.1.26</u></strong><br />
</p>
<p><strong><u>overload</u></strong><br />
</p>
<p>the use of the same symbol name to denote different entities</p>
<p><strong><u>3.1.27</u></strong><br />
</p>
<p><strong><u>override</u></strong><br />
</p>
<p>replacing the implementation of an inheritable function in a derived class</p>
<p><strong><u>3.1.28</u></strong><br />
</p>
<p><strong><u>parameter</u></strong><br />
</p>
<p>(rewrite) See actual argument, argument, formal parameter (Non-responsive, needs definition)</p>
<p>[Remove - obvious]</p>
<p><strong><u>3.1.29</u></strong><br />
</p>
<p><strong>{Protected]{.ul}</strong><br />
</p>
<p>visible only to itself and derived classes and friends</p>
<p><strong><u>3.1.30</u></strong><br />
</p>
<p><strong><u>private</u></strong><br />
</p>
<p>visible only to the class itself and friends</p>
<p><strong><u>3.1.31</u></strong><br />
</p>
<p><strong><u>Public</u></strong><br />
</p>
<p>visible without restriction</p>
<p><strong><u>3.1.33</u></strong><br />
</p>
<p><strong><u>recommended practice</u></strong><br />
</p>
<p>specification that is strongly recommended as being in keeping with the intent of the language standard, but that may be impractical for some implementations</p>
<p>[recommend removal - not used] **<u>3.1.34</u>((<br />
</p>
<p><strong><u>runtime-constraint</u></strong><br />
</p>
<p>a constraint imposed on an executing program [TBD - needs refinement] [continue from here - 7 August 2023]</p>
<p><strong><u>3.1.35</u></strong><br />
</p>
<p><strong><u>single-byte character</u></strong><br />
</p>
<p>bit representation that fits in a byte (binary representation?)</p>
<p><strong><u>3.1.36</u></strong><br />
</p>
<p><strong><u>static</u></strong><br />
</p>
<p><u>TBD</u></p>
<p>**<u>3.1.37</u></p>
<p><strong><u>STL</u></strong><br />
</p>
<p><u>TBD</u></p>
<p><strong><u>3.1.38</u></strong><br />
</p>
<p><strong><u>standard library</u></strong><br />
</p>
<p>[TBD]</p>
<p><strong><u>3.1.39</u></strong><br />
</p>
<p><strong><u>template</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.40</u></strong><br />
</p>
<p><strong><u>trap representation</u></strong><br />
</p>
<p>object representation that need not represent a value of the object type</p>
<p><strong><u>3.1.41</u></strong><br />
</p>
<p><strong><u>undefined behaviour</u></strong><br />
</p>
<p>use of a non-portable or erroneous program construct or of erroneous data, for which the language standard imposes no requirements</p>
<blockquote>
<p>Note: Undefined behaviour ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message). An example of, undefined behaviour is the behaviour on integer overflow.</p>
</blockquote>
<p><strong><u>3.1.42</u></strong><br />
</p>
<p><strong><u>unspecified behaviour</u></strong><br />
</p>
<p>use of an unspecified value, or other behaviour where the language standard provides two or more possibilities and imposes no further requirements on which is chosen in any instance</p>
<blockquote>
<p>Note: For example, unspecified behaviour is the order in which the arguments to a function are evaluated.</p>
</blockquote>
<p><strong><u>3.1.43</u></strong><br />
</p>
<p><strong><u>unspecified value</u></strong><br />
</p>
<p>valid value of the relevant type where the language standard imposes no requirements on which value is chosen in any instance</p>
<blockquote>
<p>Note: An unspecified value cannot be a trap representation.</p>
</blockquote>
<p><strong><u>3.1.44</u></strong><br />
</p>
<p><strong><u>value</u></strong><br />
</p>
<p>precise meaning of the contents of an object when interpreted as having a specific type (specific type or specified type?)</p>
<blockquote>
<p>Note: See implementation-defined value, indeterminate value, unspecified value, trap representation</p>
</blockquote>
<p><strong><u>3.1.45</u></strong><br />
</p>
<p><strong><u>virtual</u></strong><br />
</p>
<p><u>TBD</u></p>
<p><strong><u>3.1.45</u></strong><br />
</p>
<p><strong><u>wide character</u></strong><br />
</p>
<p>bit representation capable of representing any character in the current locale</p>
<p><span data-custom-style="annotation reference"></span></p>
<h1 id="language-concepts">4. Language concepts</h1>
<p><u><em>This clause requires a rewrite. See C++ Core Guidelines CPL for a good explanation of the differences</em>.</u></p>
<h2 id="overview">4.1 Overview</h2>
<p><em><strong>THIS REQUIRES MORE WORK</strong></em></p>
<p>Define unchecked (random) access in clause 3 or explain C++ approach. Likely needs a new subclause. Indexing into raw memory is a random access with no checking. In the STL, the [] operator does random access without checking. The function <code class="sourceCode cpp">at</code> was added to provide range checking, including throwing an exceptiion if the check fails.</p>
<p>C++ is a strongly- and statically-typed language: all variables and expressions must have a type. C++ also permits implicit and explicit conversions between types.</p>
<p>C++ has a rich type system with many nuances. In addition to the C base types (int, long, float, double, char, and arrays with their C-style vulnerabilities), C++ provides the following:</p>
<ul>
<li><pre><code>Distinct types for char, signed char, unsigned char</code></pre></li>
<li><pre><code>bool with a true Boolean context</code></pre></li>
<li><pre><code>enum with fixed underlying type</code></pre></li>
<li><pre><code>Classes as the primary user-defined types</code></pre></li>
<li><pre><code>Arrays</code></pre></li>
<li><pre><code>References in addition to pointers</code></pre></li>
<li><pre><code>Parameterized types</code></pre></li>
</ul>
<p>Many vulnerabilities can be mitigated more easily by using library facilities rather than the base language types. (e.g. std::string rather than char*)</p>
<ul>
<li><pre><code>Use of the `explicit`{.cpp} keyword for constructors and conversion
operators</code></pre></li>
<li><pre><code>`operator bool()`{.cpp} discussion</code></pre></li>
<li><pre><code>many built-in implicit conversions, refer to TR 24772-3 clause 6.2
and other clauses (C)</code></pre></li>
<li><pre><code>conversion to bool and null pointer conversions</code></pre></li>
<li><pre><code>legacy code operator void\* - change to explicit operator bool</code></pre></li>
<li><pre><code>C-style casts break type safety.</code></pre></li>
<li><pre><code>static_cast</code></pre></li>
<li><pre><code>explicit casts highlight mismatches between the design and
implementation.</code></pre></li>
<li><pre><code>const and volatile</code></pre></li>
<li><pre><code>constexpr -- needs a writeup -- (in C++:11 , encouraged heavy stack
use and possible exhaustion).</code></pre></li>
</ul>
<p>Narrowly tailored number-like class types, such as time_point and duration, improve safety by providing only safe and appropriate operations. User-defined types tailored to a particular use case can provide additional safety.</p>
<p>C++ was initially defined as a syntactic superset of the C programming language: adding object oriented features such as classes, encapsulation, dynamic dispatch, namespaces and templates. It was a “syntactic superset” because whilst there is a core of C++ that is syntactically identical to C, it has always been the case that there are subtle semantic differences between the two, for example:</p>
<ul>
<li><p>Historically, C permitted the use of a function before its declaration (though this is now deprecated in C) . This is illegal in C++</p></li>
<li><p>Where a struct is defined within another struct, in C the inner declaration is in effect made at file scope, so the definition is available for use later in the program. In C++, the inner declaration name is qualified by that of the parent, so without qualification, the inner struct cannot be used later in the program, as in the following example</p></li>
</ul>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S1 {</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">struct</span> S2 {...} m1;</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>   ...</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S2 v1; /\* legal in C <span class="kw">not</span> C++ \*/</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>S1::S2 v2 <span class="co">// legal in C++ not C</span></span></code></pre></div>
<p>Subsequently, the two languages have diverged, both adding features not present in the other. Not withstanding that, there is still a significant syntactic and semantic overlap between C and C++, so the starting point for this report has been the equivalent for C. However, in many cases, the additional features of C++ provide mechanisms for avoiding the vulnerabilities inherited from C, and these are reflected in the following sections.</p>
<p><em>Include discussions of Object orientation, <strong>static</strong>, and <strong>const,</strong> scoped enumerations</em></p>
<h2 id="type-system">4.2 Type System</h2>
<ul>
<li>implicit conversions</li>
<li>templates? Bring tutorial material from clause 6.2/[#IHN] Type system clause 6.6/[#FLC] Conversion errors, clause 6.11/[#HFC] Pointer type conversions, clause 6.37[#AMV] Type breaking reinterpretation of data clause 6.41[#RIP] Inheritance (includes Mix-ins and multiple inheritance) clause 6.44/[#BKK] Polymorphic variables</li>
</ul>
<p>Mix-ins (6.20, 6.40, 6.41)</p>
<p><em><strong>THIS REQUIRES MORE WORK</strong></em></p>
<p>A particular area that is misunderstood is integral promotion. It can be confusing because promotion can result in changing the internal representation of an unsigned type to/from a signed type. For expressions formed with operands of unscoped enumeration type or integral types with a conversion rank smaller than <code class="sourceCode cpp"><span class="dt">int</span></code>, <em>integral promotion</em> occurs before further implicit conversions happen. <em>Integral promotion</em> on unsigned types can convert these to the signed type <code class="sourceCode cpp"><span class="dt">int</span></code>. Undefined behavior can occur due to signed integer arithmetic overflow even when the operands are of an unsigned type. Assume for example, - signed and unsigned short occupies 16 bits - signed and unsigned int occupies 32 bits then the following code causes undefined behavior:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">unsigned</span> <span class="dt">short</span> <span class="at">const</span> x = <span class="bn">0xfff0</span>;</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>   x * x;                           <span class="co">// signed integer overflow, result will not fit in signed 32 bit int</span></span></code></pre></div>
<p>Note: C++ also uses the term promotion to apply to a subset of conversion that apply to intergral and floating point types.</p>
<p>Implicit, i.e., automatic, conversions to a type <code>T</code> can be performed, for example, in the following situations:</p>
<ol type="a">
<li><p>If the declaration, <code class="sourceCode cpp">T t=e;</code>, is defined for some expression, <code>e</code>, and some invented variable, <code>t</code> [C++17, Clause 7 [conv], para 3];</p></li>
<li><p>In expressions involving operands of operators (e.g., <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, etc.) subject to the requirements of each operators' operands [C++20, Clause 7.3 [conv], para 2.1];</p></li>
<li><p>For example, the expression, <code>5 + 6.5</code>, has operands of type <code class="sourceCode cpp"><span class="dt">int</span></code> and <code class="sourceCode cpp"><span class="dt">double</span></code>. Per language rules, the integer operand will be implicitly converted to <code class="sourceCode cpp"><span class="dt">double</span></code>, i.e., the expression becomes <code class="sourceCode cpp"><span class="dt">double</span>(<span class="dv">5</span>) + <span class="fl">6.5</span></code>, i.e., <code>5.0 + 6.5</code>.</p></li>
<li><p>In boolean contexts, such as</p>
<ul>
<li>operands of logical operators,</li>
<li>the condition of the conditional operator, and</li>
<li>the condition of the if-statement or loop-statements, contextual conversion to bool implicitly happens from arithmetic types, pointers, and classes with a possibly explicit <code>operator bool()</code>. [C++17, Clause 7 [conv], para 4];</li>
</ul></li>
<li><p>In the expression of a switch statement: the implicit conversion will be to an integral type [C++17, Clause 7 [conv], para 2.3];</p></li>
<li><p>In an expression that initializes an object (e.g., an argument to a function call, the expression in a return statement) [C++17, Clause 7 [conv], para 2.4];</p></li>
<li><p>When a non-<code class="sourceCode cpp"><span class="kw">explicit</span></code> class/struct/union constructor can be invoked on an object resulting in some desired type, <code>T</code>, from initial objects passed to the constructor; and</p></li>
<li><p>When a conversion operator has not been declared <code class="sourceCode cpp"><span class="kw">explicit</span></code>, it can be implicitly invoked on an object resulting in some desired type, <code>T</code>, from an initial type.</p></li>
</ol>
<h2 id="symbol-lookup-and-overload-resolution">4.2 Symbol Lookup and Overload Resolution</h2>
<p><em><strong>THIS REQUIRES MORE WORK</strong></em></p>
<ul>
<li>special members</li>
<li>templates?</li>
</ul>
<p>scopes, names, ADL, using</p>
<!-- from issue https://github.com/ISO-IEC-JTC1-SC22-WG23-CPP/wg23-tr24772-10/issues/80 -->
<p>Add to clause 4 “Language concepts” an issue on C++ symbol lookup issues considering the following: 1. Minimize the set of names that are available to avoid referring to an item that was not the intended target 2. hidden friends 3. ADL (argument dependent lookup) 4. Lack of this-&gt; in class templates 5. Minimizing lexical scope and visibility 6. Minimizing names in global scopes 7. Minimizing use of “using” directives</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> NS {</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A</span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">template</span> &lt;<span class="kw">typename</span> S, <span class="kw">typename</span> Q&gt; <span class="kw">friend</span> <span class="dt">void</span> add (S, Q);</span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> B {</span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true" tabindex="-1"></a>    B(<span class="dt">int</span>);</span>
<span id="cb83-12"><a href="#cb83-12" aria-hidden="true" tabindex="-1"></a>    B (NS::A&lt;<span class="dt">int</span>&gt; <span class="at">const</span> &amp;);</span>
<span id="cb83-13"><a href="#cb83-13" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb83-14"><a href="#cb83-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-15"><a href="#cb83-15" aria-hidden="true" tabindex="-1"></a>B &amp; add(B <span class="at">const</span> &amp; lhs, B <span class="at">const</span> &amp; rhs);</span>
<span id="cb83-16"><a href="#cb83-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-17"><a href="#cb83-17" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar (NS::A&lt;<span class="dt">int</span>&gt; &amp; a, B <span class="at">const</span> &amp; b)</span>
<span id="cb83-18"><a href="#cb83-18" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb83-19"><a href="#cb83-19" aria-hidden="true" tabindex="-1"></a>    add(a, b);</span>
<span id="cb83-20"><a href="#cb83-20" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>A C++ program may span multiple scopes, and when a function is called, the compiler may have many choices to select from to resolve the actual function that will be called. The set of names found for a function depend upon whether the name is qualified or if it is unqualified.</p>
<p>Unqualified lookup begins the search in the current scope and works its way out to the global scope and stops when it finds the first matching name. The search will include: - Names directly visible; - (Non-dependent) base classes if the scope is for a member; - Names introduced by the <code class="sourceCode cpp"><span class="kw">using</span></code> declaration; - Names introduced by the <code class="sourceCode cpp"><span class="kw">using</span></code> directive; and - Members of inline namespaces After these steps, Argument-Dependent Lookup (ADL) occurs. In ADL, the scope(s) of type of the function’s arguments are also searched. This search also includes <code class="sourceCode cpp">friends</code> that would not normally be found. ADL never finds member functions.</p>
<p>Unqualified name lookup in templates has two phases: - When the template is initially parsed, names are looked up as above, excluding dependent bases; and - When the template is instantiated, ADL is performed for function names, but ADL does not find member functions.</p>
<p>A qualified name lookup takes place when: - the name includes its scope (e.g <code class="sourceCode cpp">a::foo</code>); or - the name is used in a class member access expression (<code class="sourceCode cpp"><span class="kw">this</span>-&gt;foo</code>). Qualified lookup only searches: - Names directly visible; - (Non-dependent) base classes if the scope is for a member; - Names introduced by the <code class="sourceCode cpp"><span class="kw">using</span></code> declaration; - Names introduced by the <code class="sourceCode cpp"><span class="kw">using</span></code> directive; - Members of inline namespaces; and - Names that can be resolved when a template is instantiated.</p>
<p>Overload resolution</p>
<h2 id="object-lifetime">4.4 Object Lifetime</h2>
<p>Currently appears in: 6.11.PointerTypeConversion-HFC.md 6.13.NULLPointerDereference-XYH.md 6.14.DanglingReferenceToHeap-XYK.md 6.22.InitializationOfVariables-LAV.md 6.33.DanglingReferencesToStackFrames-DCM.md 6.38.DeepVsShallowCopying-YAN.md 6.39.MemoryLeakAndHeapFragmentation-XYL.md 6.61.ConcurrentDataAccess-CGX.md 6.63.ProtocolLockErrors-CGM.md 6.65.ModifyingConstants-UJO.md</p>
<p>dangling.</p>
<h2 id="initialization">4.5 Initialization</h2>
<p>C++ provides a number of ways that an object can be initialized - Value initialization, e.g. std::string s{}; - Direct initialization, e.g. std::string s(“hello”); - Copy initialization, e.g. std::string s = “hello”; - List initialization, e.g. std::string s{‘a’, ‘b’, ‘c’}; - Aggregate initialization, e.g. char a[3] = {‘a’, ‘b’}; - Reference initialization, e.g. char&amp; c = a[0]; - Zero initialization - Default initialization copy, move, default constructor</p>
<p>C++ has many forms of initilization, which generally guarantee that subsequent access to the declared object will be well-defined, however C++ does not always guarantee that it contains a legal value unless the programmer explicitly initializes it with a value. See ##6.22 Missing initialization of variables [LAV]#LAV.</p>
<p>The kind of initialization that happens in C++ when an explicit initializer is not used depends on the context of the declaration.</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> i; <span class="co">// zero-initialized in global name space, </span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> foo()</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>   {</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>       <span class="dt">int</span> i; <span class="co">// default initialized, inderterminate value</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>       <span class="dt">int</span> j{};  <span class="co">// value-initialized to zero</span></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a> </span></code></pre></div>
<p>Non-local variables with static storage duration that are dynamically initialized can cause undefined behavior if the initialization depends on other such variables, see ##6.22 Missing initialization of variables [LAV]#LAV.</p>
<p>The lifetime of most objects of a class type begins when the object’s constructor has completed. In some situations binding a reference to a temporary will extend the lifetime of the temporary. See ##4.4 Lifetime and ## 6.33 Dangling References to Stack Frames [DCM]. // In any case, an object should not be accessed until its initialization is complete (including concurrency???). Richard C thinks that https://eel.is/c++draft/basic.start.dynamic#5 means that there is no danger of one thread accessing a dynamically initialized global variable before the initialization has taken place - is that the case?</p>
<p>When a function is called, each parameter is initialized with its corresponding argument. The initialization of a parameter, including every associated value computation and side effect, is indeterminately sequenced with respect to that of any other parameter, see ## 6.24 Side-effects and Order of Evaluation of Operands [SAM]. On the other hand, the value computation and side effects of the initializer-clauses in an initializer-list are evaluated in the order they appear.</p>
<p>There are many ways for a user to construct, or initialize, an object.</p>
<h2 id="undefinedbehavior.md">4.6 UndefinedBehavior.md</h2>
<p>TBD</p>
<h2 id="error-handling">4.7 Error Handling</h2>
<ul>
<li>abstract machine</li>
<li>standard library</li>
</ul>
<h2 id="concurrency">4.8 Concurrency</h2>
<p>C++ includes concurrency within the language, expressed by <em>threads</em> and <em>tasks.</em> Threads are sequences of execution that can be executed concurrently with the entity (thread) that created them, and with each other. There are good reasons to use threads in a C++ program:</p>
<ol type="a">
<li><p>The running program, or a running thread, block for real-world events, such as awaiting input, awaiting completion of a system-level event, or communications with non-local systems.</p></li>
<li><p>Threading permit other parts of the program to continue execution even while one or more parts are blocked, or lets a program to await and respond to sets of events in the order that they are received.</p></li>
<li><p>Threading lets the program make effective use of multiple cores, proving significantly more computing power to a program.</p></li>
</ol>
<p>Threads are initiated by calling std::threads constructor. TODO: more from 6.59</p>
<p>A thread in C++ runs until completion, either a normal completion or as the result of an unhandled exception. There is no mechanism in the language to terminate another thread.</p>
<p>C++ threads use a fork-join model. This means that the initiating thread will wait for the completion of the initiated thread at the join place; otherwise the initiating thread will have no indication of when the created thread completes.</p>
<p>The thread is then initialized and begins execution on its sequence of instructions. A thread can be <em>joined</em>, i.e. the joining thread awaits the completion of the joined thread, or a thread can be <em>detached</em>.</p>
<p>Threads share data and events via <em>atomic</em> variables, <em>condition_variables</em>, <em>futures</em>, and <em>mutexes</em>.</p>
<p>Threads terminate when they complete the execution of the function that was named at thread initiation.</p>
<p>C++ also has the notion of light weight concurrency in the form of <em>tasks</em>. These tasks are created by calling the std:packaged_task with a <em>function</em>, <em>lambda expression</em>, <em>bind expression</em> or another <em>function object</em>. It is expected that the results of a task execution is collected at the end of that execution by calling <em>get_future</em> (t) and waiting for that/those completion(s).</p>
<p>In addition, C++ programs can interact with other programs executing in a system using operating system-level calls to initiate, schedule, communicate and destroy/terminate itself or others.</p>
<p>There are a number of significant vulnerabilities associated with concurrency, which are described in clause 6.59 through 6.63 of this document.</p>
<h1 id="avoiding-programming-language-vulnerabilities-in-c">5. Avoiding programming language vulnerabilities in C++</h1>
<blockquote>
<p>In addition to the generic programming rules from ISO/IECTR 24772-1 clause 5.4, additional rules from this section apply specifically to the C++ programming language. The recommendations of this section are restatements of recommendations from clause 6, but represent ones stated frequently, or that are considered as particularly noteworthy by the authors. Clause 6 of this document contains the full set of recommendations, as well as explanations of the problems that led to the recommendations made.</p>
</blockquote>
<blockquote>
<p>Every guidance provided in this section, and in the corresponding Part section, is supported by material in Clause 6 of this document, as well as other important recommendations.</p>
</blockquote>
<blockquote>
<p><strong><em>TBD</em></strong></p>
</blockquote>
<table style="width:94%;">
<colgroup>
<col style="width: 44%" />
<col style="width: 5%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th>Index</th>
<th></th>
<th>Reference[]{custom- style=“annotation reference”}</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>2</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>3</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>4</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>5</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>6</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Need to consider C++-11, 14 and 17.</p>
<h1 id="specific-guidance-for-c-vulnerabilities">6. Specific Guidance for C++ Vulnerabilities</h1>
<h2 id="general">6.1 General</h2>
<p>This clause contains specific advice for C++ about the possible presence of vulnerabilities as described in TR 24772-1, and provides specific guidance on how to avoid them in C++ code. This section mirrors TR 24772-1 clause 6 in that the vulnerability “Type System [IHN]” is found in 6.2 of TR 24772–1, and C++ specific guidance is found in clause 6.2 and subclauses in this TR.</p>
<p>As part of its design (and with few exceptions), C++ has a common subset with the complete C language. For code portions written in the common subset, the vulnerabilities described and the advice given in ISO/IEC TR 24772-3:2020, <em>Part 3 – Vulnerability descriptions for the programming language C</em>, apply, except when this document provides refined advice. The following subclauses usually do not further acknowledge the issues from the subset since those have been adequately addressed in the referenced document. However, C++ provides mechanisms to mitigate many of the problems that arise. Please refer to the respective clauses of this document for these mitigations and related guidelines.</p>
<h2 id="IHN">6.2 Type System [IHN]</h2>
<h3 id="applicability-to-language">6.2.1 Applicability to language</h3>
<p>C++ is a statically typed language. In some ways, C++ is both strongly and weakly typed, as it requires all objects/expressions to have a type, but allows for some implicit conversions of values from one type to another type. The following cases require special consideration:</p>
<ul>
<li><p>Most notably are the implicit conversions between arithmetic types (including <code class="sourceCode cpp"><span class="dt">bool</span></code>) that silently might truncate values or have loss of precision (for details see <a href="#FLC">Conversion Errors [FLC]</a>). This shared vulnerability includes <em>integral promotion</em> from small (unsigned) integer types (e.g. <code class="sourceCode cpp"><span class="dt">unsigned</span> <span class="dt">char</span></code>) to the signed integer type <code class="sourceCode cpp"><span class="dt">int</span></code> that can lead to operations with undefined behavior, where unsigned arithmetic is defined with modulo semantics.</p></li>
<li><p>The standard types used to represent text characters ( <code>char</code>, <code>char8_t</code>, <code>wchar_t</code>, <code>char16_t</code>, <code>char32_t</code>) are treated as arithmetic types even when used to represent text and thus are subject to implicit conversions to and from other arithmetic types. Using values of character types in arithmetic expressions, especially together with other types can be confusing. Furthermore, using values of such types or sequences of such values with their corresponding string types with relational operators might not provide an expected sorting order, depending on the language or the encoding the text represents. Libraries for text processing might take such locale-specific or text-representation-specific behavior into account, whereas the built-in operators of the language don’t.</p></li>
<li><p>C++ considers implicit conversions during function overload resolution, when there is not a direct match of argument type with parameter type. Sometimes such conversions lead to ambiguities, which result in a compile error. But there can also be a single best matching overload that does not correspond to developer’s expectation including conversion of argument types (see <a href="#YOW">Identifier Name Reuse [YOW]</a>). Even where the code presently corresponds to programmer expectation, a later addition of code can create a new “better match”, potentially resulting in a silent change of behaviour (see <a href="#BJL">Namespace issues [BJL]</a>, and <a href="#FLC">Conversion Errors [FLC]</a>).</p></li>
<li><p>Values of an unscoped enumeration convert to their underlying integral type in arithmetic expressions (see <a href="#CCB">Enumerator Issues [CCB]</a>).</p></li>
<li><p>Built-in array types as well as function types will decay to a pointer type. For array types this is problematic, because the array’s extent is lost (see <a href="#XYZ">Unchecked Array Indexing [XYZ]</a> and <a href="#RVG">Pointer Arithmetic [RVG]</a>)</p></li>
<li><p>Pointer types implicitly convert to pointer-to-void (see <a href="#HFC">Pointer Type Conversions [HFC]</a>).</p></li>
<li><p>Pointer and reference types referring a derived class object can implicitly convert to a pointer or reference to one of its public base classes respectively (see <a href="#BKK">Polymorphic Variables [BKK]</a>).</p></li>
<li><p>User-defined class types can define conversion operators and converting constructors that can be called with a single argument. If these member functions are not declared with the keyword <code class="sourceCode cpp"><span class="kw">explicit</span></code> they are eligible for use in implicit conversions.</p></li>
<li><p>Implicit conversions from an arithmetic type to <code class="sourceCode cpp"><span class="dt">bool</span></code> often indicate a missing comparison. Conversions from <code class="sourceCode cpp"><span class="dt">bool</span></code> in arithmetic expression can obfuscate code. For example, the following code relies on <code class="sourceCode cpp"><span class="kw">false</span></code> converting to/from zero and <code class="sourceCode cpp"><span class="kw">true</span></code> to one and from non-zero:</p></li>
</ul>
<div class="sourceCode" id="cb85"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> fluxcompensation(<span class="dt">double</span> flux, <span class="dt">bool</span> compensate){</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (flux) { <span class="co">// double to bool conversion</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> delta = compute_delta();</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="at">const</span> compensate_v = <span class="fl">1.4</span>;</span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> flux + delta * compensate; <span class="co">// bool to double conversion</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>  } </span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="fl">1.</span>;</span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<ul>
<li>In a boolean context, conversions that would not occur implicily can take place, specifically, a pointer-to-bool conversion and the application of an <code class="sourceCode cpp"><span class="kw">explicit</span> <span class="kw">operator</span> <span class="dt">bool</span>()</code> conversion operator. These conversions are idiomatic C++ in boolean contexts; however, some prefer explicit tests to show intent, for example, <code class="sourceCode cpp"><span class="cf">if</span> (p) { *p = <span class="dv">42</span>; }</code> vs. <code class="sourceCode cpp"><span class="cf">if</span> (p != <span class="kw">nullptr</span>) { *p = <span class="dv">42</span>; }</code>.</li>
</ul>
<p>Note that type aliases (<code class="sourceCode cpp"><span class="kw">using</span></code>, <code class="sourceCode cpp"><span class="kw">typedef</span></code>) do not define a different type from their alias just a different name and thus do not incur any conversion between the alias and the aliased type.</p>
<p>Instead of using the built-in arithmetic types or generic library types such as <code class="sourceCode cpp"><span class="bu">std::</span>string</code> for your domain values, C++ allows to wrap them in user-defined-class types as so-called <em>strong types</em>. For integral values, <code class="sourceCode cpp"><span class="kw">enum</span> <span class="kw">class</span></code> types can also be used. Strong types provide only those operator overloads and conversions for each such type that make sense in the application domain. User-defined-literal operators help with providing constants of appropriate strong types. Such strong types provide full control of conversions and operations available, avoiding semantically unsound operations that the built-in or other generic types might provide.</p>
<p>For example, a very simple strong type representation of temperature values can be implemented as follows:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Celsius {</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> value;</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Fahrenheit {</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> value;</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>Fahrenheit convert_to_fahrenheit(Celsius c){</span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> { <span class="dv">9</span>*c.value/<span class="dv">5</span>+<span class="dv">32</span>};</span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a><span class="co">//...</span></span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>Celsius wrong = convert_to_fahrenheit({<span class="fl">20.</span>}); <span class="co">// doesn&#39;t compile</span></span></code></pre></div>
<p>In a realistic scenario using a library for strong type support eases the definition and use of strong types.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.2.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can: - Use the avoidance mechanisms of ISO/IEC TR 24772-1:2019, 6.2.5. and the guidance provided in the different related sections of this document.</p>
<ul>
<li><p>Be aware of the rules of the type system, overload resolution, and implicit conversions to avoid vulnerabilities.</p></li>
<li><p>Enable compiler warnings regarding implicit conversions and/or use static analysis tools that provide such warnings.</p></li>
<li><p>Define any constructor of a class that can be called with a single argument of a different type as <code class="sourceCode cpp"><span class="kw">explicit</span></code>.</p></li>
<li><p>Define any conversion operator as <code class="sourceCode cpp"><span class="kw">explicit</span></code></p></li>
<li><p>Use strong types for domain values instead of the built-in types. On system boundaries, e.g., for input, convert a read value immediately to the appropriate strong type.</p></li>
<li><p>When defining variables of arithmetic type, use a braced-initializer to prevent a potential narrowing conversion from the initial value’s type.</p></li>
<li><p>Avoid the use of the following text-representing character types, <code>char</code>, <code>char8_t</code>, <code>wchar_t</code>, <code>char16_t</code> and <code>char32_t</code>, in arithmetic or relational expressions. Use an appropriate text processing library instead for character classification, conversion, comparison, and further processing.</p></li>
<li><p>Use a consistent style in a project with respect to implicit pointer conversions in boolean contexts.</p></li>
</ul>
<h2 id="bit-representations-str">6.3 Bit Representations [STR]</h2>
<h3 id="applicability-to-language">6.3.1 Applicability to language</h3>
<p>This vulnerabilities described in TR24772-1 clause 6.3 is applicable to C++. The “endianness” of integer types and packing of bit fields are implementation-defined properties and not portable.</p>
<p>The standard library type <code class="sourceCode cpp"><span class="bu">std::</span>endian</code> allows to portably check the endianness of a platform and code can use this information to operate on individual bytes of a machine word in the correct order.</p>
<p>There is no portable mapping from bitfields in a struct to individual bits in a machine word. Therefore, C++ bitfields should not be used to directly map to bits in hardware, even though the compiler provides suitable mapping and manipulation operations. A further complication is that accessing a bitfield can often not easily be performed atomically, because the non-participating bits of a memory location need to be read before the relevant bits can be mutated through masking, and the whole memory location has to be written again. It is possible to simulate bitfields with a defined layout through library class types that implement the required masking operations.</p>
<p>For individual bits <code class="sourceCode cpp"><span class="bu">std::</span>bitset&lt;N&gt;</code> and <code class="sourceCode cpp"><span class="bu">std::</span>vector&lt;<span class="dt">bool</span>&gt;</code> can provide suitable representations at run time, but don’t support a direct mapping to machine words. However, be aware that <code class="sourceCode cpp"><span class="bu">std::</span>vector&lt;<span class="dt">bool</span>&gt;</code> does not in general behave like a <code>std::vector</code> which can cause generic code to misbehave.</p>
<p>C++ provides a rich set of bitwise operators that can be used to address the issues of bit manipulation in a portable way. However, the shift operation can result in undefined behavior when shifting by a negative or too large value, or when shifting a signed operand. It is advisable to use bit operations only on appropriate unsigned integral types with a known width while being careful of potential integral promotion that might change a small unsigned operand type to be promoted to a signed integer type. When bitwise memory operations are needed, it is good practice to encapsulate such operations in a class type’s member functions.</p>
<p>For representing individual bitmasks values employed in bit operations, it is advisable to put the corresponding named constants in an enumeration type with the appropriate underlying type for easier recall.</p>
<p>While a bit shift of an integral value can be viewed as a multiplication or division by a power of two, it should not be used in arithmetic expression to implement such an operation. Compilers will automatically implement such a multiplication in the most efficient way, there is no need to obfuscate multiplication and division as shift operations.</p>
<p>Except for specific situations (trivial types), objects of class type can not be assumed to have a layout appropriate to be manipulated on a byte or bitwise level. Depending on the size and alignment of its data members a class type might have padding bytes between members. The absence of padding in a trivially copyable type <code>T</code> can be checked with a <code>static_assert(std::has_unique_object_representations_v&lt;T&gt;)</code>.</p>
<p><code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code> can be used to reinterpret suitably sized trivial types on a bitwise level, i.e., for accessing the binary representation of a floating point value. However, for types with padding bits that do do not participate in an object’s value representation, the corresponding bits in a <code>bit_cast</code> result have indeterminate values. If those bits are used to compare for equality, with the function <code class="sourceCode cpp">memcmp</code> for instance, the padding bits may differ and cause false negatives.</p>
<p>Malicious code could use such padding bits as a <em>secret channel</em> which might be accessed through copying the underlying bytes.</p>
<p>See C++ Core Guidelines ES101 use unsigned types for bit manipulation.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.3.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-3 clause 6.3.2</p></li>
<li><p>Avoid the use of shift operations to implement multiplication or division by powers of two.</p></li>
<li><p>Use built-in bitwise operations only with operands of unsigned integral types or enums with an unsigned underlying type.</p></li>
<li><p>When performing bitwise operations on operands of an unsigned type that gets promoted to a signed integral type, cast the result to the corresponding unsigned type immediately.</p></li>
<li><p>Ensure that the right-hand operand of a shift operation is not negative or greater than the number of bits the left-hand operand. Use static analysis tools or other means to prove that the right hand operand of the shift is not out of bounds.</p></li>
<li><p>Prefer <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code> over other means such as <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> to access the binary representation of an object.</p></li>
<li><p>Prefer abstractions in a class type encapsulating bit manipulations using unsigned types of well-defined width, such as <code class="sourceCode cpp"><span class="bu">std::</span>bitset</code>, over non-portable bitfields.</p></li>
<li><p>Forbid the use of <code class="sourceCode cpp"><span class="bu">std::</span>memcmp</code>, <code class="sourceCode cpp"><span class="bu">std::</span>memcpy</code>, or <code class="sourceCode cpp"><span class="bu">std::</span>memmove</code> on objects of type <code>T</code> unless <code class="sourceCode cpp"><span class="bu">std::</span>has_unique_object_representations_v&lt;T&gt;</code> is true.</p></li>
</ul>
<h2 id="floating-point-arithmetic-plf">6.4 Floating-point Arithmetic [PLF]</h2>
<h3 id="applicability-to-language">6.4.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1 clause 6.4 is applicable to C++.</p>
<p>The C++ standard assumes IEC 60559 if <code class="sourceCode cpp"><span class="bu">std::</span>numeric_limits<span class="bu">\</span>&lt;T&gt;::is_iec559</code> is true for the types in use. In the absence of this, C++ makes few guarantees about the behaviour of floating point numbers. In particular <code class="sourceCode cpp"><span class="bu">std::</span>less</code> is not a total order; <code class="sourceCode cpp"><span class="bu">std::</span>equal</code> is not equivalent to substitutability (NaNs compare unequal to themselves, but neither less nor greater, and negative zero compares equal to positive zero).</p>
<p>Sorting floating point numbers with the built-in operators violates the preconditions of sorting predicates in the presence of NaN values and may raise floating point errors. The default sorting predicate <code>std::less</code> is suspect to this precondition violation, resulting in undefined behavior when sorting a range of floating point values that contains NaNs.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.4.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.4.5</p></li>
<li><p>Verify compliance to ISO/IEC/IEEE 60559:2011 at compile time through <code class="sourceCode cpp"><span class="bu">std::</span>numeric_limits&lt;T&gt;::is_iec559</code>. Other numeric characteristics such as <code>min()</code>, <code>max()</code>, existence of NaNs, <code>has_denorm</code>, and infinities can be determined in this class template.</p></li>
<li><p>Be aware that the default comparisons in the standard library may produce wrong results when used on floating point members.</p></li>
</ul>
<h2 id="CCB">6.5 Enumerator Issues [CCB]</h2>
<h3 id="applicability-to-language">6.5.1 Applicability to language</h3>
<p>The vulnerability documented in ISO IEC 24772-1 clause 6.5 applies to C++. C++ provides scoped (<code class="sourceCode cpp"><span class="kw">enum</span> <span class="kw">class</span></code>) and unscoped (<code class="sourceCode cpp"><span class="kw">enum</span></code>) enumeration types, where an underlying integral type can be specified. For enumeration types with a fixed underlying type all values of the underlying integral type are valid. Unscoped enumeration types without an <em>enum-base</em> have a non-fixed underlying type that only guarantees values in the range of the provided enumerators are valid. The latter can cause non-representable values to be assigned to a variable of such an unscoped enumeration type.</p>
<p>Assignment of a variable of an enum type require the assigned value to be of the same enum type. This can be either an enumerator of that enum type, or requires a cast (see <a href="#FLC">6.6 Conversion errors [FLC]</a>).</p>
<p>C++ allows implicit conversion of an unscoped enum by integral promotion.</p>
<p><strong>TODO continue here </strong></p>
<div class="sourceCode" id="cb87"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Color  {red, green, blue};</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="dt">short</span> i = red; <span class="co">// implicit conversion</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>Color g { green + blue }; <span class="co">// integer result fits into short</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>Color h {<span class="dv">42</span>}; <span class="co">// OK non-narrowing</span></span></code></pre></div>
<p>List initialization of enum types with fixed underlying type implicitly does a static cast.</p>
<p>C++ does not support implicit conversion of a scoped enum to an int, hence, operations such as <code>++</code>, <code>+</code>, <code>&lt;</code> and enums used as array indices require explicit definitions.</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> Color : <span class="dt">short</span> {red, green, blue};</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="dt">short</span> i = red; <span class="co">// error -- no implicit conversion</span></span></code></pre></div>
<p>Where unscoped enums are used as array indexes and do not have a user-specified mapping to an underlying representation, there will be “holes” as documented in TR24772-1 clause 6.6.</p>
<p>Note that unscoped enumeration types implicitly promote their underlying type and can be used as the index of an array without a cast, with all of the issues described in TR 24772-1 clause 6.5.</p>
<p>From C++ 2017 forward, casting a value to an enumeration type is undefined behavior unless the source value is within the range of values of an enumeration type. See CERT INT50-CPP.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.5.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use <em>scoped enumerations</em> in preference to the C-style <em>unscoped enumerations</em> for related values, especially at namespace-level.</p>
<ul>
<li><pre><code>  See CPP Core Guidelines Enum.3 &quot;Prefer class enums over &#39;plain&#39;</code></pre>
<p>enums".</p></li>
<li><pre><code>  See AUTOSAR A7-2-3 &quot;Enumerations shall be declared as scoped</code></pre>
<p>enum classes"</p></li>
<li><pre><code>  See MISRA C++ 28.5.5</code></pre></li>
</ul></li>
<li><p>Use <code class="sourceCode cpp"><span class="kw">constexpr</span></code> to declare a set of unrelated values, such as <code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">size_t</span> bufferLen = <span class="dv">128</span>;</code> <code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">char</span> special_char = <span class="ch">&#39;a&#39;</span>;</code></p></li>
<li><p>Provide operators and functions that perform the arithmetic operations and conversions appropriate to the enumerated type. Outside those functions, avoid directly performing arithmetic or conversions on objects of the enumerated type.</p>
<ul>
<li><pre><code>  See CPP Core Guidelines Enum.4 &quot;Define operations on</code></pre>
enumerations for safe and simple use"</li>
</ul></li>
<li><p>If <em>unscoped enumerations</em> are used, follow the general advice of TR 24772-3 clause 6.5.2 as well as the following:</p>
<ul>
<li><pre><code>  Avoid casting arbitrary integer values to enumeration type. If it is</code></pre>
<p>unavoidable, use braced initialization instead of C-style or static casts<br />
<code>e_type{7};</code></p>
<pre><code>  &gt; See CERT INT50-CPP &quot;Do no Cast to an out-of-range-value&quot;</code></pre></li>
</ul></li>
<li><pre><code>Obtain the underlying enumeration value, by casting the enumeration</code></pre>
<p>to its underlying type, e.g.,</p>
<blockquote>
<p><code class="sourceCode cpp"><span class="kw">enum</span> <span class="dt">e_type</span>{A, B, C};</code></p>
</blockquote>
<blockquote>
<p><code class="sourceCode cpp"><span class="kw">auto</span> value = <span class="kw">static_cast</span>\&lt;<span class="bu">std::</span>underlying_type_t<span class="bu">\</span>&lt;<span class="dt">e_type</span>\&gt;\&gt;(B);</code></p>
</blockquote></li>
</ul>
<h2 id="FLC">6.6 Conversion Errors [FLC]</h2>
<h3 id="applicability-to-language">6.6.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO IEC 24772-1 clause 6.6 applies to C++. C++ includes some of the conversion mechanisms of C documented in TR 24772-3 clause 6.6.1, however C++ type conversion mechanisms differ from the mechanisms of C, as documented in ISO IEC 14882 Annex C. This subclause highlights differences where C++ provides mitigations of potential vulnerabilities found in C.</p>
<p>In C++, some conversions are explicit while others are implicit. Conversions can change the size of a type, whether or not the type is signed, and possibly other properties of the type. A narrowing conversion is when the target type cannot represent all the values of the original type. Many errors are associated with implicit conversions. For a comprehensive overview see clause 7.3 [conv] of [C++20]</p>
<p>Explicit conversions use one of the mechanisms provided by C++ through a</p>
<ul>
<li>type conversion operator
<ul>
<li><code class="sourceCode cpp"><span class="kw">static_cast</span></code>,</li>
<li><code class="sourceCode cpp"><span class="kw">const_cast</span></code>,</li>
<li><code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code>,</li>
<li><code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>),</li>
</ul></li>
<li>constructor notation with
<ul>
<li>parentheses (e.g., <code class="sourceCode cpp"><span class="dt">double</span>(<span class="dv">42</span>)</code>) or</li>
<li>braces (e.g., int{‘a’}) which prevents narrowing conversions, or</li>
</ul></li>
<li>a C-style cast (<code class="sourceCode cpp">(<span class="dt">int</span>)<span class="fl">3.14</span></code>).</li>
</ul>
<p>In C++, a C-style cast is defined in terms of the C++ cast operators <code class="sourceCode cpp"><span class="kw">const_cast</span></code>, <code class="sourceCode cpp"><span class="kw">static_cast</span></code>, and <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>. In some cases, it is unspecified which cast is used, for example when a cast operation involves an incomplete type, a <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> may be used for the conversion which can produce an incorrect result.</p>
<p>Unlike C++'s other cast notations, <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> relies on run-time type information generated by the compiler to ensure the requested conversion is valid. If it is not valid, then <code class="sourceCode cpp"><span class="kw">nullptr</span></code> is returned for pointer types, otherwise an exception is thrown. [C++17, Clause 8.2.7 [expr.dynamic.cast]] Thus, <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> is safer to use when converting down a hierarchy where the base class has virtual member functions. (see <a href="#HFC">Pointer Type Conversions [HFC]</a> and <a href="#BKK">Polymorphic Variables [BKK]</a>)</p>
<p>An implicit conversion to a class type can occur for a class with constructors that can be invoked with a single argument, as in the following example:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>      {<span class="kw">public</span>:</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>        C(<span class="dt">int</span> x=<span class="dv">10</span>, <span class="dt">float</span> y=<span class="dv">0</span>){...}</span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>      };</span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo(C param){...}</span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar( <span class="dt">bool</span> b){ foo(b);} </span></code></pre></div>
<p>In the example above, it can be surprising that foo() is called with a boolean.</p>
<p>Note that this implicit conversion to a class object is the default behaviour of constructors that can be called with a single parameter. The <code class="sourceCode cpp"><span class="kw">explicit</span></code> keyword can be used before the constructor to prevent this happening, as in:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">explicit</span> C(<span class="dt">int</span> x=<span class="dv">10</span>, <span class="dt">float</span> y=<span class="dv">0</span>){...}</span></code></pre></div>
<p>The call <code class="sourceCode cpp">foo(b)</code> would now not be legal.</p>
<p>Implications of casting away <code class="sourceCode cpp"><span class="at">const</span></code> using <code>const_cast</code> are described in section <a href="#UJO">Modifying Constants [UJO]</a>.</p>
<p>Other implicit conversions can sometimes result in data loss or erroneous values. This is an issue with implicit conversions since they are automatic: the programmer does not explicitly write code to do the conversion. For example, a common problem is mixing signed and unsigned integral types in arithmetic expressions. This can become a problem since the ranges of signed and unsigned integer types differ and the behaviour of signed integer arithmetic on overflow is undefined whereas unsigned integer arithmetic wraps on overflow. See subclause 4.2 for a discussion of integral promotions in C++.</p>
<p>The issue is not restricted to narrowing conversions, as shown below:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">long</span> l_64 = i_32 + i_32; <span class="co">// &#39;+&#39; operation preformed in 32 bits</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>                         <span class="co">// widened after the operation completes (and potentially overflows). </span></span></code></pre></div>
<p>This can be avoided by converting at least one operand to the wider type as part of the operation. Note that <code class="sourceCode cpp"><span class="kw">auto</span></code> directs the compiler to use the appropriate type based on the initializer expression. Subsequent use of the auto object (such as in standard mathematical operations) can lead to implicit conversions that are not obvious in the context local to the expression. Additional problems arise as a result of implicit conversions between <code>bool</code> and other types, thus hiding the fact when a wrong operator is used accidentally:</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f(<span class="dt">unsigned</span> i, <span class="dt">unsigned</span> j)</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (i &gt; <span class="dv">1</span>) &amp; (j = <span class="dv">1</span>); <span class="co">// (&gt;&gt;, &amp;&amp;, ==) ?</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In the example above, all combinations of the corresponding operators will compile with different resulting types and results.</p>
<p>Similar issues arise in conversions between character types (char, char8_t, …) and other types. Character types are provided to represent text in whatever character representation is needed.</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f(<span class="dt">char</span> c)</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (c &lt; <span class="dv">0</span>) <span class="co">// may be always false on some platforms.</span></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>    {}</span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In addition to the use of <em>strong types</em> (see <a href="#IHN">Type System [IHN]</a>), the implicit conversions and multitude of possible operations of integral types can be mitigated by using scoped enumeration types with the corresponding integer type as its underlying type. For example, <code class="sourceCode cpp"><span class="bu">std::</span>byte</code> is defined to address individual <code class="sourceCode cpp"><span class="dt">unsigned</span> <span class="dt">char</span></code> elements (bytes) in memory without participating in arithmetic or bitwise operations.</p>
<p>Because C++ allows function and operator overloading, the effect of implicit conversions provides an additional mechanism of failure, by selecting an unwanted overload during overload resolution due to implicit conversions. This can influence failure modes with lookup as described in section <a href="#BJL">Namespace Issues [BJL]</a>. // Add overload resolution reference!!</p>
<p>C++ also provides a library function <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code>. This function provides the ability to preserve the bit representation when converting between unrelated types. If such is meaningful, then <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code> reduces the risk of some undefined behaviours compared with other type punning approaches such as casts or unions.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.6.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.6.5:</p></li>
<li><p>Avoid casts and type punning (see C++ Core guidelines ES.48), treat every cast as a candidate for refactoring.</p></li>
<li><p>Avoid narrowing conversions. (see C++ Core Guidelines ES.46)</p></li>
<li><p>Prefer braces over parentheses for initialization or explicit conversions from numeric types to prevent narrowing. (see C++ Core Guidelines ES.23 and ES.64)</p></li>
<li><p>Avoid C-style casts. Use C++ type conversion operators instead, as they document intent and disallow some unsafe conversions. (see C++ Core Guidelines ES.49)</p></li>
<li><p>Declare <code class="sourceCode cpp"><span class="kw">explicit</span></code></p>
<ul>
<li>constructors callable with a single argument; and</li>
<li>conversion functions. (see C++ Core guidelines C.46 and C.164)</li>
</ul></li>
<li><p>Don’t cast away <code class="sourceCode cpp"><span class="at">const</span></code>. See subclause <a href="#UJO">Modifying Constants [UJO]</a><br />
(see C++ Core Guidelines ES.50)</p></li>
<li><p>Do not perform arithmetic operations on operands that can be promoted. In partcular, be aware of the arithmetic operators that promote their operands, and the types are subject to promotion.</p></li>
<li><p>Avoid widening the result of an arithmetic operation; prefer instead to widen the type of one or more of the operands</p></li>
<li><p>Don’t mix signed and unsigned arithmetic (see C++ Core Guidelines ES100)</p></li>
<li><p>Don’t rely on implicit conversions between <code>bool</code> and other types.</p></li>
<li><p>Don’t rely on implicit conversions between character types and other types.</p></li>
<li><p>Use <em>strong types</em> (see subclause <a href="#IHN">Type System [IHN]</a>) to limit implicit conversions and unwanted operations.</p></li>
<li><p>When using <code class="sourceCode cpp"><span class="kw">auto</span></code> ensure that you know the type that <code class="sourceCode cpp"><span class="kw">auto</span></code> deduces type and resist using <code class="sourceCode cpp"><span class="kw">auto</span></code> for the predefined types</p></li>
</ul>
<h2 id="CJM">6.7 String Termination [CJM]</h2>
<h3 id="applicability-to-language">6.7.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 exists in C++ when C-style strings are used, e.g., with interfaces that require NUL-terminated strings. C++ provides alternative string processing capabilities that do not exhibit those vulnerabilities.</p>
<p>C++ provides a class template for string processing, <code class="sourceCode cpp"><span class="bu">std::</span>basic_string</code> that manages the space for the string and the string length and always includes a string termination character. For example, when concatenating, the <code class="sourceCode cpp"><span class="bu">std::</span>basic_string</code> object will increase in size to contain the resulting string. Futhermore, as the string is guaranteed to have a string termination character, using its underlying raw pointer as a C-style string will mitigate this vulnerability because the string termination character is present.</p>
<p>C++ provides the library class templates <code class="sourceCode cpp"><span class="bu">std::</span>basic_stringview</code> and <code class="sourceCode cpp"><span class="bu">std::</span>span</code> that implement reference semantics to non-owned buffers. These types do not rely on a string termination character to determine the length of the string, thus, use of these types avoids those vulnerabilities. However, using its underlying raw pointer as a C-style string can result in these vulnerabilities because the string termination character is not guaranteed to be present.</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo(<span class="bu">std::</span>string <span class="at">const</span>&amp; s, <span class="bu">std::</span>string_view <span class="at">const</span>&amp; sv)</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>  puts(s.data());  <span class="co">// okay string has termination character</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>  puts(sv.data()); <span class="co">// not okay; string termination not guaranteed</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h3 id="avoidance-mechanisms-for-language-users">6.7.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Avoid C-style strings.</p></li>
<li><p>If using C-style strings is unavoidable, use the avoidance mechanisms of ISO/IEC 24772-3 clause 6.7.2.</p></li>
<li><p>Ensure that explicit overflow checks are performed for all string operations.</p></li>
<li><p>Prefer using a string type, e.g., <code class="sourceCode cpp"><span class="bu">std::</span>string</code>, which manages the memory of its string and handles termination in order to mitigate against this vulnerability.</p></li>
<li><p>Don’t use the underlying raw pointer of a <code class="sourceCode cpp"><span class="bu">std::</span>string_view</code> or a <code class="sourceCode cpp"><span class="bu">std::</span>span</code> with interfaces that expect C-style strings.</p></li>
<li><p>Use static analysis tools to help identify occurrences of undefined behaviour.</p></li>
</ul>
<h2 id="HCB">6.8 Buffer Boundary Violation [HCB]</h2>
<h3 id="applicability-to-language">6.8.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1 clause 6.8 exists in C++ when arrays are managed using raw pointers or indexing. The range of valid raw pointers to a plain array <code>a</code> are from the first element to one past the last element of the array, i.e., in the range [<code class="sourceCode cpp"><span class="bu">std::</span>begin(a)</code>..<code class="sourceCode cpp"><span class="bu">std::</span>end(a)</code>). An object <code>o</code> can be treated as a single element array with respect to pointers referring to it.</p>
<p>C++ provides facilities to encapsulate code that is exposed to this vulnerability. The standard library defines features that mitigate or circumvent this vulnerability. For example, <code class="sourceCode cpp"><span class="bu">std::</span>string</code>, <code class="sourceCode cpp"><span class="bu">std::</span>vector</code>, <code class="sourceCode cpp"><span class="bu">std::</span>deque</code>, and <code class="sourceCode cpp">iostreams</code> manage buffers internally; using “range-for” such as <code class="sourceCode cpp"><span class="cf">for</span> (<span class="kw">auto</span> &amp;e :</code><em><code>some container</code></em><code class="sourceCode cpp">)</code> and the algorithm library to access elements <code>e</code> of the container without the possibility of a buffer boundary violation.</p>
<p>However, the member function <code class="sourceCode cpp">data()</code> of the contiguous sequence containers returns a non-const pointer to the underlying elements. This allows manipulating the underlying memory directly, bypassing the safety features of the container leading to this vulnerability. For example, <code>std::string::data()</code> returns a non-const <code class="sourceCode cpp"><span class="dt">char</span>*</code>.</p>
<p>When working directly with iterators referring a container, one need to ensure that those iterators are and remain valid. For example, for a container <code>c</code> incrementing an iterator beyond the <code>end(c)</code> iterator or dereferencing the iterator denoted by <code>end(c)</code> are undefined behavior.</p>
<p>In general, validity of iterators requires programmer care to prevent out-of-bounds access of the underlying container:</p>
<p>For example, using algorithms and iterators correctly to convert an input string to lower case:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string to_lowercase(<span class="bu">std::</span>string_view s){</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string result{};</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>    transform(</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>        begin(s), end(s), <span class="co">// input range #1</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>back_inserter(result), <span class="co">// output iterator #2</span></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a>        [](<span class="dt">char</span> c){ <span class="cf">return</span> <span class="bu">std::</span>tolower(c);});</span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result;</span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The above example, passes two ranges of characters to the transform algorithm. Potential errors due to a boundary violation could be caused by the following changes:</p>
<ul>
<li>wrong input range #1, e.g., passing unrelated iterators,</li>
<li>insufficient space in output range #2, e.g., passing <code class="sourceCode cpp">begin(result)</code> instead of <code class="sourceCode cpp">back_inserter(result)</code>,</li>
</ul>
<p>The second problem occurs in the following code if the length of s is longer than 31:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string to_lowercase(<span class="bu">std::</span>string_view s){</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string result{<span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span>, <span class="dv">31</span>};</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>    transform(</span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>        begin(s), end(s), </span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>        begin(result), <span class="co">// error, only space for 31 characters </span></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a>        [](<span class="dt">char</span> c){ <span class="cf">return</span> <span class="bu">std::</span>tolower(c);});</span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result; <span class="co">// size(result) == 31</span></span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>An additional problem occurs when performing an operation that invalidates an in-use iterator, such as the iterator internally used by the range-for statement below:</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string to_lowercase(<span class="bu">std::</span>string s){</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (<span class="kw">auto</span> &amp;c:s){</span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>       s.append(<span class="bu">std::</span>tolower(c)); <span class="co">// error, invalidates in-use iterator</span></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s;</span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Another way that overflows can occur is through the use of C-style strings, which can be treated as arrays of characters, but mishandling of the <code>nul</code> termination can make overflows possible. See clause <span id="CJM">6.7 String Termination[CJM]</span>.</p>
<p>Since plain (C-style) arrays when passed as function arguments decay to pointers the array dimension is lost. C++ provides several means of keeping the array dimension available to the called function:</p>
<ul>
<li>use <code>std::array</code> as parameter type,</li>
<li>use <code>std::views::counted</code> or another view as parameter type,</li>
<li>use <code>std::span</code> as parameter type for plain arrays,</li>
<li>use <code>std::string_view</code> as parameter type in favour of <code>char const*</code>, or</li>
<li>pass plain arrays by reference to a function template and deduce the dimension.</li>
</ul>
<p>For further explanation and examples, see</p>
<ul>
<li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR50-CPP.+Guarantee+that+container+indices+and+iterators+are+within+the+valid+range">SEI CTR50-CPP</a></li>
<li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR53-CPP.+Use+valid+iterator+ranges">SEI CTR53-CPP</a></li>
<li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR55-CPP.+Do+not+use+an+additive+operator+on+an+iterator+if+the+result+would+overflow">SEI CTR55-CPP</a></li>
<li><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#i13-do-not-pass-an-array-as-a-single-pointer">C++ core guidelines I.13</a></li>
</ul>
<h3 id="avoidance-mechanisms-for-language-users">6.8.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.8.5.</p></li>
<li><p>Avoid C-style arrays. If unavoidable, guidance for the use of C-style arrays is provided in TR 24772-3 clause 6.8.2.</p></li>
<li><p>Avoid container functions, such as <code class="sourceCode cpp">data()</code>, that bypass the safety features of the respective containers.</p></li>
<li><p>To model a fixed-size array, use a library class such as <code class="sourceCode cpp"><span class="bu">std::</span>array</code>.</p></li>
<li><p>To model arrays with dynamically changing size, use containers of the standard library, such as <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> or <code class="sourceCode cpp"><span class="bu">std::</span>deque</code>.</p></li>
<li><p>Avoid using a pointer parameter or a pointer-and-size parameter pair for representing a contiguous buffer; instead use a range parameter, for example, <code class="sourceCode cpp"><span class="bu">std::</span>views<span class="bu">::</span>counted</code>, <code class="sourceCode cpp"><span class="bu">std::</span>span</code>, or <code class="sourceCode cpp"><span class="bu">std::</span>string_view</code>.</p></li>
<li><p>Prefer using range-based or iterator-based algorithms, such as those of the standard library, over pointer-manipulating or indexing loops.</p></li>
<li><p>Use the range-based for loop construct to iterate within the defined bounds of a range.</p></li>
<li><p>Ensure that ranges and iterators used by range-for or passed to algorithms are and remain valid.</p></li>
<li><p>When performing random access by indexing, use the avoidance mechanisms of clause <a href="#XYZ">6.9.2</a>.</p></li>
<li><p>Use static analysis tools to detect buffer boundary violations.</p></li>
</ul>
<h2 id="XYZ">6.9 Unchecked Array Indexing [XYZ]</h2>
<h3 id="applicability-to-language">6.9.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2022 6.9 exists in C++ when an access is performed using <code class="sourceCode cpp"><span class="kw">operator</span>[]</code>.</p>
<p>C-style arrays, C-style pointers, random-access iterators, and some standard library containers allow element access via <code class="sourceCode cpp"><span class="kw">operator</span>[]</code> which is unchecked. However, those standard library containers also provide an access function <code>at()</code> that behaves like <code class="sourceCode cpp"><span class="kw">operator</span>[]</code>, but performs a check that the access is within the bounds of the container and throws an exception otherwise.</p>
<p>For issues associated with exception handling and error handling, see clause <a href="#OYB">6.36</a> Ignored error status and unhandled exceptions.</p>
<p>The parameter type for contiguous sequences <code class="sourceCode cpp"><span class="bu">std::</span>span</code> does not provide a checked version of indexing and therefore should only be used via its iterator/range API.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.9.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1:2022 clause 6.9.5.</p></li>
<li><p>Follow the advice from clause <a href="#HCB">6.8.2</a>.</p></li>
<li><p>Implement your own indexable containers with an overload of <code class="sourceCode cpp"><span class="kw">operator</span>[]</code> that actually does a bounds check.</p></li>
<li><p>Prefer the <code class="sourceCode cpp">at()</code> member function of the standard library containers over <code class="sourceCode cpp"><span class="kw">operator</span>[]</code> and handle the bounds violation exceptions.</p></li>
<li><p>If indexing cannot be avoided, use static analysis or explicit checks to establish that bounds violations do not occur.</p></li>
</ul>
<h2 id="XYW">6.10 Unchecked Array Copying [XYW]</h2>
<h3 id="applicability-to-language">6.10.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC 24772-1:2022 exists in C++, but can be mitigated using features provided by the language.</p>
<p>A buffer overflow occurs when some number of elements is copied from one buffer to another and the amount being copied is greater than is allocated for the destination buffer. This is a special case of <span id="HCB">6.8 Buffer Boundary Violation [HCB]</span>. The C library functions or hand-written loops for copying bytes or C-style strings are especially prone to this vulnerability.</p>
<p>As with clause 6.8 [HCB], in most cases the vulnerability can be avoided by using library classes, such as <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> or <code class="sourceCode cpp"><span class="bu">std::</span>string</code>, which provide a copy operations operator that adjust the size of the target to fit the object being copied.</p>
<p>The standard library algorithms that copy into a target range can suffer from this vulnerability. In the case of potential overflow, the programmer must either ensure automatic extension of the underlying container, such as by using <code class="sourceCode cpp"><span class="bu">std::</span>back_inserter(container)</code> as the output iterator, or ensure that the output range has sufficient space available. In the case of overlapping input and output ranges, the suitable copying algorithm must be selected, depending on the relative ordering of the ranges. In general, this situation can be avoided by using a more appropriate algorithm, for example, <code class="sourceCode cpp"><span class="bu">std::</span>rotate</code>.</p>
<p>For arrays with fixed sizes the assignment operator or copy-constructor of <code class="sourceCode cpp"><span class="bu">std::</span>array</code> is the means of safe array copying.</p>
<p>If a system requires its own container types with dynamic size, a naïve implementation might attempt to keep the copying external, like with C-style arrays. Such external copying should be avoided.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.10.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1:2022 clause 6.10.5.</p></li>
<li><p>Use standard library containers instead of C-style arrays, such as <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> or <code class="sourceCode cpp"><span class="bu">std::</span>array</code>, that provide copying mechanisms that ensure the target array is large enough for the indicated source.</p></li>
<li><p>When using standard library algorithms that copy into an output range, ensure that either the output range is extended automatically or has sufficient space available.</p></li>
<li><p>Sidestep the need to use a copy algorithm on overlapping ranges, by selecting a more appropriate algorithm, such as <code class="sourceCode cpp"><span class="bu">std::</span>rotate</code>.</p></li>
<li><p>If a system requires its own container types with dynamic size, ensure that their copy operations are correct and do not require loops or algorithms for copying their content.</p></li>
<li><p>If copying C-style arrays is unavoidable, statically show that an access outside of the array cannot occur, or alternatively perform range checking before copying the array.</p></li>
<li><p>Avoid using the copying functions from the headers <cstring></p></li>
</ul>
<h2 id="HFC">6.11 Pointer Type Conversions [HFC]</h2>
<h3 id="applicability-to-language">6.11.1 Applicability to language</h3>
<p>The vulnerabilites as described in ISO/IEC TR 24772-1:2019 clause 6.11.1 applies to C++. In addition to pointers, C++ references are also vulnerable and the issues below include references when pointers are mentioned. In places where references cannot be substituted the corresponding code won’t compile.</p>
<p>In general casting pointers breaks the type system and should be avoided.</p>
<p>In C++, a C-style cast is defined in terms of the C++ cast operators <code class="sourceCode cpp"><span class="kw">const_cast</span></code>, <code class="sourceCode cpp"><span class="kw">static_cast</span></code>, and <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>. In some cases, it is unspecified which cast is used, for example, when a cast operation involves an incomplete type, a <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> may be used for the conversion which can produce an incorrect result.</p>
<p>Especially, <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> has the problem that it takes the original pointer value as a pointer of the target type rather than the original type. The C++ standard defines most cases where that happens as undefined behavior. For example, the lifetime model of C++ might result in accessing the target type object outside of its lifetime. Other run-time issues can be caused by alignment violations. Using <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span>&lt;<span class="bu">std::</span>byte*&gt;</code> to access the underlying memory of an object by casting its address permits access to the raw memory. However, casting the address of a piece of raw memory with the correct alignment and size to an object pointer and accessing that object is undefined behavior for most types, because doing so, will not start the lifetime of the object.</p>
<p><code class="sourceCode cpp"><span class="kw">static_cast</span></code> only works, where conversion of the source type to the target type are related. However, with pointer types the compiler cannot always check that the actual object type corresponds to the desired target type, causing invalid casts. Naïvely assuming that addresses of a derived object and its base object are identical is wrong in most cases. For example, with multiple inheritance, the address of an object may be different than one of its base class sub-objects. Using the generic pointer type <code class="sourceCode cpp"><span class="dt">void</span>*</code> (which is common in C APIs) allows converting between arbitrary pointer types using <code class="sourceCode cpp"><span class="kw">static_cast</span></code>. Most conversions via <code class="sourceCode cpp"><span class="dt">void</span> *</code> where the originial object type and the final target type are different are undefined behavior in C++. C++ allows <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> to a pointer to an incomplete type or a <code class="sourceCode cpp"><span class="kw">static_cast</span></code> from <code class="sourceCode cpp"><span class="dt">void</span> *</code> to a pointer to an incomplete type. Pointers to objects can implicitly convert to <code class="sourceCode cpp"><span class="dt">void</span> *</code> (cv-qualified accordingly).</p>
<p>It is only defined to reinterpret cast the obtained pointer back to the original type. It is implementation-defined if that bidirectional <code class="sourceCode cpp"><span class="dt">void</span> *</code> conversion also works for function pointers. A reinterpret cast can be used to convert a pointer from the integral types std::uintptr_t/std::intptr_t, but only if the value of the integer value was previously obtained by converting a valid pointer to said integral type. Casting an arbitrary integral value to a pointer is undefined behavior.</p>
<p>Casting along the inheritance relationships with <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> is safe, but it requires the dynamic type is known, which is the case when the types declare virtual member functions. Within a constructor or destructor only the static type of the current class is relevant, because the lifetime of any derived class object hasn’t started or has already ended. See subclause <a href="#BKK">Polymorphic Variables [BKK]</a>.</p>
<p>Conversions involving <code class="sourceCode cpp"><span class="at">const</span></code> and/or <code class="sourceCode cpp"><span class="at">volatile</span></code> properties of a type are permitted using <code class="sourceCode cpp"><span class="kw">const_cast</span></code> (see <a href="#UJO">Modifying constants [UJO]</a>). Adding <code class="sourceCode cpp"><span class="at">const</span></code> with <code class="sourceCode cpp"><span class="kw">const_cast</span></code> is safe.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.11.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.11.5.</p></li>
<li><p>Avoid the C-style cast, <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>, and casts to and from <code>void*</code>.</p></li>
<li><p>For conversions that remove the <code class="sourceCode cpp"><span class="at">const</span></code> qualification, see the guidance in clause <a href="#UJO">Modifying constants [UJO]</a>.</p></li>
<li><p>When downcasting or crosscasting see the guidance in clause <a href="#BKK">Polymorphic Variables [BKK]</a>.</p></li>
<li><p>If pointer and reference conversions cannot be avoided, treat compiler warnings that are issued for such conversions as hard errors.</p></li>
<li><p>Ensure through static analysis that arbitrary pointer casts return a type compatible with the source.</p></li>
</ul>
<h2 id="RVG">6.12 Pointer Arithmetic [RVG]</h2>
<h3 id="applicability-to-language">6.12.1 Applicability to language</h3>
<p>The vulnerabilites described in ISO/IEC 24772-1:2022 clause 6.12.1 also apply to C++. The vulnerabilities caused by out-of-bounds access are covered in clause <a href="#HCB">6.8</a>.</p>
<p>Pointers to functions, pointers to members, and pointers to <code class="sourceCode cpp"><span class="dt">void</span></code> do not allow pointer arithmetic.</p>
<p>The set of valid pointers referring to an array consists of the pointers to each array element plus the pointer just past the end of the array, however dereferencing a pointer one past the end of the array is undefined behaviour. A pointer to a single object is considered to point to an array of size one with respect to pointer arithmetic.</p>
<p>Adding or subtracting an integral value to a pointer value must yield a result that is a valid pointer refering to the same array, otherwise the behavior is undefined. Note: the built-in indexing operator is defined in terms of pointer arithmetic.</p>
<p>Subtraction of two pointers has undefined behaviour unless both pointers refer to the same array or are both null.</p>
<p>Comparison of two pointers with one of the operators <code class="sourceCode cpp">&lt; &gt; &lt;= &gt;= &lt;=&gt;</code> has unspecified behaviour unless both pointers refer to the same underlying array or object. The standard library function objects for comparison, like <code>std::less&lt;&gt;</code>, provide a strict total order of pointers of a given type.</p>
<p>Iterators as defined by the standard library suffer from similar vulnerabilities as pointer arithmetic. Comparison and subtraction of two iterators, or computing <code>std::distance</code> cause undefined behavior for iterators that refer to different ranges. Forming an iterator that is outside of its underlying range similarly is undefined behavior.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.12.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Avoid explicit pointer arithmetic, especially on a pointer to a single object.</p></li>
<li><p>Prefer calling range-based algorithms over pointer arithmetic.</p></li>
<li><p>Use the avoidance mechanisms of <a href="#HCB">6.8.2</a>.</p></li>
<li><p>Compare arbitrary pointers to objects with the standard library comparison function objects instead of the operators <code class="sourceCode cpp">&lt; &gt; &lt;= &gt;= &lt;=&gt;</code>.</p></li>
</ul>
<h2 id="XYH">6.13 NULL Pointer Dereference [XYH]</h2>
<h3 id="applicability-to-language">6.13.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.13 exists in C++. Dereferencing a pointer with the value of <code class="sourceCode cpp"><span class="kw">nullptr</span></code> is undefined behavior <a href="#EWF">[EWF]</a>.</p>
<p>Using pointers is inherently problematic especially for function parameters and return values, due to the following issues:</p>
<ul>
<li>is a <code class="sourceCode cpp"><span class="kw">nullptr</span></code> value valid in context?</li>
<li>is there protection against dereference of a <code class="sourceCode cpp"><span class="kw">nullptr</span></code> value?</li>
<li>is it a single object or an array of objects? (<code class="sourceCode cpp">T[]</code> as a function parameter type is identical to <code class="sourceCode cpp">T*</code>)</li>
<li>what is the lifetime of the target of the pointer?</li>
<li>who has ownership of the target object?</li>
</ul>
<p>Using values instead of pointers sidesteps all pointer vulnerabilities, especially when returned from a function. For example, standard library containers like <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> have value semantics and do not suffer from this vulnerability.</p>
<p>C++ references cannot be null in a well-defined program and solve the null-dereferencing vulnerability. They are particularly useful as function parameters. Using a reference as function return type requires the caller to avoid accessing an object outisde of its lifetime (see <a href="#XYK">[XYK]</a>, <a href="#DCM">[DCM]</a>).</p>
<p>If absence of a value is necessary, a class type for optional values such as <code class="sourceCode cpp"><span class="bu">std::</span>optional</code> provides well-defined behaviour and single-object ownership. In case of attempting to access the value of an empty <code class="sourceCode cpp"><span class="bu">std::</span>optional</code> an exception is thrown.</p>
<p>Note: Be aware that <code class="sourceCode cpp">optional&lt;T&amp;&gt;</code> is not supported by the standard library. For representing optional references <code class="sourceCode cpp"><span class="bu">std::</span>optional&lt;<span class="bu">std::</span>reference_wrapper&lt;T&gt;&gt;</code> or a non-standard implementation of <code class="sourceCode cpp">optional</code> supporting references can be used.</p>
<p>If dynamically allocated objects are required, <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr&lt;T&gt;</code> can be used for lifetime-management and for transferring ownership. When shared ownership of such objects is necessary, <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr&lt;T&gt;</code> is a solution. Using <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr&lt;T <span class="at">const</span>&gt;</code> provides value semantics for immutable heap-allocated objects thus sidestepping most of the issues of pointers above. Constructing a smart pointer through the factories <code class="sourceCode cpp"><span class="bu">std::</span>make_unique</code> or <code class="sourceCode cpp"><span class="bu">std::</span>make_shared</code> will return a non-null smart pointer or throw an exception and thus prevent the vulnerability of null pointers, in contrast to legacy allocation mechanisms and some overloads of <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">new</span></code>. However, in general dereferencing a <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr</code> or <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr</code> equal to <code class="sourceCode cpp"><span class="kw">nullptr</span></code> causes undefined behaviour, for example, when such a smart pointer is default constructed or a <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr</code> is in a moved-from state. For further information see also <a href="#XYL">[XYL]</a>.</p>
<!-- See C++ Core Guidelines ES.65 and section R: Resource Management, and CERT EXP34-C "Do not
dereference null pointers" -->
<h3 id="avoidance-mechanisms-for-language-users">6.13.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Avoid the need for pointers by using values.</p></li>
<li><p>Prefer references over pointers for parameters.</p></li>
<li><p>Use <code class="sourceCode cpp"><span class="bu">std::</span>optional</code> instead of a pointer to represent a potentially empty value.</p></li>
<li><p>Use containers with value semantics instead of plain arrays such as <code class="sourceCode cpp"><span class="bu">std::</span>array</code>, <code class="sourceCode cpp"><span class="bu">std::</span>vector</code>.</p></li>
<li><p>Use <code class="sourceCode cpp">make_unique()</code> or <code class="sourceCode cpp">make_shared()</code> for dynamically allocating objects.</p></li>
<li><p>If using objects of pointer-like types that may be a <code class="sourceCode cpp"><span class="kw">nullptr</span></code> value is unavoidable, use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.13.5.</p></li>
<li><p>Use static and dynamic analysis tools to detect potential violations of this guideline.</p></li>
</ul>
<h2 id="XYK">6.14 Dangling Reference to Heap [XYK]</h2>
<h3 id="applicability-to-language">6.14.1 Applicability to language</h3>
<p>The vulnerability as expressed in ISO/IEC TR 24772-1:2019 and ISO/IEC TR 24772-3:2020 C exists in C++. C++, however, provides mechanisms to mitigate the vulnerability. In contrast to C, where the mere existance of reachable memory for an object is sufficient to access it, the lifetime model of C++ makes it <em>undefined behaviour</em> (see subclause <a href="#EWF">[EWF]</a>) to access an object outside of its lifetime. This results in undefined behavior, when an object access is attempted before one of its constructors is finished or after its destruction. For example, container types like <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> or wrapper types like <code class="sourceCode cpp"><span class="bu">std::</span>optional</code> might have memory for an object available, that is not constructed or has ended its lifetime. For similar situations that result from accessing temporary objects or variables outside of their lifetime see subclause <a href="#DCM">[DCM]</a>. If such a temporary or local object manages heap memory (e.g., <code>std::vector</code>) referring to an element after the manager’s lifetime ended technically falls into the category of this vulnerability, but is covered there.</p>
<p>C++ provides a rich set of <em>pointer-like</em> types (potentially referring to heap memory) whose values may dangle, e.g.,</p>
<ul>
<li>References (the term value here includes references)</li>
<li>Pointers</li>
<li>Iterators</li>
<li>Views, e.g.,
<ul>
<li><code class="sourceCode cpp"><span class="bu">std::</span>string_view</code></li>
<li><code class="sourceCode cpp"><span class="bu">std::</span>span</code></li>
</ul></li>
<li><code class="sourceCode cpp"><span class="bu">std::</span>reference_wrapper</code></li>
</ul>
<p>In addition, a user-defined class type can be a <em>pointer-like</em> type, if a subobject is of <em>pointer-like</em> type and refers to an object (<em>target</em>) whose lifetime is different from and not managed by the current object. Sometimes, regular object types act as <em>pointer-like</em> types, e.g., indices into a container or operating system handles, and their validity can not be directly mapped to the C++ object lifetime model.</p>
<p>If the lifetime of a <em>pointer-like</em> value ends before the lifetime of its <em>target</em>, then the vulnerability does not apply to that <em>pointer-like</em> value. This is the primary C++ strategy for avoiding vulnerabilities of dangling <em>pointer-like</em> values. For example, an object argument passed as a function parameter of reference type persists throughout the function call. The lifetime guarantee of a function argument passed indirectly via a <em>pointer-like</em> type does not apply if * the target is destroyed explicitly by the called function (taking ownership of the target) or a concurrently executing operation, or if * copies of the <em>pointer-like</em> parameter outlive the function call, for example, as the return value, or in a coroutine or thread frame.</p>
<p>For objects directly allocated on the heap C++ provides smart pointers and corresponding factory functions (e.g., <code class="sourceCode cpp"><span class="bu">std::</span>make_unique()</code>) that allow transferring ownership or shared ownership to reduce the risk for dangling. However, storing the raw pointers managed by smart pointers can lead to accidental dangling, for example:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> * f(){</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> up = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">42</span>);</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> up.get(); <span class="co">// returned pointer dangles</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The C++ library containers, such as <code class="sourceCode cpp"><span class="bu">std::</span>vector</code>, manage the required heap memory for their elements. Referring to an element in a container via a <em>pointer-like</em> type is safe, as long as the container remains unchanged while the element object is accessed. In general, accessing an element in a mutated container via a <em>pointer-like</em> value obtained before the mutation is undefined behavior. Different containers provide different validity guarantees of accessing an element via a <em>pointer-like</em> type that was obtained before a subsequent change in that container.</p>
<p>Hand-written loops are prone to attempt to access elements of a container that are non-existent, or have been relocated. Employing standard library algorithms to iterate over a range of elements from a container tends to be safer, as long as the underlying container is not accidentally changed. For example, the following code can cause a failure, due to the attempt to iterate over a changing <code class="sourceCode cpp"><span class="bu">std::</span>vector</code>:</p>
<!-- CE: https://godbolt.org/z/qxWad1ox5 -->
<div class="sourceCode" id="cb106"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector v{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>};</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>copy(begin(v),end(v),back_inserter(v)); <span class="co">// modifying v while iterating is undefined behaviour</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>copy(begin(v),end(v), <span class="bu">std::</span>ostream_iterator&lt;<span class="dt">int</span>&gt;(<span class="bu">std::</span>cout,<span class="st">&quot;, &quot;</span>));</span></code></pre></div>
<h3 id="avoidance-mechanisms-for-language-users">6.14.2 Avoidance mechanisms for language users</h3>
<p>Software developers can avoid the vulnerability or mitigate its ill effects in the following ways: They can</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.14.5.</p></li>
<li><p>Prefer value types that manage heap memory, for example, <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> or <code class="sourceCode cpp"><span class="bu">std::</span>string</code>, and pass by value/return by value over the use of <em>pointer-like</em> types.</p></li>
<li><p>If value types are not feasible, adopt a style that makes explicit the ownership and lifetime of heap resources, by using <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr</code> or <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr</code> or similar manager types and allocate heap memory exclusively with their corresponding factory functions <code class="sourceCode cpp"><span class="bu">std::</span>make_unique/<span class="bu">std::</span>make_shared</code>.</p></li>
<li><p>Ensure all copies of any <em>pointer-like</em> value are no longer accessible or accessed after the referent’s lifetime ends.</p></li>
<li><p>Prohibit access of a container through an invalidated iterator, and similarly, access via other potentially dangling <em>pointer-like</em> values, e.g., views.</p></li>
<li><p>Avoid unmanaged heap allocation by <code class="sourceCode cpp"><span class="kw">new</span></code>/<code class="sourceCode cpp"><span class="kw">delete</span></code> expressions or calling C-library heap allocation functions.</p></li>
<li><p>Avoid manually ending the lifetime of an non-owned object by explicitly calling its destructor or <code class="sourceCode cpp"><span class="bu">std::</span>destroy_at</code>.</p></li>
<li><p>Use static and dynamic analysis tools to detect dangling.</p></li>
</ul>
<h2 id="FIF">6.15 Arithmetic Wrap-around Error [FIF]</h2>
<h3 id="applicability-to-language">6.15.1 Applicability to language</h3>
<p>C++ has the vulnerability as documented in ISO/IEC 24772-1 clause 6.15, since overflow situations are undefined behaviour for signed integer arithemtic and wrap-around for unsigned integer arithmetic, which can lead to surprising results. C++ specifies that</p>
<ul>
<li>although signed integers are defined to be represented as two’s complement, signed integer overflow is undefined behaviour,</li>
<li>unsigned integer arithmetic is defined to wrap-around (modulo arithmetic) and not overflow,</li>
<li>expressions of integral type can implicitly convert to other integral types, even when passed as function arguments,</li>
<li>operands of different arithmetic types in an expression are subject to the implicit “usual arithmetic conversions” that can be confusing, and</li>
<li>integral promotion can change the type of an expression from an unsigned type to a signed type before arithmetic takes place.</li>
</ul>
<p>For example, integral promotion happens when multiplying two <code class="sourceCode cpp"><span class="dt">unsigned</span> <span class="dt">short</span></code> operands which can result in undefined behavior:</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f(){</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>uint16_t x{<span class="dv">50&#39;000</span>},y{<span class="dv">50&#39;000</span>};</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x * y; <span class="co">// undefined behaviour due to overflow, returns int</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In the above, for a 16-bit <code>short</code> and a 32-bit <code>int</code>, i.e., <code>std::numeric_limits&lt;int&gt;::max()==0x7fff'ffff</code>, x and y are promoted to <code>int</code> and the multiplication then overflows which is undefined behaviour.</p>
<p>Even when operands have the same unsigned type, wrap-around arithmetic can be confusing, for example, <code>4U - 5U</code> yields a large positive value.</p>
<p>Calling a function taking a parameter of integral type with an argument of different integral type works due to implicit conversions. If a different overload with a better match becomes visible the called function can change when re-compiled (see <a href="#BJL">6.21 Namespace Issues[BJL]</a>)</p>
<p>Using brace-initialization prevents implicit narrowing conversions in contrast to other forms of initialization. For example:</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>uint16_t x{<span class="dv">500&#39;000</span>};  <span class="co">// won&#39;t compile due to narrowing</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>uint16_t y = <span class="dv">500&#39;000</span>; <span class="co">// compiles, but truncates value</span></span></code></pre></div>
<p>The mitigations for wrap-around errors in C++ are different than for C. The type system of C++ allows user-defined class and enum types with corresponding overloaded operators. Such user-defined types can individually control which implicit conversions or mixed type arithmetic they support, if any. For example, one can force arithmetic to be done with unsigned types:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> uint16: <span class="bu">std::</span>uint16_t{};</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>uint16 <span class="kw">operator</span>*(uint16 a, uint16 b){</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">static_cast</span>&lt;uint16&gt;(<span class="kw">static_cast</span>&lt;<span class="dt">unsigned</span>&gt;(a) * <span class="kw">static_cast</span>&lt;<span class="dt">unsigned</span>&gt;(b));</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>} <span class="co">// guarantee wrap-around</span></span></code></pre></div>
<p>High-integrity software using the built-in integral types should</p>
<ul>
<li>use integral types with a well-known range (i.e., those from <code class="sourceCode cpp">&lt;cstdint&gt;</code>),</li>
<li>refrain from relying on integral promotion and implicit conversions, and</li>
<li>guarantee that allowed variation in the range of representable values do not influence computed results.</li>
</ul>
<h3 id="avoidance-mechanisms-for-language-users">6.15.2 Avoidance mechanisms for language users</h3>
<p>Software developers can avoid the vulnerability or mitigate its ill effects in the following ways: They can</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.15.5.</p></li>
<li><p>Use appropriate user-defined types with well-defined range in place of built-in integral types, that mitigate against implicit conversions and undefined behaviour.</p></li>
<li><p>Use types with a well-defined range and have compile-time guarantees that the range of types used is sufficient, i.e., with <code class="sourceCode cpp"><span class="kw">static_assert</span></code>.</p></li>
<li><p>Avoid implicit integral promotions and integral conversions, especially on function arguments.</p></li>
<li><p>Avoid mixing integral types with different size or different signedness in the same expression.</p></li>
<li><p>Ensure that the result of any mathematical operation fits within the constraints of the types involved within the expression.</p></li>
<li><p>Use unsigned types that do not promote to <code class="sourceCode cpp"><span class="dt">int</span></code> to avoid undefined behavior due to signed integer overflow.</p></li>
<li><p>Consider the use of <code class="sourceCode cpp">numeric_limits&lt;T&gt;::is_modulo</code> to determine whether or not an integer type <code class="sourceCode cpp">T</code> wraps for the target system.</p></li>
<li><p>Document where wrap-around is expected for a type.</p></li>
<li><p>Use static and dynamic analysis tools to detect problematic expressions.</p></li>
</ul>
<h2 id="PIK">6.16 Using Shift Operations for Multiplication and Division [PIK]</h2>
<h3 id="applicability-to-language">6.16.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC 24772-1 clause 6.16 exists in C++. C++ complicates the discussion in 24772-1 clause 6.16 as a result of the integral promotion (see clause 6.06 [FLC]). A left-shift on an operand that gets promoted can result in a value outside the operand’s unpromoted type’s range.</p>
<p>Not every use of a shift operator is a bit-shift due to operator overloading.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.16.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li>use the avoidance mechanisms of ISO/IEC TR 24772-1:2019 clause 6.16 *Using Shift Operations for Multiplication and Division [PIK].</li>
<li>For promoted operands, consider converting the result of a shift operation back to the original type of the left hand operand (say using a static cast or an assignment to an object of that type) before using the result in further operations.</li>
</ul>
<h2 id="NAI">6.17 Choice of Clear Names [NAI]</h2>
<h3 id="applicability-to-language">6.17.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.17 is applicable to C++, as it is susceptible to errors resulting from the use of similarly appearing names. However, the language rules prevent using an identifier that has not been declared. There are two possible issues: the use of the identical name for different purposes (see clause <a href="#YOW">6.20 Identifier Name Reuse [YOW]</a>) and the use of similar names for different purposes.</p>
<ul>
<li><em>Mixed casing</em>: C++ distinguishes upper case and lower-case letters in names. Thus, confusion can arise through the use of <code>Item</code> and <code>item</code> as distinct declared identifiers with different meanings.</li>
<li><em>Underscores</em>: C++ permits single underscores in identifiers and they are significant. Thus, <code>BigDog</code> and <code>Big_Dog</code> are different identifiers. Multiple underscores or a leading underscore followed by an upper-case letter cause undefined behaviour, thus <code>Big__Dog</code> and <code>_BigDog</code> should not be used.</li>
<li><em>Singular/plural forms</em>: C++ does permit the use of identifiers which differ solely in this manner such as <code>item</code> and <code>items</code>. However, C++ lets the programmer use the identifier <code>item</code> for a single object of a type <code>T</code> and the identifier <code>items</code> for an object denoting a range of items of <code>T</code>. The use of <code>item</code> where <code>items</code> was intended or vice versa usually will be detected by the compiler because of the type mismatch.</li>
<li><em>International character sets</em>: C++ compilers support unicode characters in their source character set and also in identifiers. This can lead to vulnerabilities due to (near) identical representation of distinct names (e.g., homoglyph attacks). Another potential problem is in changing the text direction from left-to-right to right-to-left. This can render code that the compiler accepts, unintelligible, and can be used as an source-code attack vector.</li>
<li>Additionally, in Unicode, the right-to-left character is encoded at U+200F RIGHT-TO-LEFT MARK (‏). In UTF-8 it is E2 80 8F. Usage is prescribed in the Unicode Bidi (bidirectional) Algorithm.[1]</li>
<li><em>Identifier length</em>: The C++ standard recommends compilers to distinguish at least 1024 significant characters for an identifier. The actual limit of compiler for identifier length is implementation-defined and thus must be documented. All characters up to the length supported by the compiler in an identifier in C++ are significant. Thus <code>Long_IdentifierA</code> and <code>Long_IdentifierB</code> are always different if the documented identifier limit is at least 16 characters.</li>
</ul>
<p>C++ permits the use of names such as <code>x</code>, <code>xx</code>, and <code>xxx</code>, possibly defined in non-obvious scopes, and a programmer can easily, by mistake, write <code>xx</code> where <code>x</code> or <code>xxx</code> was intended. Especially for overloaded functions, argument-dependent-lookup might find a function in a scope that the user did not consider. The use of the wrong name will typically result in a failure to compile so no vulnerability will arise. However, if the wrong name has a type compatible with the intended name’s type, then an incorrect executable program will be generated.</p>
<p>C++ defines reserves some names as context-specific keywords. While it is technically possible to use those names for other purposes, such use can be confusing.</p>
<p>In the global scope some namespaces (such as <code>std</code>, <code>posix</code>) are reserved and should not be used otherwise.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.17.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1:2019 clause 6.17.5.</p></li>
<li><p>Follow the rules of ISO/IEC 14882:2020 clause [lex.name] regarding names to refrain from usage.</p></li>
<li><p>Avoid the use of similar names to denote different objects of the same type.</p></li>
<li><p>Use consistency in choosing names, especially for dealing with similar names.</p></li>
<li><p>Use static analysis and tooling to enforce project-specific naming rules and detect possible similar names, for example, homoglyphs and unexpected text-direction vulnerabilities.</p></li>
<li><p>Keep the scope of names as small as reasonable.</p></li>
<li><p>Ensure that the names in your program do not exceed the compiler’s documented limit.</p></li>
<li><p>Do not differentiate names through only a mixture of case or the presence/absence of an underscore character.</p></li>
<li><p>Do not use as identifiers the contextual keywords <code class="sourceCode cpp"><span class="kw">final</span></code> , <code class="sourceCode cpp"><span class="kw">import</span></code>, <code class="sourceCode cpp"><span class="kw">module</span></code> and <code class="sourceCode cpp"><span class="kw">override</span></code> and other reserved names.</p></li>
</ul>
<h2 id="WXQ">6.18 Dead Store [WXQ]</h2>
<h3 id="applicability-to-language">6.18.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 clause 6.18 exists in C++.</p>
<p>The language definition permits the compiler to eliminate effects of the abstract machine that are not observable, in particular, dead stores. For example, the often-attempted write operations to non- volatile member variables in a destructor that are not subsequently used can be elided by the compiler.</p>
<p>C++ compilers and static analysis tools do exist that detect and generate warnings for dead stores.</p>
<p>The error in ISO/IEC 24772-1:2019 subclause 6.18.3 that the planned reader misspells the name of the store is possible but unlikely in C++ since the language specifies that all objects shall be declared and typed, and the existence of two objects with almost identical names and compatible types (for assignment) in the same scope would be readily detectable. See 6.17 [NAI] Choice of clear names, 6.20 Identifier name reuse [YOW], and 6.21 Namespace issues [BJL]</p>
<h3 id="avoidance-mechanisms-for-language-users">6.18.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.18.5.</p></li>
<li><p>Use compilers and static analysis tools to identify dead stores in the program.</p></li>
<li><p>Provide sufficient synchronization to non-const variables that are accessed by multiple execution agents. See clause 6.61 Concurrent data access [CGX]</p></li>
</ul>
<h2 id="YZS">6.19 Unused Variable [YZS]</h2>
<h3 id="applicability-to-language">6.19.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC 24772-1 clause 6.19 exists in C++.</p>
<p>A common practice for resource management in C++ relies on what is called “RAII” or “SBRM” (scope-based resource management): employing a class’ destructor to release resources managed by the object. This can lead to code without visible use of a variable being present in the source code, because all work is done by the variable’s constructor and/or destructor.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.19.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.19.5.</p></li>
<li><p>Use compiler warnings and/or static analysis tools to indicate and eliminate unused variables.</p></li>
</ul>
<h2 id="identifier-name-reuse-yow">6.20 Identifier Name Reuse [YOW]</h2>
<h3 id="applicability-to-language">6.20.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.20 exists in C++, except for the second issue of limited identifier length. In C++ all characters in an identifier are significant.</p>
<p>C++ provides the scope resolution operator <code>::{.cpp}</code> to access identifiers from non-local scopes.</p>
<p>Overloading and specialization of functions is a cornerstone of C++ generic programming. In this context, the reuse of function names is essential. See clause 6.41 for inheritance issues associated with name reuse.</p>
<p>Overloaded function names and operators considered in an expression are not restricted to a simple scope hierarchy, because of argument-dependent lookup (ADL). In generic code the unqualified function or operator selected can come from a scope based on the type of the arguments and not from the current scope hierarchy. The rules for which namespaces are eligible for lookup of unqualified functions and operators are intricate, but required to make overloaded operators work.</p>
<p>In addition, if implicit conversions can happen on arguments, the overload selected by ADL can be different from programmer expectation even in non-generic code, especially when an argument is of a type that can be implicitly converted to another type where a corresponding overload is defined. Visibility on a namespace-level of such an operator overload may make it eligible, even if neither argument matches the parameter types directly. In the best case this leads to a compile error due to ambiguities, but it can also result in perfectly compiling code executing an unexcepted overload.</p>
<p>The following example demonstrates part of the problem:</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;typeinfo&gt;</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> Y {</span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print(T i){</span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">typeid</span>(T).name()&lt;&lt; <span class="st">&quot;:&quot;</span> &lt;&lt; i ;</span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> println(T x){</span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a>    print(x); <span class="co">// expects to call Y::print</span></span>
<span id="cb110-12"><a href="#cb110-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout&lt;&lt;<span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb110-13"><a href="#cb110-13" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb110-14"><a href="#cb110-14" aria-hidden="true" tabindex="-1"></a>} </span>
<span id="cb110-15"><a href="#cb110-15" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> X {</span>
<span id="cb110-16"><a href="#cb110-16" aria-hidden="true" tabindex="-1"></a>   <span class="kw">struct</span> A{</span>
<span id="cb110-17"><a href="#cb110-17" aria-hidden="true" tabindex="-1"></a>        A(<span class="dt">double</span>){}</span>
<span id="cb110-18"><a href="#cb110-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="co">// make this a hidden friend</span></span>
<span id="cb110-19"><a href="#cb110-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ostream &amp; <span class="kw">operator</span> &lt;&lt; (<span class="bu">std::</span>ostream &amp; out, A <span class="at">const</span> &amp;a){</span>
<span id="cb110-20"><a href="#cb110-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> out &lt;&lt; <span class="st">&quot;An A as expected</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb110-21"><a href="#cb110-21" aria-hidden="true" tabindex="-1"></a>        } </span>
<span id="cb110-22"><a href="#cb110-22" aria-hidden="true" tabindex="-1"></a>    };</span>
<span id="cb110-23"><a href="#cb110-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> print(A a){ <span class="co">// not expected to be called by println</span></span>
<span id="cb110-24"><a href="#cb110-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Surprise happens!&quot;</span>;</span>
<span id="cb110-25"><a href="#cb110-25" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb110-26"><a href="#cb110-26" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb110-27"><a href="#cb110-27" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main(){</span>
<span id="cb110-28"><a href="#cb110-28" aria-hidden="true" tabindex="-1"></a>    X::A a{<span class="fl">3.14</span>};</span>
<span id="cb110-29"><a href="#cb110-29" aria-hidden="true" tabindex="-1"></a>    Y::println(<span class="dv">42</span>); <span class="co">// i:42 - calls Y::print</span></span>
<span id="cb110-30"><a href="#cb110-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; a; <span class="co">// An A as expected - calls X::operator&lt;&lt;</span></span>
<span id="cb110-31"><a href="#cb110-31" aria-hidden="true" tabindex="-1"></a>    Y::println(a);  <span class="co">// Surprise happens! - calls X::print</span></span>
<span id="cb110-32"><a href="#cb110-32" aria-hidden="true" tabindex="-1"></a>    Y::println(<span class="dv">42</span><span class="bu">u</span>);<span class="co">// u:42 - calls Y::print</span></span>
<span id="cb110-33"><a href="#cb110-33" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The above code calls the overload <code>print(A)</code> from println since it is pulled in by ADL. On the other hand, ADL is required to work to allow the output operator for type <code>X::A</code> to work.</p>
<p>The consideration of implicit conversions together with ADL can be suppressed by defining operator overloads as class members or as <em>hidden friends</em>. The latter is achieved by declaring all corresponding overloads as <code class="sourceCode cpp"><span class="kw">friend</span></code> functions in the class that take the class’ objects as arguments. Generic base classes can provide mix-in facilities for <em>hidden friends</em> by taking the argument type that is the derived class as template parameter.</p>
<h3 id="avoidance-mechanismsfor-language-users">6.20.2 Avoidance mechanismsfor language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.20.5, with the exclusion of guidance related to truncated identifiers.</p></li>
<li><p>Qualify names to disambiguate potential conflicts between names introduced from different scopes.</p></li>
<li><p>Document argument-dependent lookup usage where name qualification is not desirable.</p></li>
<li><p>Limit the visibility of overloaded operators or functions for class types by defining them as member functions or <em>hidden friends</em>.</p></li>
<li><p>Place overloaded operators that are not class members and cannot be provided as <em>hidden friends</em> together with their argument type in a namespace that is not the global namespace,so that they are picked up by ADL.</p></li>
<li><p>Use modern integrated development environments that inform about the declaration of any identifier occurrence.</p></li>
<li><p>Enable compiler diagnostics that inform about the hiding of declarations.</p>
<ul>
<li><pre><code>  DCL60-CPP. Obey the one-definition</code></pre>
<p>rule (6.21)</p></li>
<li><pre><code>  DCL40-C. Do not create incompatible declarations of the same</code></pre>
<p>function or object (6.21)</p></li>
</ul></li>
</ul>
<h2 id="BJL">6.21 Namespace Issues [BJL]</h2>
<h3 id="applicability-to-language">6.21.1 Applicability to language</h3>
<p>The vulnerability described in ISO/IEC TR 24772-1:2019 clause 6.21 exists in C++. It can occur in particular when a used library changes its API. The situations where it exists are related to the following cases:</p>
<ul>
<li>Template specialization, where clause 6.40 [#SYM] applies;</li>
<li>Overloading, where clause 6.20 [#YOW] applies;</li>
<li>Overriding, where clause 6.41 [#RIP] applies.</li>
</ul>
<p>In the case of template specialization or non-identical definitions of the same entity in different translation units (ODR-violation), ill-formed code might be the result, however, a C++ compiler is not obliged to diagnose that situation, leading to undefined behaviour.</p>
<p>In the case of overloading and overriding cases, C++ compilers are required to diagnose an ambiguity if it exists.</p>
<p>However, overload resolution applies preference rules in order to select among multiple matching functions or function templates as a means to resolve the ambiguity among these functions. Hence, for calls that are not perfect matches, the user cannot guarantee in the presence of later changes which function is called, as another, better match can be introduced subsequently. The call in question then changes its binding without warning upon its next compilation. For cases, where the preference rules do not resolve the ambiguity, the resulting error message by the compiler avoids the vulnerability. Function template specializations are not considered during overload resolution, only the base template is considered.</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo (<span class="dt">long</span>);</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a><span class="co">// void foo (int);</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar ()</span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>  foo (<span class="dv">0</span>);         <span class="co">// The call to &#39;foo(long)&#39; requires implicitly conversion</span></span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>                   <span class="co">// from &#39;int&#39; to &#39;long&#39;.   The function &#39;foo(int)&#39; </span></span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>                   <span class="co">// would be a &quot;better match&quot; and so would silently</span></span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a>                   <span class="co">// be chosen when subsequently introduced</span></span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>A new declaration can impact existing code in a number of situations involving the addition of:</p>
<ul>
<li>an overload,</li>
<li>a using directive,</li>
<li>a declaration into a namespace that is searched as part of “Argument-Dependent Lookup”,</li>
<li>a non-template function that is preferred to a function template,</li>
<li>a template specialization.</li>
</ul>
<p>A <code class="sourceCode cpp"><span class="kw">using</span></code> directive broadens the possible scopes that will be examined for names during lookup. Where lookup searches a namespace referred to by a <code class="sourceCode cpp"><span class="kw">using</span></code> directive, all names in that namespace will be visible some of which may be unwanted. A using declaration, on the other hand, declares only the specified name into the scope of the <code class="sourceCode cpp"><span class="kw">using</span></code> declaration.</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> NS1</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f1 (<span class="dt">int</span>);</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f2 (<span class="dt">int</span>);        <span class="co">// Added later</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> NS2</span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> <span class="kw">namespace</span> NS1;  <span class="co">// &#39;f1&#39; needed</span></span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f2 (<span class="dt">long</span>);</span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> bar ()</span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a>    f1(<span class="dv">0</span>);              <span class="co">// Calls &#39;NS1::f1&#39;</span></span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a>    f2(<span class="dv">0</span>);              <span class="co">// Unintentionally calls &#39;NS1::f2&#39;</span></span>
<span id="cb114-14"><a href="#cb114-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb114-15"><a href="#cb114-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb114-16"><a href="#cb114-16" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> NS3</span>
<span id="cb114-17"><a href="#cb114-17" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb114-18"><a href="#cb114-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> NS1::f1;        <span class="co">// &#39;f1&#39; needed</span></span>
<span id="cb114-19"><a href="#cb114-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f2 (<span class="dt">long</span>);</span>
<span id="cb114-20"><a href="#cb114-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> bar ()</span>
<span id="cb114-21"><a href="#cb114-21" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb114-22"><a href="#cb114-22" aria-hidden="true" tabindex="-1"></a>    f1(<span class="dv">0</span>);              <span class="co">// Calls &#39;NS1::f1&#39;</span></span>
<span id="cb114-23"><a href="#cb114-23" aria-hidden="true" tabindex="-1"></a>    f2(<span class="dv">0</span>);              <span class="co">// Calls &#39;NS3::f2&#39; as expected</span></span>
<span id="cb114-24"><a href="#cb114-24" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb114-25"><a href="#cb114-25" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<!-- from 6.40: -->
<p>Overload resolution only considers conversions for the explicitly specified arguments and does not take default parameters into account:</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">short</span>, <span class="dt">int</span> = <span class="dv">0</span>);</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">int</span>, <span class="dt">short</span> = <span class="dv">0</span>);</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f2 ()</span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>);       <span class="co">// calls &#39;f1(1, 0)&#39; as &#39;1 -&gt; int&#39; is better match than &#39;1 -&gt; short&#39;</span></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>, <span class="dv">0</span>);    <span class="co">// ambiguous, ill-formed, won&#39;t compile</span></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The following example demonstrates a situation where the late addition of a better matching overload causes a silent change in the semantics of an existing program.</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> NS</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> A</span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a>  };</span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt; T foo ( T t )</span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> t;</span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-13"><a href="#cb116-13" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> NS2 <span class="co">// separately developed and included from a header file</span></span>
<span id="cb116-14"><a href="#cb116-14" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb116-15"><a href="#cb116-15" aria-hidden="true" tabindex="-1"></a>   <span class="kw">struct</span> B</span>
<span id="cb116-16"><a href="#cb116-16" aria-hidden="true" tabindex="-1"></a>   {</span>
<span id="cb116-17"><a href="#cb116-17" aria-hidden="true" tabindex="-1"></a>   };</span>
<span id="cb116-18"><a href="#cb116-18" aria-hidden="true" tabindex="-1"></a><span class="co">// This code will be added later</span></span>
<span id="cb116-19"><a href="#cb116-19" aria-hidden="true" tabindex="-1"></a><span class="co">//  template &lt; typename T &gt; T * foo ( T * t )</span></span>
<span id="cb116-20"><a href="#cb116-20" aria-hidden="true" tabindex="-1"></a><span class="co">//  {</span></span>
<span id="cb116-21"><a href="#cb116-21" aria-hidden="true" tabindex="-1"></a><span class="co">//    return t;</span></span>
<span id="cb116-22"><a href="#cb116-22" aria-hidden="true" tabindex="-1"></a><span class="co">//  }</span></span>
<span id="cb116-23"><a href="#cb116-23" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb116-24"><a href="#cb116-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-25"><a href="#cb116-25" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> NS2;</span>
<span id="cb116-26"><a href="#cb116-26" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> NS;</span>
<span id="cb116-27"><a href="#cb116-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-28"><a href="#cb116-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar()</span>
<span id="cb116-29"><a href="#cb116-29" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb116-30"><a href="#cb116-30" aria-hidden="true" tabindex="-1"></a>  A * a;</span>
<span id="cb116-31"><a href="#cb116-31" aria-hidden="true" tabindex="-1"></a>  B * b;</span>
<span id="cb116-32"><a href="#cb116-32" aria-hidden="true" tabindex="-1"></a>  foo (a); <span class="co">// After the commented-out code is added to NS2, the binding of foo changes silently from NS::foo to NS2::foo</span></span>
<span id="cb116-33"><a href="#cb116-33" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>This issue can be avoided by avoiding <code>using namespace xxx{.cpp}</code> and explicitly qualifying each call, such as <code>NS::foo(a){.cpp}</code>.</p>
<p>Analogously, when a more specialized template is added to an imported namespace where the more general template has already been provided in another namespace, preference rules will silently prefer the more specialized template.</p>
<p>A similar situation can occur when a conflict arises between compiler-synthesized or rewritten operators and explicitly created versions of those operators, as in the following example.</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span>==(A <span class="at">const</span> &amp;) <span class="at">const</span> { <span class="cf">return</span> <span class="kw">true</span>; }   </span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Evil hijacking of !=</span></span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a><span class="co">// bool operator != (A const &amp;, A const &amp;) { return true; } // #1</span></span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-9"><a href="#cb117-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar (A <span class="at">const</span> &amp; a) {</span>
<span id="cb117-10"><a href="#cb117-10" aria-hidden="true" tabindex="-1"></a>  a != a;                                                    <span class="co">// #2</span></span>
<span id="cb117-11"><a href="#cb117-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In the above example, the declaration of <code class="sourceCode cpp"><span class="kw">operator</span>==</code> will have a corresponding synthesised <code class="sourceCode cpp"><span class="kw">operator</span>!=</code> generated by the compiler, since there is no suitable user-declared <code class="sourceCode cpp">!=</code>. If the <code class="sourceCode cpp"><span class="kw">operator</span>!=</code> becomes visible, then the code at #2 uses the user-declared <code class="sourceCode cpp"><span class="kw">operator</span>!=</code> instead of the synthesized one, which can lead to a silent and unexpected change of behaviour. This is particularly risky when the operator is declared outside of the immediate visibility of the original definition.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.21.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of clauses 6.20.2, 6.40.2, and 6.41.2 as applicable.</p></li>
<li><p>Consider using fully qualified names for calls that rely on an implicit conversions.</p></li>
<li><p>Arguments to called functions should not be subject to implicit conversions.</p></li>
<li><p>Prefer using declarations to using directives.</p></li>
<li><p>Do not overload and use default arguments for the same set of functions.</p></li>
<li><p>Do not specialize function templates.</p></li>
<li><p>For template specialization, ensure that specializations are declared as follows:</p>
<ol type="1">
<li><p>In the same file as the primary template; or</p></li>
<li><p>In the same file as the user-defined type for which the specialization is declared.</p></li>
</ol></li>
<li><p>Define an entity in only one file to prevent ODR-violations.</p></li>
<li><p>Ensure that no ODR-violations occur, i.e., through a static analysis tool.</p></li>
<li><p>Use a version-aware analysis tool to identify situations where preference rules cause a silent change of name binding between versions.</p></li>
<li><p>Only declare equaility or relational operators as member functions or friend functions of the class</p></li>
</ul>
<h2 id="LAV">6.22 Missing Initialization of Variables [LAV]</h2>
<h3 id="applicability-to-language">6.22.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 exists in C++, however, defining variables only when they can be initialized properly with an initializer in their definition avoids reading uninitialized memory.</p>
<p>Defining/allocating objects of trivial type with automatic/dynamic storage duration without initialization leaves the object with an indeterminate value. A subsequent read of such a variable before it has been written is undefined behavior. In addition, sub-objects of trivial type that are omitted in a constructor’s member initializer list and not initialized by the constructor’s body or by a <em>default member initializer</em> will not be initialized by that constructor. For example, the following class definitions suffer from incomplete initialization of subobjects, even though class <code>test</code> defines a default constructor:</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> base { <span class="dt">short</span> num; };                                                     </span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> test : base                                                              </span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>{                                                                               </span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">enum</span> E1 { e1a=<span class="dv">100</span>, e1b, e1c };                                                </span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> one; </span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> two; </span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> ar1[<span class="dv">2</span>]{ <span class="fl">1.1</span>, <span class="fl">2.2</span> }; </span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> ar2[<span class="dv">2</span>]; </span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>  E1 e1; </span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a>  E1 e2;                 </span>
<span id="cb118-11"><a href="#cb118-11" aria-hidden="true" tabindex="-1"></a>  test() </span>
<span id="cb118-12"><a href="#cb118-12" aria-hidden="true" tabindex="-1"></a>  : <span class="co">// base unintialized </span></span>
<span id="cb118-13"><a href="#cb118-13" aria-hidden="true" tabindex="-1"></a>  one{ <span class="dv">1</span> }</span>
<span id="cb118-14"><a href="#cb118-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// two uninitialized</span></span>
<span id="cb118-15"><a href="#cb118-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ar1 initialized through default member initializer</span></span>
<span id="cb118-16"><a href="#cb118-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ar2 uninitialized</span></span>
<span id="cb118-17"><a href="#cb118-17" aria-hidden="true" tabindex="-1"></a>  , e1{} <span class="co">// initializes to zero, not a named enumerator value </span></span>
<span id="cb118-18"><a href="#cb118-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">// e2 uninitialized</span></span>
<span id="cb118-19"><a href="#cb118-19" aria-hidden="true" tabindex="-1"></a>  { }                                  </span>
<span id="cb118-20"><a href="#cb118-20" aria-hidden="true" tabindex="-1"></a>};                                                                              </span></code></pre></div>
<p>Dynamically allocating memory for an object using <code class="sourceCode cpp">malloc</code>, or some other C-style equivalent, does not initialize the object. Interpreting such memory as an object with trivial type will result in it having an indeterminate value.<br />
Objects with non-trivial type require running a constructor for its lifetime to start correctly. In both cases attempting to cast a pointer to the allocated memory and using the object is undefined behavior except for special sanctioned cases, see <a href="#FLC">Conversion Errors [FLC]</a> and <a href="#HFC">Pointer Type Conversion [HFC]</a>.</p>
<p>Non-local variables with static storage duration that are dynamically initialized can cause undefined behavior if the initialization depends on other such variables. If the dependency is in the same translation unit the sequencing is defined in definition order, however, there is no sequencing guarantees across translation unit boundaries and thus, undefined behaviour can occur by accessing an uninitialized variable. For example:</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A {</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>  A (<span class="dt">int</span> i ) : <span class="va">i_</span> { i }  {  }</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> <span class="va">i_</span>;</span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> B {</span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a>  B (A <span class="at">const</span> &amp; a) : <span class="va">j_</span>{a.<span class="va">i_</span>} { }</span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> <span class="va">j_</span>;</span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> A a;  <span class="co">// declare existance of variable &#39;a&#39;</span></span>
<span id="cb119-10"><a href="#cb119-10" aria-hidden="true" tabindex="-1"></a><span class="co">// defining variables with dynamic intialization:</span></span>
<span id="cb119-11"><a href="#cb119-11" aria-hidden="true" tabindex="-1"></a>B b { a };   <span class="co">//  #1</span></span>
<span id="cb119-12"><a href="#cb119-12" aria-hidden="true" tabindex="-1"></a>A a { <span class="dv">42</span> };  <span class="co">//  #2</span></span></code></pre></div>
<p>If #1 and #2 are in the same translation unit, then <code>a</code> in #1 is incompletely initialized (zero initialized). If #1 and #2 are in different translation units, then the order of initialization of <code>a</code>(#2) relative to <code>b</code>(#1) is indeterminate.</p>
<p>The <code>constexpr</code>-specifier for a variable ensures initialization at compile time. The <code class="sourceCode cpp"><span class="kw">constinit</span></code> specifier ensures a variable is initialized at compile time, even if it is non-const.</p>
<p>Defining non-member variables as <code class="sourceCode cpp"><span class="at">const</span></code> or as <code class="sourceCode cpp"><span class="kw">constexpr</span></code>, enforces initialization by the compiler and makes reasoning about code easier.</p>
<p>If determining the initial value of a variable requires complex logic, putting that logic into an immediately-invoked lambda expression that computes the initial value, permits the variable to be initialized when defined.</p>
<!--
In addition some of the rules of initialization in C++ are complicated.  For example, there are the 
following initialization cases:
- no initialization (see above),
- zero-initialization,
- value-initialization,
- default-initialization,
- list initialization,
- aggregate inialization,
- member initialization,
- base-class initialization,
- constant initialization (`constexpr`{.cpp} and `constinit`{.cpp}),
- static initialization,
- dynamic initialization, 
- etc...
-->
<p>See C++ Core Guidelines ES.20 and CERT C++ Coding Guidelines EXP53-CPP. Note that ES.20 and EXP53 are complementary. Both point out that you should always initialize before reading, but ES.20 uses the narrow sense of initialize while EXP53 includes assignment.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.22.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li>Use the avoidance mechanisms of ISO/IEC 24772-1 subclause 6.22.5</li>
<li>Initialize every object defined, including data members, such as by providing an initializer for each variable definition.</li>
<li>Consider defining non-member variables as <code class="sourceCode cpp"><span class="at">const</span></code> to enforce initialization, otherwise defer the definition of the variable until a sensible initial value can be provided.</li>
<li>In situations where variable initialization seems to require complex logic, encapsulate that logic either in a function or a lambda that encapsulates the complex logic and returns the initial value. In case of multiple interdependent variables, group those in a struct and return the struct.</li>
<li>Avoid using non-const variables with static storage duration (see <span id="CGX">6.61 Concurrent Data Access [CGX]</span>).</li>
<li>Define variables with static storage duration with <code class="sourceCode cpp"><span class="kw">constexpr</span></code> or <code class="sourceCode cpp"><span class="kw">constinit</span></code> whenever possible to avoid problems with dynamic initialization order.</li>
<li>Do not depend on the order of dynamic initialization of non-local variables with static storage duration, unless the initialization order is guaranteed by the language.</li>
<li>If the use of uninitialized variables is unavoidable, employ tools, including the compiler, that detect reads of variables with indeterminate values.</li>
</ul>
<h2 id="operator-precedence-and-associativity-jcw">6.23 Operator Precedence and Associativity [JCW]</h2>
<h3 id="applicability-to-language">Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.23 is applicable to C++.</p>
<p>Operator precedence and associativity in C++ are determined by the C++ grammar. There are four operators that cannot be overloaded (user-defined):</p>
<ul>
<li><p><code class="sourceCode cpp">::</code> ;</p></li>
<li><p><code class="sourceCode cpp">.</code> ;</p></li>
<li><p><code class="sourceCode cpp">.*</code> ; and</p></li>
<li><p><code class="sourceCode cpp">?:</code> .</p></li>
</ul>
<p>Due to the large number of operators, one is recommended to consult an operator precedence table when needed, e.g., <a href="https://en.cppreference.com/w/cpp/language/operator_precedence">[https://en.cppreference.com/w/cpp/language/operator_precedence]</a>. For example, in C++, the bitwise logical and shift operators are sometimes incorrectly treated as having the same precedence as arithmetic operations even though the bitwise operators have lower precedence. For example, the following (correct) expression subtracts one from <code class="sourceCode cpp">x</code> and then checks if the result is zero:</p>
<p><code class="sourceCode cpp">x - <span class="dv">1</span> == <span class="dv">0</span></code></p>
<p>which is equivalent to <code class="sourceCode cpp">(x - <span class="dv">1</span>) == <span class="dv">0</span></code>,i.e., <code class="sourceCode cpp">x - <span class="dv">1</span></code> is done first, then that result is compared to <code class="sourceCode cpp"><span class="dv">0</span></code>. Programmers mistakenly thinking the bitwise operations have the same precedence as arithmetic ones might write:</p>
<p><code class="sourceCode cpp">x &amp; <span class="dv">1</span> == <span class="dv">0</span></code></p>
<p>intending to perform <code class="sourceCode cpp">(x &amp; <span class="dv">1</span>) == <span class="dv">0</span></code>, but precedence rules result in this evaluating <code class="sourceCode cpp">x &amp; (<span class="dv">1</span> == <span class="dv">0</span>)</code> instead. This would have been easily fixed by using parenthesis to ensure the proper evaluation of an expression.</p>
<p>In addition to the aforementioned, C++ also permits operators to be overloaded when used with user-defined types. While it is not possible to change the precedence, associativity, and number of operands of overloaded operators [C++17, Clause 16.5 [over.oper], para. 6], overloaded operators can be executed differently than built-in operators. For example, overloaded operators lose any built-in operator short-circuiting properties and sequence order guarantees. Similarly overloaded operators and their arguments' evaluations behave as normal function calls, differing from built-in operator evaluation.</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A {  };</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span>&amp;&amp;(A <span class="at">const</span> &amp;, <span class="dt">int</span>);</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> foo ();</span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar (A <span class="at">const</span> &amp; a)</span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (a     &amp;&amp; foo());  <span class="co">// &#39;foo()&#39; always evaluated</span></span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="kw">false</span> &amp;&amp; foo());  <span class="co">// &#39;foo()&#39; never evaluated</span></span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (a.<span class="kw">operator</span>&amp;&amp; (<span class="kw">false</span>,foo())); <span class="co">// &#39;foo()&#39; always evaluated</span></span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Note that overloaded assignment falls into this category.</p>
<p>For issues related to the declaration of equality and relational operators see Clause 6.25 [KOA].</p>
<h3 id="avoidance-mechanisms-for-language-users">6.23.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 Clause 6.23.5 [JCW].</p></li>
<li><p>Enable all C++ compiler/tool warnings and static analysis tool diagnostics concerning possible issues with precedence and associativity to help detect and avoid mistakes.</p></li>
<li><p>Even if technically unnecessary, use parentheses around operator (sub)expressions that are known to be or felt likely to be sources of error.</p></li>
<li><p>Avoid overloading the following operators <code class="sourceCode cpp">&amp;&amp;</code>, <code class="sourceCode cpp">||</code>, <code class="sourceCode cpp">,</code> and their alternative spellings.</p></li>
<li><p>Break up complex expressions and use temporary variables to make complex expressions easier to understand and maintain.</p></li>
</ul>
<h2 id="side-effects-and-order-of-evaluation-of-operands-sam">6.24 Side-effects and Order of Evaluation of Operands [SAM]</h2>
<h3 id="applicability-to-language">6.24.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.24 exists in C++.</p>
<p>The evaluation of an expression includes: (i) its value computation; and (ii) its side-effects. The value computation is the value returned by the expression, e.g., the valuation of <code>3 * 2 + 1</code> is <code>7</code>. The side-effect of an expression are</p>
<ul>
<li><p>Write accesses to objects in that expression,</p></li>
<li><p>Reading a volatile object,</p></li>
<li><p>Calling a library I/O function, and</p></li>
<li><p>Calling a function that does any of the above.</p></li>
</ul>
<p>For example consider:</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i = <span class="dv">2</span>;</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> j = i++;</span></code></pre></div>
<p>the evaluation of i++ is 2 and the side-effects are the writing of 3 to i and the initialization of j.</p>
<p>Within an expression, one must ensure an object is stored only once to avoid undefined behaviour, e.g.,</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>i = i++ + <span class="dv">5</span>; <span class="co">// undefined behaviour (before C++17)</span></span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>k = i++ + i\--; <span class="co">// undefined behaviour in all versions of C++</span></span></code></pre></div>
<p>and expressions modifying objects can only read the object to determine the value to be stored (e.g., ++i requires reading the value), i.e., other accesses are undefined behaviour, e.g.,</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>my_array\[i\] = i++; <span class="co">// undefined behaviour (before C++17)</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>Starting with C++<span class="dv">17</span>, the evaluation order of an expression involving</span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>overloaded operators preserves the sequenced before behaviour of the</span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>built-in <span class="kw">operator</span>:</span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a><span class="er">```</span>{.cpp}</span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a>my_array[i] = i++;</span>
<span id="cb124-9"><a href="#cb124-9" aria-hidden="true" tabindex="-1"></a>my_array[i++] = i++;</span></code></pre></div>
<p>say <code class="sourceCode cpp">i = <span class="dv">10</span></code> before the expression</p>
<p>evaluate RHS <code>i++</code> – <code>i</code> is <code>11</code></p>
<p>evaluate <code>my_array[i++]</code> //evaluates <code>my_array\[11\]</code>, then assigns <code>i</code> to <code>12</code></p>
<p><code>my_array[11]</code> is assigned <code>10</code></p>
<p>This occurs because assignment is sequenced after the value computation of the right and left operands and before the value computation of the assignment expression and, the right operand is sequenced before the left operand. [C++17, Clause 8.18 [expr.ass], para. 1] Since this is the built-in operator, this statement can be thought of as:</p>
<blockquote>
<p>Compute value of right-hand-side: <code>i++</code> (e.g., integer value).</p>
<p>Compute value of left-hand-side: <code>my_array[i]</code> (e.g., memory address).</p>
<p>Apply side-effects of <code>i++</code>.</p>
<p>Apply side-effects of the assignment.</p>
</blockquote>
<p>In general, one should follow commonly-stated C/C++ advice of never reading from and writing to the same object within an expression to avoid potential vulnerabilities. Often breaking the expression into separate statements achieves clear and clean semantics, e.g.,</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>++i;</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>my_array[i] = i;</span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a>my_array[i] = i;</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>++i;</span></code></pre></div>
<p>makes it unambiguous what the value of i is during the array assignment and eliminates the possibility of vulnerabilities.</p>
<p>In addition, it is important to note that overloading an operator disables short-circuiting behaviours (e.g., built-in boolean operators): those operators' operands are all evaluated before the operator itself.</p>
<p>The C++ built-in (two-argument) Boolean operators (e.g., <code class="sourceCode cpp">&amp;&amp;</code> and <code class="sourceCode cpp">\|\|</code>)as well as <code>&lt;type_traits&gt;</code>’s <code class="sourceCode cpp"><span class="bu">std::</span>conjunction</code> and <code class="sourceCode cpp"><span class="bu">std::</span>disjunction</code> operations are all short-circuiting, i.e., if the value of an earlier (from left-to-right) operand of an operation determines the result of the operation, then all remaining arguments are not evaluated.</p>
<pre><code>&lt;!--
Conjunction and disjunction operate at compile time and the short-circuiting is about template 
instantiations that might lead to compile errors otherwiese. This is not a runtime safety issue. I 
suggest dropping that (Peter)_
--&gt;</code></pre>
<p>Typically this allows one to write code like this, e.g.,</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> *p;</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (p != <span class="kw">nullptr</span> &amp;&amp; *p != <span class="dv">0</span>) {</span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* do something */</span></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>i.e., if <code class="sourceCode cpp">p</code> is <code class="sourceCode cpp"><span class="kw">nullptr</span></code>, then <code class="sourceCode cpp">*p != <span class="dv">0</span></code> is never executed, thus, avoiding undefined behaviour. Only when <code>p</code> is not <code class="sourceCode cpp"><span class="kw">nullptr</span></code> is *p != 0 is evaluated. It must be stressed that this only applies to the built-in <code class="sourceCode cpp">&amp;&amp;</code> and <code>||</code> operators: user-defined operator overloads as functions always evaluate all operands first.</p>
<p>Consequently should one want to always evaluate all operands of a boolean expression, one should not write code like this:</p>
<p><code class="sourceCode cpp"><span class="dt">bool</span> x = foo() &amp;&amp; bar();</code></p>
<p>where <code>foo()</code> and <code>bar()</code> are functions that return something convertible to <code>bool</code>. In this expression, if <code>foo()</code> returns <code class="sourceCode cpp"><span class="kw">false</span></code>, then <code>bar()</code> will never be executed; –only when <code>foo()</code> returns <code class="sourceCode cpp"><span class="kw">true</span></code> will <code>bar()</code> be executed. Similarly for <code>||</code>:</p>
<p><code class="sourceCode cpp"><span class="dt">bool</span> y = foo() || bar();</code></p>
<p>i.e., only when <code class="sourceCode cpp">foo()</code> returns <code class="sourceCode cpp"><span class="kw">false</span></code> will <code class="sourceCode cpp">bar()</code> be executed if <code class="sourceCode cpp">foo()</code> returns <code class="sourceCode cpp"><span class="kw">true</span></code> then <code class="sourceCode cpp">bar()</code> will never be executed. Thus, if both <code class="sourceCode cpp">foo()</code> and <code class="sourceCode cpp">bar()</code> are both required to be executed, then execute them in separate statements first, e.g.,</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> foo_result = foo();</span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> bar_result = bar();</span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> x = foo_result &amp;&amp; bar_result;</span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> y = foo_result \|\| bar_result;</span></code></pre></div>
<pre><code>&lt;!--
Stephen: My write-up here is lengthy but should help get more terse
wording\... but I note this: C++ operator information is in C++17 Clause
8 and Clause 16.5, \... Also per 16.5.1 para 2. unary and binary forms
of the same operator are considered to have the same name so one can
hide another from an enclosing scope. Thus, this is also another
possible vulnerability.\]
--&gt;</code></pre>
<h3 id="avoidance-mechanisms-for-language-users">6.24.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.24.5.</p></li>
<li><p>Write expressions so that the same effects will occur under any order of evaluation that C++ permits since side effects can be dependent on an implementation specific order of evaluation.</p></li>
<li><p>Avoid overloading logical operators (&amp;&amp; and ||), as these overloaded versions will not short-circuit.</p></li>
<li><p><em>Ensure that</em> ++, --, @= <em>are used as solitary items in a statement.</em></p></li>
<li><p>Be aware to which C++ standard a compiler is compiling code against. This determines the semantics of all operator (overloaded and built-in) expressions.</p></li>
<li><p>Avoid placing multiple operations with side effects in a single expression.</p></li>
<li><p>Write simple code expressions and statements so that within any expression or statement an object is one of:</p>
<ul>
<li><pre><code>  Read from;</code></pre></li>
<li><pre><code>  Only modified once; or</code></pre></li>
<li><pre><code>  Only read and modified by: a single increment; a single</code></pre>
decrement; a single simple assignment; or a single compound assignment.</li>
</ul></li>
<li><p>Be aware that different versions of C++ have different evaluation order specifications and program accordingly.</p></li>
</ul>
<h2 id="KOA">6.25 Likely Incorrect Expression [KOA]</h2>
<h3 id="applicability-to-language">6.25.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.25 exists in C++.</p>
<p>C++ has several instances of operators which are similar in structure, but different in meaning. Examples of operators in C-based languages that can cause confusion are:</p>
<ul>
<li><code class="sourceCode cpp">==</code> and <code class="sourceCode cpp">=</code>;</li>
<li><code class="sourceCode cpp">&amp;&amp;</code> and <code class="sourceCode cpp">&amp;</code>;</li>
<li><code class="sourceCode cpp">||</code> and <code class="sourceCode cpp">|</code>;</li>
<li><code class="sourceCode cpp">&lt;</code>, <code class="sourceCode cpp">&lt;&lt;</code>, and <code class="sourceCode cpp">&lt;&lt;=</code>; and</li>
<li><code class="sourceCode cpp">&gt;</code>, <code class="sourceCode cpp">&gt;&gt;</code>, and <code class="sourceCode cpp">&gt;&gt;=</code>.</li>
</ul>
<p>The typographical similarity can lead to code like the following, where it is unclear if the expression as spelled is actually intended, or if the author has typos in it, meaning a different operator instead:</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f(<span class="dt">unsigned</span> i, <span class="dt">unsigned</span> j)</span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (i &gt; <span class="dv">1</span>) &amp; (j = <span class="dv">1</span>); <span class="co">// (&gt;&gt;, &amp;&amp;, ==)?</span></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The following code in a production phone OS caused the “bricking” of many users phones:</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="va">key_data_</span>.has_value() &amp; !<span class="va">key_data_</span>-&gt;label().empty())</span></code></pre></div>
<p>instead of</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="va">key_data_</span>.has_value() &amp;&amp; !<span class="va">key_data_</span>-&gt;label().empty())</span></code></pre></div>
<p>or the even clearer using the alternative operator representation <code class="sourceCode cpp"><span class="kw">and</span></code> for <code class="sourceCode cpp">&amp;&amp;</code></p>
<div class="sourceCode" id="cb137"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="va">key_data_</span>.has_value() <span class="kw">and</span> !<span class="va">key_data_</span>-&gt;label().empty())</span></code></pre></div>
<p>As a general rule, the use of <code>=</code>, <code>+=</code>, <code>-=</code> in an expression when the operator is not the final assignment to a variable is unsafe since the assignment operator creates side-effects within the expression which are difficult to analyze by a human reader and can be have different results depending upon the order of evaluation of terms within the expression.</p>
<p>But even in assignment expression flipping the assignment symbol with the operator can itself lead to valid code that was not intended:</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i{<span class="dv">42</span>};</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>i += <span class="dv">22</span>; <span class="co">// i becomes 64</span></span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a>i =+ <span class="dv">22</span>; <span class="co">// i becomes 22</span></span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a>i =- <span class="dv">22</span>; <span class="co">// i becomes -22</span></span></code></pre></div>
<p>C++ provides significant freedom in constructing statements. This freedom, if misused, can result in unexpected results and potential vulnerabilities.</p>
<p>Since the order of evaluation within expressions is only partially defined, sub-expressions with side effects on variables used within the overall expression can result in undefined behaviour.</p>
<p>The flexibility of C++ can obscure the intent of a programmer. Consider:</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x,y;</span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a><span class="co">/* ... */</span></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (x = y){</span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* ... */</span></span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>A fair amount of analysis may need to be done to determine whether the programmer intended to do an assignment as part of the <code class="sourceCode cpp"><span class="cf">if</span></code> statement (valid in C++) or whether the programmer made the common mistake of using an <code class="sourceCode cpp">=</code> (assignment) instead of a <code class="sourceCode cpp">==</code> (equality).</p>
<p>This confusion can be corrected by moving assignments outside of Boolean contexts. This would change the example code to:</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x,y;</span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a><span class="co">/* … */</span></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a>x = y;</span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (x == <span class="dv">0</span>) {</span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* ... */</span></span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>This would clearly state what the programmer meant and that the assignment of y to x was intended.</p>
<p>Additional confusion occurs in the use of the logical <code class="sourceCode cpp">&amp;&amp;</code> or <code class="sourceCode cpp">||</code> operators and the bitwise <code class="sourceCode cpp">&amp;</code> or <code class="sourceCode cpp">|</code> operators. The compiler will implicitly convert arithmetic expressions to <code class="sourceCode cpp"><span class="dt">bool</span></code> for operands of the logical operators. Similarly, operands of <code class="sourceCode cpp"><span class="dt">bool</span></code> type will be promoted to <code class="sourceCode cpp"><span class="dt">int</span></code> for operands of the bitwise operators (see <a href="#FLC">Conversion Errors [FLC]</a>).<br />
It may not be clear whether the programmer intended to use the logical operator <code class="sourceCode cpp">&amp;&amp;</code> or bitwise operator <code class="sourceCode cpp">&amp;</code> instead:</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> f(<span class="dt">unsigned</span> i, <span class="dt">unsigned</span> j)</span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (i &gt; <span class="dv">0</span>) &amp; j;</span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Using the alternative tokens <code class="sourceCode cpp"><span class="kw">and</span></code> / <code class="sourceCode cpp"><span class="kw">or</span></code> in lieu of <code class="sourceCode cpp">&amp;&amp;</code> and <code class="sourceCode cpp">||</code> reduces the possibility of confusion. Similarly, <code>a not_eq b</code> is preferable to <code>a != b</code> since the latter is easily confused with the equally valid expression <code>a |= b</code>.</p>
<p>Programmers can easily get in the habit of inserting the <code class="sourceCode cpp">;</code> statement terminator at the end of statements. However, inadvertently doing this can drastically alter the meaning of code, even though the code is valid as in the following example:</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a,b;</span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* … */</span></span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (a == b);  <span class="co">// the semi-colon will make the following code always execute</span></span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a>    {             </span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* ... */</span></span>
<span id="cb142-6"><a href="#cb142-6" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>Because of the misplaced semi-colon, the code block following the if will always be executed. In this case, it is extremely likely that the programmer did not intend to put the semi-colon there.</p>
<p>Unary ‘<code>+</code>’{.cpp} on a variable is (almost) a no-op, and is possibly a mistype of ‘<code>++</code>’{.cpp}. A unary ‘<code>-</code>’{.cpp} on a variable will switch its sign, unless applied to a variable of an unsigned type, in which case the result is the value subtracted from 2^n where n is the number of bits in the unsigned type.</p>
<h4 id="c-overloading-of-operators-can-also-cause-confusion.">C++ overloading of operators can also cause confusion.</h4>
<p>The language does not impose any restrictions on semantics of overloaded operators. This can cause (potentially generic) code to behave in completely unobvious ways, when such types with “unusual” operator semantics are used.</p>
<p>For example, the boost.spirit library allows code like the following to create parser rules:</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a>r = real_p &gt;&gt; *(ch_p(<span class="ch">&#39;,&#39;</span>) &gt;&gt; real_p); <span class="co">// rule that accepts a comma-separated list of real numbers</span></span></code></pre></div>
<p>This library uses C++ operator overloads to create an embedded domain-specific language for grammar rules, allowing the specification of parser rules as C++ expressions.</p>
<p>When overloaded, related operators like the compound assignment with their base operator are not longer guaranteed to keep their behavioral relationship that they have for built-in types. For example, <code class="sourceCode cpp">a += b</code> is not guaranteed to behave like <code class="sourceCode cpp">a = a + b</code>, or being defined at all.</p>
<p>Similarly for overloaded relational operators, for <code class="sourceCode cpp">a == b</code>, there is no guarantee that <code class="sourceCode cpp">a != b</code> is equivalent to <code class="sourceCode cpp">!(a == b)</code> if both are overloaded by the user.</p>
<p>Unless all relational operators for a type are defined either explicitly in a consistent way or implicitly, unexpected results can occur. A user-declared three-way comparison operator (<code class="sourceCode cpp">&lt;=&gt;</code>) is used by the compiler to synthesize the relational operators consistently. If <code class="sourceCode cpp"><span class="kw">operator</span>&lt;=&gt;</code> is defined as <code class="sourceCode cpp">=<span class="cf">default</span></code>, the equality comparison operators will also be defined; and if <code class="sourceCode cpp"><span class="kw">operator</span>==</code> with return type <code class="sourceCode cpp"><span class="dt">bool</span></code> is defined, a corresponding inequality <code class="sourceCode cpp"><span class="kw">operator</span>!=</code> is also defined implicitly.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.25.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<p>— Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.25.5.</p>
<ul>
<li><p>Simplify expressions to aid in code readability and help future maintainers understand the intent and nuances of the code. For example,</p>
<ul>
<li>by using parentheses around sub-expressions to limit precedence confusion,</li>
<li>by extracting intermediate results into const variables with a meaningful name, or</li>
<li>by extracting a subexpression into a function with a meaningful name.</li>
</ul></li>
<li><p>Avoid assignments embedded within other statements and expressions.</p></li>
<li><p>Spell unary operators (e.g., <code>-</code>) with a leading blank in expressions to avoid them being misread as combined operators.</p></li>
<li><p>Avoid the use of unary plus, since it is almost always a no-op for built-in types.</p></li>
<li><p>Avoid Boolean operators (<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>) with non-<code>bool</code> operands, e.g., operands of numeric types.</p></li>
<li><p>Avoid bit operators (<code>&amp;</code>, <code>|</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code> ) with anything except operands of non-<code>bool</code> unsigned types.</p></li>
<li><p>Consider using alternative tokens for the logical operators, such as <code>and</code>, <code>or</code>, and <code>not</code>, and comparison operators such as <code>equal</code> and <code>not_eq</code>.</p></li>
<li><p>If your code structure requires an empty statement <code class="sourceCode cpp">;</code> use an empty code block instead <code class="sourceCode cpp">{}</code>.</p></li>
<li><p>Prohibit conflicting side-effects in sub-expressions.</p></li>
<li><p>Avoid defining semantics of overloaded operators to deviate from the semantics of these operators for the built-in types.</p></li>
<li><p>Prefer defaulted and synthesized comparison operators over individual overloads to ensure that all of the related comparison operators behave consistently.</p></li>
</ul>
<h2 id="XYQ">6.26 Dead and Deactivated Code [XYQ]</h2>
<h3 id="applicability-to-language">6.26.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC 24772-1 clause 6.26 exists in C++.</p>
<p>The language mechanisms around templates and overload resolution can require definitions to exist that are not part of the executable program. But the mechanisms at compile time guarantee that the corresponding code never becomes part of the executable program. However, a programmer might be unaware of all details with respect to the language mechnisms and thus make subtle errors leading to code selected for the executable program that was unintended.</p>
<p>If there is code that was once needed or might be needed in the future, programmers might opt to comment or use preprocessor conditional compilation to exclude such parts. The latter might even be confusing, because an intentionally undefined macro might be defined for a specific compilation outside of the program source text. Modern version control systems are better places to keep unused code in a revision or branch and ressurect it if needed through a merge.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.26.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.26.5.</p></li>
<li><p>Use IDEs or similar tools that visualize the code that gets selected for the executable program.</p></li>
<li><p>Use modern version control to manage unused code.</p></li>
</ul>
<h2 id="switch-statements-and-static-analysis-cll">6.27 Switch Statements and Static Analysis [CLL]</h2>
<h3 id="applicability-to-language">6.27.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.27 exists in C++.</p>
<p>Because of the way in which the switch-case statement in C++ is structured, it can be relatively easy to unintentionally omit the break statement between cases causing unintended execution of statements for some cases.</p>
<p>The switch statement has the form:</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> abc = someExpression();</span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* … */</span></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> (abc) {</span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a>       <span class="cf">case</span> <span class="dv">1</span>:</span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>          sval = “a”;</span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a>           <span class="cf">break</span>;</span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a>       <span class="cf">case</span> <span class="dv">2</span>:</span>
<span id="cb144-8"><a href="#cb144-8" aria-hidden="true" tabindex="-1"></a>           sval = “b”;</span>
<span id="cb144-9"><a href="#cb144-9" aria-hidden="true" tabindex="-1"></a>           <span class="cf">break</span>;</span>
<span id="cb144-10"><a href="#cb144-10" aria-hidden="true" tabindex="-1"></a>       <span class="cf">case</span> <span class="dv">3</span>:</span>
<span id="cb144-11"><a href="#cb144-11" aria-hidden="true" tabindex="-1"></a>           sval = “c”;</span>
<span id="cb144-12"><a href="#cb144-12" aria-hidden="true" tabindex="-1"></a>           <span class="cf">break</span>;</span>
<span id="cb144-13"><a href="#cb144-13" aria-hidden="true" tabindex="-1"></a>       <span class="cf">default</span>:</span>
<span id="cb144-14"><a href="#cb144-14" aria-hidden="true" tabindex="-1"></a>           <span class="cf">throw</span> SomeException();</span>
<span id="cb144-15"><a href="#cb144-15" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>If there isn’t a default case and the switched expression doesn’t match any of the cases, then control simply shifts to the next statement after the switch statement block. Unintentionally omitting a break statement between two cases will cause subsequent cases to be executed until a break or the end of the switch block is reached. This could cause unexpected results.</p>
<p>The attribute <code class="sourceCode cpp">[[<span class="at">fallthrough</span>]]</code> expresses the programmer’s intent that the code where it is placed is intended to fall through. If this attribute is not used, compilers typically diagnose the absence of a break statement.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.27.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.27.5</p></li>
<li><p>Use <code class="sourceCode cpp">[[<span class="at">fallthrough</span>]]</code> wherever fall-through is intended.</p></li>
<li><p>Terminate every case with either a flow control transfer or <code class="sourceCode cpp">[[<span class="at">fallthrough</span>]]</code> as illustrated in the following example:</p>
<pre><code>```{.cpp}
int i;
. . .
switch (i) {
       case 1: 
                     [[fallthrough]]; // documents the intended fallthrough.
       case 2:
            i++;    
            break;
        case 3: 
            j++; 
          [[fallthrough]]; // documents the intended fallthrough.
       case 4: //other code
            return 42;
       default: throw CaseNotFound();   
      }
```</code></pre></li>
<li><p>Adopt a style that permits your language processor and analysis tools to verify that all cases are covered. Where this is not possible, use a default clause that diagnoses the error.</p></li>
</ul>
<blockquote>
<p>See also the C++ Core Guidelines ES.78</p>
</blockquote>
<h2 id="demarcation-of-control-flow-eoj">6.28 Demarcation of Control Flow [EOJ]</h2>
<h3 id="applicability-to-language">6.28.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.28 exists in C++.</p>
<p>C++ lacks a keyword to be used as an explicit terminator. Therefore, it may not be readily apparent which statements are part of a loop construct or an if statement.</p>
<p>Consider the following sections of code:</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foo(<span class="dt">int</span> a, <span class="at">const</span> <span class="dt">int</span> *b) {</span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i=<span class="dv">0</span>;</span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// . . .</span></span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>        a = <span class="dv">0</span>;</span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">10</span>; i++); <span class="co">// notice the &#39;;&#39; !!</span></span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true" tabindex="-1"></a>        {</span>
<span id="cb146-7"><a href="#cb146-7" aria-hidden="true" tabindex="-1"></a>            a = a + b[i];</span>
<span id="cb146-8"><a href="#cb146-8" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb146-9"><a href="#cb146-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> c = <span class="dv">0</span>;</span>
<span id="cb146-10"><a href="#cb146-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x = <span class="dv">0</span>;</span>
<span id="cb146-11"><a href="#cb146-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (<span class="dt">int</span> j=<span class="dv">0</span>; j&lt;<span class="dv">10</span>; j++)</span>
<span id="cb146-12"><a href="#cb146-12" aria-hidden="true" tabindex="-1"></a>            c = c + b[j];</span>
<span id="cb146-13"><a href="#cb146-13" aria-hidden="true" tabindex="-1"></a>            x += c; </span>
<span id="cb146-14"><a href="#cb146-14" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>At first it may appear that, after the first loop, <code class="sourceCode cpp">a</code> will be a sum of the numbers <code class="sourceCode cpp">b[<span class="dv">0</span>]</code> to <code class="sourceCode cpp">b[<span class="dv">9</span>]</code>. However, even though the code is laid out so that the <code class="sourceCode cpp">a = a + b[i]</code> code appears to be within the for loop, the “<code class="sourceCode cpp">;</code>” at the end of the for statement causes the loop to be on a null statement (the “<code class="sourceCode cpp">;</code>”) and the</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a>a = a + b[i];</span></code></pre></div>
<p>statement to only be executed once. Similarly, the indentation leads us to believe that that assignment to x is part of the second loop, but it is not. These mistakes may be readily apparent during development or testing. More subtle cases may not be as readily apparent leading to unexpected results.</p>
<p><code class="sourceCode cpp"><span class="cf">if</span></code> statements in C++ are also susceptible to control flow problems since there isn’t a requirement in C++ for there to be an else statement for every if statement. An <code class="sourceCode cpp"><span class="cf">else</span></code> statement in C++ always belong to the most recent <code class="sourceCode cpp"><span class="cf">if</span></code> statement without an <code class="sourceCode cpp"><span class="cf">else</span></code>. However, the situation could occur where it is not readily apparent to which <code class="sourceCode cpp"><span class="cf">if</span></code> statement an <code class="sourceCode cpp"><span class="cf">else</span></code> belongs due to the way the code is indented or aligned.</p>
<p>Similar issues arise for <code class="sourceCode cpp"><span class="cf">if</span></code>-statements, particularly during maintenance, for example:</p>
<pre><code>```{.cpp}
int a,b,i;
// . . . 
if (i == 10){
       a = 5;       
       b = 10; // added later, but correct since within the {…}
      }
      else 
          a = 10;   
          b = 5;    // added later, intended to be part 
                        // of the else clause
```</code></pre>
<p>If the assignments to b were added later and were expected to be part of each <code class="sourceCode cpp"><span class="cf">if</span></code> and <code class="sourceCode cpp"><span class="cf">else</span></code> clause (they are indented as such), the above code is incorrect: the assignment to <code class="sourceCode cpp">b</code> that was intended to be in the <code class="sourceCode cpp"><span class="cf">else</span></code> clause is unconditionally executed.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.28.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.28.5.</p></li>
<li><p>Enclose the bodies of <code class="sourceCode cpp"><span class="cf">if</span></code>, <code class="sourceCode cpp"><span class="cf">else</span></code>, <code class="sourceCode cpp"><span class="cf">while</span></code>, <code class="sourceCode cpp"><span class="cf">for</span></code>, and similar in braces. This will reduce confusion and potential problems when modifying the software.</p></li>
<li><p>Declare loop variables in the initializer of the loop statement</p></li>
<li><p>Prefer the standard library algorithms over hand-crafted loops.</p></li>
<li><p>Consider the use of source code auto-formatters before code reviews.</p></li>
</ul>
<blockquote>
<p>See also the C++ Core Guidelines ES.85, ES.71, ES.74, ES.1 and ES.2</p>
</blockquote>
<h2 id="loop-control-variables-tex">6.29 Loop Control Variables [TEX]</h2>
<h3 id="applicability-to-language">6.29.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.29 exists in C++.</p>
<p>C++ allows the modification of loop control variables within non range-based loops. This is usually not considered good programming practice as it can cause unexpected problems. The flexibility of C++ expects the programmer to use this capability responsibly.</p>
<p>Since the modification of a loop control variable within a loop is infrequently encountered, reviewers of C++ code may not expect it and hence miss noticing the modification. Modifying the loop control variable can cause unexpected results if not carefully done. In C++, the following is semantically correct, but is error-prone:</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a;</span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; <span class="dv">10</span>; i++){</span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (a &gt; <span class="dv">7</span>)</span>
<span id="cb149-5"><a href="#cb149-5" aria-hidden="true" tabindex="-1"></a>        i = <span class="dv">10</span>;</span>
<span id="cb149-6"><a href="#cb149-6" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb149-7"><a href="#cb149-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>which will cause the for loop to exit once <code class="sourceCode cpp">a</code> is greater than <code class="sourceCode cpp"><span class="dv">7</span></code> regardless of the number of iterations that have occurred.</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">int</span> i : <span class="bu">std::</span>ranges<span class="bu">::</span>iota_view{<span class="dv">1</span>,<span class="dv">10</span>})</span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (a &gt; <span class="dv">7</span>) {</span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a>       i = <span class="dv">10</span>;   <span class="co">// This changes the local variable for this loop iteration&#39;s execution</span></span>
<span id="cb150-5"><a href="#cb150-5" aria-hidden="true" tabindex="-1"></a>                 <span class="co">// but subsequent iterations are not affected</span></span>
<span id="cb150-6"><a href="#cb150-6" aria-hidden="true" tabindex="-1"></a>       }</span>
<span id="cb150-7"><a href="#cb150-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb150-8"><a href="#cb150-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb150-9"><a href="#cb150-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">int</span> <span class="at">const</span> i : <span class="bu">std::</span>ranges<span class="bu">::</span>iota_view{<span class="dv">1</span>,<span class="dv">10</span>})</span>
<span id="cb150-10"><a href="#cb150-10" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb150-11"><a href="#cb150-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (a &gt; <span class="dv">7</span>) {</span>
<span id="cb150-12"><a href="#cb150-12" aria-hidden="true" tabindex="-1"></a>       i = <span class="dv">10</span>;   <span class="co">// This is now illegal since the &#39;const int&#39; prevents assign</span></span>
<span id="cb150-13"><a href="#cb150-13" aria-hidden="true" tabindex="-1"></a>       }</span>
<span id="cb150-14"><a href="#cb150-14" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>The range for example immediately above does not have the vulnerability of the C-like for loop above.</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">1</span>; i &lt; <span class="dv">10</span>; ++i) ...</span></code></pre></div>
<p>In a range-based for loop, the control variable is not available.</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>array a {<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">5</span>};</span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="kw">auto</span> <span class="at">const</span> x : a) {</span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h3 id="avoidance-mechanisms-for-language-users">6.29.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.29.5.</p></li>
<li><p>Do not modify a loop control variable within a loop.</p></li>
<li><p>Use a range-for loop in preference to general loops.</p></li>
<li><p>Alternatively, use standard library generic algorithm functions like <code>copy</code>, <code>reduce</code>, <code>transform</code>, <code>inner_product</code>, etc. in preference to general loops.</p></li>
</ul>
<p>Note: See also the C++ Core Guidelines ES.71, ES.86.</p>
<h2 id="off-by-one-error-xzh">6.30 Off-by-one Error [XZH]</h2>
<h3 id="applicability-to-language">6.30.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.30 exists in C++.</p>
<p>Arrays are a common place for off by one errors to manifest. In C++, arrays are indexed starting at 0, causing the common mistake of looping from 0 to the size of the array as in:</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> foo() {</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a[<span class="dv">10</span>];</span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i;</span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i=<span class="dv">0</span>, i&lt;=<span class="dv">10</span>, i++)</span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a>      ...</span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="dv">0</span>);</span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>C++ mitigates the issue of sentinel values in strings document in ISO/IEC 24772-1 clause 6.30 by providing the <code class="sourceCode cpp">string</code> class and the <code class="sourceCode cpp">string_view</code> class.</p>
<p>C++ does not flag accesses outside of array bounds, so an off by one error may not be as detectable in C++ as in some other languages. Several good and freely available tools can be used to help detect accesses beyond the bounds of arrays that are caused by an off by one error. However, such tools will not help in the case where only a portion of the array is used, and the access is still within the bounds of the array.</p>
<p>C++ mitigates these issues by providing</p>
<ul>
<li><p>Range-based for loops</p></li>
<li><p><code class="sourceCode cpp">std</code> algorithms</p></li>
<li><p>Iterator style loops terminated by <code class="sourceCode cpp">!=</code></p></li>
<li><p>Container classes</p></li>
<li><p><code class="sourceCode cpp">gsl::span</code> (soon to be <code class="sourceCode cpp"><span class="bu">std::</span>span</code>)</p></li>
</ul>
<h3 id="avoidance-mechanisms-for-language-users">6.30.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.30.5.</p></li>
<li><p>Use careful programming, testing of border conditions, and static analysis tools to detect off-by-one errors in C++.</p></li>
<li><p>Use range-based for loops, std algorithms, iterator style loops terminated by !=, or container classes in preference to C-style arrays and structures.</p></li>
</ul>
<blockquote>
<p>See also the C++ Core guidelines ES.1, ES.42, ES.71, SL.con.3 (more to come)</p>
</blockquote>
<h2 id="structured-programming-ewd">6.31 Structured Programming [EWD]</h2>
<h3 id="applicability-to-language">6.31.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.31 exists in C++.</p>
<p>It is as easy to write structured programs in C++ as it is not to. C++ contains the <code class="sourceCode cpp"><span class="cf">goto</span></code> statement, which can create unstructured code. It also has <code class="sourceCode cpp"><span class="cf">continue</span></code>, <code class="sourceCode cpp"><span class="cf">break</span></code>, and <code class="sourceCode cpp"><span class="cf">return</span></code> that can create a complicated control flow, when used in an undisciplined manner. Spaghetti code can be more difficult for static analyzers to analyze and is sometimes used on purpose to intentionally obfuscate the functionality of software. Code that has been modified multiple times by an assortment of programmers to add or remove functionality or to fix problems can be prone to become unstructured.</p>
<p>Because unstructured code in can cause problems for analyzers, both automated and human, of code, problems with the code may not be detected as readily or at all as would be the case if the software was written in a structured manner.</p>
<p>In C++, the <code class="sourceCode cpp"><span class="cf">break</span></code> and <code class="sourceCode cpp"><span class="cf">continue</span></code> operations only act on the innermost loop. At times, escape from nested loops is required. In such cases, the use of <code class="sourceCode cpp"><span class="cf">goto</span></code> may be simpler and easier to verify than a series of tests with <code class="sourceCode cpp"><span class="cf">break</span></code> and/or <code class="sourceCode cpp"><span class="cf">continue</span></code> operations.</p>
<p>The <code class="sourceCode cpp">setjmp</code> macro sets the current execution context into a variable, which can be use later to return to that current context using <code class="sourceCode cpp">longjmp</code> call. These calls originated from the C standard library to mimic <code class="sourceCode cpp"><span class="cf">goto</span></code> across the call stack. They do not support the relevant additions to C++ such as destructors for automatic objects, exceptions, and concurrency, and hence are incompatible with modern C++ programming.</p>
<p>A coroutine is a function that can suspend execution for later resumption (optional).</p>
<h3 id="avoidance-mechanisms-for-language-users">6.31.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.31.5.</p></li>
<li><p>Write clear and concise structured code to make code as understandable as possible.</p></li>
<li><p>Avoid the use of <code class="sourceCode cpp">setjmp</code> and <code class="sourceCode cpp">longjmp</code></p></li>
<li><p>Consider the use of coroutines as an alternative to <code class="sourceCode cpp"><span class="cf">goto</span></code> and <code class="sourceCode cpp">setjmp/longjmp</code></p></li>
</ul>
<p>See also the C++ Core guidelines ES.76, ES.77, SL.C.1</p>
<h2 id="passing-parameters-and-return-values-csj">6.32 Passing Parameters and Return Values [CSJ]</h2>
<h3 id="applicability-to-language">6.32.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.32 exists in C++. However, the language also provides appropriate mitigation.</p>
<p>C++ provides both <em>call by copy</em> (aka <em>call by value</em>) and <em>call by reference</em> parameter passing. The argument is evaluated to initialize the formal parameter (in the first case) or bound to the formal parameter (in the second case) of the function that is being called. A formal parameter behaves like a local variable, however, changes to a non-const reference parameter affect the bound object.</p>
<p>The rich type system of C++ allows types that when passed by value still have <em>call by reference</em> semantics, for example, pointer types, <code>std::reference_wrapper</code>, or class types with pointer or reference member variables.</p>
<p>C++ assumes that pointer or reference parameters of different types never alias, even if the underlying object representations are identical, i.e., for a function declared as <code class="sourceCode cpp"><span class="dt">void</span> f(<span class="dt">int</span> *pi, <span class="dt">long</span> *pl)</code> the compiler will assume that <code>pi</code> and <code>pl</code> always refer to different objects, even if <code class="sourceCode cpp"><span class="kw">sizeof</span>(<span class="dt">int</span>) == <span class="kw">sizeof</span>(<span class="dt">long</span>)</code>. Two parameters may refer to the same object if they have pointer or reference type, and the target types are the same or related. This means, aliasing between reference parameters or with a reference result needs to be taken into account in user code. For example, in an assignment expression the left and right hand side can refer to the same object. This implies that user-defined assignment operators must take precautions against self-assignment or document that it is forbidden.</p>
<p>Modern C++ ensures that in many cases the need for and overhead of copying value arguments or results is elided by the compiler, especially from temporary objects.</p>
<p>The use of <code class="sourceCode cpp"><span class="at">const</span></code> lvalue-reference parameters combines the efficiency of <em>call by reference</em> with the guarantee that the underlying input parameter is not changed (marking it as an <em>in</em> parameter). A non-const reference parameter must be considered an <em>inout</em> parameter. Rvalue-reference parameters are <em>inout</em> parameters that allow <em>transfer-of-ownership</em> semantics. At their call site it is best to assume that the argument object is in an indeterminate state and has to be reassigned before subsequent use. There is no language mechanism for marking <em>out</em> parameters, one would use the return mechanism. Instead of multiple <em>out</em> parameters a <code class="sourceCode cpp"><span class="kw">struct</span></code>, <code class="sourceCode cpp"><span class="bu">std::</span>pair</code>, or <code class="sourceCode cpp"><span class="bu">std::</span>tuple</code> can be used as a return type and eventually decomposed at the call site to its constituents via a <em>structured binding</em>.</p>
<p>Member functions take the <code class="sourceCode cpp">*<span class="kw">this</span></code> object as an implicit reference parameter. The kind of reference can be specified through qualification of the member function. However, in addition to lvalue-reference, const-lvalue-reference, and rvalue-reference qualification, there exists an oddity with respect to normal reference parameters:</p>
<ul>
<li>without a qualification a member function can be called on rvalues and non-const lvalues, and</li>
<li>with a const-qualification a member function can be called on const lvalues and rvalues.</li>
</ul>
<p>This means, unqualified member functions are callable on temporaries (rvalues) and thus can have side effects, but also can return an lvalue-reference to said temporary by returning <code>*this</code> (or members of <code>*this</code>), which can lead to dangling if such a reference is used beyond the expression of the function call returning it. For example, the compiler-provided assignment operators of a class are unqualified member functions that return an lvalue-reference to <code class="sourceCode cpp">*<span class="kw">this</span></code>.</p>
<p>Rvalue-reference parameters in a context where their actual type is deduced from the call site, are called <em>forwarding references</em>. A forwarding references will either be deduced to an lvalue-reference or an rvalue-reference depending on the argument at the call site.</p>
<p>Aliasing is expected and allowed in some cases, such as:</p>
<pre><code>-   Assignment and compound assignment operators: the right parameter may alias the left parameter. The function result always refers to the left parameter unless overloaded differently. In the case of self-assignment the stored value should not change.

-   Functions that `swap`{.cpp} their parameters: The two parameters to be swapped may refer to the same object.

-   Shift operators used for input and output: the result always refers to the left parameter.

-   Prefix increment and decrement operators: the result always refers to the parameter.
    </code></pre>
<p>The C++ preprocessor macros use a <em>call by name</em> parameter passing; a call to the macro replaces the macro by the body of the macro. This is called <em>macro expansion</em>. Macro expansion is applied to the program source text and amounts to the substitution of the formal parameters with the actual parameter expressions. Formal parameters are often parenthesized to avoid syntax issues after the expansion. Call by name parameter passing reevaluates the actual parameter expression each time the formal parameter is read.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.32.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.32.5.</p></li>
<li><p>Prefer pass-by-value and pass-by-const-reference over other means of parameter declaration.</p></li>
<li><p>Prefer reference parameters over corresponding pointer parameters.</p></li>
<li><p>Use pass by non-const reference only when side-effects on the argument are intended (<em>inout</em>-parameter).</p></li>
<li><p>Always reassign a variable passed by rvalue-reference before subsequent use after the call.</p></li>
<li><p>Use forwarding reference parameters only, if perfect forwarding is needed in the body of a function template or generic lambda.</p></li>
<li><p>Define member functions that have side effects on <code class="sourceCode cpp">*<span class="kw">this</span></code> or return a potentially dangling object referring to <code>*this</code> or its members with the appropriate lvalue-ref-qualification. Either delete the rvalue-ref-qualified overload if a const-ref-qualified overload exists to avoid calling the function on temporary objects, or define the rvalue-ref-qualified overload as returning by value.</p></li>
<li><p>Document the referents of potentially dangling objects created by or modified by a function if any potentially dangling object outlives the invocation of that function.</p></li>
<li><p>Document any allowable aliasing between the referents of function parameters of potentially dangling type. Absent such documentation, avoid passing aliased parameters.</p></li>
<li><p>Do not use function-like macros. If used, surround all macro parameters in the replacement text with parenthesis.</p></li>
</ul>
<h2 id="dangling-references-to-stack-frames-dcm">6.33 Dangling References to Stack Frames [DCM]</h2>
<h3 id="applicability-to-language">6.33.1 Applicability to language</h3>
<p>The vulnerability as expressed in ISO/IEC TR 24772-1:2019 and ISO/IEC TR 24772-3:2020 C exists in C++ by indirect access to variables with automatic storage duration or to temporary objects.</p>
<p>The lifetime model of C++ makes it undefined behaviour (see subclause [EWF]) to access an object outside of its lifetime. This results in undefined behavior, when an object access is attempted after its destruction. C++ provides a rich set of <em>pointer-like</em> types whose values may refer to temporaries or variables with automatic storage duration and can dangle (see Subclause <a href="#XYK">[XYK]</a>).</p>
<p>A C++ class type with a <em>pointer-like</em> member will behave as a <em>pointer-like</em> type, unless the class itself manages the lifetime of the object referred to by its member.</p>
<p>In general, any caller storing the <em>pointer-like</em> object returned from a function call risks dangling; such situations require thorough lifetime analysis to ensure that access via the <em>pointer-like</em> object doesn’t dangle.</p>
<p>The efficiency of return-by-value, copy-elision, and move-semantics as specified by C++ reduces the incentive to return a <em>pointer-like</em> type from a function or bind a temporary to a local reference.</p>
<p>The lifetime of a temporary object usually ends at the end of a <em>full expression</em> where it was created. Dangling can occur, when an expression including the creation of a temporary object results in a <em>pointer-like</em> value referring to the temporary object. For example, <code>std::max</code> returns the const-reference given as parameter, which might be bound to a temporary argument:</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> g(<span class="dt">int</span> i){</span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="at">const</span> &amp;m = <span class="bu">std::</span>max(i,<span class="dv">20</span>);</span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> m; <span class="co">// access dangling reference to temporary if i &lt; 20</span></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In some situations binding a reference to a temporary will extend the lifetime of the temporary.</p>
<p>This lifetime extension is not transitive across function calls, therefore, changes in the code, such as replacing a data member access with an accessor member function, can silently lead to dangling in such lifetime-extension situations.</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A{</span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a;</span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="at">const</span> &amp;getA(){<span class="cf">return</span> a;}</span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> h(){</span>
<span id="cb156-6"><a href="#cb156-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> &amp;&amp; ra = A{<span class="dv">42</span>}.a; <span class="co">// lifetime extended</span></span>
<span id="cb156-7"><a href="#cb156-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="at">const</span> &amp; cra = A{<span class="dv">42</span>}.getA(); <span class="co">// dangling</span></span>
<span id="cb156-8"><a href="#cb156-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The range-based for statement contains a subtle situation with lifetime extension.<br />
A temporary in the range expression will have its lifetime extended, unless it is accessed indirectly. As a mitigation C++ permits the creation of a variable for such situations that has the scope of the range-for loop, as shown in the following example:</p>
<pre class="{cpp}"><code>extern std::vector&lt;std::string&gt; make(); // creates a vector

for(char c : make().front()) { // attempt to iterate over first string in vector
   // vector and thus contained string is already destroyed before C++23
}

for(auto range = make().front(); char c : range){ // mitigation, create a variable for the range to be iterated over
  // string to be iterated over remaings valid throughout
}</code></pre>
<p>This issue is no longer present from C++23 onwards, as temporaries within the for-range-initializer are lifetime extended until the end of the statement.</p>
<p>Returning a <em>pointer-like</em> object from a function is problematic, if the return value refers to a temporary or an object with automatic storage duration, either directly or indirectly. The following example show different situations with this problem:</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> *bad_pointer() {</span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a = <span class="dv">0</span>;</span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> &amp;a;      <span class="co">// Returning the address of a local variable &quot;a&quot;.</span></span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a> }</span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-6"><a href="#cb158-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span>&amp; bad_reference(<span class="dt">int</span> b) {</span>
<span id="cb158-7"><a href="#cb158-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> b;      <span class="co">// Returning a reference to a local (parameter) variable &quot;b&quot; .</span></span>
<span id="cb158-8"><a href="#cb158-8" aria-hidden="true" tabindex="-1"></a> }</span>
<span id="cb158-9"><a href="#cb158-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-10"><a href="#cb158-10" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">3</span>&gt;::iterator bad_iterator() {</span>
<span id="cb158-11"><a href="#cb158-11" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">3</span>&gt; c = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };</span>
<span id="cb158-12"><a href="#cb158-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> c.begin();</span>
<span id="cb158-13"><a href="#cb158-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Returning an iterator that refers the first element of the local array &quot;c&quot;.</span></span>
<span id="cb158-14"><a href="#cb158-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb158-15"><a href="#cb158-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-16"><a href="#cb158-16" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> bad_lambda() {</span>
<span id="cb158-17"><a href="#cb158-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d = <span class="dv">0</span>;</span>
<span id="cb158-18"><a href="#cb158-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [&amp;] { <span class="cf">return</span> d = <span class="dv">1</span>; };</span>
<span id="cb158-19"><a href="#cb158-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Returning a lambda that captures local variable &quot;d&quot; by reference</span></span>
<span id="cb158-20"><a href="#cb158-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// and thus indirectly returns a reference to the local variable</span></span>
<span id="cb158-21"><a href="#cb158-21" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb158-22"><a href="#cb158-22" aria-hidden="true" tabindex="-1"></a><span class="kw">decltype</span>(<span class="kw">auto</span>) bad_assign(){ <span class="co">// deduces: std::string &amp;</span></span>
<span id="cb158-23"><a href="#cb158-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>string{} = <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span><span class="bu">s</span>;</span>
<span id="cb158-24"><a href="#cb158-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Returns reference to temporary object returned from copy-assignment operator</span></span>
<span id="cb158-25"><a href="#cb158-25" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb158-26"><a href="#cb158-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-27"><a href="#cb158-27" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> erroneous_use() {</span>
<span id="cb158-28"><a href="#cb158-28" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; *bad_pointer();</span>
<span id="cb158-29"><a href="#cb158-29" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; bad_reference(<span class="dv">42</span>);</span>
<span id="cb158-30"><a href="#cb158-30" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; *bad_iterator();</span>
<span id="cb158-31"><a href="#cb158-31" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; bad_lambda()();</span>
<span id="cb158-32"><a href="#cb158-32" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; bad_assign();</span>
<span id="cb158-33"><a href="#cb158-33" aria-hidden="true" tabindex="-1"></a> }</span></code></pre></div>
<p>In the examples above, the function <code>bad_assign</code> returns a <code class="sourceCode cpp"><span class="bu">std::</span>string &amp;</code> that was itself returned from the copy-assignement operator of <code class="sourceCode cpp"><span class="bu">std::</span>string</code>. Such an assignement operator (including the compiler-provied ones) can be called with a temporary as its left-hand operand, because it is an unqualified member function (for historical reasons).</p>
<p>Dangling may occur by calling a member function on a temporary that returns a <em>pointer-like</em> object referring to <code class="sourceCode cpp">*<span class="kw">this</span></code>, a sub-object of <code class="sourceCode cpp">*<span class="kw">this</span></code>, or an object managed by <code class="sourceCode cpp">*<span class="kw">this</span></code>. This can be prevented by - For a non-const member function: adding an lvalue ref-qualification (<code class="sourceCode cpp">&amp;</code>), - For a const member function: adding an lvalue ref-qualification (<code class="sourceCode cpp"><span class="at">const</span> &amp;</code>) <strong>and</strong> declaring an rvalue ref-qualified overload (<code class="sourceCode cpp">&amp;&amp;</code>) either defined as <code class="sourceCode cpp">=<span class="kw">delete</span></code> or declared to return by value.</p>
<p>In the following example, class <code class="sourceCode cpp">nta</code> declares its copy assignment with lvalue ref-qualification to avoid the situation created in the example function <code>bad_assign</code>:</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ta{}; <span class="co">// default allows assignment to temporary</span></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> nta{</span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a>nta &amp; <span class="kw">operator</span>=(nta <span class="at">const</span> &amp;) &amp; = <span class="cf">default</span>; <span class="co">// lvalue-ref qualified</span></span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true" tabindex="-1"></a>ta &amp; check_ta(){</span>
<span id="cb159-6"><a href="#cb159-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ta{} = ta{}; <span class="co">// returns dangling reference to temporary</span></span>
<span id="cb159-7"><a href="#cb159-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb159-8"><a href="#cb159-8" aria-hidden="true" tabindex="-1"></a>nta &amp; check_nta(){</span>
<span id="cb159-9"><a href="#cb159-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> nta{} = nta{}; <span class="co">// won&#39;t compile</span></span>
<span id="cb159-10"><a href="#cb159-10" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div>
<p>Referring to a variable with automatic storage duration from a <em>pointer-like</em> variable with static or thead-local storage duration usually means dangling, when the indirect access happens.</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> init{<span class="dv">42</span>};</span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>reference_wrapper&lt;<span class="dt">int</span> <span class="at">const</span>&gt; bad_ref = init; <span class="co">// static storage duration</span></span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bad_global_assign(){</span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (bad_ref == <span class="dv">42</span>){ <span class="co">// undefined behavior on 2nd call</span></span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true" tabindex="-1"></a>       <span class="dt">int</span> local{<span class="dv">44</span>};</span>
<span id="cb160-6"><a href="#cb160-6" aria-hidden="true" tabindex="-1"></a>       bad_ref = local; <span class="co">// Any further access of bad_ref dangles</span></span>
<span id="cb160-7"><a href="#cb160-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb160-8"><a href="#cb160-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>A class type with <em>pointer-like</em> members can lead to dangling when those members refer to constructor arguments.</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> X{</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> &amp;rci;</span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>X(<span class="dt">int</span> i):rci{i}{} <span class="co">// No lifetime extension of parameter object by binding reference to it</span></span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div>
<p>Similarly, in the following example the vulnerability exists in the conversion <code class="sourceCode cpp"><span class="kw">operator</span> string_view()</code> of <code class="sourceCode cpp"><span class="bu">std::</span>string</code>, that returns a <em>pointer-like</em> type from a member function callable on a temporary object.</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string_view bad_var(<span class="st">&quot;a string&quot;</span><span class="bu">s</span>); <span class="co">// dangling view on temporary string object</span></span></code></pre></div>
<h3 id="avoidance-mechanisms-for-language-users">6.33.2 Avoidance mechanisms for language users</h3>
<p>Software developers can avoid the vulnerability or mitigate its ill effects in the following ways: They can</p>
<ul>
<li><p>Prefer value types, pass-by-value, and return-by-value over <em>pointer-like</em> types and passing or returning <em>pointer-like</em> objects.</p></li>
<li><p>Prohibit the following uses of a <em>pointer-like</em> value referring to a variable with automatic storage duration or referring to a temporary object:</p>
<ul>
<li>Returning the <em>pointer-like</em> value from a function;</li>
<li>Assigning the <em>pointer-like</em> value to a <em>pointer-like</em> variable with a greater lifetime, such as a variable with static or thread storage duration, or initializing a <em>pointer-like</em> member variable from a constructor value parameter.</li>
</ul></li>
<li><p>Avoid capturing by reference in a lambda that will be used non-locally, that is</p>
<ul>
<li>returned,</li>
<li>passed to another thread or coroutine, or</li>
<li>stored in a variable with a longer lifetime than the captured variables.</li>
</ul></li>
<li><p>Avoid relying on lifetime extension of temporaries by binding them to named references; use (local) variables instead.</p></li>
<li><p>Show that the <em>range-based for</em> dangling vulnerability does not apply or take steps to avoid it, for example, use a variable representing the range and not an expression that yields a reference to a temporary.</p></li>
<li><p>Consider making member functions ref-qualified, that return <em>pointer-like</em> types to members or objects managed by the class.<br />
If required, provide an rvalue-ref-qualified overload that either returns a copy by value, or is defined as <code class="sourceCode cpp">=<span class="kw">delete</span></code> to prevent calling it on a temporary.</p></li>
<li><p>Perform lifetime analysis when using a <em>pointer-like</em> object beyond the expression that created it and ensure it is not used in a dangling situation.</p></li>
<li><p>Employ static and dynamic analysis tools to detect dangling <em>pointer-like</em> objects.</p></li>
</ul>
<h2 id="OTR">6.34 Subprogram Signature Mismatch [OTR]</h2>
<h3 id="applicability-to-language">6.34.1 Applicability to language</h3>
<p>In general, there must be a match between the number of parameters in a function call and the number of arguments in the function definition. For issues related to macro signatures, see subclause <a href="NMP">Pre-processor directives[NMP]</a>.</p>
<p>The number of arguments can be different to the number of parameters in a function where: - a function template includes a <em>function parameter pack</em>, or - a function parameter includes a default argument, or - a function parameter-declaration-clause ends with an ellipsis, <code>f(\...)</code>.</p>
<p>Calling a function template with a <em>function parameter pack</em> results in a specialization of the function with the parameter types matching the corresponding argument types.</p>
<p>The compiler will ensure for variadic templates that the type and number of arguments is correct.</p>
<p>A call to a function with default arguments can provide fewer arguments than parameters as long as the parameters for which no explicit argument is provided include a default argument.</p>
<p>Where a function parameter-declaration-clause ends with an ellipsis, additional arguments can be accessed through the mechanisms provided by <code>&lt;cstdarg&gt;</code>. No information about the number or types of the parameters is supplied by the compiler. The use of this feature outside of special situations can be the basis for vulnerabilities.</p>
<p>Undefined behavior can arise, for example:</p>
<ul>
<li>Arguments with integral or enumeration type that are passed to an ellipsis parameter will undergo integral promotions, and so the type of the parameter is <code>int</code> and not <code>short</code>. The use of <code>short</code> with <code>va_arg</code> is therefore invalid.</li>
</ul>
<div class="sourceCode" id="cb163"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;cstdarg&gt;</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">int</span> cnt, ...)</span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">va_list</span> ap;</span>
<span id="cb163-6"><a href="#cb163-6" aria-hidden="true" tabindex="-1"></a>  va_start (ap, cnt);</span>
<span id="cb163-7"><a href="#cb163-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-8"><a href="#cb163-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">short</span> i = va_arg (ap, <span class="dt">short</span>);  <span class="co">// Invalid type</span></span>
<span id="cb163-9"><a href="#cb163-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-10"><a href="#cb163-10" aria-hidden="true" tabindex="-1"></a>  va_end(ap);</span>
<span id="cb163-11"><a href="#cb163-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<ul>
<li>In the following case, <code>f1</code> assumes that there will be two parameters after the named parameter.</li>
</ul>
<div class="sourceCode" id="cb164"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstdarg&gt;</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">int</span> cnt, ...)</span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">va_list</span> ap;</span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true" tabindex="-1"></a>  va_start (ap, cnt);</span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-8"><a href="#cb164-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i = va_arg (ap, <span class="dt">int</span>);</span>
<span id="cb164-9"><a href="#cb164-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> j = va_arg (ap, <span class="dt">int</span>);</span>
<span id="cb164-10"><a href="#cb164-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-11"><a href="#cb164-11" aria-hidden="true" tabindex="-1"></a>  va_end(ap);</span>
<span id="cb164-12"><a href="#cb164-12" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb164-13"><a href="#cb164-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-14"><a href="#cb164-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f2 ()</span>
<span id="cb164-15"><a href="#cb164-15" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb164-16"><a href="#cb164-16" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>);  <span class="co">// OK</span></span>
<span id="cb164-17"><a href="#cb164-17" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>, <span class="dv">2</span>);     <span class="co">// results in undefined behaviour</span></span>
<span id="cb164-18"><a href="#cb164-18" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>These issues cannot occur where default arguments or variadic function templates are used.</p>
<p>The C++ Name mangling ensures that function signatures match accross translation units.</p>
<p>This does not apply to other mangling schemes. For example, parameters do not form part of the mangled name for functions declared with the <code>extern "C"</code> linkage specification. Thus such a function can be invoked with incorrect parameter types due to an incorrect redeclaration of the function:</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="co">// library.cc</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> <span class="dt">void</span> foo (<span class="dt">unsigned</span>, <span class="dt">unsigned</span>)</span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb166"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a><span class="co">// main.cc</span></span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> <span class="dt">void</span> foo (<span class="dt">unsigned</span>);</span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main ()</span>
<span id="cb166-6"><a href="#cb166-6" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb166-7"><a href="#cb166-7" aria-hidden="true" tabindex="-1"></a>  foo (<span class="bn">0xffffffff</span>);  <span class="co">// Calling function that is</span></span>
<span id="cb166-8"><a href="#cb166-8" aria-hidden="true" tabindex="-1"></a>                     <span class="co">// defined to take 2 parameters</span></span>
<span id="cb166-9"><a href="#cb166-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h3 id="avoidance-mechanisms-for-language-users">6.34.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC TR 24772-1:2019 clause 6.34.5.</p></li>
<li><p>Avoid using functionality from <code>&lt;cstdarg&gt;</code>; use variadic function templates instead.</p></li>
<li><p>When using functions declared with <code>extern "C"</code> linkage specifications, use static analysis tools to ensure that all such declarations of equally named functions have identical signatures.</p></li>
</ul>
<p>Note: See also C++ Core Guidelines F.55.</p>
<h2 id="GDL">6.35 Recursion [GDL]</h2>
<h3 id="applicability-to-language">6.35.1 Applicability to language</h3>
<p>C++ permits recursion, hence is subject to the problems described in ISO/IEC 24772-1 clause 6.35.</p>
<p>C++ allows recursive <code class="sourceCode cpp"><span class="kw">constexpr</span></code> functions and <code class="sourceCode cpp"><span class="kw">consteval</span></code> functions that are evaluated at compile time where such calls don’t contribute to the vulnerability.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.35.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.35.5.</p>
<h2 id="ignored-error-status-and-unhandled-exceptions-oyb">6.36 Ignored Error Status and Unhandled Exceptions [OYB]</h2>
<h3 id="applicability-to-language">6.36.1 Applicability to language</h3>
<p>The vulnerabilities described in ISO/IEC 24772-1:2019 clause 6.36 exist in C++, however, C++ provides a mitigation.</p>
<p>C++ includes the C library, especially the header <code>&lt;cerrno&gt;</code> and thus shares C’s issues with the global error-reporting variable <code>errno</code>. See ISO/IEC TR 24772-3:2020, clause 6.36 for details and guidance.</p>
<p>In addition to <code>errno</code> some C++ library features expose error conditions indirectly via a side-effect on the object the operation failed with or via side-effect on a reference parameter. For example, input stream objects will go into a <code>fail</code> state, when formatted input cannot be performed. Without resetting that fail-state of a stream, further input will continue to fail, that can cause further failures when a failure is ignored. Streams provide a non-default mode to throw exceptions on failure. Another example of error reporting via a side-effect is the filesystem library that provides overloads that take a non-const reference of <code>std::error_code</code>.</p>
<p>In general, reporting errors as side-effects, in the worst case via a global state, is too easy to accidentally ignore by developers, leading to further consistency problems in the continued execution of the program.</p>
<p>By default, C++ has the C weakness of permitting the call to a function that returns an error code without capturing the return value in a variable.</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a>errnum foo( <span class="dt">int</span> a, <span class="dt">int</span> b);</span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a>. . .</span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a>foo(x, y); <span class="co">// failure to capture the return error code.</span></span></code></pre></div>
<p>C++ offers as a mitigating mechanism the <code class="sourceCode cpp">[[<span class="at">nodiscard</span>]]</code> attribute. This attribute indicates that the function result must not be discarded. Ignoring the result of a function marked <code class="sourceCode cpp">[[<span class="at">nodiscard</span>]]</code> causes a compiler warning.</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a>[[<span class="at">nodiscard</span>]] errnum foo( <span class="dt">int</span> a, <span class="dt">int</span> b);</span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a>. . .</span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a>foo(x, y);  <span class="co">// compile error.</span></span>
<span id="cb168-4"><a href="#cb168-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-5"><a href="#cb168-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>( <span class="kw">auto</span> e = foo(a,b); e == <span class="dv">0</span>) { <span class="co">// no compile error</span></span>
<span id="cb168-6"><a href="#cb168-6" aria-hidden="true" tabindex="-1"></a><span class="co">// success</span></span>
<span id="cb168-7"><a href="#cb168-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb168-8"><a href="#cb168-8" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> {</span>
<span id="cb168-9"><a href="#cb168-9" aria-hidden="true" tabindex="-1"></a><span class="co">// handle errors</span></span>
<span id="cb168-10"><a href="#cb168-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In addition, the C++ library provides mechanism to extend the return type of a function with extra values for denoting an error. The simplest case is <code class="sourceCode cpp"><span class="bu">std::</span>optional&lt;T&gt;</code> that extends <code class="sourceCode cpp">T</code> with an “empty” state. Callers must check the result of functions returning an <code class="sourceCode cpp">optional</code> for the empty state, before accessing its value. This increases the chances that a reported error is detected by the caller. If additional information of the error has to be returned to the caller <code class="sourceCode cpp"><span class="bu">std::</span>expected&lt;T,AnErrorCode&gt;</code> or alternatively <code class="sourceCode cpp"><span class="bu">std::</span>variant&lt;T,AnErrorCode&gt;</code> can be used.</p>
<p>C++ offers a set of library-defined exceptions for error conditions that may be detected by checks that are performed by the standard library. In addition, the programmer may define exceptions that are appropriate for their application. These exceptions are handled using an exception handler. Exceptions may be handled in the environment where the exception occurs or may be propagated out to an enclosing scope. Exceptions that are never handled in the program result in abnormal termination of the application. In this case, it is implementation-defined whether the destruction of local objects (stack unwinding) occurs. An unhandled exception that occurs in a thread also results in the abnormal termination of the application. See 6.62 Concurrency - Premature Termination [CGS] for issues related to thread or process termination.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.36.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 subclause 6.36.5.</p></li>
<li><p>Prohibit error handling based on global state, such as <code>errno</code>.</p></li>
<li><p>If the use of <code>errno</code> cannot be avoided, follow the avoidance mechanisms of ISO/IEC 24772-3 subclause 6.36.2.</p></li>
<li><p>Use static analysis tools to detect and report missing or ineffective error detection or handling.</p></li>
<li><p>Use <code class="sourceCode cpp">[[<span class="at">nodiscard</span>]]</code> to prevent callers from ignoring error values and configure your compiler to report violations as errors (<code>-Werror</code>).</p></li>
<li><p>Consider <code class="sourceCode cpp"><span class="bu">std::</span>expected</code>, <code class="sourceCode cpp"><span class="bu">std::</span>optional</code>, <code class="sourceCode cpp"><span class="bu">std::</span>variant</code> or similar mechanisms to extend a return type with an error status.</p></li>
<li><p>Handle errors at each function where an alternative strategy for mitigations of the error is available, and in functions where no local mitigation strategy is available pass on the error indication or ignore the exception, respectively, so that the error will be handled up the call chain.</p></li>
<li><p>Use a <code class="sourceCode cpp"><span class="cf">try</span>-<span class="cf">catch</span></code> function body for <code class="sourceCode cpp">main</code> or any thread-entry function with a <code class="sourceCode cpp"><span class="cf">catch</span>(...)</code> handler to guarantee stack unwinding, which guarantees the destruction of all local objects.</p></li>
<li><p>Consider controlled termination as a last resort strategy for main or for <code class="sourceCode cpp"><span class="kw">noexcept</span></code> functions.</p></li>
<li><p>Consider the use of <code class="sourceCode cpp"><span class="bu">std::</span>exception_ptr</code> or an object encapsulating its mechanics like <code class="sourceCode cpp"><span class="bu">std::</span>future</code> to transport an exception from one thread to another thread for further processing.</p></li>
</ul>
<h2 id="AMV">6.37 Type-breaking Reinterpretation of Data [AMV]</h2>
<h3 id="applicability-to-language">6.37.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO IEC 24772-1 clause 6.37 applies to C++. The language mechanisms where type-breaking reinterpretation of data can happen involve unions and <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code>. <!-- reinterpret cast only between pointer and int --> For type-breaking reinterpretation involving pointers or references see <a href="#HFC">6.11 Pointer Type Conversions [HFC]</a>.</p>
<p>In C++, the issue of casting vulnerabilities are mitigated by the fact that the C++ named casts, i.e., <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>, <code class="sourceCode cpp"><span class="kw">const_cast</span></code>, <code class="sourceCode cpp"><span class="kw">static_cast</span></code>, <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code>, and <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code>, are easily identified, e.g., by text search for more careful review. C-style casts do not share this property and therefore should be prohibited. In addition, C++ named casts include some compile-time checks, and in the case of dynamic_cast run-time checks, that help avoid some but not all vulnerabilities.</p>
<p>Of the available "_cast" operations, only <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code> provides reinterpretation of data values, and only <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> allow the reintepretation of data as a different type within limits. For uses of <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> see <a href="#HFC">6.11 Pointer Type Conversions [HFC]</a>. The named casts <code class="sourceCode cpp"><span class="kw">static_cast</span></code>, <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code>, and <code class="sourceCode cpp"><span class="kw">const_cast</span></code> perform type conversions and not reintepretation of bits and thus don’t have this vulnerability but are subject to potential conversion errors (see <a href="#FLC">6.6 Conversion Errors [FLC]</a>).</p>
<p>Reading a union member that was not previously written is undefined behaviour except for a few cases described by ISO/IEC 14882:2020 clause [class.mem.general]. The reinterpretation of data values via different union members that is common practice in C is undefined behaviour in C++. The type <code class="sourceCode cpp"><span class="bu">std::</span>variant</code> provides a similar mechanism to union but prevents reading an inactive member.</p>
<p>If there is no value of the target type corresponding to the bit representation of the source type’s value, using <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code> is undefined behaviour, such as in the following example.</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> E { one, two, four=<span class="dv">4</span> };</span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> x = <span class="bu">std::</span>bit_cast&lt;E&gt;(<span class="dv">42</span>); <span class="co">// 42 is not representable by E</span></span></code></pre></div>
<p>C++ also provides <code class="sourceCode cpp">&lt;type_traits&gt;</code>, such as <code class="sourceCode cpp"><span class="bu">std::</span>is_layout_compatible</code>, that can be used to ensure the legality of a specific <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code>.</p>
<p>A legacy means of “bit casting” is the use of <code>memcpy</code> to transfer the bytes of an object’s representation to another object of a different type. Except for cases that are well-defined with <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code>, such use of <code>memcpy</code> to reinterpret data values is undefined behaviour.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.37.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.37.5, and clauses <a href="#FLC">6.6 Conversion Errors [FLC]</a> and <a href="#HFC">6.11 Pointer Type Conversions [HFC]</a> of this document.</p></li>
<li><p>Prohibit casts that reinterpret data values.</p></li>
<li><p>Whenever possible use <code class="sourceCode cpp"><span class="bu">std::</span>variant</code> or a similar safe union type instead of <code class="sourceCode cpp"><span class="kw">union</span></code>.</p></li>
<li><p>Prefer <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code> over <code class="sourceCode cpp">memcpy</code> when reinterpreting the bit-representation of an object to a different type is unavoidable.</p></li>
<li><p>Use <code class="sourceCode cpp"><span class="bu">std::</span>is_layout_compatible</code>, and <code class="sourceCode cpp"><span class="bu">std::</span>is_trivially_copyable</code> and other <code class="sourceCode cpp">&lt;type_traits&gt;</code> to mitigate incorrect usage of <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code>.</p></li>
<li><p>Ensure through static analysis that no accidental type-breaking reinterpretation of data values occur.</p></li>
</ul>
<h2 id="deep-vs.-shallow-copying-yan">6.38 Deep vs. Shallow Copying [YAN]</h2>
<h3 id="applicability-to-language">6.38.1 Applicability to Language</h3>
<p>The vulnerability described in ISO/IEC TR 24772-1:2019 clause 6.38 exists in C++ and only arises in C++ when there is a mismatch between the type’s copy semantics and the programmer’s intent.</p>
<p>On the language level, reference semantics, that can lead to shallow copies, usually requires the use of pointer or reference types, however, an integral type can also have reference semantics, for example, when it is used as an index or as an operating system handle.</p>
<p>Such types with reference semantics are also called <em>relationship types</em> and they will suffer from the aliasing problematic of this vulnerability and additionally from potential dangling due to expired lifetime of referred objects (see <a href="#XYK">[XYK]</a>).</p>
<p>In general, relationship types with an immutable referent, such as a const-reference, do not suffer the deep vs. shallow copying semantics problem, unless mixed with relationship types with a mutable reference to the same object. However, the lifetime of a const referent is still an issue to manage (see <a href="#XYK">[XYK]</a>).</p>
<p>The standard library type <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr&lt;T&gt;</code> has shallow copy semantics when the managed type is non-const, but in contrast to other relationship types guarantees the lifetime of the referent.</p>
<p>Class types that have <em>relationship type</em> members will become <em>relationship types</em> themselves, unless the class provides deep copy semantics or disables it and manages the lifetime of the referred object (<em>manager type</em>). Such <em>relationship types</em> and <em>manager types</em> will refer to their referred/managed resources via a data member with reference semantics.</p>
<p>A <em>manager type</em> defines a non-empty, non-deleted destructor in addition to providing appropriate copy and move operations. Examples of a <em>manager types</em> are the standard library container types such as <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> that use pointers to the allocated space of their elements and copying a vector will also copy all contained elements not just the pointers. This management is achieved by replacing the compiler-provided copy-constructor and copy-assignment operator with implementations providing value semantics that perform the deep copy (<em>general manager</em>). An alternative to potentially expensive deep copies for <em>manager types</em> is the prevention of copying, either by defining move operations that transfer the ownership of a managed resources, like <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr</code> does (<em>unique manager</em>), or by preventing both copy and move operations (<em>scoped manager</em>), for example, by defining the move-assignment operator as deleted.</p>
<p>Without such replacement of copy and move operations a class type with <em>relationship type</em> members suffers from the potential confusion due to shallow copies. For example, the standard library types <code class="sourceCode cpp"><span class="bu">std::</span>span</code>, <code class="sourceCode cpp"><span class="bu">std::</span>string_view</code>, iterators, and the views of the standard ranges library are relationship types. Care must be taken to not only understand implications of their shallow copy semantics, but also about their validity depending on the lifetime of the referred ranges.</p>
<p>Using <em>relationship types</em> as function parameter types is usually safe, because language semantics guarantee the lifetime of parameter objects. Exceptions exists for thread functions and coroutines, where the initial calling context is not guaranteed to exist when parameters of relationship type are accessed.</p>
<p>Returning a relationship type from a function can be problematic, unless the lifetime of the referred object is clear. For example, returning a reference to a local variable will return a dangling reference (see <a href="#XYK">[XYK]</a> and <a href="#XYH">[XYH]</a>).</p>
<p>See also Core Guidelines C.20, C.22, C.32, C.67.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.38.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.38.5.</p></li>
<li><p>Use and create value types.</p></li>
<li><p>Consider relationship types only when the lifetime of the referent can be ensured, and</p>
<ul>
<li>when reference semantics is required, e.g., for side effects, or</li>
<li>when copying is prohibitively expensive.</li>
</ul></li>
<li><p>Be aware of <em>relationship types</em> and document the reference semantics of user-defined class types.</p></li>
<li><p>For <em>manager types</em>, define copy constructor, copy assignment operator, move constructor, move assignment operator, and their destructor appropriately.</p></li>
<li><p>Prefer value parameters to thread functions and coroutines.</p></li>
</ul>
<h2 id="memory-leak-and-heap-fragmentation-xyl">6.39 Memory Leak and Heap Fragmentation [XYL]</h2>
<h3 id="applicability-to-language">6.39.1 Applicability to language</h3>
<p>The memory leak vulnerability documented in ISO/IEC TR24772-1:2019 clause 6.39 exists in C++, unless the programmer takes steps to avoid it. Using standard library containers sidesteps most memory leak issues described in that document.</p>
<p>See ISO/IEC TR 24772-3 for issues associated with the C functions <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code> and <code>free()</code>. Because of the issues with these functions, C++ users should refrain from using these functions wherever possible.</p>
<p>C++ has an additional vulnerability in that it provides multiple alternatives for allocation and deallocation.</p>
<p>Failing to match the deallocation to the corresponding allocation causes undefined behaviour. For example, if an array <code class="sourceCode cpp"><span class="kw">new</span>[]</code> expression was used to allocate and create an array then array <code class="sourceCode cpp"><span class="kw">delete</span>[]</code> must be used for its destruction and release.</p>
<p>The C++ object lifetime model allows to create an object in existing raw memory using non-allocating <em>placement new</em>. Such an object must be destroyed by calling its destructor explicitly, a call to delete causes undefined behaviour.</p>
<p>C++ destructors allow <em>scope-based resource management</em> that should be used to mitigate memory leaks. The standard library provides the class templates <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr</code> and <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr</code> for managing heap-allocated objects. To avoid issues with constructors throwing exceptions during heap allocation with a <code class="sourceCode cpp"><span class="kw">new</span></code> expression and potentially causing leaks, these <em>smart pointers</em> should be obtained through the factory functions <code class="sourceCode cpp"><span class="bu">std::</span>make_unique()</code> or <code class="sourceCode cpp"><span class="bu">std::</span>make_shared()</code>. Using <code>shared_ptr</code> can cause memory leaks if it is used to create a cyclic data structure.</p>
<p>If using functions that manage memory using the C library mechanisms is unavoidable, wrapping such a pointer immediately into a specialization of <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr&lt;&gt;</code> that uses <code>free()</code> in its deleter object ensures that memory is correctly released when the <code>unique_ptr</code> is destroyed, for example:</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> free_deleter{</span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="kw">operator</span>()(T *p) <span class="at">const</span> {</span>
<span id="cb170-4"><a href="#cb170-4" aria-hidden="true" tabindex="-1"></a>     <span class="bu">std::</span>free(<span class="kw">const_cast</span>&lt;<span class="bu">std::</span>remove_const_t&lt;T&gt;*&gt;(p));</span>
<span id="cb170-5"><a href="#cb170-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb170-6"><a href="#cb170-6" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb170-7"><a href="#cb170-7" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb170-8"><a href="#cb170-8" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> unique_C_ptr=<span class="bu">std::</span>unique_ptr&lt;T,free_deleter&gt;;</span>
<span id="cb170-9"><a href="#cb170-9" aria-hidden="true" tabindex="-1"></a><span class="co">//...</span></span>
<span id="cb170-10"><a href="#cb170-10" aria-hidden="true" tabindex="-1"></a><span class="co">// abi::__cxa_demangle() returns a pointer to be released with free()</span></span>
<span id="cb170-11"><a href="#cb170-11" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="kw">auto</span> plain_demangle(<span class="dt">char</span> <span class="at">const</span> *name){</span>
<span id="cb170-12"><a href="#cb170-12" aria-hidden="true" tabindex="-1"></a>  unique_C_ptr&lt;<span class="dt">char</span> <span class="at">const</span>&gt; result {abi::__cxa_demangle(name,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>)};</span>
<span id="cb170-13"><a href="#cb170-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> result;</span>
<span id="cb170-14"><a href="#cb170-14" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>C++ allocators, i.e., as defined in header <code class="sourceCode cpp">&lt;scoped_allocator&gt;</code>, can be used to mitigate heap fragmentation and guarantee deterministic timing through specific allocation strategies, especially with standard library containers. The class hierarchy provided by the header <code class="sourceCode cpp">&lt;memory_resource&gt;</code> provide some possible advanced allocation strategies. Users of earlier C++ versions often overloaded <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">new</span></code> and <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">delete</span></code> to achieve similar results.</p>
<p>The library functions <code class="sourceCode cpp"><span class="bu">std::</span>construct_at()</code> and <code class="sourceCode cpp"><span class="bu">std::</span>destroy_at()</code> are simpler than and preferrable to using non-allocating <em>placement new</em> and manual destructor calls when those are needed.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.39.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Prefer containers like those in the standard library over any other form of memory management.</p></li>
<li><p>Use smart pointers and their factory functions to allocate and manage heap memory.</p></li>
<li><p>For heap fragmentation issues, use special memory resource objects with appropriate allocation strategies.</p></li>
<li><p>If using <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr</code> in potentially cyclic data structures, break cycles using <code class="sourceCode cpp"><span class="bu">std::</span>weak_ptr</code>.</p></li>
<li><p>Use static analysis to prevent uses of C-library memory management functions and direct calls to operators <code class="sourceCode cpp"><span class="kw">new</span></code> and <code class="sourceCode cpp"><span class="kw">delete</span></code>.</p></li>
<li><p>Use dynamic analysis to detect memory leaks and issues with heap fragmentation.</p></li>
</ul>
<h2 id="SYM">6.40 Templates and Generics [SYM]</h2>
<h3 id="applicability-to-language">6.40.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1 clause 6.40 exists in C++. C++ provides the facility <em>Templates</em> to support the generic programming methodology.</p>
<p>C++ provides templates for functions, classes(types), and variables (constants). In addition one can form alias templates for class templates. Template parameters can be types, values (including addresses of global variables), and templates. C++ Templates can have variadic template parameters, that mean any number of arguments of a given kind can be used. Concepts are templates that describe constraints on template arguments and can be used to define template parameters or other deduced contexts.</p>
<p>At compile-time, templates are instantiated with concrete template arguments. Function templates as well as class template constructors can deduce the concrete template argument from the types of the function arguments used in a call. For class templates in addition to the implicit deduction guides provided by its constructors, explicit deduction guides can be specified. This mechanism of template-argument deduction allows one to use templates without explicitly mentioning a template argument for each template parameter. For class templates, only those member functions get instantiated that are actually used. Each template instantiation is checked for syntax, concept and type errors.</p>
<p>Each instantiation of a template is compiled separately, which can cause different instantiations from the same original source code to call different actual functions because of overload resolution.</p>
<p>When comes the time for instantiation of a template, there can be different speciations that match the template arguments. There is an ranking of the different (partial) speecializations that the compiler uses for selection. In case of ambiguities, the compiler will fail. This ranking can be influenced by <em>Concepts</em> and <em>SFINAE</em> (Substitution Failure Is Not An Error). If the chosen specialization compiles but behaves differently than expected, this can be a source of programmer confusion.</p>
<p><strong>To Be Continued 2 Oct 2023</strong> Templates add another level of complexity to overload resolution.</p>
<p>In case of a function overload set that includes function templates, overload resolution happens before template specialization. This means, any desired behaviour through explicit function template specialization is not considered during overload resolution, only the primary template is used there.</p>
<p>Class template and variable template specializations can provide specific code for a given set of template arguments. Such specializations must be defined in the namespace of the primary template. To prevent confusion and different compilation of identical looking template instantiations, a specialization should either be defined in the same file as the generic template, or in case of a specialization for a specific template argument type, in the file of the definition of that type.</p>
<p>Functions and lambdas that define parameters with the use of <code class="sourceCode cpp"><span class="kw">auto</span></code> are implicitly templates without using the <code class="sourceCode cpp"><span class="kw">template</span></code> keyword.</p>
<p>Variables defined with the use of <code>auto</code> keyword get their concrete type deduced from their initializer, as if they were function template parameters.</p>
<p>A constructor template or assignment operator template is never a copy or move operation and hence does not prevent the implicit definition of a copy or move operations even if it looks similar.</p>
<p>Due to the two phase compilation model of templates, name lookup can be surprising in class templates with dependent base classes. A name used in the derived class that is defined in the base might be found in an outer namespace instead.</p>
<pre><code>double foo{0};
template &lt;typename T&gt; 
struct base {
    int foo;
};
template &lt;typename T&gt; 
struct d : base&lt;T&gt;{
auto bar() {
return foo; // matches global foo not base&lt;T&gt;::foo [1]
}
};</code></pre>
<p>In the above example line [1], in place of <code>foo</code>, either <code class="sourceCode cpp"><span class="kw">this</span>-&gt;foo</code> or the fully qualified name <code class="sourceCode cpp">d::foo</code> would refer to the member of the base class.</p>
<p>When used appropriately, templates are suitable for embedded and safety critical systems;</p>
<ul>
<li>They provide type-safe generics in contrast to legacy <code class="sourceCode cpp"><span class="dt">void</span> *</code>-based or macro-based genericity;</li>
<li>They have no runtime overhead;</li>
<li>They do not have any implicit run-time memory usage; and</li>
<li>They do not generate code for unused operations.</li>
</ul>
<p>While using template greatly increases type safety, there can be requirements on template arguments that can neither be specified by concepts nor checked by a compiler. For example, sorting elements requires the comparison function to provide a <em>strict weak ordering</em> which is a property of the values of the type to be sorted by which are impossible to check at compile time for all possible value combinations.</p>
<p>C++ provides means to restrict template arguments. One is to use concepts, that can prevent instantiating a template, but allow for substituting it with an alternative. A second means is to use <code class="sourceCode cpp"><span class="kw">static_assert</span></code> in a template’s definition to prevent certain instantiations.</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> wrapper {</span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a>T x;</span>
<span id="cb172-4"><a href="#cb172-4" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span>(<span class="kw">not</span> (<span class="bu">std::</span>is_pointer_v&lt;T&gt; || <span class="bu">std::</span>is_reference_v&lt;T&gt;));</span>
<span id="cb172-5"><a href="#cb172-5" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb172-6"><a href="#cb172-6" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb172-7"><a href="#cb172-7" aria-hidden="true" tabindex="-1"></a>wrapper(T )-&gt;wrapper&lt;T&gt;;</span>
<span id="cb172-8"><a href="#cb172-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-9"><a href="#cb172-9" aria-hidden="true" tabindex="-1"></a>wrapper&lt;<span class="dt">int</span>&gt; w{<span class="dv">42</span>};</span>
<span id="cb172-10"><a href="#cb172-10" aria-hidden="true" tabindex="-1"></a>wrapper x{&amp;w}; <span class="co">// compile error due to static_assert</span></span>
<span id="cb172-11"><a href="#cb172-11" aria-hidden="true" tabindex="-1"></a>wrapper&lt;<span class="dt">int</span>&amp;&gt;{}; <span class="co">// compile error due to static_assert</span></span></code></pre></div>
<p>The generic nature of templates require a more elaborate approach to unit tests. Such tests should provide instantiations of the base template and all provided explicit template specializations to ensure that each code path is actually tested. Tests for non-compilability of suppressed instantiations, i.e., through concepts or static_assert, are also beneficial.</p>
<p>Templates allow to reduce the amount of boilerplate code to write, e.g., by providing consistent definitions of operators. However, defining operator function templates in namespace scope can greatly influence compile times due to potential participation in the overload set, whenever the operator is used in code. In addition such generic operator functions might be picked up in inappropriate places causing programmer confusion. Implementing them as hidden friends in a CRTP base class instead makes using operator function templates feasible (see <a href="#YOW">6.20 Identifier Name Reuse [YOW]</a>).</p>
<pre><code>template &lt;typename T&gt;
struct Plus {
friend constexpr auto operator+(T l, T const &amp;r) {
  return l += r;
}
};
struct Int: Plus&lt;Int&gt; {
constexpr auto operator+=(Int const &amp;r) {
  val += r.val;
  return *this;
}
constexpr Int(int v):val{v}{}
int val;
};
struct Short: Plus&lt;Short&gt; {
constexpr auto operator+=(Short const &amp;r) {
  val += r.val;
  return *this;
}
constexpr Short(short v):val{v}{}
short val;
};
auto x = Int{4} + Int{38};
auto y = Short{4} + Short{2};</code></pre>
<pre><code>&lt;!--

(*We may wish to summarize)*
--&gt;</code></pre>
<h3 id="avoidance-mechanisms-for-language-users">6.40.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 subclause 6.40.5. and the guidance provided in the different related sections of this document.</p></li>
<li><p>Use <code>static_assert</code> to prevent the use of inappropriate template arguments.</p></li>
<li><p>Consider using <em>concepts</em> to constrain template parameters.</p></li>
<li><p>Prefer <em>concepts</em> over <em>SFINAE</em>.</p></li>
<li><p>Be aware that a constructor template or assignment operator function template will not replace compiler-provided special member functions.</p></li>
<li><p>For generic operator functions, consider providing them as hidden friends through mix-in class templates.</p></li>
<li><p>Use <em>qualified-id</em> or <code class="sourceCode cpp"><span class="kw">this</span>-&gt;</code> to refer to names that may be found in a dependent base class.</p></li>
<li><p>For template specialization, ensure that specializations are declared as follows:</p>
<ol type="1">
<li><p>In the same file as the primary template; or</p></li>
<li><p>In the same file as the user-defined type for which the specialization is declared.</p></li>
</ol></li>
<li><p>Prohibit specializing function templates.</p></li>
</ul>
<h2 id="RIP">6.41 Inheritance [RIP]</h2>
<h2 id="applicability-to-language">6.41.1 Applicability to language</h2>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.41 is applicable to C++.</p>
<p>Inheritance as a mechanism in C++ serves multiple purposes and is defined differently than in most other languages supporting inheritance.</p>
<ul>
<li>There is no implicit common base class.</li>
<li>Defining a member with a name that is defined in a base class causes hiding the base class member in the derived class including all overloads with that name. Full qualification via the base class name is required to access these hidden members.</li>
<li>A base class that declares virtual member functions defines inheritance in the classic object-oriented programming way. To employ the dynamic polymorphism in that case, requires the use of references or pointers to the base type. Such a base type needs to be public base class to obtain the ‘is-a’-relationship of the derived class. Multiple such bases complicate lookup and can yield ambiguities, causing code not to compile. Even private virtual member functions can be overridden in derived classes.</li>
<li>C++ allows base classes that don’t have virtual member functions. That means, the derived class cannot change the behavior of the base, but still inherits all features. To prevent accidentally using a derived class object via a base class reference, such bases could be defined as protected or private. However, that has other side effects, such as losing the “aggregate” property of a type with only public members and bases otherwise.</li>
<li>Inheriting from a non-polymorphic base class can be used to implement adaptor types, i.e., by limiting or extending the base’s functionality. Using private inheritance can be prevent treating the derived type object as a base type object. Inheriting constructors and using declarations ease re-promoting the scope of otherwise hidden members of the base.<br />
</li>
<li>Multiple inheritance adds additional dimension, because a class can inherit the same base class <code>A</code> indirectly via different direct base classes. Without any special preparation, this means the base class <code>A</code> object exists multiple times. Addressing members of <code>A</code> explicitly requires to specify the differentiating base class as a prefix, otherwise the code will be ambiguous. If all classes in such a multiple inheritance hierarchy that directly inherit from <code>A</code> use the keyword <code class="sourceCode cpp"><span class="kw">virtual</span></code> when inheriting from <code>A</code>, there will be only one object of type <code>A</code> in the most derived object. Inconsistently inheriting from <code>A</code> with and without <code>virtual</code> might lead to confusing behavior, because still multiple base objects of type <code>A</code> exist. Inheriting from base classes without virtual member functions and without non-static data members (empty bases) does not suffer from the multiple object problem of multiple inheritance, because the empty base class object will be omitted (elided) by the compiler (empty base class optimization). Such empty bases are often used to <em>mix-in</em> functionality into derived classes.</li>
</ul>
<p>The compiler-provided default behaviour for copy and move operations as well as destruction favors value semantics which conflicts with object-oriented polymorphic behaviour.</p>
<ul>
<li><p><strong>Virtual Destructor</strong>: This means, base classes that define virtual member functions will need to also define a virtual destructor and in addition need to care about the copy and move operations, otherwise deleting a dynamically-allocated derived object via a base class pointer will cause undefined behaviour.</p></li>
<li><p><strong>Slicing</strong>: A common failure is to not eliminate implicitly callable copy and move operations in base classes which will lead to accidental copying of a base class suboject via a base class reference that actually refers to a derived object. Preventing implicit copy and move operations in base classes defining virtual member functions is a common mitigation.</p></li>
<li><p><strong>Incomplete Copy</strong>: When a derived class defines its own non-defaulted, non-deleted copy or move operations, care must be taken to actually copy and move all base class subobjects as well. Omitting a base class when defining copy or move constructors means the default construction of a base class object happens. Not invoking a base class assignment in the definition of copy and move assignment operators will cause the base class retaining its previous members and not obtaining the source object’s base members. None of these omissions are a compile error and none are an issue for empty bases.</p></li>
</ul>
<p>If a base class overloads <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">new</span></code> and <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">delete</span></code>, any derived classes will inherit and therefore will use such. If the base class’ <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">new</span></code> and/or <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">delete</span></code> assume the size of the objects being allocated are all the size of the base class and they are not all the same size, then this will result in undefined behaviour such as access errors to memory that wasn’t allocated, overwriting of memory (if there are regions of memory immediately after the last byte allocated), memory leaks, etc. For example, consider,</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;new&gt;</span></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> base</span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb175-6"><a href="#cb175-6" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb175-7"><a href="#cb175-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">static</span> <span class="dt">void</span>* <span class="kw">operator</span> <span class="kw">new</span>(<span class="bu">std::</span>size_t sz)</span>
<span id="cb175-8"><a href="#cb175-8" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb175-9"><a href="#cb175-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr &lt;&lt; <span class="st">&quot;DEBUG: Base::&quot;</span> &lt;&lt; <span class="ot">__func__</span> &lt;&lt; <span class="st">&quot;(&quot;</span> &lt;&lt; sz &lt;&lt; <span class="st">&quot;)&quot;</span> &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb175-10"><a href="#cb175-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ::<span class="kw">operator</span> <span class="kw">new</span>(<span class="kw">sizeof</span>(base));</span>
<span id="cb175-11"><a href="#cb175-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb175-12"><a href="#cb175-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-13"><a href="#cb175-13" aria-hidden="true" tabindex="-1"></a>  <span class="at">static</span> <span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span>(<span class="dt">void</span> *ptr, <span class="bu">std::</span>size_t sz)</span>
<span id="cb175-14"><a href="#cb175-14" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb175-15"><a href="#cb175-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr &lt;&lt; <span class="st">&quot;DEBUG: Base::&quot;</span> &lt;&lt; <span class="ot">__func__</span> &lt;&lt; <span class="st">&quot;(&quot;</span> &lt;&lt; ptr &lt;&lt; <span class="ch">&#39;,&#39;</span> &lt;&lt; sz &lt;&lt; <span class="st">&quot;)&quot;</span> &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb175-16"><a href="#cb175-16" aria-hidden="true" tabindex="-1"></a>    ::<span class="kw">operator</span> <span class="kw">delete</span>(ptr);</span>
<span id="cb175-17"><a href="#cb175-17" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb175-18"><a href="#cb175-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-19"><a href="#cb175-19" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb175-20"><a href="#cb175-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-21"><a href="#cb175-21" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> derived : <span class="kw">public</span> base</span>
<span id="cb175-22"><a href="#cb175-22" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb175-23"><a href="#cb175-23" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> d;</span>
<span id="cb175-24"><a href="#cb175-24" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb175-25"><a href="#cb175-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-26"><a href="#cb175-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-27"><a href="#cb175-27" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main()</span>
<span id="cb175-28"><a href="#cb175-28" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb175-29"><a href="#cb175-29" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cerr &lt;&lt; <span class="st">&quot;DEBUG: sizeof(base): &quot;</span> &lt;&lt; <span class="kw">sizeof</span>(base) &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb175-30"><a href="#cb175-30" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cerr &lt;&lt; <span class="st">&quot;DEBUG: sizeof(derived): &quot;</span> &lt;&lt; <span class="kw">sizeof</span>(derived) &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb175-31"><a href="#cb175-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-32"><a href="#cb175-32" aria-hidden="true" tabindex="-1"></a>  <span class="co">// new derived invokes base::operator new</span></span>
<span id="cb175-33"><a href="#cb175-33" aria-hidden="true" tabindex="-1"></a>  derived *p = <span class="kw">new</span> derived;</span>
<span id="cb175-34"><a href="#cb175-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-35"><a href="#cb175-35" aria-hidden="true" tabindex="-1"></a>  <span class="co">// delete p invokes base::operator delete</span></span>
<span id="cb175-36"><a href="#cb175-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">delete</span> p;</span>
<span id="cb175-37"><a href="#cb175-37" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>If a class-overloaded <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">new</span></code> and <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">delete</span></code> can only handle fixed-sized allocations, then consider the following:</p>
<ul>
<li><p>declare the class as a <code class="sourceCode cpp"><span class="kw">final</span></code> class to prohibit derived classes</p></li>
<li><p>call the global <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">new</span></code> when the size parameter does not match what is expected, e.g.,</p></li>
</ul>
<div class="sourceCode" id="cb176"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (sz != <span class="kw">sizeof</span>(base))</span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ::<span class="kw">operator</span> <span class="kw">new</span>(sz);</span></code></pre></div>
<ul>
<li>use the version of <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">delete</span></code> that has a <code class="sourceCode cpp"><span class="bu">std::</span>size_t</code> size parameter passed to it so that the global <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">delete</span></code> can be properly called (if the global <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">new</span></code> was called to allocate the data), e.g.,</li>
</ul>
<div class="sourceCode" id="cb177"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (sz != <span class="kw">sizeof</span>(base))</span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a>  ::<span class="kw">operator</span> <span class="kw">delete</span>(ptr);</span></code></pre></div>
<p>It should also be mentioned that C++ requires <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">new</span></code> to return a valid pointer should its size parameter be zero.</p>
<p>The mechanisms of failure from ISO/IEC TR 24772-1:2019 clause 6.41 manifest and can be mitigated in C++ as follows:</p>
<ul>
<li><p><em>Execution of malicious redefinitions</em> can be prevented by use of <code class="sourceCode cpp"><span class="kw">final</span></code> on each member function to generate compiler diagnostics when overriding is not permitted.</p></li>
<li><p><em>Accidental redefinition</em> can be mitigated by a project mandate to use the <code class="sourceCode cpp"><span class="kw">override</span></code> or <code class="sourceCode cpp"><span class="kw">final</span></code> special identifiers when overriding a virtual member functions.</p></li>
<li><p><em>Accidental failure of redefinition</em> can be prevented by using <code class="sourceCode cpp"><span class="kw">override</span></code> on each member function intended to be redefined to generate compiler diagnostics when overriding does not apply.</p></li>
<li><p><em>Breaking of class invariants</em> can be avoided by proper initialization even with the default constructor and by defining data members private if the class invariant depends on them. If copy and move operations are user-defined in a derived class they must ensure to call the corresponding base class operations.</p></li>
<li><p><em>Direct reading and writing of visible class members</em> of a base class can be avoided by declaring the data members private and only allowing the class-invariant-preserving member functions in the derived classes. If those member functions are not part of the public API, they can be declared as <code class="sourceCode cpp"><span class="kw">protected</span></code>.</p></li>
</ul>
<h2 id="avoidance-mechanisms-for-language-users">6.41.2 Avoidance mechanisms for language users</h2>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 41.5.</p></li>
<li><p>Except for <em>mix-in empty bases</em> avoid multiple inheritance.</p></li>
<li><p>Avoid defining copy or move operations (see clause 6.38 Deep vs. Shallow Copying [YAN]), and if the implementation of copy-operations or move-operations in a derived class is mandatory, then statically ensure that all calls are to the corresponding base classes’ operations.</p></li>
<li><p>Prefer composition over inheritance, and in general keep inheritance hierarchies shallow.</p></li>
<li><p>Restrict the use of virtual member functions to situations where unbounded run-time polymorphism is beneficial.</p></li>
<li><p>Use <code class="sourceCode cpp"><span class="kw">override</span></code> when overriding a virtual member function to generate compiler diagnostics for failures to override.</p></li>
<li><p>Mandate re-compilation of all derived classes when a base class changes.</p></li>
<li><p>Consider using fully-qualified names to address members of a base class.</p></li>
<li><p>When defining a potentially hiding overload in a derived class, consider adding a <em>using declaration</em> of the base class name.</p></li>
<li><p>Prohibit the use of public inheritance for “has-a” relationships; instead preferring composition or private/protected inheritance to “has-a”-relationships.</p></li>
<li><p>Prohibit mix virtual and non-virtual inheritance of the same base class in a hierarchy.</p></li>
</ul>
<h2 id="BLP">6.42 Violations of the Liskov Substitution Principle or the Contract Model [BLP]</h2>
<h3 id="applicability-to-language">6.42.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC 24772-1 clause 6.42 applies to C++. C++ leaves verification of the correctness of an overridden call to the programmer.</p>
<p>The vulnerability can be mitigated by a style of programming that uses wrapper functions to check preconditions, calls a virtual function to perform the required functionality and subsequently checks the postconditions before returning. An example is provided below.</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Base  {</span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">private</span>:</span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a>     <span class="kw">virtual</span> <span class="dt">int</span> function_to_override( <span class="dt">int</span> x ) = <span class="dv">0</span>;</span>
<span id="cb178-4"><a href="#cb178-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">// ...</span></span>
<span id="cb178-5"><a href="#cb178-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-6"><a href="#cb178-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span>:</span>
<span id="cb178-7"><a href="#cb178-7" aria-hidden="true" tabindex="-1"></a>     <span class="dt">int</span> interface_to_overridden_function( <span class="dt">int</span> x ) {</span>
<span id="cb178-8"><a href="#cb178-8" aria-hidden="true" tabindex="-1"></a>           check_preconditions( x );</span>
<span id="cb178-9"><a href="#cb178-9" aria-hidden="true" tabindex="-1"></a>           <span class="at">const</span> <span class="kw">auto</span> saved = data_saved_for_postcondition( x );</span>
<span id="cb178-10"><a href="#cb178-10" aria-hidden="true" tabindex="-1"></a>           <span class="kw">auto</span> result = function_to_override( x );</span>
<span id="cb178-11"><a href="#cb178-11" aria-hidden="true" tabindex="-1"></a>           check_postconditions( x, saved, result );</span>
<span id="cb178-12"><a href="#cb178-12" aria-hidden="true" tabindex="-1"></a>           <span class="cf">return</span> result;</span>
<span id="cb178-13"><a href="#cb178-13" aria-hidden="true" tabindex="-1"></a>         }</span>
<span id="cb178-14"><a href="#cb178-14" aria-hidden="true" tabindex="-1"></a>     <span class="co">// ...      </span></span>
<span id="cb178-15"><a href="#cb178-15" aria-hidden="true" tabindex="-1"></a> };</span></code></pre></div>
<h3 id="avoidance-mechanisms-for-language-users">6.42.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Obey all preconditions and postconditions of each member function, whether they are specified in the language or not.</p></li>
<li><p>Prohibit the strengthening of preconditions (specified or not) by overriding member functions.</p></li>
<li><p>Prohibit the weakening of postconditions (specified or not) by overriding member functions.</p></li>
<li><p>Prohibit the use of public inheritance for “has-a” relationships. Use composition for “has-a”-relationships instead.</p></li>
<li><p>Use static analysis tools that identify misuse of inheritance in the contract model.</p></li>
<li><p>Ensure that all invariants of a derived class are preserved by all public operations on its public base classes, and if this cannot be ensured, make the base class private, or avoid inheritance.</p></li>
</ul>
<blockquote>
<p>See also C++ Core Guidelines C.120, C.121, C.122, C.126, C.127, and C.129 through C.133.</p>
</blockquote>
<h2 id="redispatching-pph">6.43 Redispatching [PPH]</h2>
<h3 id="applicability-to-language">6.43.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.43 exists in C++ for virtual functions, except for constructors and destructors which are not dispatching. An example of the infinite recursion is:</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A {</span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb179-5"><a href="#cb179-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A::f()</span><span class="sc">\n</span><span class="st">&quot;</span>; }</span>
<span id="cb179-6"><a href="#cb179-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> g() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A::g()</span><span class="sc">\n</span><span class="st">&quot;</span>; A::f(); }  <span class="co">//call to f() will not dispatch.</span></span>
<span id="cb179-7"><a href="#cb179-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> h() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A::h()</span><span class="sc">\n</span><span class="st">&quot;</span>; }</span>
<span id="cb179-8"><a href="#cb179-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> i() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A::i()</span><span class="sc">\n</span><span class="st">&quot;</span>; h(); } <span class="co">//call to h() will dispatch</span></span>
<span id="cb179-9"><a href="#cb179-9" aria-hidden="true" tabindex="-1"></a>                                                      <span class="co">//showing the vulnerability</span></span>
<span id="cb179-10"><a href="#cb179-10" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb179-11"><a href="#cb179-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-12"><a href="#cb179-12" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B : <span class="kw">public</span> A {</span>
<span id="cb179-13"><a href="#cb179-13" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb179-14"><a href="#cb179-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f() <span class="kw">override</span> { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;B::f()</span><span class="sc">\n</span><span class="st">&quot;</span>; g(); }</span>
<span id="cb179-15"><a href="#cb179-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> h() <span class="kw">override</span> { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;B::h()</span><span class="sc">\n</span><span class="st">&quot;</span>; i(); }</span>
<span id="cb179-16"><a href="#cb179-16" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb179-17"><a href="#cb179-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-18"><a href="#cb179-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main() {</span>
<span id="cb179-19"><a href="#cb179-19" aria-hidden="true" tabindex="-1"></a>    B b;</span>
<span id="cb179-20"><a href="#cb179-20" aria-hidden="true" tabindex="-1"></a>    A * pA = &amp;b;</span>
<span id="cb179-21"><a href="#cb179-21" aria-hidden="true" tabindex="-1"></a>    pA-&gt;f(); <span class="co">// no problem</span></span>
<span id="cb179-22"><a href="#cb179-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;---</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb179-23"><a href="#cb179-23" aria-hidden="true" tabindex="-1"></a>    pA-&gt;h(); <span class="co">// infinite recursion</span></span>
<span id="cb179-24"><a href="#cb179-24" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In C++, the call to a member function can be qualified, as shown in the above example, and avoids the vulnerability.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.43.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>At a call site, consider whether virtual dispatch is desired: if not, construct the call using the qualified name.</p></li>
<li><p>Be suspicious of any call from a virtual member function of the derived class to any member function of any of its base classes.</p></li>
</ul>
<h2 id="BKK">6.44 Polymorphic variables [BKK]</h2>
<h3 id="applicability-to-language">6.44.1 Applicability to language</h3>
<p>This vulnerability as described in ISO/IEC TR 24772-1:2019 applies to C++. In addition to the upcast and downcast issues addressed in that document, this clause also addresses cross-casting, which is unique to C++. For further type system related issues see subclause <a href="#IHN">Type System[IHN]</a>.</p>
<p>C++ provides language mitigations to help avoid the problems as follows:</p>
<p>Since C++ supports multiple inheritance, up-casting, down-casting, and cross-casting operations can be used to switch to different (pointer/reference) types in the inheritance hierarchy of a specific object, i.e.,</p>
<ul>
<li><p><em>up-casting</em> is casting an object to an ancestor type in the object's type inheritance hierarchy.</p></li>
<li><p><em>down-casting</em> is casting an object to a descendent type in the object's type inheritance hierarchy, and,</p></li>
<li><p><em>cross-casting</em> is casting an object to a sibling/cousin (possibly removed) type in the object's type inheritance hierarchy with multiple inheritance.</p></li>
<li><p>Unsafe casts, which include C-style casts and <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>, can cast to unrelated arbitrarily structured types. This allows reading and modifying arbitrary memory areas. See subclause [[6.11 Pointer Casting and Pointer Type Changes] [HFC](#HFC) for more details.</p></li>
</ul>
<blockquote>
<p>Developers should be aware that virtual member functions can be overridden in derived classes, even if they are private.</p>
</blockquote>
<p>Given the following:</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Z { <span class="dt">int</span> z; <span class="kw">virtual</span> ~Z() { } };</span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Y { <span class="dt">int</span> y; <span class="kw">virtual</span> ~Y() { } };</span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A : Z { <span class="dt">int</span> a; };</span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> B : <span class="kw">virtual</span> A { <span class="dt">int</span> b; };</span>
<span id="cb180-5"><a href="#cb180-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> C : <span class="kw">virtual</span> A, Y { <span class="dt">int</span> c; };</span>
<span id="cb180-6"><a href="#cb180-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> D : B, C { <span class="dt">int</span> d; };</span>
<span id="cb180-7"><a href="#cb180-7" aria-hidden="true" tabindex="-1"></a>D d_inst;</span></code></pre></div>
<p>then these examples demonstrate upcasts, downcasts, and crosscasts:</p>
<p><strong>Upcasts:</strong></p>
<div class="sourceCode" id="cb181"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a>B* b_ptr = &amp;d_inst; <span class="co">// implicit</span></span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a>C&amp; c_ref = d_inst; <span class="co">// implicit</span></span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a>Z* z_ptr = <span class="kw">static_cast</span>&lt;Z*&gt;(&amp;d_inst);</span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a>Y* y_ptr = <span class="kw">dynamic_cast</span>&lt;Y*&gt;(&amp;d_inst);</span></code></pre></div>
<p><strong>Downcasts:</strong></p>
<div class="sourceCode" id="cb182"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a>D&amp; d_ref = <span class="kw">dynamic_cast</span>&lt;D&amp;&gt;(*y_ptr);</span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a>D* d_ptr = <span class="kw">static_cast</span>&lt;D*&gt;(b_ptr);</span></code></pre></div>
<p><strong>Crosscasts:</strong></p>
<div class="sourceCode" id="cb183"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a>C* c_ptr = <span class="kw">dynamic_cast</span>&lt;C*&gt;(b_ptr);</span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a>Y* y_ptr2 = <span class="kw">dynamic_cast</span>&lt;Y*&gt;(b_ptr);</span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a>C* c_ptr = <span class="kw">static_cast</span>&lt;C*&gt; (<span class="kw">static_cast</span>&lt;D*&gt;(b_ptr));</span></code></pre></div>
<p>and notes the following about such:</p>
<p>Upcasts:</p>
<ul>
<li><p>are the only ones that can be performed implicitly</p></li>
<li><p>can cause object slicing when a copy of a base class object is created from a derived class object.</p></li>
<li><p>can also be done with <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> or <code class="sourceCode cpp"><span class="kw">static_cast</span></code></p></li>
</ul>
<p>Downcasts</p>
<ul>
<li><p>are explicit;</p></li>
<li><p>can be done safely with <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code></p></li>
<li><p><code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> requires appropriate portions of inheritance to be polymorphic (i.e. has <code class="sourceCode cpp"><span class="kw">virtual</span></code> members);</p></li>
<li><p>can be done using <code class="sourceCode cpp"><span class="kw">static_cast</span></code> which is unchecked and may be unsafe;</p></li>
</ul>
<p>Crosscasts:</p>
<ul>
<li><p>are explicit</p></li>
<li><p>can be done safely with a single call to <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> which requires appropriate portions of inheritance to be polymorphic (i.e. has <code class="sourceCode cpp"><span class="kw">virtual</span></code> members).</p></li>
<li><p>can often be done with a chain of <code class="sourceCode cpp">static_casts</code> traversing the inheritance hierarchy, which is almost always unsafe.</p></li>
</ul>
<p>Deleting derived objects via a base class pointer is undefined behavior, unless the base class declares a virtual destructor.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.44.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.44.5.</p></li>
<li><p>In a base class declaring virtual member functions, define a virtual defaulted destructor (Core Guidelines C.35) and make the class non-copyable (Core Guidelines C.130).</p></li>
<li><p>Avoid designs relying on downcasts or crosscasts; rely on proper virtual member functions in the base classes instead.</p></li>
<li><p>Avoid explicit upcast, rely on implicit conversion.</p></li>
<li><p>If a downcast or a crosscast is needed, prefer using <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> since it is checked.</p></li>
<li><p>Ensure that all invariants of a derived class are preserved by all public operations on its public base classes. If this cannot be ensured, make the base class private, or avoid inheritance.</p></li>
<li><p>Avoid attempting to navigate class hierarchies using C-style casts or <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>.</p></li>
<li><p>Prohibit deletion of a polymorphic object without a virtual destructor; including using <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr&lt;base&gt;</code> from a unique pointer allocated with <code class="sourceCode cpp"><span class="bu">std::</span>make_unique&lt;derived&gt;()</code></p></li>
</ul>
<blockquote>
<p>See also C++ Core Guidelines ES.48, ES.49, C.146, C.147, C.148 and C.153. source: OOP52-CPP?</p>
</blockquote>
<h2 id="LRM">6.45 Extra Intrinsics [LRM]</h2>
<h3 id="applicability-to-the-language">6.45.1 Applicability to the language</h3>
<p>The vulnerability as described in ISO/IEC 24772-1 clause 6.45 applies to C++ as explained below.</p>
<p>C++ implementations are allowed to provide built-in functionality but are restricted to a specific naming schema reserved by the standard. For example, names containing a double underscore or that begin with an underscore and a capital letter are reserved for that purpose. See ISO/IEC 14882 clause [Lex.name]. The use of such names by the programmer is forbidden by the language. Language processors are not required to prohibit such usage, hence the vulnerability exists.</p>
<p>The standard restricts definitions in reserved namespaces, such as <code>std</code> (see ISO/IEC 14882 clause [namespace.constraints]). In addition, specializing a template from namespace <code>std</code> is restricted (see ISO/IEC 14882 clause [namespace.std]) unless explicitly allowed, for example, see ISO/IEC 14882 clause [unord.hash].</p>
<h3 id="avoidance-mechanisms-for-program-users">6.45.2 Avoidance mechanisms for program users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li>Prohibit identifiers containing a double underscore <code>__</code>.</li>
<li>Avoid identifiers starting with <code>_</code>, except when used for a literal suffix.</li>
<li>Ensure user-defined literal suffixes start with a single <code>_</code>.</li>
<li>Prohibit the declaration of names in reserved namespaces.</li>
<li>Prohibit the specialization of a restricted template.</li>
<li>Use compiler warnings and static analysis tools to detect and report violations of the above.</li>
</ul>
<h2 id="argument-passing-to-library-functions-trj">6.46 Argument Passing to Library Functions [TRJ]</h2>
<h3 id="applicability-to-language">6.46.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.46 is applicable to C++.</p>
<p>Libraries that supply objects or functions are in most cases not required to check the validity of parameters passed to them. In those cases where parameter validation is required there might not be adequate parameter validation.</p>
<p>When calling a library, either the calling function or the library may make assumptions about parameters. For example, it may be assumed by a library that a parameter is non-zero so division by that parameter is performed without checking the value. Sometimes some validation is performed by the calling function, but the library may use the parameters in ways that were unanticipated by the calling function resulting in a potential vulnerability. Even when libraries do validate parameters, their response to an invalid parameter is usually undefined and can cause unanticipated results.</p>
<p>This vulnerability applies in particular to C++ libraries which are designed for high efficiency; responsibility for satisfying the preconditions for most functions rests with the caller. When these preconditions are not met, the result will be undefined behaviour. In addition, error conditions are specified by the language for specific functions, such as raising an exception, returning an error code or a known value, such as NaN.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.46.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.47.5.</p></li>
<li><p>Use translation modes provided by the implementation to perform addition analysis or checking, such as contracts checks, or instrumentation of executing code.</p></li>
<li><p>Pay attention to the distinction between precondition violation and error conditions in library documentation: the former results in undefined behaviour; the latter results in defined but possibly unwanted behaviour.</p></li>
</ul>
<h2 id="inter-language-calling-djs">6.47 Inter-language Calling [DJS]</h2>
<h3 id="applicability-to-language">6.47.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.47 is applicable to C++.</p>
<p>C++ is a multi-paradigm language with a number of features that do not interface simply with other language systems. It is left to the implementation team the task of converting the results of these paradigms to constructs that can cross an interface for further processing in other languages.</p>
<p>C++ compilers provide an application binary interface (ABI) that delineates areas of interoperability with other languages or other C++ compiler/runtime systems. An ABI includes calling conventions, data layout, error and exception handling and return conventions, name mangling, data model, initialization of memory, and linkage to operating systems and libraries.</p>
<p>C++ compilers implement a C++ language linkage and a C language linkage. It is implementation-defined what other languages the implementation supports. Alternatively, other language systems provide linkages to C systems[^3](Ada has developed a standard for interfacing with C. Fortran has included a Clause 15 that explains how to call C functions.), leaving the developer the task of channeling everything through this common language system.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.47.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.47.5</p></li>
<li><p>Use standard layout types for the interoperable interfaces.</p>
<ul>
<li><pre><code>  Use language linkage facilities that support the languages being</code></pre>
<p>used.</p></li>
<li><pre><code>  EXP56-CPP. Do not call a function with a mismatched language</code></pre>
<p>linkage (-&gt; 6.47)</p></li>
<li><pre><code>  EXP60-CPP. Do not pass a nonstandard-layout type object across</code></pre>
<p>(-&gt; 6.47 ?)<br />
execution boundaries</p></li>
</ul></li>
<li><p>Be aware that the static initialization phase and dynamic initialization for every language system are required before the system begins execution</p></li>
<li><p>Be aware that C++ exceptions are not usually compatible with exceptions in other languages.</p></li>
<li><p>Segregate outgoing cross-language interfacing code into functions that present a C++ interface to the C++ code and implements that interface by calling code compatible with the other language system. Similarly implement incoming cross-language interfaces by providing simplified functions that presents a simplified (C or other language) interface and is implemented by calling C++ code with the correct style.</p></li>
<li><p>Separate the interfacing code from the code containing the main functionality</p></li>
</ul>
<p>See also the C++ Core Guidelines CPL.3.</p>
<p><em>AI 63-6 – group – add the guidance from 6.47.2 Interoperability into the Core Guidelines.</em></p>
<h2 id="NYY">6.48 Dynamically-linked Code and Self-modifying Code [NYY]</h2>
<h3 id="applicability-to-language">6.48.1 Applicability to language</h3>
<p>Most loaders allow dynamically linked libraries also known as shared libraries. Code is designed and tested using a suite of shared libraries which are loaded at execution time. The process of linking and loading is outside the scope of the C++ standard.</p>
<p>C++ prevents data pointers to be reinterpreted as function pointers and vice versa. Reinterpreting a pointer via a void pointer or <code class="sourceCode cpp"><span class="bu">std::</span>intptr_t</code> to a pointer of different type is undefined behaviour (with very few defined exceptions of data pointers to pointer to its raw bytes).</p>
<h3 id="avoidance-mechanisms-for-language-users">6.48.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.48.5.</p></li>
<li><p>Rely on compiler warnings and reports from analysis tools to prevent reinterpreting a data pointer as function pointer or vice versa.</p></li>
</ul>
<h2 id="NSQ">6.49 Library Signature [NSQ]</h2>
<h3 id="applicability-to-language">6.49.1 Applicability to language</h3>
<p>The vulnerability as enumerated in ISO/IEC 24772-1 clause 6.49 applies to C++.</p>
<p>As a mitigation, the C++ <code class="sourceCode cpp"><span class="at">extern</span> <span class="st">&quot;C&quot;</span></code> linkage specifier usually provides simple interoperability with libraries using the C application binary interface (ABI).</p>
<h3 id="avoidance-mechanisms-for-language-users">6.49.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.49.5.</p></li>
<li><p>Follow the avoidance mechanisms of clause <a href="#DJS">6.47 Inter-language Calling [DJS]</a> as applicable.</p></li>
</ul>
<h2 id="unanticipated-exceptions-from-library-routines-hjw">6.50. Unanticipated Exceptions from Library Routines [HJW]</h2>
<h3 id="applicability-to-language">6.50.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 clause 6.50 exists for C++. In particular the issue of the failing dynamic initialization of namespace-scope objects exists in C++.</p>
<p>When dynamic initialization of a namespace-scope object fails with an exception, the exception cannot be caught and the program is terminated. Function-scope static objects, in contrast, are initialized the first time execution passes through the declaration. Using function-scope static objects in preference to dynamic initialization ensures that there is always an enclosing function that could catch the exception.</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a><span class="dt">exception_prone_type</span> troubling_object;</span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a><span class="co">// An exception from the constructor could cause termination.</span></span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a><span class="co">// The following function always returns a reference to the same object,</span></span>
<span id="cb187-4"><a href="#cb187-4" aria-hidden="true" tabindex="-1"></a><span class="co">// which is initialized the first time this function is called.</span></span>
<span id="cb187-5"><a href="#cb187-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-6"><a href="#cb187-6" aria-hidden="true" tabindex="-1"></a><span class="co">// If initialization fails, it will be retried on the next call.</span></span>
<span id="cb187-7"><a href="#cb187-7" aria-hidden="true" tabindex="-1"></a><span class="dt">exception_prone_type</span>&amp; safer_object()</span>
<span id="cb187-8"><a href="#cb187-8" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb187-9"><a href="#cb187-9" aria-hidden="true" tabindex="-1"></a>   <span class="at">static</span> <span class="dt">exception_prone_type</span> the_safer_object;</span>
<span id="cb187-10"><a href="#cb187-10" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> the_safer_object;</span>
<span id="cb187-11"><a href="#cb187-11" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<h3 id="avoidance-mechanisms-for-language-users">6.50.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Expect functions not marked <code class="sourceCode cpp"><span class="kw">noexcept</span></code> to throw exceptions of arbitrary type, excluding all destructors, which are are implicitly <code class="sourceCode cpp"><span class="kw">noexcept</span></code>.</p></li>
<li><p>Follow the avoidance mechanisms of clause 6.36.2 for catching and handling exceptions.</p></li>
<li><p>Prefer function-scope static objects to namespace-scope objects for objects needing dynamic initialization.</p></li>
</ul>
<h2 id="NMP">6.51 Pre-processor Directives [NMP]</h2>
<h3 id="applicability-to-language">6.51.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.51 applies to C++.</p>
<p>The C++ pre-processor allows the use of macros that are text-replaced before compilation.</p>
<p>Function-like macros look similar to functions but have different semantics. Because the arguments are text-replaced, expressions passed to a function-like macro may be evaluated multiple times. This can result in unintended and undefined behaviour if the arguments have side effects or are pre-processor directives. Additionally, the arguments and body of function-like macros should be fully parenthesized to avoid unintended and undefined behaviour.</p>
<p>The following code example demonstrates undefined behaviour when a function-like macro is called with arguments that have side-effects (in this case, the increment operator) .</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CUBE</span>(X)<span class="pp"> </span>((X)<span class="pp"> </span><span class="er">\</span>*<span class="pp"> </span>(X)<span class="pp"> </span><span class="er">\</span>*<span class="pp"> </span>(X))</span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i = <span class="dv">2</span>;</span>
<span id="cb188-4"><a href="#cb188-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a = <span class="dv">81</span> / CUBE(++i);</span></code></pre></div>
<p>The above example could expand to:</p>
<div class="sourceCode" id="cb189"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a = <span class="dv">81</span> / ((++i) * (++i) * (++i));</span></code></pre></div>
<p>which has undefined behaviour so this macro expansion is difficult to predict.</p>
<p>Another mechanism of failure can occur when the arguments within the body of a function-like macro are not fully parenthesized. The following example shows the CUBE macro without parenthesized arguments.</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CUBE</span>(X)<span class="pp"> </span>(X<span class="pp"> </span><span class="er">\</span>*<span class="pp"> </span>X<span class="pp"> </span><span class="er">\</span>*<span class="pp"> </span>X)</span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb190-3"><a href="#cb190-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a = CUBE(<span class="dv">2</span> + <span class="dv">1</span>);</span></code></pre></div>
<p>This example expands to:</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a = (<span class="dv">2</span> + <span class="dv">1</span> * <span class="dv">2</span> + <span class="dv">1</span> * <span class="dv">2</span> + <span class="dv">1</span>)</span></code></pre></div>
<p>which evaluates to 7 instead of the intended 27.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.51.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Replace function-like macros with <code class="sourceCode cpp"><span class="kw">constexpr</span></code> inline functions where possible.</p></li>
<li><p>Replace normal macros with <code class="sourceCode cpp"><span class="kw">constexpr</span></code> variables where possible.</p></li>
<li><p>Replace conditional compilation with the preprocessor with <code class="sourceCode cpp"><span class="cf">if</span> <span class="kw">constexpr</span></code> where possible, e.g., in function bodies, including cases where compile-time define of a macro (as empty) controls if a macro definition is used to expand to an empty statement or another statement.</p></li>
<li><p>Replace preprocessor include directives with module <code class="sourceCode cpp"><span class="kw">import</span></code> where possible.</p></li>
<li><p>Prefer <code class="sourceCode cpp"><span class="bu">std::</span>source_location</code> mechanisms over employing macros that use <code class="sourceCode cpp"><span class="ot">__LINE__</span></code>, <code class="sourceCode cpp"><span class="ot">__FILE__</span></code>, or <code class="sourceCode cpp"><span class="ot">__func__</span></code>.</p></li>
<li><p>If a function-like macro must be used, ensure that its parameters and body are parenthesized.</p></li>
<li><p>In a function-like macro, ensure that each argument is evaluated at most once.</p></li>
<li><p>Prohibit embedding the following in a function-like macro: pre-processor directives; or side-effects such as an assignment, increment/decrement, volatile access, or function call.</p></li>
<li><p>Only use macros for <em>include guards</em>, to control conditional compilation, or when the macro’s definition requires token pasting (<code>##</code>.{.cpp}) or stringification (<code class="sourceCode cpp"><span class="er">#</span></code>) of macro arguments.</p></li>
<li><p>Prohibit the use of macro paramters that are used as argument for <code class="sourceCode cpp"><span class="pp">#</span><span class="er">#</span></code> or <code class="sourceCode cpp"><span class="er">#</span></code> in the macro.</p></li>
</ul>
<h2 id="suppression-of-language-defined-run-time-checking-mxb">6.52 Suppression of Language-defined Run-time Checking [MXB]</h2>
<h3 id="applicability-to-language">6.52.1 Applicability to language</h3>
<p>With the exception of the macro <code>assert</code>, the vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.52 does not apply to C++, because there is no language-defined runtime checking. Macro assert is defined by the standard but is invoked by the programmer, hence is not a language-defined check.</p>
<p>C++ libraries, however, often provide run-time checks which meet the criteria of this vulnerability. Also, compilers and other tools commonly provide means to perform such runtime checks.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.51.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.52.5 with respect to library and compiler-provided checks, which will almost always require the explicit enabling the checks.</p>
<h2 id="provision-of-inherently-unsafe-operations-skl">6.53 Provision of Inherently Unsafe Operations [SKL]</h2>
<h3 id="applicability-to-language">6.53.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.53 applies to C++. In particular, anything described by ISO/IEC 14882:2017 as “undefined behaviour” is unsafe.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.53.2 Avoidance mechanisms for language users</h3>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.53.5.</p></li>
<li><p>Enable checks that warn about unsafe operations.</p></li>
<li><p>Use static analysis tools to detect unsafe constructs.</p></li>
</ul>
<h2 id="BRS">6.54 Obscure Language Features [BRS]</h2>
<h3 id="applicability-of-language">6.54.1 Applicability of language</h3>
<p>The vulnerability as described in ISO/IEC 24772-1 clause 6.54 applies to C++.</p>
<p>C++ is a rich language and provides facilities for a wide range of application areas with a long history of evolution. The latter means that evolution of the language also means an evolution of best and safe practices. This means that code can look obscure, because it either uses obsolete or very modern language idioms.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.54.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.54.5.</p></li>
<li><p>Use static analysis tools or multiple compilers to help identify occurrences of obscure language features.</p></li>
</ul>
<h2 id="unspecified-behaviour-bqf">6.55 Unspecified Behaviour [BQF]</h2>
<h3 id="applicability-of-language">6.55.1 Applicability of language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.55 applies to C++.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.55.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.55.5.</p></li>
<li><p>Use static analysis tools and multiple compilers/tools to help identify occurrences of unspecified behaviour.</p></li>
</ul>
<h2 id="EWF">6.56 Undefined Behaviour [EWF]</h2>
<h3 id="applicability-to-language">6.56.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.56 applies to C++. In ISO/IEC 14882:2017, the terms “undefined behaviour” and “ill-formed, no diagnostic required” expose situations to be avoided.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.56.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.56.5.</p></li>
<li><p>Use static analysis tools to help identify occurrences of undefined behaviour.</p></li>
<li><p>Augment static analysis tool usage with runtime tools such as ASAN (address sanitizer) and related tools.</p></li>
<li><p>Use multiple compilers/tools and different optimization levels to increase the chance of identifying constructs that have undefined behaviours.</p></li>
<li><p>Where the C++ language provides defined behaviour mechanisms and undefined behaviour mechanisms, mandate the use the mechanisms with defined behaviours.</p></li>
</ul>
<h2 id="implementationdefined-behaviour-fab">6.57 Implementation–defined Behaviour [FAB]</h2>
<h3 id="applicability-to-language">6.57.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.57 applies to C++. In ISO/IEC 14882, the term “implementation-defined” is used to describe implementation-defined behaviour. In addition, the C++ standard provides a dedicated index titled, “Index of implementation-defined behavior”.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.57.2 Avoidance mechanisms for language users</h3>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.57.5.</p></li>
<li><p>Eliminate to the extent possible any reliance on implementation-defined behaviour from programs in order to increase portability. Even programs that are specifically intended for a particular implementation may in the future be ported to another environment or sections reused for future implementations.</p></li>
<li><p>Use multiple compilers/tools to increase your chance of identifying constructs that have implementation-defined behaviours.</p></li>
<li><p>Refer to “Index of implementation-defined behavior” for the definitive list of C++ implementation-defined behaviours and understand the relevant compiler documentation for each of these behaviours.</p></li>
</ul>
<h2 id="deprecated-language-features-mem">6.58 Deprecated Language Features [MEM]</h2>
<h3 id="applicability-to-language">6.58.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1 clause 6.58 applies to C++. Appendix D “Compatibility features” of ISO/IEC 14882:2020 enumerates the deprecated features. The C++ attribute <code class="sourceCode cpp">[[<span class="at">deprecated</span>]]</code> allows library writers and users to mark deprecated declarations.</p>
<p>Although backward compatibility is sometimes offered as an option for compilers so one can avoid changes to code to be compliant with current language specifications, updating the legacy software to the current standard is a better option.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.58.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.58.5.</p></li>
<li><p>Enable compiler options or use static analysis tools that identify the use of deprecated features.</p></li>
<li><p>Apply the <code class="sourceCode cpp">[[<span class="at">deprecated </span>(<span class="st">&quot;*reason*&quot;</span>)]]</code> attribute to obsolete declarations that exist only for backward compatibility.</p></li>
</ul>
<h2 id="CGA">6.59 Concurrency – Activation [CGA]</h2>
<h3 id="applicability-to-language">6.59.1 Applicability to language</h3>
<p>This vulnerability as specified in ISO/IEC 24772-1 clause 6.59 does not apply to C++, as long as the standard library facilities for creating threads are used.</p>
<p>Creating a thread using the <code class="sourceCode cpp"><span class="bu">std::</span>async</code> function or the <code class="sourceCode cpp"><span class="bu">std::</span>thread</code> or <code class="sourceCode cpp"><span class="bu">std::</span>jthread</code> constructors is synchronized with the thread creation site.</p>
<p>Failure to create or start a thread due to lack of system resources will cause an exception to be thrown to the creating thread thus the thread object never exists. For the vulnerabilities with unhandled exceptions see clause <a href="#OYB">6.36 Ignored error status and unhandled exceptions [OYB]</a>.</p>
<p>Any exception thrown within a thread’s function, needs to be handled by that thread, otherwise such an exception will cause program termination. For handling such termination see clause <a href="#CGS">6.62 Concurrency - Premature termination [CGS]</a>.</p>
<p>TODO: talk about detach() and forgetting to join.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.59.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>When using non-standard thread facilities, e.g., by making use of <code class="sourceCode cpp"><span class="bu">std::</span>thread<span class="bu">::</span>native_handle</code>, use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.59.5.</p></li>
<li><p>When handling the exception thrown due to failure to create a thread, ensure that potentially dependent other threads get informed.</p></li>
</ul>
<h2 id="concurrency-directed-termination-cgt">6.60 Concurrency – Directed termination [CGT]</h2>
<h3 id="applicability-to-language">6.60.1 Applicability to language</h3>
<p>This vulnerability as specified in ISO/IEC 24772-1 clause 6.60 is mitigated in C++, as long as the standard library facilities for threads are used. C++ does not provide the means to terminate a thread asynchronously. Instead C++ allows cooperative termination through the use of <code class="sourceCode cpp"><span class="bu">std::</span>stop_token</code>, however, a thread instructed by a stop request to cease execution can ignore such a request. For example, using <code class="sourceCode cpp"><span class="bu">std::</span>jthread<span class="bu">::</span>request_stop()</code> to send a stop request to the started thread, the created thread can have a thread function that never handles such a stop request.</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> some_function(<span class="dt">int</span> some_arg);</span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> other_function(<span class="bu">std::</span>stop_token tok, <span class="dt">int</span> some_arg);</span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main(){</span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>jthread t(some_function,<span class="dv">42</span>); <span class="co">// stop_token ignored</span></span>
<span id="cb192-6"><a href="#cb192-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>jthread t2(other_function,<span class="dv">42</span>); <span class="co">// stop_token passed</span></span>
<span id="cb192-7"><a href="#cb192-7" aria-hidden="true" tabindex="-1"></a>    t.request_stop(); <span class="co">// no-op</span></span>
<span id="cb192-8"><a href="#cb192-8" aria-hidden="true" tabindex="-1"></a>    t2.request_stop(); <span class="co">// stop_token tok signalled</span></span>
<span id="cb192-9"><a href="#cb192-9" aria-hidden="true" tabindex="-1"></a>} </span></code></pre></div>
<p>In the above example, at the end of the main function the destructors of the thread objects t and t2 will call <code>this-&gt;request_stop()</code> and <code>this-&gt;join()</code>. If one of the thread functions never returns, then the corresponding <code class="sourceCode cpp">join()</code> call will block.</p>
<p>Other programmed mechanisms can be constructed to cause another thread to complete, such as setting a shared variable to a known value that the target thread reads and then terminates itself.</p>
<h2 id="avoidance-mechanisms-for-language-users">6.60.2 Avoidance mechanisms for language users</h2>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.60.5.</p></li>
<li><p>Use static analysis tools and code reviews to ensure that threads accepting stop requests handle the request.</p></li>
</ul>
<h2 id="CGX">6.61 Concurrent Data Access [CGX]</h2>
<h3 id="applicability-to-language">6.61.1 Applicability to language</h3>
<p>C++ has threading and shared access to variables which have the vulnerabilities described in ISO/IEC TR 24772-1:2019 clause 6.61.1. C++ provides features such as atomic (type template) to guarantee the internal consistency of the data and to prevent corruption of data due to potentially interleaved updates to data elements.</p>
<p>What about concurrent data access between tasks?</p>
<p>Programmers should be aware that conversions or manipulations of data items are not always atomic, such as the conversion of an object as part of a computation</p>
<p><em>Need the C++ definition of atomic (indivisible access and memory ordering)</em></p>
<p><em>and volatile.</em></p>
<p>The C++ <span data-custom-style="typ">atomic</span> capability can be applied to any basic data type equivalent to <span data-custom-style="typ">char</span>, <span data-custom-style="typ">short</span>, <span data-custom-style="typ">int</span>, <span data-custom-style="typ">long</span>, and <span data-custom-style="typ">long</span> <span data-custom-style="typ">long</span>. When the C++ <span data-custom-style="typ">std::atomic</span> facilities are used, the language guarantees that simultaneous updates and reads to an atomic element will be well-behaved. Atomic does not guarantee the order in which competing reads and/or updates will occur. In order to manage order of access, synchronized locks are required. In order to use the atomic capabilities, each variable must be declared to be of one of the <span data-custom-style="typ">std::atomic</span> types, and the member functions used to compare, load, store or exchange values in an atomic variable.</p>
<p>We also need to move the notion of creating SHARED POINTERS FROM 6.13 TO HERE.</p>
<p>A volatile qualifier on a variable is used to indicate that updates to the variable may happen at any time and outside of program control, hence two subsequent reads on such a variable may return different results.</p>
<p>Programmers should be aware that even simple data accesses on modern architectures can involve instruction reordering, cache issues, and data alignment issues, hence the acquisition time and order are highly nondeterministic, especially when being accessed by concurrent threads. Any data structure that can be shared between threads should be shown to be accessed by at most one thread at a time or should be protected by synchronization mechanisms such as locks (see <a href="#CGM">Lock Protocol Errors [CGM]</a>) or atomicity.</p>
<p>Most concurrent programming algorithms require some level of synchronization between threads or tasks when exchanging information, synchronization that “<span data-custom-style="typ">atomic</span>” does not provide. Mechanisms such as monitors, mailboxes, or mutexes (lock with a queue), futures, condition variables, and locks control scheduling of threads or tasks to control order-of-access and to enforce higher levels of cooperation between schedulable entities<span data-custom-style="annotation reference"></span>.</p>
<p>Atomic tied to memory orders.</p>
<p>Mutexes provide mutual exclusion and guaranteed visibility (consistency) of the shared data.</p>
<p>Mutex is a lock-and-release that is usually hidden.</p>
<p>Encapsulate mutexes and data</p>
<p>Thread-level storage (official term thread_local) has lifetime of the thread. Can exist at local scope or global scope.</p>
<p>For massively parallel concurrency – concurrent access mechanisms not applicable.</p>
<p>No resource management</p>
<p>Exception and exception handling (has some impact on threading)</p>
<p>Memory management issues more complex under concurrency</p>
<p>Volatile should be used for signal handlers to prevent the optimization of replicated accesses to volatile memory. (other) and does not guarantee that the object value will be available to other threads.</p>
<p>Controlling access to shared data (protected or including</p>
<p>Use of volatile (keyword type qualifier) for signal handlers (communicating with hardware?). Prefer volatile for communicating with hardware?</p>
<p>For signal handling, <code class="sourceCode cpp"><span class="at">volatile</span> <span class="dt">sig_atomic_t</span></code> or atomic variables can be used to prevent this vulnerability.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.61.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.62.5.</p></li>
<li><p>Use mutexes and condition variables (<code class="sourceCode cpp">convar</code>) in preference to atomic variables to protect data from simultaneous access.</p></li>
<li><p>Use volatile only for synchronizing abstract machine state from memory.</p></li>
<li><p>Avoid the use of volatile for synchronizing access to shared memory between threads (which needs mutex, condvar, or atomics)</p>
<ul>
<li><pre><code>  See C++ Core guidelines CP.8, CP.200,</code></pre>
CP.111,<span data-custom-style="annotation reference"></span></li>
</ul></li>
<li><p>Avoid relaxed atomic operations whenever possible. Prefer the sequentially consistent std::memory_order_seq_cst instead .</p></li>
<li><p>Use mutexes appropriately to protect accesses to non-atomic shared objects.</p></li>
<li><p>Use <code class="sourceCode cpp"><span class="at">volatile</span> <span class="dt">sig_atomic_t</span></code> to protect data shared with signal handlers in a single-threaded environment.</p></li>
<li><p>Pass all thread function arguments by value, or ensure their lifetime outlasts the running thread. In the latter case proper synchronization is required.</p></li>
</ul>
<h2 id="concurrency-premature-termination-cgs">6.62 Concurrency – Premature Termination [CGS]</h2>
<h3 id="applicability-to-language">6.62.1 Applicability to language</h3>
<h3 id="section"></h3>
<p>A thread will terminate when it completes its assigned method, or when it raises an exception, or when it has been explicitly terminated (how is this done)</p>
<p>Joining a thread causes the joining thread to await the joined thread’s termination before continue. Useful for executing in parallel and then proceeding after the dispatched work is complete, but does not notify the joining task if the termination was premature.</p>
<p>In C++ 2020, methods are provided to instruct one or more threads to terminate. This is not premature termination since the requested thread terminates itself.</p>
<p>C++ 2020 provides callbacks in the form of stop_callback to notify the setting thread when a thread of interest has been terminated. It also provides stop_token for a thread to query it is being instructed to terminate.</p>
<p>Any thread can re-throw an exception to be caught by the creator of the terminating thread, (but the parent may have terminated first).</p>
<p>The semantics of C++ is that all children of the main program will terminate if the main program terminates. It is necessary to join the main program to all its children to ensure that children are not silently terminated prematurely.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.62.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.63.5.</p></li>
<li><p>Use low-level operating system primitives or other APIs where available to check that a required thread is still active.</p></li>
<li><p>Ensure that the main program joins all created threads that need to complete normally.</p></li>
</ul>
<h2 id="CGM">6.63 Protocol Lock Errors [CGM]</h2>
<h3 id="applicability-to-language">6.63.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1 clause 6.63 is applicable to C++.</p>
<p>This subclause requires a complete rewrite to have it reflect C++ issues.</p>
<p>Difference between threads and tasks. Can threads and tasks coexist?</p>
<p>Deadlock with single mutex,</p>
<p>The C standard does not provide hidden protocols. Although the vulnerability does not apply to the C language, there could exist an application vulnerability if a program uses synchronization mechanisms incorrectly. For example:</p>
<p>atomic int a;</p>
<p>int b;</p>
<p>/* . . . */</p>
<p>a += b; // This operation is an atomic read-modify-write of the variable ‘a’.</p>
<p>a = a + b; // This statement contains two accesses to ‘a’ and is not atomic.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.63.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.63.5.</p></li>
<li><p>Be aware of the operation of each synchronization mechanism, such as the cases where accesses to atomic variables may occur more than once in a statement.</p></li>
<li><p>Use higher level building blocks (such as TBB) in preference to …</p></li>
<li><p>Use the C++ Task mechanism in preference to threads …</p></li>
<li><p>Always put the acquisition and release of mutexes and the data access in a wrapper function. (i.e. <em>Do not call member functions of std::mutex, std::timed_mutex, std::recursive_mutex, std::recursive_timed_mutex, std::shared_mutex and std::shared_timed_mutex objects directly.)</em></p></li>
<li><p><em>Use std::lock(), std::try_lock() or std::scoped_lock to acquire multiple mutexes in same scope. (std::lock() permits multiple mutexes at the same time).</em></p></li>
<li><p>Use std::lock() only where multiple locks must be locked together and use std::lock_guard with the std::adopt_lock argument for all mutexes (needs example) see std::lock() example on cppreference.com.</p></li>
<li><p><em>Wrap mutex locks std::lock or std::try_lock with std<strong>::</strong>lock_guard, std::unique_lock or std::shared_lock with adopt_lock tag within the same scope</em></p></li>
<li><p>If explicit locking are used, ensure that the lock is released on every exit path, including exceptions. Use lock_guard, scope_lock and unique_lock in preference to lock(), unlock(), and try_lock(),</p></li>
<li><p><strong><em>Do not use platform specific multi-threading facilities</em></strong></p></li>
<li><p><strong><em>A thread shall not access objects whose lifetime has expired</em></strong></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.kj1vcao94oy1"><u>0.4.4 [12] Do not destroy objects of the following types std::mutex, std::timed_mutex, std::recursive_mutex, std::recursive_timed_mutex, std::shared_mutex, std::shared_timed_mutex if object is in locked or shared locked state Do not destroy a mutex while it is locked</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.1kfv9jdgd8ib"><u>0.4.5 [13] Mutexes locked with std::lock or std::try_lock shall be wrapped with std::lock_guard, std::unique_lock or std::shared_lock with adopt_lock tag within the same scope Ensure actively held locks are released on exceptional conditions</u> <u>12</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.729gvquxakq8"><u>0.4.6 [14] Do not call virtual functions and callable objects passed by argument of the function within the scope of locked mutex Never call unknown code while holding a lock (e.g., a callback)</u> <u>12</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.920crsa3sscx"><u>0.4.7 [15] Avoid deadlock by locking in a predefined order</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.xufkh9tsiuk8"><u>0.4.8 [16] Objects of std::lock_guards, std::unique_locks, std::shared_lock and std::scoped_lock classes shall always be named Remember to name your lock_guards and unique_locks</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.d6qklu5mi3fn"><u>0.4.9 [17] Define a mutex together with the data it guards. Use synchronized_value&lt;T&gt; where possible</u> <u>13</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.isn3bwogdp97"><u>0.4.10 [18] Do not speculatively lock a non-recursive mutex that is already owned by the calling thread</u> <u>14</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.einwxosnxvhf"><u>0.4.11 [19] There shall be no code path which results in locking of the non-recursive mutex within the scope when this mutex is already locked Within the scope of a lock, ensure that no static path results in a lock of the same mutex</u> <u>14</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.vq776pxv4nn5"><u>0.4.12 [20] The order of nested locks unlock shall form a DAG Ensure that order of nesting of locks in a project forms a DAG</u> <u>15</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.7pf8azwmy8l4"><u>0.4.13 [21] std::recursive_mutex and std::recursive_timed_mutex should not be used Do not use std::recursive_mutex</u> <u>17</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.z9k66jbl65u6"><u>0.4.14 [22] There should be a code path, where at least one member functions is called for std::unique_lock objects Only use std::unique_lock when std::lock_guard cannot be used</u> <u>18</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.3icrgfn0r3ae"><u>0.5 Conditional variable</u> <strong><u>19</u></strong></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.g0cdm0bk7l9l"><u>0.5.1 [23] std::condition_variable::wait, std::condition_variable::wait_for, std::condition_variable::wait_until shall always be called with a condition predicate</u> <u>19</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.ul4y0p7eoih1"><u>0.5.2 [24] Wrap functions that can spuriously wake up in a loop</u> <u>20</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.13kr181fh926"><u>0.5.3 [25] std::conditional_variable::notify_one() can be used if all threads must perform the same set of operations after waking up Preserve thread safety and liveness when using condition variables</u> <u>21</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.yt0hxah53p9e"><u>0.5.4 [26] Do not use std::condition_variable_any on a std::mutex</u></a></p></li>
<li><p>[<span data-custom-style="Hyperlink">0.10.1 [35] Source CCG Rule CP.100: Don't use lock-free programming unless you absolutely have to</span></p>
<p><span data-custom-style="Hyperlink">27</span>](https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.3hq5f8vdw7d)</p></li>
<li><p>0.10.2 [36] Source CCG Rule CP.101: Distrust your hardware/compiler combination</p></li>
<li><p>0.10.3 [37] Source CCG Rule CP.102: Carefully study the literature</p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.ca8el9ehijae"><span data-custom-style="Hyperlink">0.10.4 [38] Source CCG Rule CP.110: Do not write your own double-checked locking for initialization</span></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.9syx86lze887"><span data-custom-style="Hyperlink">0.10.5 [39] Source HIC Rule 18.2.4 Use std::call_once to ensure a function is called exactly once (rather than the Double-Checked Locking pattern)</span></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.gg4jn12ygzi5"><span data-custom-style="Hyperlink">0.10.6 [40] Source CCG Rule CP.111: Use a conventional pattern if you really need double-checked locking</span></a></p></li>
<li></li>
</ul>
<h2 id="uncontrolled-format-string-shl">6.64 Uncontrolled Format String [SHL]</h2>
<h3 id="applicability-to-language">6.64.1 Applicability to language</h3>
<p>C++ inherits the C libraries which provide a large family of input and output functions that use a control string to interpret the data read or format the output. These strings include all the feature described in ISO/IEC TR 24772-1:2019 clause 6.64.1.</p>
<p>C++ provides type-safe alternatives for input/output, which do not use format strings and which should be used in preference, such as</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> aNumber{};</span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span>(<span class="bu">std::</span>cin){ <span class="co">// is input still available</span></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Enter a whole number, please:&quot;</span>;</span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="bu">std::</span>cin &gt;&gt; aNumber) { <span class="co">// no format string needed</span></span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &gt;&gt; <span class="st">&quot;Thank you, the number can be represented as &quot;</span></span>
<span id="cb194-6"><a href="#cb194-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>format(<span class="st">&quot;0b</span><span class="sc">{0:b}</span><span class="st"> </span><span class="sc">{0:d}</span><span class="st"> 0</span><span class="sc">{0:o}</span><span class="st"> 0x</span><span class="sc">{0:x}</span><span class="st">&quot;</span>, aNumber);</span>
<span id="cb194-7"><a href="#cb194-7" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> { <span class="co">// input failed</span></span>
<span id="cb194-8"><a href="#cb194-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin.clear();  <span class="co">// re-enable input</span></span>
<span id="cb194-9"><a href="#cb194-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string line;</span>
<span id="cb194-10"><a href="#cb194-10" aria-hidden="true" tabindex="-1"></a>    getline(<span class="bu">std::</span>cin,line); <span class="co">// skip to eol</span></span>
<span id="cb194-11"><a href="#cb194-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb194-12"><a href="#cb194-12" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In addition, operator overloading of output operators allows to extend formatting abilities to user-defined types.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.64.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Forbid the use of the C library facilities provided by <strong><code>&lt;cstdio&gt;</code></strong>.</p></li>
<li><p>Use the avoidance mechanisms provided by the standard library as described in ISO/IEC 14882 20.20 Formatting [format] or similar libraries, if <em>printf-style</em> formatting of output or strings is desired, or when the formatting facilities of <code>std::ostream</code> are inadequate.</p></li>
<li><p>Read untrusted input as plain characters and then check for validity, before any conversion to numbers or program entities occurs, using facilities that do not require format strings and that check and report error conditions.</p></li>
</ul>
<h1 id="UJO">6.65 Modifying constants [UJO]</h1>
<h3 id="applicability-to-language">6.65.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 clause 6.65 exists in C++.</p>
<p>An object can be declared as <code class="sourceCode cpp"><span class="at">const</span></code>, denoting that its value will not change in its lifetime without invoking mechanisms which have undefined behaviour, e.g.,</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> i = <span class="dv">0</span>;</span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span>&amp; j = <span class="kw">const_cast</span>&lt;<span class="dt">int</span>&amp;&gt;(i); <span class="co">// undefined behaviour</span></span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo(<span class="dt">int</span>* p) { *p += <span class="dv">43</span>; }</span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a><span class="co">//...</span></span>
<span id="cb195-5"><a href="#cb195-5" aria-hidden="true" tabindex="-1"></a>foo(<span class="kw">const_cast</span>&lt;<span class="dt">int</span>*&gt;(&amp;i)); <span class="co">// undefined behaviour</span></span>
<span id="cb195-6"><a href="#cb195-6" aria-hidden="true" tabindex="-1"></a>foo(&amp;i); <span class="co">// ill-formed, compiler error</span></span></code></pre></div>
<p>A object that is not <code class="sourceCode cpp"><span class="at">const</span></code>-qualified can be accessed through a path that is <code class="sourceCode cpp"><span class="at">const</span></code>-qualified:</p>
<div class="sourceCode" id="cb196"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a>  T k = <span class="dv">0</span>;</span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true" tabindex="-1"></a>  T <span class="at">const</span> &amp; j = k;                <span class="co">// &#39;j&#39; is a const reference to &#39;k&#39;</span></span>
<span id="cb196-3"><a href="#cb196-3" aria-hidden="true" tabindex="-1"></a>  T <span class="at">const</span> * p = &amp;k;               <span class="co">// &#39;p&#39; is a pointer to const &#39;k&#39;</span></span>
<span id="cb196-4"><a href="#cb196-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const_cast</span>&lt;T <span class="at">const</span> &amp;&gt;(k);       <span class="co">// The type of the expression is const</span></span></code></pre></div>
<p>The checking for the correctness of <code class="sourceCode cpp"><span class="at">const</span></code> is enforced based on the access-path and not the type of the target object. For example, the following are ill-formed as the access path of the left-hand expression is <code class="sourceCode cpp"><span class="at">const</span></code>-qualified:</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a>  i = <span class="dv">0</span>; <span class="co">// T const i;</span></span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a>  j = <span class="dv">0</span>; <span class="co">// T const &amp;j</span></span>
<span id="cb197-3"><a href="#cb197-3" aria-hidden="true" tabindex="-1"></a>  *p = <span class="dv">0</span>; <span class="co">// T const *p</span></span>
<span id="cb197-4"><a href="#cb197-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const_cast</span>&lt;T <span class="at">const</span> &amp;&gt;(k) = <span class="dv">0</span>; <span class="co">// T k i.e. not const</span></span></code></pre></div>
<p>Note that the object <code class="sourceCode cpp">k</code> referred to by <code class="sourceCode cpp">j</code>, <code class="sourceCode cpp">*p</code> and the <code class="sourceCode cpp"><span class="kw">const_cast</span>,</code> is not constant. In each case the access path could be changed to remove <code class="sourceCode cpp"><span class="at">const</span></code> making the program well-formed: <code class="sourceCode cpp"><span class="kw">const_cast</span>&lt;T&amp;&gt; (j) = <span class="dv">0</span>; <span class="co">// well-formed</span></code></p>
<p>While it is possible to remove the const-qualification for an access path, attempting to modify a const object this way is undefined-behavior(see <span id="EWF">Undefined Behavior [EWF]</span>) : <code class="sourceCode cpp"><span class="kw">const_cast</span>&lt;T&amp;&gt; (i) = <span class="dv">0</span>; <span class="co">// undefined behavior</span></code></p>
<p>We distinguish between qualifications on the pointer’s type (pointer type) and qualifications on the type being referenced (pointer type).</p>
<p>A pointer type can be qualified as <code class="sourceCode cpp"><span class="at">const</span></code>, however the qualification only applies to the pointer type and not the pointee’s type. A reference type is implicitly immutable, only the referred type can be <code class="sourceCode cpp"><span class="at">const</span></code> qualified.</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> T = <span class="dt">int</span>;</span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> T1 = T &amp;;</span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> T2 = T *;</span>
<span id="cb198-4"><a href="#cb198-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> S1 = T1 <span class="at">const</span>;  <span class="co">// The const is ignored, S1 has type &#39;T &amp;&#39;</span></span>
<span id="cb198-5"><a href="#cb198-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> S2 = T2 <span class="at">const</span>;  <span class="co">// The const applies to the pointer type,</span></span>
<span id="cb198-6"><a href="#cb198-6" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// S2 has type &#39;T * const&#39;</span></span>
<span id="cb198-7"><a href="#cb198-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-8"><a href="#cb198-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> foo (S1 s1, S2 s2)</span>
<span id="cb198-9"><a href="#cb198-9" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb198-10"><a href="#cb198-10" aria-hidden="true" tabindex="-1"></a>    s1 = <span class="dv">0</span>;            <span class="co">// well-formed</span></span>
<span id="cb198-11"><a href="#cb198-11" aria-hidden="true" tabindex="-1"></a>    *s2 = <span class="dv">0</span>;           <span class="co">// well-formed</span></span>
<span id="cb198-12"><a href="#cb198-12" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>A common misconception is that a member function qualified with <code class="sourceCode cpp"><span class="at">const</span></code> cannot modify any of its members. The following badly defined class introduces a non-<code class="sourceCode cpp"><span class="at">const</span></code> access path to a potentially const object:</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> A</span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb199-3"><a href="#cb199-3" aria-hidden="true" tabindex="-1"></a>    A * pA;                <span class="co">// Pointer to non-const A</span></span>
<span id="cb199-4"><a href="#cb199-4" aria-hidden="true" tabindex="-1"></a>    T array[<span class="dv">2</span>];            <span class="co">// Array of type T</span></span>
<span id="cb199-5"><a href="#cb199-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-6"><a href="#cb199-6" aria-hidden="true" tabindex="-1"></a>    A () : pA{<span class="kw">this</span>}{}      <span class="co">// pA provides access path to non-const</span></span>
<span id="cb199-7"><a href="#cb199-7" aria-hidden="true" tabindex="-1"></a>                           <span class="co">// this.</span></span>
<span id="cb199-8"><a href="#cb199-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-9"><a href="#cb199-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f () <span class="at">const</span></span>
<span id="cb199-10"><a href="#cb199-10" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb199-11"><a href="#cb199-11" aria-hidden="true" tabindex="-1"></a>      <span class="co">// pA = nullptr;     // ill-formed</span></span>
<span id="cb199-12"><a href="#cb199-12" aria-hidden="true" tabindex="-1"></a>      <span class="co">// array[0] = 0;     // ill-formed</span></span>
<span id="cb199-13"><a href="#cb199-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-14"><a href="#cb199-14" aria-hidden="true" tabindex="-1"></a>      pA-&gt;array[<span class="dv">0</span>] = <span class="dv">0</span>;    <span class="co">// compiles, but undefined behavior</span></span>
<span id="cb199-15"><a href="#cb199-15" aria-hidden="true" tabindex="-1"></a>                           <span class="co">// if executed on a const object</span></span>
<span id="cb199-16"><a href="#cb199-16" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb199-17"><a href="#cb199-17" aria-hidden="true" tabindex="-1"></a>  };</span></code></pre></div>
<p>In the const member function f, naming array directly results in a const-qualified access path and so an attempt to modify it is ill-formed. However, the type of pA is <code class="sourceCode cpp">A * <span class="at">const</span></code>, that is a <code class="sourceCode cpp"><span class="at">const</span></code> pointer to a non-const <code class="sourceCode cpp">A</code>. An attempt to modify <code class="sourceCode cpp">pA</code> is ill-formed, however, modification of the value pointed to by <code class="sourceCode cpp">pA</code> is not a const-qualified access path and so is not ill-formed.</p>
<p>It is undefined behavior to attempt to modify a const object. The programmer can incorrectly assume that a call to a const member function will not modify the object. However, as has been shown above, there is no guarantee that this is the case. The following example, therefore, will compile but has undefined behavior as a result of the modification of the const object:</p>
<div class="sourceCode" id="cb200"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> foo ()</span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a>  { </span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true" tabindex="-1"></a>     A a1 {} ;</span>
<span id="cb200-4"><a href="#cb200-4" aria-hidden="true" tabindex="-1"></a>     A <span class="at">const</span> a2 {} ;</span>
<span id="cb200-5"><a href="#cb200-5" aria-hidden="true" tabindex="-1"></a>     a1.f();           <span class="co">// OK - &#39;a1&#39; is not const</span></span>
<span id="cb200-6"><a href="#cb200-6" aria-hidden="true" tabindex="-1"></a>     a2.f();           <span class="co">// compiles but has undefined behavior</span></span>
<span id="cb200-7"><a href="#cb200-7" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>C++ classes wrapping pointer or reference members can be used to provide transitivity of <code class="sourceCode cpp"><span class="at">const</span></code> within <code class="sourceCode cpp"><span class="at">const</span></code> member functions. This is shown by the <code class="sourceCode cpp">MyRef</code> type in the following example:</p>
<div class="sourceCode" id="cb201"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; </span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MyRef</span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">operator</span> T&amp;() &amp;;</span>
<span id="cb201-6"><a href="#cb201-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">operator</span> T <span class="at">const</span> &amp;() <span class="at">const</span> &amp;;</span>
<span id="cb201-7"><a href="#cb201-7" aria-hidden="true" tabindex="-1"></a>  MyRef &amp; <span class="kw">operator</span>=(T <span class="at">const</span> &amp;) &amp;;</span>
<span id="cb201-8"><a href="#cb201-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-9"><a href="#cb201-9" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span>:</span>
<span id="cb201-10"><a href="#cb201-10" aria-hidden="true" tabindex="-1"></a>  T &amp; <span class="va">m_t</span>;</span>
<span id="cb201-11"><a href="#cb201-11" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb201-12"><a href="#cb201-12" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb201-13"><a href="#cb201-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A {</span>
<span id="cb201-14"><a href="#cb201-14" aria-hidden="true" tabindex="-1"></a>  A();</span>
<span id="cb201-15"><a href="#cb201-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-16"><a href="#cb201-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f1() {</span>
<span id="cb201-17"><a href="#cb201-17" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_i</span> = <span class="dv">0</span>;</span>
<span id="cb201-18"><a href="#cb201-18" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_j</span> = <span class="dv">0</span>;</span>
<span id="cb201-19"><a href="#cb201-19" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_j</span> ++;</span>
<span id="cb201-20"><a href="#cb201-20" aria-hidden="true" tabindex="-1"></a>    ++<span class="va">m_j</span>;</span>
<span id="cb201-21"><a href="#cb201-21" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb201-22"><a href="#cb201-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-23"><a href="#cb201-23" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f() <span class="at">const</span> {</span>
<span id="cb201-24"><a href="#cb201-24" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_i</span> = <span class="dv">0</span>;     <span class="co">// compiles, but undefined behavior</span></span>
<span id="cb201-25"><a href="#cb201-25" aria-hidden="true" tabindex="-1"></a>                 <span class="co">// if &#39;m_i&#39; refers to a const object</span></span>
<span id="cb201-26"><a href="#cb201-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-27"><a href="#cb201-27" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_j</span> = <span class="dv">0</span>;     <span class="co">// ill-formed</span></span>
<span id="cb201-28"><a href="#cb201-28" aria-hidden="true" tabindex="-1"></a>    ++ <span class="va">m_j</span>;      <span class="co">// ill-formed</span></span>
<span id="cb201-29"><a href="#cb201-29" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb201-30"><a href="#cb201-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-31"><a href="#cb201-31" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> &amp; <span class="va">m_i</span>;</span>
<span id="cb201-32"><a href="#cb201-32" aria-hidden="true" tabindex="-1"></a>  MyRef&lt;<span class="dt">int</span>&gt; <span class="va">m_j</span>;</span>
<span id="cb201-33"><a href="#cb201-33" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div>
<p>Attempts to modify the object referenced by <code class="sourceCode cpp"><span class="va">m_j</span></code> are ill-formed when they occur in the const member function <code class="sourceCode cpp">f2</code>.</p>
<p>C++ container iterator types, <code class="sourceCode cpp">iterator</code> and <code class="sourceCode cpp">const_iterator</code>, are examples of use of this pattern.</p>
<p>If a member variable is declared with the <code class="sourceCode cpp"><span class="at">mutable</span></code> keyword, then it can still be modified, even if the containing object is <code class="sourceCode cpp"><span class="at">const</span></code>. This is preferable to use <code class="sourceCode cpp"><span class="at">mutable</span></code> rather than removing the constness of the containing object (see <span id="FLC">Conversion Errors [FLC]</span>).<br />
Members declared <code class="sourceCode cpp"><span class="at">mutable</span></code> typically should not contribute to the value of the object. The following is a common example where a mutex member is declared <code class="sourceCode cpp"><span class="at">mutable</span></code> to allow locking in a <code class="sourceCode cpp"><span class="at">const</span></code> member function:</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;mutex&gt;</span></span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb202-3"><a href="#cb202-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MyQueue</span>
<span id="cb202-4"><a href="#cb202-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb202-5"><a href="#cb202-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb202-6"><a href="#cb202-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> empty () <span class="at">const</span> </span>
<span id="cb202-7"><a href="#cb202-7" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb202-8"><a href="#cb202-8" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>lock_guard sg (<span class="va">m_mutex</span>); <span class="co">// lock the mutex, which requires m_mutex to be writable</span></span>
<span id="cb202-9"><a href="#cb202-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="va">m_head</span> != <span class="kw">nullptr</span>;</span>
<span id="cb202-10"><a href="#cb202-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb202-11"><a href="#cb202-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb202-12"><a href="#cb202-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb202-13"><a href="#cb202-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb202-14"><a href="#cb202-14" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span>:</span>
<span id="cb202-15"><a href="#cb202-15" aria-hidden="true" tabindex="-1"></a>  <span class="at">mutable</span> <span class="bu">std::</span>mutex <span class="va">m_mutex</span>;</span>
<span id="cb202-16"><a href="#cb202-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> * <span class="va">m_head</span> { <span class="kw">nullptr</span> };</span>
<span id="cb202-17"><a href="#cb202-17" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div>
<h3 id="avoidance-mechanisms-for-language-users">6.65.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.65.5.</p></li>
<li><p>Forbid the use of cast-away <code class="sourceCode cpp"><span class="at">const</span></code>.</p></li>
<li><p>Leverage the C++ type system to restrict the operations on a type in a way that emulates <em>logical const</em> and document where used.</p></li>
<li><p>Be aware that, while <code class="sourceCode cpp"><span class="at">const</span></code> means “read only”, C++ permits <code class="sourceCode cpp"><span class="at">const</span></code> values to be modified as shown in clause 6.65.1.</p></li>
<li><p>Consider the use of <code class="sourceCode cpp"><span class="kw">constexpr</span></code> wherever possible to move the detection of the misuse of <code class="sourceCode cpp"><span class="at">const</span></code> to compile time.</p></li>
<li><p>Apply <code class="sourceCode cpp"><span class="at">mutable</span></code> only to member variables that do not influence the external behavior of an object.</p></li>
</ul>
<!-- -->
<h1 id="language-specific-vulnerabilities-for-c">7. Language specific vulnerabilities for C</h1>
<p>7.2 Copy/move semantics from Classes. (Peter Sommerlad’s paper at http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1412r0.pdf</p>
<h1 id="implications-for-standardization">8. Implications for standardization</h1>
<p>Future standardization efforts should consider:</p>
<ul>
<li><pre><code>Moving in the direction over time to being a more strongly typed</code></pre>
<p>language. Much of the use of weak typing is simply convenience to the developer in not having to fully consider the types and uses of variables. Stronger typing forces good programming discipline and clarity about variables while at the same time removing many unexpected run time errors due to implicit conversions. This is not to say that C should be strictly a strongly typed language – some advantages of C are due to the flexibility that weaker typing provides. It is suggested that when enforcement of strong typing does not detract from the good flexibility that C offers (for example, adding an integer to a character to step through a sequence of characters) and is only a convenience for programmers (for example, adding an integer to a floating-point number), then the standard should specify the stronger typed solution.</p></li>
<li><pre><code>A common warning in Annex I should be added for floating-point</code></pre>
<p>expressions being used in a Boolean test for equality.</p></li>
<li><pre><code>Modifying or deprecating many of the C standard library functions</code></pre>
<p>that make assumptions about the occurrence of a string termination character.</p></li>
<li><pre><code>Define a string construct that does not rely on the null termination</code></pre>
<p>character.</p></li>
<li><pre><code>Defining an array type that does automatic bounds checking.</code></pre></li>
<li><pre><code>Deprecating less safe functions such as strcpy() and strcat() where</code></pre>
<p>a more secure alternative is available.<span data-custom-style="annotation reference"></span></p></li>
<li><pre><code>Defining safer and more secure replacement functions such as</code></pre>
<p>memncpy() and memncmp() to complement the memcpy() and memcmp() functions (see <em>6.11.6 Implications for standardization</em>)</p></li>
<li><pre><code>Defining an array type that does automatic bounds checking.</code></pre></li>
<li><pre><code>Defining functions that contain an extra parameter in memcpy() and</code></pre>
<p>memmove() for the maximum number of bytes to copy. In the past, some have suggested that the size of the destination buffer be used as an additional parameter. Some critics state that this solution is easy to circumvent by simply repeating the parameter that was used for the number of bytes to copy as the parameter for the size of the destination buffer. This analysis and criticism is correct. What is needed is a failsafe check as to the maximum number of bytes to copy. There are several reasons for creating new functions with an additional parameter. This would make it easier for static analysis to eliminate those cases where the memory copy could not be a problem (such as when the maximum number of bytes is demonstrably less than the capacity of the receiving buffer). Manual analysis or more involved static analysis could then be used for the remaining situations where the size of the destination buffer may not be sufficient for the maximum number of bytes to copy. This extra parameter may also help in determining which copies could take place among objects that overlap. Such copying is undefined according to the C standard. It is suggested that safer versions of functions that include a restriction max_n on the number of bytes n to copy (for example, void *memncpy(void * restrict s1,const void * restrict s2,size_t n), const size_t max_n) be added to the standard in addition to retaining the current corresponding functions (for example, memcpy(void * restrict s1,const void * restrict s2,size_t n))). The additional parameter would be consistent with the copying function pairs that have already been created such as strcpy()/strncpy() and strcat()/strncat(). This would allow a safer version of memory copying functions for those applications that want to use them in to facilitate both safer and more secure code and more efficient and accurate static code reviews<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p></li>
<li><pre><code>Restrictions on pointer arithmetic that could eliminate common</code></pre>
<p>pitfalls. Pointer arithmetic is error-prone and the flexibility that it offers is useful, but some of the flexibility is simply a shortcut that if restricted could lessen the chance of a pointer arithmetic based error.</p></li>
<li><pre><code>Defining a standard way of declaring an attribute to indicate that a</code></pre>
<p>variable is intentionally unused.</p></li>
<li><pre><code>A common warning in Annex I should be added for variables with the</code></pre>
<p>same name in nested scopes.</p></li>
<li><pre><code>Creating a few standardized precedence orders. Standardizing on a</code></pre>
<p>few precedence orders will help to eliminate the confusing intricacies that exist between languages. This would not affect current languages as altering precedence orders in existing languages is too onerous. However, this would set a basis for the future as new languages are created and adopted. Stating that a language uses “ISO precedence order A” would be useful rather than having to spell out the entire precedence order that differs in a conceptually minor way from some other languages, but in a major way when programmers attempt to switch between languages.</p></li>
<li><pre><code>Deprecating the goto statement. The use of the goto construct is</code></pre>
<p>often spotlighted as the antithesis of good structured programming. Though its deprecation will not instantly make all C code structured, deprecating the goto and leaving in place the restricted goto variations (for example, break and continue) and possibly adding other restricted goto’s could assist in encouraging safer and more secure C programming in general.</p></li>
<li><pre><code>Defining a &quot;fallthru&quot; construct that will explicitly bind multiple</code></pre>
<p>switch cases together and eliminate the need for the break statement. The default would be for a case to break instead of falling through to the next case. Granted this is a major shift in concept, but if it could be accomplished, less unintentional errors would occur.</p></li>
<li><pre><code>Defining an identifier type for loop control that cannot be modified</code></pre>
<p>by anything other than the loop control construct would be a relatively minor addition to C that could make C code safer and encourage better structured programming.</p></li>
<li><pre><code>Defining a standardized interface package for interfacing C with</code></pre>
<p>many of the top programming languages and a reciprocal package should be developed of the other top languages to interface with C.</p></li>
<li><pre><code>Joining with other languages in developing a standardized set of</code></pre>
<p>mechanisms for detecting and treating error conditions so that all languages to the extent possible could use them. Note that this does not mean that all languages should use the same mechanisms as there should be a variety ( label parameters, auxiliary status variables), but each of the mechanisms should be standardized.</p></li>
<li><pre><code>Since fault handling and exiting of a program is common to all</code></pre>
<p>languages, it is suggested that common terminology such as the meaning of fail safe, fail hard, fail soft, and so on along with a core API set such as exit, abort, and so on be standardized and coordinated with other languages.</p></li>
<li><pre><code>Deprecating unions. The primary reason for the use of unions to save</code></pre>
<p>memory has been diminished considerably as memory has become cheaper and more available. Unions are not statically type safe and are historically known to be a common source of errors, leading to many C programming guidelines specifically prohibiting the use of unions.</p></li>
<li><pre><code>Creating a recognizable naming standard for routines such that one</code></pre>
<p>version of a library does parameter checking to the extent possible and another version does no parameter checking. The first version would be considered safer and more secure and the second could be used in certain situations where performance is critical and the checking is assumed to be done in the calling routine. A naming standard could be made such that the library that does parameter checking could be named as usual, say “library_xyz” and an equivalent version that does not do checking could have a “_p” appended, such as “library_xyz_p”. Without a naming standard such as this, a considerable number of wasted cycles will be conducted doing a double check of parameters or even worse, no checking will be done in both the calling and receiving routines as each is assuming the other is doing the checking.</p></li>
<li><pre><code>Creating an Annex that lists deprecated features.</code></pre></li>
</ul>
<h1 id="bibliography">Bibliography</h1>
<div data-custom-style="Bibliography1">
<p>[1] ISO/IEC Directives, Part 2, <em>Rules for the structure and drafting of International Standards</em>, 2004</p>
</div>
<div data-custom-style="Bibliography1">
<p>[2] ISO/IEC TR 10000‑1, <em>Information technology — Framework and taxonomy of International Standardized Profiles — Part 1: General principles and documentation framework</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[3] ISO 10241 (all parts), <em>International terminology standards</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[4] ISO/IEC 9899:2011, <em>Information technology</em> — <em>Programming languages —</em> C</p>
</div>
<div data-custom-style="Bibliography1">
<p>[5] ISO/IEC 9899:2011/Cor.1:2012, <em>Technical Corrigendum 1</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[6] ISO/IEC 30170:2012, <em>Information technology</em> — <em>Programming languages —</em> Ruby</p>
</div>
<div data-custom-style="Bibliography1">
<p>[7] ISO/IEC/IEEE 60559:2011, <em>Information technology – Microprocessor Systems – Floating-Point arithmetic</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[8] ISO/IEC 1539-1:2010, <em>Information technology — Programming languages —</em> Fortran — Part 1: Base language</p>
</div>
<div data-custom-style="Bibliography1">
<p>[9] ISO/IEC 8652:1995, <em>Information technology — Programming languages —</em> Ada</p>
</div>
<div data-custom-style="Bibliography1">
<p>[10] ISO/IEC 14882:2011, <em>Information technology</em> — <em>Programming languages —</em> C++</p>
</div>
<div data-custom-style="Bibliography1">
<p>[11] R. Seacord, <em>The CERT C Secure Coding Standard</em>. Boston,MA: Addison-Westley, 2008.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[12] Motor Industry Software Reliability Association. <em>Guidelines for the Use of the C Language in Vehicle Based Software</em>, 2012 (third edition)16F<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[13] ISO/IEC TR24731–1, <em>Information technology — Programming languages, their environments and system software interfaces — Extensions to the C library — Part 1: Bounds-checking interfaces</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[14] ISO/IEC TR 15942:2000, <em>Information technology — Programming languages — Guide for the use of the Ada programming language in high integrity systems</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[15] Joint Strike Fighter Air Vehicle: C++ Coding Standards for the System Development and Demonstration Program. Lockheed Martin Corporation. December 2005.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[16] Motor Industry Software Reliability Association. <em>Guidelines for the Use of the C++ Language in critical systems</em>, June 2008</p>
</div>
<div data-custom-style="Bibliography1">
<p>[17] ISO/IEC TR 24718: 2005, <em>Information technology — Programming languages — Guide for the use of the Ada Ravenscar Profile in high integrity systems</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[18] L. Hatton, Safer C: developing software for high-integrity and safety-critical systems. McGraw-Hill 1995</p>
</div>
<div data-custom-style="Bibliography1">
<p>[19] ISO/IEC 15291:1999, <em>Information technology — Programming languages — Ada Semantic Interface Specification (ASIS)</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[20] Software Considerations in Airborne Systems and Equipment Certification. Issued in the USA by the Requirements and Technical Concepts for Aviation (document RTCA SC167/DO-178B) and in Europe by the European Organization for Civil Aviation Electronics (EUROCAE document ED-12B).December 1992.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[21] IEC 61508: Parts 1-7, Functional safety: safety-related systems. 1998. (Part 3 is concerned with software).</p>
</div>
<div data-custom-style="Bibliography1">
<p>[22] ISO/IEC 15408: 1999 Information technology. Security techniques. Evaluation criteria for IT security.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[23] J Barnes, High Integrity Software - the SPARK Approach to Safety and Security. Addison-Wesley. 2002.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[25] Steve Christy, <em>Vulnerability Type Distributions in CVE</em>, V1.0, 2006/10/04</p>
</div>
<div data-custom-style="Bibliography1">
<p>[26] <em>ARIANE 5: Flight 501 Failure</em>, Report by the Inquiry Board, July 19, 1996 <a href="http://esamultimedia.esa.int/docs/esa-x-1819eng.pdf"><span data-custom-style="Hyperlink">http://esamultimedia.esa.int/docs/esa-x-1819eng.pdf</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[27] Hogaboom, Richard, <em>A Generic API Bit Manipulation in C</em>, Embedded Systems Programming, Vol 12, No 7, July 1999 <a href="http://www.embedded.com/1999/9907/9907feat2.htm"><span data-custom-style="Hyperlink">http://www.embedded.com/1999/9907/9907feat2.htm</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[28] Carlo Ghezzi and Mehdi Jazayeri, Programming Language Concepts, 3<sup>rd</sup> edition, ISBN-0-471-10426-4, John Wiley &amp; Sons, 1998</p>
</div>
<div data-custom-style="Bibliography1">
<p>[29] Lions, J. L. <a href="http://en.wikisource.org/wiki/Ariane_501_Inquiry_Board_report"><span data-custom-style="Hyperlink">ARIANE 5 Flight 501 Failure Report</span></a>. Paris, France: European Space Agency (ESA) &amp; National Center for Space Study (CNES) Inquiry Board, July 1996.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[30] Seacord, R. <em>Secure Coding in C and C++</em>. Boston, MA: Addison-Wesley, 2005. See <a href="http://www.cert.org/books/secure-coding"><span data-custom-style="Hyperlink">http://www.cert.org/books/secure-coding</span></a> for news and errata.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[31] John David N. Dionisio. Type Checking. <a href="http://myweb.lmu.edu/dondi/share/pl/type-checking-v02.pdf"><span data-custom-style="Hyperlink">http://myweb.lmu.edu/dondi/share/pl/type-checking-v02.pdf</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[32] MISRA Limited. "<a href="http://www.misra.org.uk/"><span data-custom-style="Hyperlink">MISRA C</span></a>: 2012 Guidelines for the Use of the C Language in Critical Systems." Warwickshire, UK: MIRA Limited, March 2013 (ISBN 978-1-906400-10-1 and 978-1-906400-11-8).</p>
</div>
<div data-custom-style="Bibliography1">
<p>[33] The Common Weakness Enumeration (CWE) Initiative, MITRE Corporation, (<a href="http://cwe.mitre.org/"><span data-custom-style="Hyperlink">http://cwe.mitre.org/</span></a>)</p>
</div>
<div data-custom-style="Bibliography1">
<p>[34] Goldberg, David, <em>What Every Computer Scientist Should Know About Floating-Point Arithmetic</em>, ACM Computing Surveys, vol 23, issue 1 (March 1991), ISSN 0360-0300, pp 5-48.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[35] IEEE Standards Committee 754. IEEE Standard for Binary Floating-Point Arithmetic, ANSI/IEEE Standard 754-2008. Institute of Electrical and Electronics Engineers, New York, 2008.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[36] Robert W. Sebesta, Concepts of Programming Languages, 8<sup>th</sup> edition, ISBN-13: 978-0-321-49362-0, ISBN-10: 0-321-49362-1, Pearson Education, Boston, MA, 2008</p>
</div>
<div data-custom-style="Bibliography1">
<p>[37] Bo Einarsson, ed. Accuracy and Reliability in Scientific Computing, SIAM, July 2005 <a href="http://www.nsc.liu.se/wg25/book"><span data-custom-style="Hyperlink">http://www.nsc.liu.se/wg25/book</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[38] GAO Report, Patriot <em>Missile Defense: Software Problem Led to System Failure at Dhahran, Saudi Arabia</em>, B-247094, Feb. 4, 1992, <a href="http://archive.gao.gov/t2pbat6/145960.pdf"><span data-custom-style="Hyperlink">http://archive.gao.gov/t2pbat6/145960.pdf</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[39] Robert Skeel, <em>Roundoff Error Cripples Patriot Missile</em>, SIAM News, Volume 25, Number 4, July 1992, page 11, <a href="http://www.siam.org/siamnews/general/patriot.htm"><span data-custom-style="HTML Typewriter"><u>http://www.siam.org/siamnews/general/patriot.htm</u></span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[40] CERT. <em>CERT C++ Secure Coding Standard</em>.  <a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637%20"><span data-custom-style="Hyperlink">https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637</span></a> (2009).</p>
</div>
<div data-custom-style="Bibliography1">
<p>[41] Holzmann, Garard J., Computer, vol. 39, no. 6, pp 95-97, Jun., 2006, <em>The Power of 10: Rules for Developing Safety-Critical Code</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[42] P. V. Bhansali, A systematic approach to identifying a safe subset for safety-critical software, ACM SIGSOFT Software Engineering Notes, v.28 n.4, July 2003</p>
</div>
<div data-custom-style="Bibliography1">
<p>[43] Ada 95 Quality and Style Guide, SPC-91061-CMC, version 02.01.01. Herndon, Virginia: Software Productivity Consortium, 1992. Available from: <a href="http://www.adaic.org/docs/95style/95style.pdf"><span data-custom-style="Hyperlink">http://www.adaic.org/docs/95style/95style.pdf</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[44] Ghassan, A., &amp; Alkadi, I. (2003). Application of a Revised DIT Metric to Redesign an OO Design. <em>Journal of Object Technology</em> , 127-134.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[45] Subramanian, S., Tsai, W.-T., &amp; Rayadurgam, S. (1998). Design Constraint Violation Detection in Safety-Critical Systems. The 3rd IEEE International Symposium on High-Assurance Systems Engineering , 109 - 116.</p>
</div>
<p>[46] Lundqvist, K and Asplund, L., “<em>A Formal Model of a Run-Time Kernel for Ravenscar</em>”, The 6th International Conference on Real-Time Computing Systems and Applications – RTCSA 1999</p>
<p>[47] ISO/IEC TS 17961, <em>Information technology – Programming languages, their environments and system software interfaces – C secure coding rules</em></p>
<p>[48] GNU Project. GCC Bugs “Non-bugs” http://gcc.gnu.org/bugs.html#nonbugs_c (2009).</p>
<h1 id="index">Index</h1>
<div data-custom-style="Bibliography1">
<p>LHS (left-hand side), 22</p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>::: {custom-style=“footnote text”} <span data-custom-style="footnote reference"></span> This has been addressed by WG 14 in an optionally normative annex in the current working paper<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>::: {custom-style=“footnote text”} <span data-custom-style="footnote reference"></span> The first edition should not be used or quoted in this work.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
