<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>tr24772-10-C++</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div data-custom-style="zzCover">
<p>ISO/IEC JTC 1/SC 22/WG23 N1012</p>
</div>
<div data-custom-style="zzCover">
<p>Date: 2020-11-23</p>
</div>
<div data-custom-style="zzCover">
<p>ISO/IEC TR 24772–10<br />
Notes on this document</p>
</div>
<p>Effective 23 November 2020, this document is being moved to “github”. Contact <span data-custom-style="Hyperlink">Stephen.michell@maurya.on.ca</span> to gain access.</p>
<p>This document is a draft of a Guidance to avoiding programming language vulnerabilities in C++.</p>
<p>At this point in time, the following clauses are essentially completed first pass.</p>
<ul>
<li><pre><code>6.2 type system</code></pre></li>
<li><pre><code>6.3 Bit representation</code></pre></li>
<li><pre><code>6.4 Floating Point</code></pre></li>
<li><pre><code>6.5 Enumerator issues \[CCB\],</code></pre></li>
<li><pre><code>6.6 Conversion errors</code></pre></li>
<li><pre><code>6.7 String termination</code></pre></li>
<li><pre><code>6.8 Buffer boundary violation</code></pre></li>
<li><pre><code>6.9 Unchecked array indexing</code></pre></li>
<li><pre><code>6.10 Unchecked array copying (needs to be revisited)</code></pre></li>
<li><pre><code>6.11 Pointer type conversions</code></pre></li>
<li><pre><code>6.12 Pointer arithmetic</code></pre></li>
<li><pre><code>6.13 Null pointer dereference \[XYH\],</code></pre></li>
<li><pre><code>6.14 Dangling reference to heap</code></pre></li>
<li><pre><code>6.15 Arithmetic wrap-around error</code></pre></li>
<li><pre><code>6.16 Using shift operations for multiplication and division</code></pre></li>
<li><pre><code>6.17 Choice of clear names \[NAI\]</code></pre></li>
<li><pre><code>6.18 Dead Store</code></pre></li>
<li><pre><code>6.19 Unused variables</code></pre></li>
<li><pre><code>6.20 Identifier name reuse</code></pre></li>
<li><pre><code>6.21 Namespace Issues</code></pre></li>
<li><pre><code>6.22 Initialization of variables \[LAV\]</code></pre></li>
<li><pre><code>6.23 Operator precedence and associativity</code></pre></li>
<li><pre><code>6.24 Side effects and order of evaluation</code></pre></li>
<li><pre><code>6.25 Likely incorrect expression</code></pre></li>
<li><pre><code>6.26 Dead store,</code></pre></li>
<li><pre><code>6.27 Switch statements and static analysis</code></pre></li>
<li><pre><code>6.28 Demarcation of control flow</code></pre></li>
<li><pre><code>6.29 Loop control variables</code></pre></li>
<li><pre><code>6.30 Off-by-one errors</code></pre></li>
<li><pre><code>6.31 Structured programming</code></pre></li>
<li><pre><code>6.32 Passing parameters and return values</code></pre></li>
<li><pre><code>6.33 Dangling references to stack frames</code></pre></li>
<li><pre><code>6.34 Subprogram signature mismatch</code></pre></li>
<li><pre><code>6.35 Recursion</code></pre></li>
<li><pre><code>6.36 Ignored error status and unhandled exceptions</code></pre></li>
<li><pre><code>6.37 Type breaking reinterpretation of data</code></pre></li>
<li><pre><code>6.38 Deep vs shallow copying \[YAN\]</code></pre></li>
<li><pre><code>6.39 Memory leak and heap fragmentation</code></pre></li>
<li><pre><code>6.41 Inheritance</code></pre></li>
<li><pre><code>6.42 Violations of the Liskov substitution principle</code></pre></li>
<li><pre><code>6.43 Redispatching</code></pre></li>
<li><pre><code>6.44 Polymorphic variables</code></pre></li>
<li><pre><code>6.45 Extra intrinsics</code></pre></li>
<li><pre><code>6.46 Argument passing to library functions</code></pre></li>
<li><pre><code>6.47 Inter-language calling</code></pre></li>
<li><pre><code>6.48 Dynamically-linked code and self-modifying code \[NYY\]</code></pre></li>
<li><pre><code>6.49 Library Signature</code></pre></li>
<li><pre><code>6.50 Unanticipated exceptions from library routines</code></pre></li>
<li><pre><code>6.51 Pre-processor directives</code></pre></li>
<li><pre><code>6.52 Suppression of language-defined run-time checking</code></pre></li>
<li><pre><code>6.53 Provision of inherently unsafe operations</code></pre></li>
<li><pre><code>6.54 Obscure language features</code></pre></li>
<li><pre><code>6.55 Unspecified behaviour</code></pre></li>
<li><pre><code>6.56 Undefined behaviour</code></pre></li>
<li><pre><code>6.57 Implementation-defined behaviour</code></pre></li>
<li><pre><code>6.58 Deprecated language features</code></pre></li>
<li><pre><code>6.59 Concurrency \-- Activation</code></pre></li>
<li><pre><code>6.60 Concurrency -- Directed termination</code></pre></li>
<li><pre><code>6.64 Uncontrolled format string</code></pre></li>
</ul>
<div data-custom-style="Normal (Web)">
<p>TBD</p>
</div>
<ul>
<li><pre><code>6.2 Type system -- issues being fed from 6.40 and elsewhere</code></pre></li>
<li><pre><code>6.61 Concurrent data access</code></pre></li>
<li><pre><code>6.62 Concurrency -- Premature termination</code></pre></li>
<li><pre><code>6.63 Protocol lock errors</code></pre></li>
</ul>
<div data-custom-style="Normal (Web)">
<p>Participants at meeting 23 November 2020</p>
</div>
<p>Stephen Michell</p>
<p>Paul Preney</p>
<p>Peter Sommerlad</p>
<p>Richard Corden</p>
<p>Erhard Ploedereder</p>
<p>Clive Pygott</p>
<p>Michael Wong</p>
<!-- Here we include stuff... with pandoc-include filter -->
<div data-custom-style="zzCover">
<p>Edition 1</p>
</div>
<div data-custom-style="zzCover">
<p>ISO/IEC JTC 1/SC 22/WG 23</p>
</div>
<div data-custom-style="zzCover">
<p>Secretariat: ANSI</p>
</div>
<div data-custom-style="Bibliography1">
<p>Information Technology — Programming languages — Guidance to avoiding vulnerabilities in programming languages – Part 10 – Vulnerability descriptions for the programming language C++</p>
</div>
<div data-custom-style="zzCover">
<p>Document type: International standard</p>
</div>
<div data-custom-style="zzCover">
<p>Document subtype: if applicable</p>
</div>
<div data-custom-style="zzCover">
<p>Document stage: (10) development stage</p>
</div>
<div data-custom-style="zzCover">
<p>Document language: E</p>
</div>
<p><em>Élément introductif — Élément principal — Partie n: Titre de la partie</em></p>
<div data-custom-style="zzCover">
<p>Warning</p>
</div>
<div data-custom-style="zzCover">
<p>This document is not an ISO International Standard. It is distributed for review and comment. It is subject to change without notice and may not be referred to as an International Standard.</p>
</div>
<div data-custom-style="zzCover">
<p>Recipients of this draft are invited to submit, with their comments, notification of any relevant patent rights of which they are aware and to provide supporting documentation.</p>
</div>
<div data-custom-style="zzCopyright">
<p><strong>Copyright notice</strong></p>
</div>
<div data-custom-style="zzCopyright">
<p>This ISO document is a working draft or committee draft and is copyright-protected by ISO. While the reproduction of working drafts or committee drafts in any form for use by participants in the ISO standards development process is permitted without prior permission from ISO, neither this document nor any extract from it may be reproduced, stored or transmitted in any form for any other purpose without prior written permission from ISO.</p>
</div>
<div data-custom-style="zzCopyright">
<p>Requests for permission to reproduce this document for the purpose of selling it should be addressed as shown below or to ISO’s member body in the country of the requester:</p>
</div>
<div data-custom-style="zzCopyright">
<p><em>ISO copyright office</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>Case postale 56, CH-1211 Geneva 20</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>Tel. + 41 22 749 01 11</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>Fax + 41 22 749 09 47</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>E-mail copyright@iso.org</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>Web www.iso.org</em></p>
</div>
<div data-custom-style="zzCopyright">
<p>Reproduction for sales purposes may be subject to royalty payments or a licensing agreement.</p>
</div>
<div data-custom-style="zzCopyright">
<p>Violators may be prosecuted.</p>
</div>
<div data-custom-style="zzContents">
<p>Contents Page</p>
</div>
<div data-custom-style="toc 1">
<p><a href="#foreword"><span data-custom-style="Hyperlink">Foreword</span> vii</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#introduction"><span data-custom-style="Hyperlink">Introduction</span> viii</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#scope"><span data-custom-style="Hyperlink">1. Scope</span> 1</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#normative-references"><span data-custom-style="Hyperlink">2. Normative references</span> 1</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#terms-and-definitions-symbols-and-conventions"><span data-custom-style="Hyperlink">3. Terms and definitions, symbols and conventions</span> 1</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#terms-and-definitions"><span data-custom-style="Hyperlink">3.1 Terms and definitions</span> 1</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#language-concepts"><span data-custom-style="Hyperlink">4. Language concepts</span> 4</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#section"><span data-custom-style="Hyperlink">5. Avoiding programming language vulnerabilities in C++</span> 4</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#specific-guidance-for-c-vulnerabilities"><span data-custom-style="Hyperlink">6. Specific Guidance for C++ Vulnerabilities</span> 6</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#general"><span data-custom-style="Hyperlink">6.1 General</span> 6</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#type-system-ihn"><span data-custom-style="Hyperlink">6.2 Type System [IHN]</span> 6</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#bit-representations-str"><span data-custom-style="Hyperlink">6.3 Bit Representations [STR]</span> 7</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#floating-point-arithmetic-plf"><span data-custom-style="Hyperlink">6.4 Floating-point Arithmetic [PLF]</span> 8</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#enumerator-issues-ccb"><span data-custom-style="Hyperlink">6.5 Enumerator Issues [CCB]</span> 8</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc1165233"><span data-custom-style="Hyperlink">6.6 Conversion Errors [FLC]</span> 9</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#string-termination-cjm"><span data-custom-style="Hyperlink">6.7 String Termination [CJM]</span> 10</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc1165235"><span data-custom-style="Hyperlink">•</span> <span data-custom-style="Hyperlink">Use std::string or similar, in preference to C-style arrays of chars</span> 11</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#buffer-boundary-violation-hcb"><span data-custom-style="Hyperlink">6.8 Buffer Boundary Violation [HCB]</span> 11</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unchecked-array-indexing-xyz"><span data-custom-style="Hyperlink">6.9 Unchecked Array Indexing [XYZ]</span> 12</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unchecked-array-copying-xyw"><span data-custom-style="Hyperlink">6.10 Unchecked Array Copying [XYW]</span> 13</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#pointer-type-conversions-hfc"><span data-custom-style="Hyperlink">6.11 Pointer Type Conversions [HFC]</span> 13</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#pointer-arithmetic-rvg"><span data-custom-style="Hyperlink">6.12 Pointer Arithmetic [RVG]</span> 15</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#null-pointer-dereference-xyh"><span data-custom-style="Hyperlink">6.13 NULL Pointer Dereference [XYH]</span> 16</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dangling-reference-to-heap-xyk"><span data-custom-style="Hyperlink">6.14 Dangling Reference to Heap [XYK]</span> 16</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#arithmetic-wrap-around-error-fif"><span data-custom-style="Hyperlink">6.15 Arithmetic Wrap-around Error [FIF]</span> 18</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#using-shift-operations-for-multiplication-and-division-pik"><span data-custom-style="Hyperlink">6.16 Using Shift Operations for Multiplication and Division [PIK]</span> 18</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#choice-of-clear-names-nai"><span data-custom-style="Hyperlink">6.17 Choice of Clear Names [NAI]</span> 19</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dead-store-wxq"><span data-custom-style="Hyperlink">6.18 Dead Store [WXQ]</span> 19</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unused-variable-yzs"><span data-custom-style="Hyperlink">6.19 Unused Variable [YZS]</span> 20</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#identifier-name-reuse-yow"><span data-custom-style="Hyperlink">6.20 Identifier Name Reuse [YOW]</span> 20</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc310518176"><span data-custom-style="Hyperlink">6.21 Namespace Issues [BJL]</span> 21</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#initialization-of-variables-lav"><span data-custom-style="Hyperlink">6.22 Initialization of Variables [LAV]</span> 21</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#operator-precedence-and-associativity-jcw"><span data-custom-style="Hyperlink">6.23 Operator Precedence and Associativity [JCW]</span> 21</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#side-effects-and-order-of-evaluation-of-operands-sam"><span data-custom-style="Hyperlink">6.24 Side-effects and Order of Evaluation of Operands [SAM]</span> 21</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#likely-incorrect-expression-koa"><span data-custom-style="Hyperlink">6.25 Likely Incorrect Expression [KOA]</span> 22</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dead-and-deactivated-code-xyq"><span data-custom-style="Hyperlink">6.26 Dead and Deactivated Code [XYQ]</span> 24</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#switch-statements-and-static-analysis-cll"><span data-custom-style="Hyperlink">6.27 Switch Statements and Static Analysis [CLL]</span> 24</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#demarcation-of-control-flow-eoj"><span data-custom-style="Hyperlink">6.28 Demarcation of Control Flow [EOJ]</span> 25</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#loop-control-variables-tex"><span data-custom-style="Hyperlink">6.29 Loop Control Variables [TEX]</span> 26</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#off-by-one-error-xzh"><span data-custom-style="Hyperlink">6.30 Off-by-one Error [XZH]</span> 27</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#structured-programming-ewd"><span data-custom-style="Hyperlink">6.31 Structured Programming [EWD]</span> 28</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#passing-parameters-and-return-values-csj"><span data-custom-style="Hyperlink">6.32 Passing Parameters and Return Values [CSJ]</span> 28</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dangling-references-to-stack-frames-dcm"><span data-custom-style="Hyperlink">6.33 Dangling References to Stack Frames [DCM]</span> 29</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#subprogram-signature-mismatch-otr"><span data-custom-style="Hyperlink">6.34 Subprogram Signature Mismatch [OTR]</span> 30</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#recursion-gdl"><span data-custom-style="Hyperlink">6.35 Recursion [GDL]</span> 31</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#ignored-error-status-and-unhandled-exceptions-oyb"><span data-custom-style="Hyperlink">6.36 Ignored Error Status and Unhandled Exceptions [OYB]</span> 31</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#type-breaking-reinterpretation-of-data-amv"><span data-custom-style="Hyperlink">6.37 Type-breaking Reinterpretation of Data [AMV]</span> 32</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#deep-vs.-shallow-copying-yan"><span data-custom-style="Hyperlink">6.38 Deep vs. Shallow Copying [YAN]</span> 33</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#memory-leak-and-heap-fragmentation-xyl"><span data-custom-style="Hyperlink">6.39 Memory Leak and Heap Fragmentation [XYL]</span> 33</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#templates-and-generics-sym"><span data-custom-style="Hyperlink">6.40 Templates and Generics [SYM]</span> 34</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#inheritance-rip"><span data-custom-style="Hyperlink">6.41 Inheritance [RIP]</span> 35</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#applicability-to-language-39"><span data-custom-style="Hyperlink">6.41.1 Applicability to language</span> 35</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-37"><span data-custom-style="Hyperlink">6.41.2 Guidance to language users</span> 37</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#violations-of-the-liskov-substitution-principle-or-the-contract-model-blp"><span data-custom-style="Hyperlink">6.42 Violations of the Liskov Substitution Principle or the Contract Model [BLP]</span> 37</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#applicability-to-language-40"><span data-custom-style="Hyperlink">6.42.1 Applicability to language</span> 37</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-38"><span data-custom-style="Hyperlink">6.42.2 Guidance to language users</span> 38</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#redispatching-pph"><span data-custom-style="Hyperlink">6.43 Redispatching [PPH]</span> 38</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#applicability-to-language-41"><span data-custom-style="Hyperlink">6.43.1 Applicability to language</span> 38</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-39"><span data-custom-style="Hyperlink">6.43.2 Guidance to language users</span> 39</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#polymorphic-variables-bkk"><span data-custom-style="Hyperlink">6.44 Polymorphic variables [BKK]</span> 39</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#applicability-to-language-42"><span data-custom-style="Hyperlink">6.44.1 Applicability to language</span> 40</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-40"><span data-custom-style="Hyperlink">6.44.2 Guidance to language users</span> 41</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#extra-intrinsics-lrm"><span data-custom-style="Hyperlink">6.45 Extra Intrinsics [LRM]</span> 42</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#argument-passing-to-library-functions-trj"><span data-custom-style="Hyperlink">6.46 Argument Passing to Library Functions [TRJ]</span> 42</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#inter-language-calling-djs"><span data-custom-style="Hyperlink">6.47 Inter-language Calling [DJS]</span> 42</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dynamically-linked-code-and-self-modifying-code-nyy"><span data-custom-style="Hyperlink">6.48 Dynamically-linked Code and Self-modifying Code [NYY]</span> 45</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#library-signature-nsq"><span data-custom-style="Hyperlink">6.49 Library Signature [NSQ]</span> 46</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unanticipated-exceptions-from-library-routines-hjw"><span data-custom-style="Hyperlink">6.50</span> <span data-custom-style="Hyperlink">Unanticipated Exceptions from Library Routines [HJW]</span> 47</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#pre-processor-directives-nmp"><span data-custom-style="Hyperlink">6.51 Pre-processor Directives [NMP]</span> 48</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#suppression-of-language-defined-run-time-checking-mxb"><span data-custom-style="Hyperlink">6.52 Suppression of Language-defined Run-time Checking [MXB]</span> 49</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#provision-of-inherently-unsafe-operations-skl"><span data-custom-style="Hyperlink">6.53 Provision of Inherently Unsafe Operations [SKL]</span> 49</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#obscure-language-features-brs"><span data-custom-style="Hyperlink">6.54 Obscure Language Features [BRS]</span> 49</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unspecified-behaviour-bqf"><span data-custom-style="Hyperlink">6.55 Unspecified Behaviour [BQF]</span> 50</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#undefined-behaviour-ewf"><span data-custom-style="Hyperlink">6.56 Undefined Behaviour [EWF]</span> 50</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#implementationdefined-behaviour-fab"><span data-custom-style="Hyperlink">6.57 Implementation–defined Behaviour [FAB]</span> 51</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#deprecated-language-features-mem"><span data-custom-style="Hyperlink">6.58 Deprecated Language Features [MEM]</span> 52</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#concurrency-activation-cga"><span data-custom-style="Hyperlink">6.59 Concurrency – Activation [CGA]</span> 52</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#concurrency-directed-termination-cgt"><span data-custom-style="Hyperlink">6.60 Concurrency – Directed termination [CGT]</span> 52</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc1165297"><span data-custom-style="Hyperlink">6.60.1 Applicability to language</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-55"><span data-custom-style="Hyperlink">6.60.2 Guidance to language users</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc1165299"><span data-custom-style="Hyperlink">6.61 Concurrent Data Access [CGX]</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#concurrency-premature-termination-cgs"><span data-custom-style="Hyperlink">6.62 Concurrency – Premature Termination [CGS]</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#protocol-lock-errors-cgm"><span data-custom-style="Hyperlink">6.63 Protocol Lock Errors [CGM]</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#uncontrolled-format-string-shl"><span data-custom-style="Hyperlink">6.64 Uncontrolled Format String [SHL]</span> 54</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#language-specific-vulnerabilities-for-c"><span data-custom-style="Hyperlink">7. Language specific vulnerabilities for C</span> 54</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#implications-for-standardization"><span data-custom-style="Hyperlink">8. Implications for standardization</span> 54</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#bibliography"><span data-custom-style="Hyperlink">Bibliography</span> 57</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#index"><span data-custom-style="Hyperlink">Index</span> 60</a></p>
</div>
<h1 id="foreword">Foreword</h1>
<p>ISO (the International Organization for Standardization) and IEC (the International Electrotechnical Commission) form the specialized system for worldwide standardization. National bodies that are members of ISO or IEC participate in the development of International Standards through technical committees established by the respective organization to deal with particular fields of technical activity. ISO and IEC technical committees collaborate in fields of mutual interest. Other international organizations, governmental and non-governmental, in liaison with ISO and IEC, also take part in the work. In the field of information technology, ISO and IEC have established a joint technical committee, ISO/IEC JTC 1.</p>
<p>International Standards are drafted in accordance with the rules given in the ISO/IEC Directives, Part 2.</p>
<p>The main task of the joint technical committee is to prepare International Standards. Draft International Standards adopted by the joint technical committee are circulated to national bodies for voting. Publication as an International Standard requires approval by at least 75 % of the national bodies casting a vote.</p>
<p>In exceptional circumstances, when the joint technical committee has collected data of a different kind from that which is normally published as an International Standard (“state of the art”, for example), it may decide to publish a Technical Report. A Technical Report is entirely informative in nature and shall be subject to review every five years in the same manner as an International Standard.</p>
<p>Attention is drawn to the possibility that some of the elements of this document may be the subject of patent rights. ISO and IEC shall not be held responsible for identifying any or all such patent rights.</p>
<p>ISO/IEC TR 24772-10, was prepared by Joint Technical Committee ISO/IEC JTC 1, <em>Information technology</em>, Subcommittee SC 22, <em>Programming languages, their environments and system software interfaces</em>.</p>
<h1 id="introduction">Introduction</h1>
<div data-custom-style="zzHelp">
<p>This Technical Report provides guidance for the programming language C++, so that application developers using or considering C++ will be better able to avoid the programming constructs that lead to vulnerabilities in software written in the C++ language and their attendant consequences. This guidance can also be used by developers to select source code evaluation tools that can discover and eliminate some constructs that could lead to vulnerabilities in their software. This report can also be used in comparison with companion Technical Reports and with the language-independent report, TR 24772–1, to select a programming language that provides the appropriate level of confidence that anticipated problems can be avoided.</p>
</div>
<div data-custom-style="zzHelp">
<p>This technical report part is intended to be used with TR 24772–1, which discusses programming language vulnerabilities in a language independent fashion. It is also intended to be used with TR 24772-3, which discusses how the vulnerabilities introduced in TR 24772-1 are manifested in C, which is a subset of C++.</p>
</div>
<p>It should be noted that this Technical Report is inherently incomplete. It is not possible to provide a complete list of programming language vulnerabilities because new weaknesses are discovered continually. Any such report can only describe those that have been found, characterized, and determined to have sufficient probability and consequence.</p>
<div data-custom-style="Bibliography1">
<p><strong>Information Technology — Programming Languages — Guidance to avoiding vulnerabilities in programming languages — Vulnerability descriptions for the programming language C++</strong></p>
</div>
<h1 id="scope">1. Scope</h1>
<p>This Technical Report specifies software programming language vulnerabilities to be avoided in the development of systems where assured behaviour is required for security, safety, mission-critical and business-critical software. In general, this guidance is applicable to the software developed, reviewed, or maintained for any application.</p>
<p>Vulnerabilities described in this Technical Report document the way that the vulnerability described in the language-independent TR 24772–1 are manifested in C++.</p>
<h1 id="normative-references">2. Normative references</h1>
<p>The following referenced documents are indispensable for the application of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.</p>
<p>ISO/IEC 14882:2014 — <em>Programming Languages—C</em> ++</p>
<p>ISO/IEC TR24772–3 -- Information Technology — Programming Languages — Guidance to avoiding vulnerabilities in programming languages — Vulnerability descriptions for the programming language C</p>
<h1 id="terms-and-definitions-symbols-and-conventions">3. Terms and definitions, symbols and conventions</h1>
<h2 id="terms-and-definitions">3.1 Terms and definitions</h2>
<!-- TODO: needs formatting adjustment as of ISO word template document -->
<p>For the purposes of this document, the terms and definitions given in ISO/IEC 2382, in TR 24772–1, in 14882:2014 and the following apply. Other terms are defined where they appear in <em>italic</em> type.</p>
<p>The following terms are in alphabetical order, with general topics referencing the relevant specific terms.</p>
<p><u>3.1.1</u></p>
<p><u>TBD</u></p>
<p><u>3.1.2</u></p>
<p><u>access</u>:</p>
<p>An execution-time action, to read or modify the value of an object.</p>
<blockquote>
<p>Note 1: Where only one of two actions is meant, read or modify. Modify includes the case where the new value being stored is the same as the previous value. Expressions that are not evaluated do not access objects</p>
</blockquote>
<p><strong><u>3.1.3</u></strong></p>
<p>access protection</p>
<p><strong><u>alignment</u></strong><br />
requirement that objects of a particular type be located on storage boundaries with addresses that are particular multiples of a byte address.</p>
<p><strong><u>3.1.3</u></strong></p>
<p><strong><u>argument</u></strong><br />
the expression in the comma-separated list bounded by the parentheses in a function call expression, or a sequence of preprocessing tokens in the comma-separated list bounded by the parentheses in a function-like macro invocation</p>
<blockquote>
<p>Note 1: Also called actual argument</p>
<p>Note 2: An argument replaces a <em>formal parameter</em> as the call is realized.</p>
</blockquote>
<p><strong><u>3.1.4</u></strong></p>
<p><strong><u>behaviour</u></strong><br />
an external appearance or action</p>
<blockquote>
<p>Note 3: See: implementation-defined behavior, locale-specific behavior, undefined behavior, unspecified behaviour</p>
</blockquote>
<p><strong><u>3.1.5</u></strong></p>
<p><strong><u>bit</u></strong><br />
the unit of data storage in the execution environment large enough to hold an object that may have one of two values</p>
<p>Note: It need not be possible to express the address of each individual bit of an object.</p>
<p><strong><u>3.1.6</u></strong></p>
<p><strong><u>byte</u></strong><br />
the addressable unit of data storage large enough to hold any member of the basic character set of the execution environment</p>
<blockquote>
<p>Note: It is possible to express the address of each individual byte of an object uniquely. A byte is composed of a contiguous sequence of bits, the number of which is implementation-defined. The least significant bit is called the low-order bit; the most significant bit is called the high-order bit.</p>
</blockquote>
<p><strong><u>3.1.7</u></strong></p>
<p><strong><u>character</u></strong><br />
abstract member of a set of elements used for the organization, control, or representation of data</p>
<blockquote>
<p>Note: See: single-byte character, multibyte character, wide character</p>
</blockquote>
<p><strong><u>correctly rounded result</u></strong><br />
representation in the result format that is nearest in value, subject to the current rounding mode, to what the result would be given unlimited range and precision.</p>
<p>3.1.8</p>
<p><strong><u>class</u></strong><br />
<u>TBD</u></p>
<p><strong><u>3.1.9</u></strong></p>
<p><strong><u>concrete</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.10</u></strong></p>
<p><strong><u>diagnostic message</u></strong><br />
</p>
<p>message belonging to an implementation-defined subset of the implementation’s message output</p>
<p>Note: The C Standard requires diagnostic messages for all constraint violations.</p>
<p><strong>[3.1.11]</strong>{.ul}**<br />
</p>
<p><strong><u>dynamic dispatch</u></strong><br />
</p>
<p><u>TBD</u></p>
<p>3.1.12</p>
<p><strong><u>encapsulation</u></strong><br />
</p>
<p><u>TBD</u></p>
<p><strong><u>3.1.13</u></strong><br />
</p>
<p><strong><u>formal parameter</u></strong><br />
</p>
<p>object declared as part of a function declaration or definition that acquires a value on entry to the function, or an identifier from the comma-separated list bounded by the parentheses immediately following the macro name in a function-like macro definition.</p>
<p><strong>[3.1.14] hidden friends</strong><br />
</p>
<p>an available function or object that can only be accessed … (needs completion)</p>
<p>Note: explain the difference between C++ “hidden friends” “[hidden.friends] in the C++ standard” and the usage in this document.</p>
<p><strong><u>3.1.14</u></strong><br />
</p>
<p><strong><u>Implementation</u></strong><br />
</p>
<p>particular set of software, running in a particular translation environment under particular control options, that performs translation of programs for, and supports execution of functions in, a particular execution environment.</p>
<p><strong><u>3.1.15</u></strong><br />
</p>
<p><strong><u>implementation-defined behaviour</u></strong><br />
</p>
<p>unspecified behaviour where each implementation documents how the choice is made</p>
<p>Note: An example of implementation-defined behaviour is the propagation of the high-order bit when a signed integer is shifted right.</p>
<p><strong><u>3.1.16</u></strong><br />
</p>
<p><strong><u>implementation-defined value</u></strong><br />
</p>
<p>unspecified value where each implementation documents how the choice for the value is selected.</p>
<p><strong><u>3.1.17</u></strong><br />
</p>
<p><strong><u>implementation limit</u></strong><br />
</p>
<p>restriction imposed upon programs by the implementation.</p>
<p><strong><u>3.1.18</u></strong><br />
</p>
<p><strong><u>indeterminate value</u></strong><br />
</p>
<p>unspecified value or a trap representation.</p>
<p><strong><u>3.1.19</u></strong><br />
</p>
<p><strong><u>Inheritance</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.20</u></strong><br />
</p>
<p><strong><u>language type</u></strong><br />
</p>
<p>see block-structured language, comb-structured language (Non-responsive)</p>
<p><strong><u>3.1.21</u></strong><br />
</p>
<p><strong><u>locale-specific behaviour</u></strong><br />
</p>
<p>behaviour that depends on local conventions of nationality, culture, and language that each implementation documents</p>
<p>Note: An example, locale-specific behaviour is whether the islower() function returns true for characters other than the 26 lower case Latin letters.</p>
<p><strong><u>3.1.22</u></strong><br />
</p>
<p><strong><u>memory location</u></strong><br />
</p>
<p>an object of scalar[^1] type, or a maximal sequence of adjacent bit-fields all having nonzero width (Non-responsive)</p>
<blockquote>
<p>Note: A bit-field and an adjacent non-bit-field member are in separate memory locations. The same applies to two bit-fields, if one is declared inside a nested structure declaration and the other is not, or if the two are separated by a zero-length bit-field declaration, or if they are separated by a non-bit-field member declaration. It is not safe to concurrently update two bit-fields in the same structure if all members declared between them are also bit-fields, no matter what the sizes of those intervening bit-fields happen to be. For example a structure declared as</p>
</blockquote>
<p>struct {</p>
<p>char a;</p>
<p>int b:5, c:11, :0, d:8;</p>
<p>struct { int ee:8; } e;</p>
<p>}</p>
<p>contains four separate memory locations: The member a, and bit-fields d and e.ee are separate memory locations, and can be modified concurrently without interfering with each other. The bit-fields b and c together constitute the fourth memory location. The bit-fields b and c can’t be concurrently modified, but b and a, can be concurrently modified.</p>
<p><strong><u>3.23</u></strong><br />
</p>
<p><strong><u>multibyte character</u></strong><br />
</p>
<p>sequence of one or more bytes representing a member of the extended character set of either the source or the execution environment.</p>
<p>Note: The extended character set is a superset of the basic character set.</p>
<p><strong><u>3.1.24</u></strong><br />
</p>
<p><strong><u>namespace</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.25</u></strong><br />
</p>
<p><strong><u>object</u></strong><br />
</p>
<p>region of data storage in the execution environment, the contents of which can represent values</p>
<p>Note: When referenced, an object may be interpreted as having a particular type.</p>
<p><strong><u>3.1.26</u></strong><br />
</p>
<p><strong><u>overload</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.27</u></strong><br />
</p>
<p><strong><u>override</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.28</u></strong><br />
</p>
<p><strong><u>parameter</u></strong><br />
</p>
<p>(rewrite) See actual argument, argument, formal parameter (Non-responsive, needs definition)</p>
<p><strong><u>3.1.29</u></strong><br />
</p>
<p><strong>{Protected]{.ul}</strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.30</u></strong><br />
</p>
<p><strong><u>private</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.31</u></strong><br />
</p>
<p><strong><u>Public</u></strong><br />
</p>
<p>TBD</p>
<p>3.1.32</p>
<p>Pure</p>
<p><u>TBD</u></p>
<p><strong><u>3.1.33</u></strong><br />
</p>
<p><strong><u>recommended practice</u></strong><br />
</p>
<p>specification that is strongly recommended as being in keeping with the intent of the language standard, but that may be impractical for some implementations</p>
<p>**<u>3.1.34</u>((<br />
</p>
<p><strong><u>runtime-constraint</u></strong><br />
</p>
<p>requirement on a program when calling a library function</p>
<p><strong><u>3.1.35</u></strong><br />
</p>
<p><strong><u>single-byte character</u></strong><br />
</p>
<p>bit representation that fits in a byte (binary representation?)</p>
<p><strong><u>3.1.36</u></strong><br />
</p>
<p><strong><u>static</u></strong><br />
</p>
<p><u>TBD</u></p>
<p>**<u>3.1.37</u></p>
<p><strong><u>STL</u></strong><br />
</p>
<p><u>TBD</u></p>
<p><strong><u>3.1.38</u></strong><br />
</p>
<p><strong><u>standard library</u></strong><br />
</p>
<p>[TBD]</p>
<p><strong><u>3.1.39</u></strong><br />
</p>
<p><strong><u>template</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.40</u></strong><br />
</p>
<p><strong><u>trap representation</u></strong><br />
</p>
<p>object representation that need not represent a value of the object type</p>
<p><strong><u>3.1.41</u></strong><br />
</p>
<p><strong><u>undefined behaviour</u></strong><br />
</p>
<p>use of a non-portable or erroneous program construct or of erroneous data, for which the language standard imposes no requirements</p>
<blockquote>
<p>Note: Undefined behaviour ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message). An example of, undefined behaviour is the behaviour on integer overflow.</p>
</blockquote>
<p><strong><u>3.1.42</u></strong><br />
</p>
<p><strong><u>unspecified behaviour</u></strong><br />
</p>
<p>use of an unspecified value, or other behaviour where the language standard provides two or more possibilities and imposes no further requirements on which is chosen in any instance</p>
<blockquote>
<p>Note: For example, unspecified behaviour is the order in which the arguments to a function are evaluated.</p>
</blockquote>
<p><strong><u>3.1.43</u></strong><br />
</p>
<p><strong><u>unspecified value</u></strong><br />
</p>
<p>valid value of the relevant type where the language standard imposes no requirements on which value is chosen in any instance</p>
<blockquote>
<p>Note: An unspecified value cannot be a trap representation.</p>
</blockquote>
<p><strong><u>3.1.44</u></strong><br />
</p>
<p><strong><u>value</u></strong><br />
</p>
<p>precise meaning of the contents of an object when interpreted as having a specific type (specific type or specified type?)</p>
<blockquote>
<p>Note: See implementation-defined value, indeterminate value, unspecified value, trap representation</p>
</blockquote>
<p><strong><u>3.1.45</u></strong><br />
</p>
<p><strong><u>virtual</u></strong><br />
</p>
<p><u>TBD</u></p>
<p><strong><u>3.1.45</u></strong><br />
</p>
<p><strong><u>wide character</u></strong><br />
</p>
<p>bit representation capable of representing any character in the current locale</p>
<p><span data-custom-style="annotation reference"></span></p>
<h1 id="language-concepts">4. Language concepts</h1>
<p><u><em>This clause requires a rewrite. See C++ Core Guidelines CPL for a good explanation of the differences</em>.</u></p>
<p>C++ is a strongly- and statically-typed language: all variables and expressions must have a type. C++ also permits implicit and explicit conversions between types.</p>
<p>C++ has a rich type system with many nuances. In addition to the C base types (int, long, float, double, char, and arrays with their C-style vulnerabilities), C++ provides the following:</p>
<ul>
<li><pre><code>Distinct types for char, signed char, unsigned char</code></pre></li>
<li><pre><code>bool with a true Boolean context</code></pre></li>
<li><pre><code>enum with fixed underlying type</code></pre></li>
<li><pre><code>Classes as the primary user-defined types</code></pre></li>
<li><pre><code>Arrays</code></pre></li>
<li><pre><code>References in addition to pointers</code></pre></li>
<li><pre><code>Parameterized types</code></pre></li>
</ul>
<p>Many vulnerabilities can be mitigated more easily by using library facilities rather than the base language types. (e.g. std::string rather than char*)</p>
<ul>
<li><pre><code>Use of the `explicit`{.cpp} keyword for constructors and conversion
operators</code></pre></li>
<li><pre><code>`operator bool()`{.cpp} discussion</code></pre></li>
<li><pre><code>many built-in implicit conversions, refer to TR 24772-3 clause 6.2
and other clauses (C)</code></pre></li>
<li><pre><code>conversion to bool and null pointer conversions</code></pre></li>
<li><pre><code>legacy code operator void\* - change to explicit operator bool</code></pre></li>
<li><pre><code>C-style casts break type safety.</code></pre></li>
<li><pre><code>static_cast</code></pre></li>
<li><pre><code>explicit casts highlight mismatches between the design and
implementation.</code></pre></li>
<li><pre><code>const and volatile</code></pre></li>
<li><pre><code>constexpr -- needs a writeup -- (in C++:11 , encouraged heavy stack
use and possible exhaustion).</code></pre></li>
</ul>
<p>Narrowly tailored number-like class types, such as time_point and duration, improve safety by providing only safe and appropriate operations. User-defined types tailored to a particular use case can provide additional safety.</p>
<p>C++ was initially defined as a syntactic superset of the C programming language: adding object oriented features such as classes, encapsulation, dynamic dispatch, namespaces and templates. It was a “syntactic superset” because whilst there is a core of C++ that is syntactically identical to C, it has always been the case that there are subtle semantic differences between the two, for example:</p>
<ul>
<li><p>Historically, C permitted the use of a function before its declaration (though this is now deprecated in C) . This is illegal in C++</p></li>
<li><p>Where a struct is defined within another struct, in C the inner declaration is in effect made at file scope, so the definition is available for use later in the program. In C++, the inner declaration name is qualified by that of the parent, so without qualification, the inner struct cannot be used later in the program, as in the following example</p></li>
</ul>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S1 {</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">struct</span> S2 {...} m1;</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>   ...</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S2 v1; /\* legal in C <span class="kw">not</span> C++ \*/</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>S1::S2 v2 <span class="co">// legal in C++ not C</span></span></code></pre></div>
<p>Subsequently, the two languages have diverged, both adding features not present in the other. Not withstanding that, there is still a significant syntactic and semantic overlap between C and C++, so the starting point for this report has been the equivalent for C. However, in many cases, the additional features of C++ provide mechanisms for avoiding the vulnerabilities inherited from C, and these are reflected in the following sections.</p>
<p><em>Include discussions of Object orientation, <strong>static</strong>, and <strong>const,</strong> scoped enumerations</em></p>
<!-- parts added -->
<p>4.1 Overview 4.2 Type system implicit conversions templates? 4.3 Symbol Lookup and resolution special members templates? 4.4 Lifetime initialization 4.4 Error handling (includes exceptions and undefined behaviour(?)) abstract machine standard library 4.5 Concurrency</p>
<p>$include parts/4.1.Lifetime.md $include parts/4.2.SymbolLookupResolution.md $include parts/4.3.Concurency.md</p>
<p>4.2 Type system A particular area that is misunderstood is integral promotion. It can be confusing because promotion can result in changing the internal representation of an unsigned type to/from a signed type. For expressions formed with operands of unscoped enumeration type or integral types with a conversion rank smaller. than <code class="sourceCode cpp"><span class="dt">int</span></code>, <em>integral promotion</em> occurs before further implicit conversions happen. <em>Integral promotion</em> on unsigned types can convert these to the signed type <code class="sourceCode cpp"><span class="dt">int</span></code>. Undefined behavior can occur due to signed integer arithmetic overflow even when the operands are of an unsigned type. Assume for example, - signed and unsigned short occupies 16 bits - signed and unsigned int occupies 32 bits then the following code causes undefined behavior:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">unsigned</span> <span class="dt">short</span> <span class="at">const</span> x = <span class="bn">0xfff0</span>;</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>   x * x;                           <span class="co">// signed integer overflow, result will not fit in signed 32 bit int</span></span></code></pre></div>
<p>Note: C++ also uses the term promotion to apply to a subset of conversion that apply to intergral and floating point types.</p>
<p>Implicit, i.e., automatic, conversions to a type <code>T</code> can be performed, for example, in the following situations:</p>
<ol type="a">
<li><p>If the declaration, <code class="sourceCode cpp">T t=e;</code>, is defined for some expression, <code>e</code>, and some invented variable, <code>t</code> [C++17, Clause 7 [conv], para 3];</p></li>
<li><p>In expressions involving operands of operators (e.g., <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, etc.) subject to the requirements of each operators' operands [C++20, Clause 7.3 [conv], para 2.1];</p></li>
<li><p>For example, the expression, <code>5 + 6.5</code>, has operands of type <code class="sourceCode cpp"><span class="dt">int</span></code> and <code class="sourceCode cpp"><span class="dt">double</span></code>. Per language rules, the integer operand will be implicitly converted to <code class="sourceCode cpp"><span class="dt">double</span></code>, i.e., the expression becomes <code class="sourceCode cpp"><span class="dt">double</span>(<span class="dv">5</span>) + <span class="fl">6.5</span></code>, i.e., <code>5.0 + 6.5</code>.</p></li>
<li><p>In boolean contexts, such as</p>
<ul>
<li>operands of logical operators,</li>
<li>the condition of the conditional operator, and</li>
<li>the condition of the if-statement or loop-statements, contextual conversion to bool implicitly happens from arithmetic types, pointers, and classes with a possibly explicit <code>operator bool()</code>. [C++17, Clause 7 [conv], para 4];</li>
</ul></li>
<li><p>In the expression of a switch statement: the implicit conversion will be to an integral type [C++17, Clause 7 [conv], para 2.3];</p></li>
<li><p>In an expression that initializes an object (e.g., an argument to a function call, the expression in a return statement) [C++17, Clause 7 [conv], para 2.4];</p></li>
<li><p>When a non-<code class="sourceCode cpp"><span class="kw">explicit</span></code> class/struct/union constructor can be invoked on an object resulting in some desired type, <code>T</code>, from initial objects passed to the constructor; and</p></li>
<li><p>When a conversion operator has not been declared <code class="sourceCode cpp"><span class="kw">explicit</span></code>, it can be implicitly invoked on an object resulting in some desired type, <code>T</code>, from an initial type.</p></li>
</ol>
<h1 id="avoiding-programming-language-vulnerabilities-in-c">5. Avoiding programming language vulnerabilities in C++</h1>
<blockquote>
<p>In addition to the generic programming rules from ISO/IECTR 24772-1 clause 5.4, additional rules from this section apply specifically to the C++ programming language. The recommendations of this section are restatements of recommendations from clause 6, but represent ones stated frequently, or that are considered as particularly noteworthy by the authors. Clause 6 of this document contains the full set of recommendations, as well as explanations of the problems that led to the recommendations made.</p>
</blockquote>
<blockquote>
<p>Every guidance provided in this section, and in the corresponding Part section, is supported by material in Clause 6 of this document, as well as other important recommendations.</p>
</blockquote>
<blockquote>
<p><strong><em>TBD</em></strong></p>
</blockquote>
<table style="width:94%;">
<colgroup>
<col style="width: 44%" />
<col style="width: 5%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th>Index</th>
<th></th>
<th>Reference[]{custom- style=“annotation reference”}</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>2</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>3</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>4</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>5</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>6</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Need to consider C++-11, 14 and 17.</p>
<h1 id="specific-guidance-for-c-vulnerabilities">6. Specific Guidance for C++ Vulnerabilities</h1>
<h2 id="general">6.1 General</h2>
<p>This clause contains specific advice for C++ about the possible presence of vulnerabilities as described in TR 24772-1, and provides specific guidance on how to avoid them in C++ code. This section mirrors TR 24772-1 clause 6 in that the vulnerability “Type System [IHN]” is found in 6.2 of TR 24772–1, and C++ specific guidance is found in clause 6.2 and subclauses in this TR.</p>
<p>As part of its design (and with few exceptions), C++ has a common subset with the complete C language. For code portions written in the common subset, the vulnerabilities described and the advice given in ISO/IEC TR 24772-3:2020, <em>Part 3 – Vulnerability descriptions for the programming language C</em>, apply, except when this document provides refined advice. The following subclauses usually do not further acknowledge the issues from the subset since those have been adequately addressed in the referenced document. However, C++ provides mechanisms to mitigate many of the problems that arise. Please refer to the respective clauses of this document for these mitigations and related guidelines.</p>
<h2 id="IHN">6.2 Type System [IHN]</h2>
<h3 id="applicability-to-language">6.2.1 Applicability to language</h3>
<p>C++ is a statically typed language. In some ways, C++ is both strongly and weakly typed, as it requires all objects/expressions to have a type, but allows for some implicit conversions of values from one type to another type. The following cases require special consideration:</p>
<ul>
<li><p>Most notably are the implicit conversions between arithmetic types (including <code class="sourceCode cpp"><span class="dt">bool</span></code>) that silently might truncate values or have loss of precision (for details see <a href="#FLC">Conversion Errors [FLC]</a>). This shared vulnerability includes <em>integral promotion</em> from small (unsigned) integer types (e.g. <code class="sourceCode cpp"><span class="dt">unsigned</span> <span class="dt">char</span></code>) to the signed integer type <code class="sourceCode cpp"><span class="dt">int</span></code> that can lead to operations with undefined behavior, where unsigned arithmetic is defined with modulo semantics.</p></li>
<li><p>C++ considers implicit conversions during function overload resolution, when there is not a direct match of argument type with parameter type. Sometimes such conversions lead to ambiguities, which result in a compile error. But there can also be a single best matching overload that does not correspond to developer’s expectation including conversion of argument types (see <a href="#YOW">Identifier Name Reuse [YOW]</a>)</p></li>
<li><p>Values of an unscoped enumeration convert to their underlying integral type in arithmetic expressions (see <a href="#CCB">Enumerator Issues [CCB]</a>).</p></li>
<li><p>Built-in array types as well as function types will decay to a pointer type. For array types this is problematic, because the array’s extent is lost.</p></li>
<li><p>Pointer and reference types referring a derived class object can implicitly convert to a pointer or reference to one of its public base classes respectively (see <a href="#BKK">Polymorphic Variables [BKK]</a>).</p></li>
<li><p>User-defined class types can define converting constructors, that can be called with a single argument, or conversion operators. If these member functions are not declared with the keyword <code class="sourceCode cpp"><span class="kw">explicit</span></code> they are eligible for use in implicit conversions.</p></li>
<li><p>Boolean contexts are a special case, because in addition to arithmetic types all pointer types implicitly convert to <code>bool</code>. In such contexts even an <code class="sourceCode cpp"><span class="kw">explicit</span> <span class="kw">operator</span> <span class="dt">bool</span>()</code> conversion operator is used. The latter conversions (pointer and explicit conversion operator) are desirable, the conversions from an arithmetic type in boolean contexts often indicate a missing comparison.</p></li>
</ul>
<p>Note that type aliases (<code class="sourceCode cpp"><span class="kw">using</span></code>, <code class="sourceCode cpp"><span class="kw">typedef</span></code>) do not define a different type from their alias just a different name and thus do not incur any conversion between the alias and the aliased type.</p>
<p>Instead of using the built-in arithmetic types or generic library types such as <code class="sourceCode cpp"><span class="bu">std::</span>string</code> for your domain values, C++ allows to wrap them in user-defined-class types as so-called <em>strong types</em>. <em>Strong types</em> provide only those operator overloads and conversions for each such type that make sense in the application domain. User-defined-literal operators help with providing constants of appropriate <em>strong types</em>. Such <em>strong types</em> provide full control of conversions and operations available, avoiding semantically unsound operations that the built-in or other generic types might provide.</p>
<h3 id="guidance-to-language-users">6.2.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance contained in ISO/IEC TR 24772-1:2019, 6.2.5. and the guidance provided in the different related sections of this document.</p></li>
<li><p>Be aware of the rules of the type system, overload resolution, and implicit conversions to avoid vulnerabilities.</p></li>
<li><p>Enable compiler warnings regarding implicit conversions and/or use static analysis tools that provide such warnings.</p></li>
<li><p>Define any constructor of a class that can be called with a single argument of a different type as <code class="sourceCode cpp"><span class="kw">explicit</span></code>.</p></li>
<li><p>Define any conversion operator as <code class="sourceCode cpp"><span class="kw">explicit</span></code></p></li>
<li><p>Use <em>strong types</em> for domain values instead of the built-in types except on system boundaries, e.g., output and input.</p></li>
<li><p>When defining variables of arithmetic type, use a braced-initializer to prevent a potential narrowing conversion from the initial value’s type.</p></li>
</ul>
<h2 id="bit-representations-str">6.3 Bit Representations [STR]</h2>
<h3 id="applicability-to-language">6.3.1 Applicability to language</h3>
<p>This vulnerabilities described in TR24772-1 clause 6.3 is applicable to C++.</p>
<pre><code>&lt;!--
Document the C++ behaviours- handling bit-fields, - hitting enclosing
word, concurrent access, hardware implications,
--&gt;</code></pre>
<p>Able to use non-integer types (such as enumerations) in accessing bit fields.</p>
<p>A C++ memory location is either an object is or a contiguous collection of bit-fields.</p>
<p>C++ bit fields are not separated from adjacent bit-fields for purposes of thread synchronization or volatility. Bit-fields are very difficult to use correctly in these contexts.</p>
<pre><code>&lt;!--
TO-DO -- Bit_Cast - Applies a bit representation to an object of a new
type, for example copy a 64 bit IEEE 654 number to a 64 bit integer to
perform bit operations and then cast back.
--&gt;</code></pre>
<pre><code>&lt;!--
Needs documentation.
--&gt;</code></pre>
<pre><code>&lt;!--
Issue was raised about padding bits between object/struct/union members
can leak information. Where to put this? Mitigation -- use member copy
instead of byte-wise copy.
--&gt;</code></pre>
<p>When a struct, union or class is embedded within an array, implementations will typically add padding to provide efficient alignment and access. Therefore, the compiler will add padding bytes in case it is used in arrays. The padding bytes can be used as a <em>secret channel</em> to hide information and extract it later.</p>
<h3 id="guidance-to-language-users">6.3.2 Guidance to language users</h3>
<p>In addition to the advice of ISO/IEC TR 24772-3:2020 clause 6.3.2:</p>
<p>See C++ Core Guidelines ES101 use unsigned types for bit manipulation.</p>
<p>CERT INT34-C</p>
<ul>
<li><p>Do not use <code class="sourceCode cpp"><span class="bu">std::</span>vector&lt;<span class="dt">bool</span>&gt;</code></p></li>
<li><p>Use bit-fields with care or avoid them entirely. Instead, use a class type containing one or more unsigned integer data members and member functions appropriate to the particular situation.</p></li>
<li><p>Do not create a bit-field of a signed type and size one.</p></li>
</ul>
<p>See AUTOSAR A9-6-1</p>
<ul>
<li><p>Avoid using <code>bit_cast</code> or heavily analyse and document its use.</p></li>
<li><p>Prefer performing member-by-member copies and moves instead of using <code>std::memcpy</code> or <code>std::memmove</code></p></li>
<li><p>Cover known padding with named members to eliminate padding. This can be checked with a <code>static_assert(std::has_unique_object_representations_v&lt;T&gt;)</code>. If this assertion is true then there are no padding bits.</p></li>
</ul>
<p>CERT EXP62-CPP</p>
<h2 id="floating-point-arithmetic-plf">6.4 Floating-point Arithmetic [PLF]</h2>
<h3 id="applicability-to-language">6.4.1 Applicability to language</h3>
<p>C++ has the vulnerability as described in ISO/IEC TR 24772-1 clause 6.4. The C++ standard assumes IEC 60559 if <code class="sourceCode cpp"><span class="bu">std::</span>numeric_limits<span class="bu">\</span>&lt;T&gt;::is_iec559</code> is true for the types in use. In the absence of this, C++ makes few guarantees about the behaviour of floating point numbers.</p>
<p>Sorting floating point numbers with the built-in operators violates the preconditions of sorting predicates in the presence of NaN values and may raise floating point errors. The default sorting predicate <code>std::less</code> is suspect to this precondition violation, resulting in undefined behavior when sorting a range of floating point values that contains NaNs.</p>
<h3 id="guidance-to-language-users">6.4.2 Guidance to language users</h3>
<ul>
<li><p>Follow the general advice of ISO/IEC TR 24772-1:2019 clause 6.4.5</p></li>
<li><p>Verify compliance to ISO/IEC/IEEE 60559:2011 at compile time through <code class="sourceCode cpp"><span class="bu">std::</span>numeric_limits&lt;T&gt;::is_iec559</code>. Other numeric characteristics such as <code>min()</code>, <code>max()</code>, existence of NaNs, <code>has_denorm</code>, and infinities can be determined in this class template.</p></li>
<li><p>Be aware that the default comparisons in the standard library may produce wrong results when used on floating point members. In particular <code class="sourceCode cpp"><span class="bu">std::</span>less</code> is not a total order; <code class="sourceCode cpp"><span class="bu">std::</span>equal</code> is not equivalent to substitutability (NaNs compare unequal to themselves, but neither less nor greater, and negative zero compares equal to positive zero).</p></li>
</ul>
<h2 id="CCB">6.5 Enumerator Issues [CCB]</h2>
<h3 id="applicability-to-language">6.5.1 Applicability to language</h3>
<h4 id="references">6.5.1.1 References</h4>
<p>AUTOSAR A7-2-2 Enumeration base type shall be explicitly defined</p>
<h4 id="applicability">6.5.1.2 Applicability</h4>
<p>C++ offers enums for defining distinct types composed of sets of related named constants. The type of each enum is different from all other types. Each enum has an underlying integral type, which the user can specify. Since enums are distinct types, the user can only assign values to an object of enumerated type that are values of that enumerated type. C++ does not support implicit conversion of an int to an enum, therefore preventing <code>A = B + C</code> where <code>A</code>, <code>B</code> and <code>C</code> are variables of the same enum, unless an overloaded operator “<code>+</code>” is provided.</p>
<p>C++ enums can be scoped (<code>enum class</code>) or unscoped (<code>enum</code>). C++ supports implicit conversion of an unscoped enum to an integer by integral promotion</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Color : <span class="dt">short</span> {red, green, blue};</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="dt">short</span> i = red; <span class="co">// implicit conversion</span></span></code></pre></div>
<p>C++ does not support implicit conversion of a scoped enum to an int. Hence, operations such as <code>++</code>, <code>+</code>, <code>&lt;</code> and enums used as array indices require explicit definitions.</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> Color : <span class="dt">short</span> {red, green, blue};</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="dt">short</span> i = red; <span class="co">// error -- no implicit conversion</span></span></code></pre></div>
<p>Where unscoped enums are used as array indexes and do not have a user-specified mapping to an underlying representation, there will be “holes” as documented in TR24772-1 clause 6.6.</p>
<p>Note that unscoped enumeration types implicitly promote their underlying type and can be used as the index of an array without a cast, with all of the issues described in TR 24772-1 clause 6.5.</p>
<p>From C++ 2017 forward, casting a value to an enumeration type is undefined behavior unless the source value is within the range of values of an enumeration type. See CERT INT50-CPP.</p>
<h3 id="guidance-to-language-users">6.5.2 Guidance to language users</h3>
<ul>
<li><p>Use <em>scoped enumerations</em> in preference to the C-style <em>unscoped enumerations</em> for related values, especially at namespace-level.</p>
<ul>
<li><pre><code>  See CPP Core Guidelines Enum.3 &quot;Prefer class enums over &#39;plain&#39;</code></pre>
<p>enums".</p></li>
<li><pre><code>  See AUTOSAR A7-2-3 &quot;Enumerations shall be declared as scoped</code></pre>
<p>enum classes"</p></li>
<li><pre><code>  See MISRA C++ 28.5.5</code></pre></li>
</ul></li>
<li><p>Use <code class="sourceCode cpp"><span class="kw">constexpr</span></code> to declare a set of unrelated values, such as <code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">size_t</span> bufferLen = <span class="dv">128</span>;</code> <code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">char</span> special_char = <span class="ch">&#39;a&#39;</span>;</code></p></li>
<li><p>Provide operators and functions that perform the arithmetic operations and conversions appropriate to the enumerated type. Outside those functions, avoid directly performing arithmetic or conversions on objects of the enumerated type.</p>
<ul>
<li><pre><code>  See CPP Core Guidelines Enum.4 &quot;Define operations on</code></pre>
enumerations for safe and simple use"</li>
</ul></li>
<li><p>If <em>unscoped enumerations</em> are used, follow the general advice of TR 24772-3 clause 6.5.2 as well as the following:</p>
<ul>
<li><pre><code>  Avoid casting arbitrary integer values to enumeration type. If it is</code></pre>
<p>unavoidable, use braced initialization instead of C-style or static casts<br />
<code>e_type{7};</code></p>
<pre><code>  &gt; See CERT INT50-CPP &quot;Do no Cast to an out-of-range-value&quot;</code></pre></li>
</ul></li>
<li><pre><code>Obtain the underlying enumeration value, by casting the enumeration</code></pre>
<p>to its underlying type, e.g.,</p>
<blockquote>
<p><code class="sourceCode cpp"><span class="kw">enum</span> <span class="dt">e_type</span>{A, B, C};</code></p>
</blockquote>
<blockquote>
<p><code class="sourceCode cpp"><span class="kw">auto</span> value = <span class="kw">static_cast</span>\&lt;<span class="bu">std::</span>underlying_type_t<span class="bu">\</span>&lt;<span class="dt">e_type</span>\&gt;\&gt;(B);</code></p>
</blockquote></li>
</ul>
<h2 id="FLC">6.6 Conversion Errors [FLC]</h2>
<h3 id="applicability-to-language">6.6.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO IEC 24772-1 clause 6.6 applies to C++. C++ includes some of the conversion mechanisms of C documented in TR 24772-3 clause 6.6.1, however C++ type conversion mechanisms differ from the mechanisms of C, as documented in ISO IEC 14882 Annex C. This subclause highlights differences where C++ eliminates potential vulnerabilities found in C.</p>
<p>In C++, some conversions are explicit while others are implicit. Conversions can change the size of a type, whether or not the type is signed, and possibly other properties of the type. A narrowing conversion is when the target type cannot represent all the values of the original type. Many errors are associated with implicit conversions. For a comprehensive overview see clause 7.3 [conv] of [C++20]</p>
<p>Explicit conversions use one of the mechanisms provided by C++ through a</p>
<ul>
<li>type conversion operator
<ul>
<li><code class="sourceCode cpp"><span class="kw">static_cast</span></code>,</li>
<li><code class="sourceCode cpp"><span class="kw">const_cast</span></code>,</li>
<li><code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code>,</li>
<li><code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>),</li>
</ul></li>
<li>constructor notation with
<ul>
<li>parentheses (e.g., <code class="sourceCode cpp"><span class="dt">double</span>(<span class="dv">42</span>)</code>) or</li>
<li>braces (e.g., int{‘a’}) which prevents narrowing conversions, or</li>
</ul></li>
<li>a C-style cast (<code class="sourceCode cpp">(<span class="dt">int</span>)<span class="fl">3.14</span></code>).</li>
</ul>
<p>In C++, a C-style cast is defined in terms of the C++ cast operators <code class="sourceCode cpp"><span class="kw">const_cast</span></code>, <code class="sourceCode cpp"><span class="kw">static_cast</span></code>, and <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>. In some cases, it is unspecified which cast is used, for example when a cast operation involves an incomplete type, a <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> may be used for the conversion which can produce an incorrect result.</p>
<p>Unlike C++'s other cast notations, <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> relies on run-time type information generated by the compiler to ensure the requested conversion is valid. If it is not valid, then <code class="sourceCode cpp"><span class="kw">nullptr</span></code> is returned for pointer types, otherwise an exception is thrown. [C++17, Clause 8.2.7 [expr.dynamic.cast]] Thus, <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> is safer to use when converting down a hierarchy where the base class has virtual member functions. (see <a href="#HFC">Pointer Type Conversions [HFC]</a> and <a href="#BKK">Polymorphic Variables [BKK]</a>)</p>
<p>An implicit conversion to a class type can occur for a class with constructors that can be invoked with a single argument, as in the following example:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>      {<span class="kw">public</span>:</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>        C(<span class="dt">int</span> x=<span class="dv">10</span>, <span class="dt">float</span> y=<span class="dv">0</span>){...}</span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>      };</span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo(C param){...}</span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar( <span class="dt">bool</span> b){ foo(b);} </span></code></pre></div>
<p>In the example above, it can be surprising that foo() is called with a boolean.</p>
<p>Note that this implicit conversion to a class object is the default behavior of constructors that can be called with a single parameter. The <code class="sourceCode cpp"><span class="kw">explicit</span></code> keyword can be used before the constructor to prevent this happening, as in:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">explicit</span> C(<span class="dt">int</span> x=<span class="dv">10</span>, <span class="dt">float</span> y=<span class="dv">0</span>){...}</span></code></pre></div>
<p>The call <code class="sourceCode cpp">foo(b)</code> would now not be legal.</p>
<p>Implications of casting away <code class="sourceCode cpp"><span class="at">const</span></code> using <code>const_cast</code> are described in section <a href="#UJO">Modifying Constants [UJO]</a>.</p>
<p>Other implicit conversions can sometimes result in data loss or erroneous values. This is an issue with implicit conversions since they are automatic: the programmer does not explicitly write code to do the conversion. For example, a common problem is mixing signed and unsigned integral types in arithmetic expressions. This can become a problem since the ranges of signed and unsigned integer types differ and the behavior of signed integer arithmetic on overflow is undefined whereas unsigned integer arithmetic wraps on overflow.</p>
<p>Additional problems arise as a result of implicit conversions between <code>bool</code> and other types, thus hiding the fact when a wrong operator is used accidentally:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f(<span class="dt">unsigned</span> i, <span class="dt">unsigned</span> j)</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (i &gt; <span class="dv">1</span>) &amp; (j = <span class="dv">1</span>); <span class="co">// (&gt;&gt;, &amp;&amp;, ==) ?</span></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In the example above, all combinations of the corresponding operators will compile with different resulting types and results.</p>
<p>Similar issues arise in conversions between character types (char, char8_t, …) and other types. Character types are provided to represent text in whatever character representation is needed.</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f(<span class="dt">char</span> c)</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (c &lt; <span class="dv">0</span>) <span class="co">// may be always false on some platforms.</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>    {}</span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In addition to the use of <em>strong types</em> (see <a href="#IHN">Type System [IHN]</a>), the implicit conversions and multitude of possible operations of integral types can be mitigated by using scoped enumeration types with the corresponding integer type as its underlying type. For example, <code class="sourceCode cpp"><span class="bu">std::</span>byte</code> is defined to address individual <code class="sourceCode cpp"><span class="dt">unsigned</span> <span class="dt">char</span></code> elements (bytes) in memory without participating in arithmetic or bitwise operations.</p>
<p>Because C++ allows function and operator overloading, the effect of implicit conversions provides an additional mechanism of failure, by selecting an unwanted overload during overload resolution due to implicit conversions. This can influence failure modes with lookup as described in section <a href="#BJL">Namespace Issues [BJL]</a>. // Add overload resolution reference!!</p>
<p>A particular area that is misunderstood is integral promotion. It can be confusing because promotion can result in changing the internal representation of an unsigned type to/from a signed type. For expressions formed with operands of unscoped enumeration type or integral types with a conversion rank smaller. than <code class="sourceCode cpp"><span class="dt">int</span></code>, <em>integral promotion</em> occurs before further implicit conversions happen. <em>Integral promotion</em> on unsigned types can convert these to the signed type <code class="sourceCode cpp"><span class="dt">int</span></code>. Undefined behavior can occur due to signed integer arithmetic overflow even when the operands are of an unsigned type. Assume for example, - signed and unsigned short occupies 16 bits - signed and unsigned int occupies 32 bits then the following code causes undefined behavior:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">unsigned</span> <span class="dt">short</span> <span class="at">const</span> x = <span class="bn">0xfff0</span>;</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>   x * x;                           <span class="co">// signed integer overflow, result will not fit in signed 32 bit int</span></span></code></pre></div>
<p>Note: C++ also uses the term promotion to apply to a subset of conversion that apply to intergral and floating point types.</p>
<p>Implicit, i.e., automatic, conversions to a type <code>T</code> can be performed, for example, in the following situations:</p>
<ol type="a">
<li><p>If the declaration, <code class="sourceCode cpp">T t=e;</code>, is defined for some expression, <code>e</code>, and some invented variable, <code>t</code> [C++17, Clause 7 [conv], para 3];</p></li>
<li><p>In expressions involving operands of operators (e.g., <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, etc.) subject to the requirements of each operators' operands [C++20, Clause 7.3 [conv], para 2.1];</p></li>
<li><p>For example, the expression, <code>5 + 6.5</code>, has operands of type <code class="sourceCode cpp"><span class="dt">int</span></code> and <code class="sourceCode cpp"><span class="dt">double</span></code>. Per language rules, the integer operand will be implicitly converted to <code class="sourceCode cpp"><span class="dt">double</span></code>, i.e., the expression becomes <code class="sourceCode cpp"><span class="dt">double</span>(<span class="dv">5</span>) + <span class="fl">6.5</span></code>, i.e., <code>5.0 + 6.5</code>.</p></li>
<li><p>In boolean contexts, such as</p>
<ul>
<li>operands of logical operators,</li>
<li>the condition of the conditional operator, and</li>
<li>the condition of the if-statement or loop-statements, contextual conversion to bool implicitly happens from arithmetic types, pointers, and classes with a possibly explicit <code>operator bool()</code>. [C++17, Clause 7 [conv], para 4];</li>
</ul></li>
<li><p>In the expression of a switch statement: the implicit conversion will be to an integral type [C++17, Clause 7 [conv], para 2.3];</p></li>
<li><p>In an expression that initializes an object (e.g., an argument to a function call, the expression in a return statement) [C++17, Clause 7 [conv], para 2.4];</p></li>
<li><p>When a non-<code class="sourceCode cpp"><span class="kw">explicit</span></code> class/struct/union constructor can be invoked on an object resulting in some desired type, <code>T</code>, from initial objects passed to the constructor; and</p></li>
<li><p>When a conversion operator has not been declared <code class="sourceCode cpp"><span class="kw">explicit</span></code>, it can be implicitly invoked on an object resulting in some desired type, <code>T</code>, from an initial type.</p></li>
</ol>
<h3 id="guidance-to-language-users">6.6.2 Guidance to language users</h3>
<p>In addition to the general advice of ISO/IEC 24772-1 clause 6.6.5:</p>
<ul>
<li><p>Avoid casts (see C++ Core guidelines ES.48), treat every cast as a candidate for refactoring.</p></li>
<li><p>Avoid narrowing conversions. (see C++ Core Guidelines ES.46)</p></li>
<li><p>Prefer braces over parentheses for initialization or explicit conversions from numeric types to prevent narrowing. (see C++ Core Guidelines ES.23 and ES.64)</p></li>
<li><p>Avoid C-style casts. Use C++ type conversion operators instead, as they document intent and disallow some unsafe conversions. (see C++ Core Guidelines ES.49)</p></li>
<li><p>Declare <code class="sourceCode cpp"><span class="kw">explicit</span></code></p>
<ul>
<li>constructors callable with a single argument; and</li>
<li>conversion functions. (see C++ Core guidelines C.46 and C.164)</li>
</ul></li>
<li><p>Don’t cast away <code class="sourceCode cpp"><span class="at">const</span></code>. See subclause <a href="#UJO">Modifying Constants [UJO]</a><br />
(see C++ Core Guidelines ES.50)</p></li>
<li><p>Be aware of the size of the type(s) in which arithmetic for promoted types will be performed</p></li>
<li><p>Don’t mix signed and unsigned arithmetic (see C++ Core Guidelines ES100)</p></li>
<li><p>Don’t rely on implicit conversions between <code>bool</code> and other types.</p></li>
<li><p>Don’t rely on implicit conversions between character types and other types.</p></li>
<li><p>Use <em>strong types</em> (see subclause <a href="#IHN">Type System [IHN]</a>) to limit implicit conversions and unwanted operations.</p></li>
</ul>
<h2 id="string-termination-cjm">6.7 String Termination [CJM]</h2>
<h3 id="applicability-to-language">6.7.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IECTR 24772-1:2019 exists in C++ when C-style strings are used. C++ provides the library class templates <code class="sourceCode cpp"><span class="bu">std::</span>basic_stringview</code> and <code class="sourceCode cpp"><span class="bu">std::</span>span</code> that implment reference semantics to non-owned buffers. These classes do not include a string termination character and their use can result in this vulnerability. C++ provides alternative string processing capabilities that do not exhibit those vulnerabilities.</p>
<p>C++ provides a class template for string processing, <code class="sourceCode cpp"><span class="bu">std::</span>basic_string</code> that manages the space for the string and the string length and always includes a termination character. On concatenation, the string object will increase in size to contain the resulting string. The class <code class="sourceCode cpp"><span class="bu">std::</span>filesystem<span class="bu">::</span>path</code> also provides string processing capabilities among other facilities by wrapping <code class="sourceCode cpp"><span class="bu">std::</span>basic_string</code>.</p>
<p>Unlike C-style strings, the class templates <code class="sourceCode cpp"><span class="bu">std::</span>basic_string</code>, <code class="sourceCode cpp"><span class="bu">std::</span>basic_string_view</code>, and <code class="sourceCode cpp"><span class="bu">std::</span>span</code> permit embedded null characters to be used safely.</p>
<h3 id="guidance-to-language-users">6.7.2 Guidance to language users</h3>
<ul>
<li><p>Avoid C-style strings. Use <code class="sourceCode cpp"><span class="bu">std::</span>string</code> or corresponding instantiations of <code class="sourceCode cpp"><span class="bu">std::</span>basic_string</code> for the character type used.</p></li>
<li><p>If <code class="sourceCode cpp"><span class="bu">std::</span>basic_string</code> is not appropriate, provide your own encapsulation and perform the appropriate verifications.</p></li>
<li><p>If C-style strings are used, follow the guidance of ISO/IEC TR 24772-3 clause 6.7.2.</p></li>
<li><p>When calling interfaces that expect C-style strings as arguments, pass the result of a <code class="sourceCode cpp"><span class="bu">std::</span>string<span class="bu">::</span>c_str()</code> as an argument. Do not employ types that cannot guarantee the string termination.</p></li>
<li><p>When obtaining C-style strings via character pointers from interfaces, manage the string via a <code class="sourceCode cpp"><span class="bu">std::</span>string_view</code> only if lifetime and content of the underlying buffer is persistent, or store it in a <code class="sourceCode cpp"><span class="bu">std::</span>string</code> object otherwise.</p></li>
</ul>
<h2 id="buffer-boundary-violation-hcb">6.8 Buffer Boundary Violation [HCB]</h2>
<h3 id="applicability-to-language">6.8.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1 clause 6.8 exists in C++ when arrays are managed using raw pointers and indexing. To avoid the vulnerability, C++ provides facilities to encapsulate code that may suffer from this vulnerability. The standard library provides classes that mitigate or circumvent this vulnerability. For example, <code class="sourceCode cpp"><span class="bu">std::</span>string,</code> <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> and <code class="sourceCode cpp">iostreams</code> manage buffers internally using “range-for” such as for (auto I: <em>some container</em>) and the algorithm library to access elements of the container without the possibility of a buffer boundary violation.</p>
<p><del>A buffer boundary violation condition occurs when an array is indexed outside its bounds, or pointer arithmetic results in an access to storage that occurs outside the bounds of the object accessed. This behaviour may occur when copying, initializing, writing or reading.</del></p>
<p><del>In C++, the built-in subscript operator <code class="sourceCode cpp">\[\]</code> is defined such that <code class="sourceCode cpp">E1\[E2\]</code> is identical to <code class="sourceCode cpp">(\*((E1)+(E2))</code>), so that in either representation, the value in location (E1+E2) is returned. C++ does not perform bounds checking on arrays: arrays may be accessed outside of their bounds which is undefined behaviour. For example, in C++ the following code is syntactically valid, though, if offset has the value <code class="sourceCode cpp"><span class="dv">10</span></code>, the behaviour is undefined:</del></p>
<blockquote>
<p><del>int foo(const int offset) {</del></p>
<p><del>int t;</del></p>
<p><del>int x[] = {0,0,0,0,0};</del></p>
<p><del>t = x[offset];</del></p>
<p><del>return t;</del></p>
<p><del>}</del></p>
</blockquote>
<p><del>or, when written using iterators, the same issues can occur</del></p>
<blockquote>
<p><del>int foo(const int offset) {</del></p>
</blockquote>
<blockquote>
<p>~~ std::array&lt;int, 5&gt; a;~~</p>
</blockquote>
<blockquote>
<p>~~ return *(a.begin() + offset);~~</p>
</blockquote>
<p>Another way that overflows can occur is through the use of C-style strings, which can be treated as arrays of characters, but the nul termination can make overflows possible. See clause 6.7 String Termination.</p>
<p>For further explanation and examples, see</p>
<p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR50-CPP.+Guarantee+that+container+indices+and+iterators+are+within+the+valid+range"><span data-custom-style="Hyperlink">https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR50-CPP.+Guarantee+that+container+indices+and+iterators+are+within+the+valid+range</span></a></p>
<p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR53-CPP.+Use+valid+iterator+ranges"><span data-custom-style="Hyperlink">https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR53-CPP.+Use+valid+iterator+ranges</span></a></p>
<p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR55-CPP.+Do+not+use+an+additive+operator+on+an+iterator+if+the+result+would+overflow"><span data-custom-style="Hyperlink">https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR55-CPP.+Do+not+use+an+additive+operator+on+an+iterator+if+the+result+would+overflow</span></a></p>
<pre><code>&lt;!--
Note: Consider C++ Core guidelines if completed.
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.8.2 Guidance to language users</h3>
<ul>
<li><p>Avoid C-style arrays. Guidance for the use of C-style arrays is provided in TR 24772-3 clause 6.8.2.</p></li>
<li><p>Use a library class such as <code>std::array</code> to encapsulate an array, or write a class with similar behavior.</p></li>
<li><p>Use library classes such as <code>std::span</code> or <code>std::string_view</code> to represent ranges of elements within an array or container. (AI – Paul, double check)</p></li>
<li><p>Use containers of the standard library, such as <code>std::vector</code> or <code>std::deque</code>, to model arrays with dynamically changing size.</p></li>
<li><p>Use iterator-based algorithms, such as those of the standard library.</p></li>
<li><p>Use the range-based for loop construct such as <code>for (auto e:</code> <em>some container</em><code>)</code> to iterate within the defined bounds of the object.</p></li>
<li><p>Use iterators over the range of elements to be accessed instead of using an array and bounds as parameters.</p></li>
<li><p>When using C-style arrays, statically show that an access outside of the array cannot occur, or alternatively perform range checking before indexing into the array.</p></li>
<li><p>When performing random access by indexing, follow the guidance of clause 6.9.2. When performing other forms of random access, follow the guidance of clause 6.12.2. <em>)</em></p></li>
<li><p>Use static analysis tools to detect buffer boundary violations.</p></li>
</ul>
<h2 id="unchecked-array-indexing-xyz">6.9 Unchecked Array Indexing [XYZ]</h2>
<h3 id="applicability-to-language">6.9.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 exists in C++ when C-style arrays are used, when access to some containers is performed using <code class="sourceCode cpp"><span class="kw">operator</span>[]</code>, or when accessing elements in containers by pointer arithmetic.</p>
<p>Like a C-style array, some STL containers, such as <code>std::vector</code>, can be indexed using [], and as in C such an access is unchecked. However, these containers also provide an access function <code>at()</code> that behaves like [], but performs a check that the access is within the bounds of the container.</p>
<p>Placing C-types (such as arrays) in containers let the implementer create access operators that check bounds.</p>
<p>The following example compares C and C++ performing equivalent array operations:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>C</strong></th>
<th style="text-align: left;"><strong>C++</strong></th>
<th style="text-align: left;"><strong>Comment</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;array&gt;</span></code></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode cpp"><span class="dt">int</span> arr [<span class="dv">10</span>];</code></td>
<td style="text-align: left;"><code class="sourceCode cpp"><span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">10</span>&gt;arr;</code></td>
<td style="text-align: left;">Both arrays are of 10 elements</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode cpp">arr[<span class="dv">10</span>] = <span class="dv">0</span>;</code></td>
<td style="text-align: left;"><code class="sourceCode cpp">arr[<span class="dv">10</span>] = <span class="dv">0</span>;</code></td>
<td style="text-align: left;">Both accesses silently violate array’s bounds</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode cpp">arr[<span class="dv">10</span>] = <span class="dv">0</span>;</code></td>
<td style="text-align: left;"><code class="sourceCode cpp">arr.at(<span class="dv">10</span>) = <span class="dv">0</span>;</code></td>
<td style="text-align: left;">The C++ access fails with an error exception</td>
</tr>
</tbody>
</table>
<h3 id="guidance-to-language-users">6.9.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance from clause 6.8.2.</p></li>
<li><p>Use static analysis or explicit checks to establish that bounds violations do not occur. Otherwise use the <code class="sourceCode cpp">at()</code> member function of the standard library containers and handle the bounds violation exceptions. For issues associated with exception handling and error handling, see clause 6.36 Ignored error status and unhandled exceptions.</p></li>
</ul>
<h2 id="unchecked-array-copying-xyw">6.10 Unchecked Array Copying [XYW]</h2>
<h3 id="applicability-to-language">6.10.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 exists in C++, but can be mitigated using features provided by the language.</p>
<p>A buffer overflow occurs when some number of bytes (or other units of storage) is copied from one buffer to another and the amount being copied is greater than is allocated for the destination buffer. This is a special case of Buffer Boundary Violation [HCB].</p>
<p>As with clause 6.8 [HCB], in most cases the vulnerability can be avoided by using library classes, such as <code class="sourceCode cpp"><span class="bu">std::</span>vector</code>, which provides a copy assignment operator that adjusts the size of the target to fit the object being copied.</p>
<p>If for some reason this is not acceptable, C++ has access to the C library functions <code class="sourceCode cpp">memcpy()</code> and <code class="sourceCode cpp">memmove()</code>. Both simply copy memory and no checks are made as to whether the destination area is large enough to accommodate the amount of data being copied. It is assumed that the calling routine or programmer has ensured that adequate space has been provided in the destination. Problems can arise when the destination buffer is too small to receive the amount of data being copied.</p>
<p>In general, placing C-types (such as arrays) in containers lets the implementer create whole array operations that can eliminate the errors discussed in Part 1, clause 6.10.</p>
<h3 id="guidance-to-language-users">6.10.2 Guidance to language users</h3>
<ul>
<li><p>Use standard library containers, such as <code class="sourceCode cpp"><span class="bu">std::</span>vector</code>, that provide copying mechanisms that ensure the target array is large enough for the indicated source.</p></li>
<li><p>When copying C-style arrays, statically shown that an access outside of the array cannot occur, or alternatively perform range checking before copying the array.</p></li>
</ul>
<pre><code>&lt;!--
Deleted text
-   ~~For copies of fixed-sized arrays, perform range checking to
    prevent out-of-bounds access on the target and the source arrays. In
    the interest of speed and efficiency, range checking only needs to
    be done when it cannot be statically shown that an access outside of
    the arrays cannot occur.~~
--&gt;</code></pre>
<ul>
<li><p>Use <code class="sourceCode cpp"><span class="bu">std::</span>string_view</code> to represent immutable string literals<span data-custom-style="annotation reference"></span>.</p></li>
<li><p>Use <code class="sourceCode cpp">std:string</code> to represent mutable strings<span data-custom-style="annotation reference"></span>.</p></li>
<li><p>Place arrays in containers with whole-array and bounds-checking operations. <span data-custom-style="annotation reference"></span></p></li>
</ul>
<h2 id="HFC">6.11 Pointer Type Conversions [HFC]</h2>
<h3 id="applicability-to-language">6.11.1 Applicability to language</h3>
<pre><code>&lt;!--
In this clause, all C++ references, in addition to pointers. The
`shared_ptr`{.cpp} casts
--&gt;</code></pre>
<p>The vulnerabilites as described in ISO/IEC TR 24772-1:2019 clause 6.11.1 applies to C++.</p>
<p>In general casting pointers breaks the type system and should be avoided.</p>
<p>In C++, a C-style cast is defined in terms of the C++ cast operators <code class="sourceCode cpp"><span class="kw">const_cast</span></code>, <code class="sourceCode cpp"><span class="kw">static_cast</span></code>, and <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>. In some cases, it is unspecified which cast is used, for example when a cast operation involves an incomplete type, a <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> may be used for the conversion which can produce an incorrect result.</p>
<p>Especially, <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> has the problem that it simply treats the unmodified pattern of bits in the pointer as being of the target type rather than the original type, but the C++ standard recognizes that the language or compiler may impose constraints or additional data requirements on a pointer. <code class="sourceCode cpp"><span class="kw">static_cast</span></code> and <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> take this difference into account, but other cast operators do not take this into consideration and hence can give incorrect results. For example, in the use of multiple inheritance, the address of an object may be different than one of its base class sub-objects, causing the potential for the exploitable access of adjacent memory.</p>
<p>C++ permits the change of constant or volatile properties as part of a conversion. Such conversions, unless done in extremely limited ways, puts the program at risk of creating undefined behavior.</p>
<p>A typical use of pointer conversion in C++ occurs where there is a hierarchy of classes declared, as in:</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Base {<span class="kw">virtual</span> ~Base() = <span class="cf">default</span>; };</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Derived: Base { };</span></code></pre></div>
<p>Where a <code>Base</code> pointer needs to be converted to <code>Derived</code> pointer, <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> will check at runtime that the pointer is to an object of the correct type. If it’s not, either <code class="sourceCode cpp"><span class="kw">nullptr</span></code> will be returned, or an is exception thrown in case references are used as source and target type. See subclause <a href="#BKK">Polymorphic Variables [BKK]</a>.</p>
<pre><code>&lt;!--
C++ Dynamic cast and the use of it during construction and destruction needs further exposition. The this pointer type can have surprising effects.*
--&gt;</code></pre>
<pre><code>&lt;!--
*AI* *--* *Paul, Richard to review* *-- Writeup about incomplete objects before or after their lifetime and related to translation units.[]{custom-style=&quot;annotation reference&quot;}*[]{custom-style=&quot;annotation reference&quot;}

The following is a video from Jason Turner on why to avoid reinterpret_cast: https://youtu.be/L06nbZXD2D0

The committee introduced &#39;bit_cast&#39; to replace incorrect usage of &#39;reinterpret_cast&#39;: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0476r2.html.

--&gt;</code></pre>
<p>Pointer casts to a more strictly aligned pointer type is undefined behaviour.</p>
<p><code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> for pointer-interconvertible on objects (see clause 6.9.2 of IS 14882)</p>
<p>C++ permits <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> to be used to convert a pointer to an object, a, to a pointer to another object, b, only in specific restricted circumstances, i.e., when</p>
<ul>
<li><p>a and b are the same object,</p></li>
<li><p>either a or b is a standard-layout union object and the other is a non-static data member of that object,</p>
<ul>
<li>Examples: <code>{.cpp}     union A { int i; double d; } a;\     int\* iptr = reinterpret_cast\&lt;int\*\&gt;(&amp;a);\     double\* dptr = reinterpret_cast\&lt;double\*\&gt;(&amp;a);\     A\* uptr1 = reinterpret_cast\&lt;A\*\&gt;(iptr);\     A\* uptr2 = reinterpret_cast\&lt;A\*\&gt;(dptr);</code></li>
</ul></li>
<li><p>either a or b is a standard-layout class object and the other is the first non-static data member of that object,</p>
<ul>
<li>Examples: <code>{.cpp}     struct B { int i; double d; } b;\     int\* iptr = reinterpret_cast\&lt;int\*\&gt;(&amp;b);\     B\* bptr = reinterpret_cast\&lt;B\*\&gt;(iptr);</code></li>
</ul></li>
<li><p>either a or b is a standard-layout class object with no non-static data members and the other is the first base class subobject of that object, or,</p>
<ul>
<li>Examples: <code>{.cpp}     struct A { double d; };\     struct B : A { static int i; } b;\     double\* dptr = reinterpret_cast\&lt;double\*\&gt;(&amp;b.d);\     B\* cptr = reinterpret_cast\&lt;B\*\&gt;(dptr);</code></li>
</ul></li>
<li><p>there exists an object c where a and c are <em>pointer-interconvertible</em> and c and b are pointer-interconvertible.<span data-custom-style="annotation reference"></span></p></li>
</ul>
<p>In essence, such pointer-interconvertibility implies objects a and b have the same address, however, having the same address does not imply a and b are pointer-interconvertible! For example, an array and its first element have the same address but they are not pointer-interconvertible. This means that one cannot use reinterpret_cast to cast an array object to the type of its first element or vice versa. [Reference: ISO 14882 Section 6.9.2 [basic.compound], Paragraph 4].</p>
<h3 id="guidance-to-language-users">6.11.2 Guidance to language users</h3>
<ul>
<li><p>Follow the advice provided in ISO/IEC TR 24772-1:2019 clause 6.11.5.</p></li>
<li><p>Prefer C++ <code class="sourceCode cpp">T&amp;</code> references to <code class="sourceCode cpp">T*</code> pointers</p></li>
<li><p>Avoid the C-style cast, <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>, and casts to and from <code>void*</code>.</p></li>
<li><p>For conversions that remove the <code class="sourceCode cpp"><span class="at">const</span></code> qualification, see the guidance in clause 6.65.</p></li>
<li><p>When downcasting, prefer <code>dynamic_cast</code> and explicitly handle the possible failure cases. <em>What about</em> <em>references???</em></p>
<ul>
<li><pre><code>  *C++ Core guidelines C.146, 1.47 and 1.48*</code></pre></li>
</ul></li>
<li><p>Only be made using <code>dynamic_cast</code> for casts between two bases in a multiple inheritance hierarchy shall o. <em>What about references???</em></p>
<ul>
<li><pre><code>  *C++ Core guidelines C.146*</code></pre></li>
</ul></li>
<li><p>Heed compiler warnings that are issued for pointer conversion instances. The decision may be made to avoid all conversions so any warnings must be addressed. Note that casting into and out of <code>void *</code> pointers will most likely not generate a compiler warning as this is valid in C++</p></li>
<li><p>Use <code>new</code> and <code>delete</code> to allocate/deallocate memory, rather than <code>malloc()</code>/<code>free()</code>.</p>
<ul>
<li><pre><code>  EXP51-CPP. Do not delete an array through a pointer of the</code></pre>
<p>incorrect type (implied by 6.11)</p></li>
<li><pre><code>  EXP57-CPP. Do not cast or delete pointers to incomplete classes</code></pre>
<p>(-&gt; 6.11)</p></li>
<li><pre><code>  EXP36-C. Do not cast pointers into more strictly aligned pointer</code></pre>
<p>types (-&gt; 6.11)</p></li>
<li></li>
<li><pre><code>  MISRA C++ 10-1-1 - Classes should not be derived from virtual</code></pre>
<p>bases.</p></li>
</ul></li>
</ul>
<h2 id="pointer-arithmetic-rvg">6.12 Pointer Arithmetic [RVG]</h2>
<h3 id="applicability-to-language">6.12.1 Applicability to language</h3>
<p>The vulnerabilites described in ISO/IEC TR 24772-1:2019 clause 6.12.1 also apply to C++ pointers. Analogous vulnerabilities can also apply to C++ iterators.</p>
<p>Although based on the same implementation principles, iterators provide a layer of abstraction over pointer arithmetic. Their use typically restricts the arithmetic to the safe access to elements of the container. This restriction is enforced by the typical usage, not necessarily by the capability of iterators.</p>
<h3 id="guidance-to-language-users">6.12.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance of clause 6.8.2.</p></li>
<li><p>Prefer standard algorithms to hand-written loops</p>
<ul>
<li>See Core Guideline.ES.1 (TBD)</li>
</ul></li>
<li><p>Prefer ranges over iterators; and iterators over pointer arithmetic.</p></li>
<li><p>When using iterators, use an iterator that checks against the bounds of the container before performing the intended operation on the container.</p></li>
<li><p>Consider an outright ban on pointer arithmetic due to the error-prone nature of pointer arithmetic.</p></li>
<li><p>Verify that all pointers are assigned a valid memory address for use.</p></li>
</ul>
<h2 id="null-pointer-dereference-xyh">6.13 NULL Pointer Dereference [XYH]</h2>
<h3 id="applicability-to-language">6.13.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.13 exists in C++. Dereferencing a pointer with the value of <code class="sourceCode cpp"><span class="kw">nullptr</span></code> is undefined behavior <a href="#EWF">[EWF]</a>.</p>
<p>C++ does, however, provide references that cannot be null and can be used in most places instead of pointers. In addition the standard library type <code class="sourceCode cpp"><span class="bu">std::</span>optional</code> can be used in place of pointers in many cases but requires similar diligence when it is empty.</p>
<p>As a historical programming convention a return value of <code class="sourceCode cpp"><span class="kw">nullptr</span></code> is used to denote tha absence of a result. This mechanism lead to a style where pointer returns are very common and magnify potential dereference problems. Instead of returning a pointer, std::optional can be used to denote the absence of a result an still return a result by value. In addition, passing pointers as function arguments places the burden of checking for a <code class="sourceCode cpp"><span class="kw">nullptr</span></code> value on the called function. Using pointers as return values and function parameters is inherently problematic, due to the following issues:</p>
<ul>
<li>is a <code class="sourceCode cpp"><span class="kw">nullptr</span></code> value valid in context?</li>
<li>is it a single object or an array of objects? (<code>T[]</code> as a function parameter type is identical to <code>T*</code>)</li>
<li>what is the lifetime of the pointee?</li>
<li>who has ownership of the pointee?</li>
<li>is there protection against dereference of a <code class="sourceCode cpp"><span class="kw">nullptr</span></code> value?</li>
</ul>
<p>Using a reference as a function parameter instead of a pointer has none of these issues. Using a reference as function return type requires the caller to avoid accessing an object outisde of its lifetime (see <a href="#XYK">[XYK]</a>, <a href="#DCM">[DCM]</a>).</p>
<p>Using a <code>std::optional</code> as a function parameter or function return value instead of a pointer addresses all of these issues, except for the last. Accessing the content of a std::optional requires a check for <code>has_value{}</code>, which happens implicitly when using <code class="sourceCode cpp"><span class="bu">std::</span>optional<span class="bu">::</span>value()</code> instead of its overloaded dereference-operator.</p>
<p>Note: Be aware that <code>optional&lt;T&amp;&gt;</code> is not supported by the standard library. In that case either use <code class="sourceCode cpp"><span class="bu">std::</span>optional&lt;<span class="bu">std::</span>reference_wrapper&lt;T&gt;&gt;</code> or another implementation of <code>optional</code> supporting holding references.</p>
<p>The language provided dynamic memory management functionionality might return a nullptr value in case of a failed allocation. Employing the smart pointer factories <code>make_unique</code> or <code>make_shared</code> will return a non-null smart pointer managing the lifetime of the underlying memory or throw <code>std::bad_alloc</code> on a failed allocation.</p>
<p>See C++ Core Guidelines ES.65 and section R: Resource Management, and CERT EXP34-C “Do not dereference null pointers”</p>
<h3 id="guidance-to-language-users">6.13.2 Guidance to language users</h3>
<ul>
<li><p>If using objects of pointer-like types that may contain a <code class="sourceCode cpp"><span class="kw">nullptr</span></code> value is unavoidable, follow the guidance from TR 24772-3 clause 6.13.2.</p></li>
<li><p>Use references to reduce the number of places where pointers are dereferenced.</p></li>
<li><p>Use <code>std::optional</code> instead of a pointer to denote a potentially missing function argument or result.</p></li>
<li><p>Use containers instaed of arrays such as <code>std::array</code>, <code>std::vector</code>, and <code>std::span</code>.</p></li>
<li><p>Use <code>make_unique()</code> or <code>make_shared()</code> for allocating objects on the heap.</p></li>
<li><p>Do not suppress exceptions on memory allocation and handle any exceptions that arise. If exceptions are suppressed, follow the guidance of TR 24772-3:2020 clause 6.13.2.</p></li>
<li><p>Use static and dynamic analysis tools to detect potential violations of this guideline.</p></li>
</ul>
<h2 id="XYK">6.14 Dangling Reference to Heap [XYK]</h2>
<h3 id="applicability-to-language">6.14.1 Applicability to language</h3>
<p>The vulnerability as expressed in ISO/IEC TR 24772-1:2019 and ISO/IEC TR 24772-3:2020 C exists in C++. C++, however, provides mechanisms to mitigate the vulnerability.</p>
<p>C++ provides a rich set of types whose objects may dangle, e.g.</p>
<ul>
<li><p>References</p></li>
<li><p>Pointers</p></li>
<li><p>Iterators</p></li>
<li><p><code class="sourceCode cpp"><span class="bu">std::</span>string_view</code></p></li>
<li><p><code class="sourceCode cpp"><span class="bu">std::</span>span</code></p></li>
<li><p><code class="sourceCode cpp"><span class="bu">std::</span>reference_wrapper</code></p></li>
</ul>
<p>This document calls these <em>potentially dangling types</em> since an attempt to access an object outside of its lifetime through a <em>potentially dangling object</em> is <em>undefined behaviour</em> (see [EWF]). In addition, user-defined class types can be <em>potentially dangling types</em>, if a subobject is of <em>potentially dangling type</em> and it refers to an object who’s lifetime is different from and not managed by the current object.</p>
<p>If the lifetime of a <em>potentially dangling object</em> ends before its referent’s lifetime ends, then the vulnerability does not apply to that potentially dangling object. This is the primary C++ strategy for avoiding vulnerabilities due to potentially dangling objects. For example, using a <em>potentially dangling type</em> as a function parameter and passing an argument that refers to an object (referent) in the scope of the function call, and the function does not take ownership of the referent (for example, by deleting the referent), then the language guarantees that the lifetime of the referent is longer than the lifetime of the parameter, even if the referent is a temporary object created within the function call expression. This lifetime guarantee does not apply to further copies made to potentially dangling objects that outlive the function call, or if the function is a coroutine.</p>
<p>In general, a temporary object is destroyed at the end of the surrounding full expression. However, in certain specific circumstances the language guarantees that a const-lvalue-reference or an rvalue-reference that is bound to a (member of a) temporary object extends the lifetime of the temporary until the reference goes out of scope. This lifetime extension is not transitive across function calls, therefore, changes in the code, such as replacing a data member access with an accessor member function, can silently lead to dangling in such lifetime-extension situations.</p>
<p>A simple example is where the temporary <code class="sourceCode cpp"><span class="bu">std::</span>string</code> object constructed by the suffix <code class="sourceCode cpp"><span class="st">&quot;&quot;</span><span class="bu">s</span></code> is passed as a constructor argument:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string_view bad(<span class="st">&quot;a temporary string&quot;</span><span class="bu">s</span>); <span class="co">// \&quot;bad\&quot; holds a dangling pointer</span></span></code></pre></div>
<p>Note: technically in this example the vulnerability exists in the conversion operator <code class="sourceCode cpp"><span class="bu">std::</span>string<span class="bu">::</span>operator string_view()</code> of <code class="sourceCode cpp"><span class="bu">std::</span>string</code>, that returns a potentially dangling type from a member function callable on a temporary object.</p>
<p>Functions returning <em>potentially dangling types</em> are vulnerable, when the caller is not copying the resulting referent, but just stores the <em>potentially dangling object</em>. For example, the <em>range-for statement</em> uses the above mentioned lifetime extension for the range object to be iterated upon. If that range object itself is given as a reference already, the loop will access the elements through dangling iterators.</p>
<pre class="{cpp}"><code>extern std::vector&lt;std::string&gt; make(); // creates a vector

for(char c: make().front()) { // attempt to iterate over first string in vector
   // vector and thus contained string is already destroyed
}</code></pre>
<p>For objects directly allocated on the heap C++ provides smart pointers and corresponding factory functions (e.g., <code class="sourceCode cpp">make_unique()</code>) that allow transferring ownership or shared ownership to reduce the risk for dangling.</p>
<h3 id="guidance-to-language-users">6.14.2 Guidance to language users</h3>
<p>In addition to the guidance provided in TR 24772-1 clause 6.14.5:</p>
<ul>
<li><p>Do not rely on lifetime extension of temporaries by binding them to named references. Use (local) variables instead.</p></li>
<li><p>Prefer value types that manage heap memory, for example, <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> or <code class="sourceCode cpp"><span class="bu">std::</span>string</code>, and pass by value/return by value over the use of <em>potentially dangling types</em>.</p></li>
<li><p>If value types are not feasible, adopt a style that makes explicit the ownership and lifetime of heap resources, by using <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr</code> or <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr</code> or similar RAII/SBRM types and allocate heap memory exclusively with their corresponding factory functions <code class="sourceCode cpp"><span class="bu">std::</span>make_unique/<span class="bu">std::</span>make_shared</code>.</p></li>
<li><p>Adopt a style that ensures all copies of any potentially dangling objects are guaranteed to be cleaned up before the referent’s lifetime ends or never accessed afterwards. For example, do not store the raw pointers managed by smart pointers, e.g., by calling their <code class="sourceCode cpp">get()</code> member function.</p></li>
<li><p>Consider making member functions ref-qualified, that return potentially dangling types to members or heap allocated objects managed by the class,<br />
to avoid being called on temporary objects. Note: An rvalue-ref-qualified overload should either return a copy by value, or be defined as <code class="sourceCode cpp">=<span class="kw">delete</span></code> to prevent calling it on a temporary that would lead to returning an immediately dangling object.</p></li>
<li><p>Show that the <em>range-for</em> dangling vulnerability does not apply or take steps to avoid it, for example, use a variable representing the range and not an expression that yields a reference to a temporary.</p></li>
</ul>
<p>$incldue 6.15.ArithmeticWrap-aroundError-FIF.md</p>
<h2 id="PIK">6.16 Using Shift Operations for Multiplication and Division [PIK]</h2>
<h3 id="applicability-to-language">6.16.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC 24772-1 clause 6.16 exists in C++. C++ complicates the discussion in 24772-1 clause 6.16 as a result of the integral promotion (see clause 6.06 [FLC]). A left-shift on an operand that gets promoted can result in a value outside the operand’s unpromoted type’s range.</p>
<p>Not every use of a shift operator is a bit-shift due to operator overloading.</p>
<h3 id="guidance-to-language-users">6.16.2 Guidance to language users</h3>
<ul>
<li>Follow the advice of ISO/IEC TR 24772-1:2019 clause 6.16 *Using Shift Operations for Multiplication and Division [PIK].</li>
<li>For promoted operands, consider converting the result of a shift operation back to the original type of the left hand operand (say using a static cast or an assignment to an object of that type) before using the result in further operations.</li>
</ul>
<h2 id="choice-of-clear-names-nai">6.17 Choice of Clear Names [NAI]</h2>
<h3 id="applicability-to-language">6.17.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.17 is applicable to C++.</p>
<p>’’’ <!--
This subclause requires a complete rewrite to have it reflect C++
issues.. TBD!!!

Think about discussing reserved names. Maybe also in Part 1.
--></p>
<pre><code>
C is somewhat susceptible to errors resulting from the use of similarly
appearing names. C does require the declaration of variables before they
are used. However, C allows scoping so that a variable that is not
declared locally may be resolved to some outer block and a human
reviewer may not notice that resolution. Variable name length is
implementation specific and so one implementation may resolve names to
one length whereas another implementation may resolve names to another
length resulting in unintended behaviour.

As with the general case, calls to the wrong subprogram or references to
the wrong data element (when missed by human review) can result in
unintended behaviour.ISO/IEC 14882:2017 C++ clause 20.5.4
\[constraints\] -- reserved names, from C++, also from C, deprecated
names

`Numeric_limits`{.cpp} are in std namespace,

To Do *(Paul)*

-   One can add names to a templates as part of specialization.

-   Example extending a hash function from std::

-   Also inline namespaces.

-   Also the use of underscores in symbol names.

-   Also Unicode in identfiers.

### 6.17.2 Guidance to language users

-   Follow the guidance of ISO/IEC 148822017 clause 20.5.4 regarding
    names to refrain from usage.

-   Use names that are clear and non-confusing.

-   Use consistency in choosing names.

-   Keep the scope of names as small as reasonable.

-   Keep names short and concise in order to make the code easier to
    understand.

-   Use longer names for longer-lived objects.

-   Choose names that are appropriately rich in meaning for the context.

-   When choosing names, keep in mind that code will be reused and
    combined in ways that the original developers never imagined.

-   Do not differentiate names through only a mixture of case or the
    presence/absence of an underscore character. (this is in Part 1?)

-   Do not choose names that conflict with (unreserved) keywords or
    language-defined library names for the language being used, as
    follows:

    -       Names that begin with two or more underscore;
    
    -       Names that begin with a single underscore followed by an
        uppercase letter;
    
    -   Contextual keywords such as module, final and override;

    -   In the global namespace, identifiers commencing with std
        followed by any string of digits;

&gt; Follow common conventions for naming macros:

-   Avoid names for macros that are not all uppercase;

-   Avoid names that are all uppercase not used for macros;

```{=html}
&lt;!-- --&gt;</code></pre>
<ul>
<li><p>Avoid differentiating through characters that are commonly confused visually such as ‘O’ and ‘0’, ‘l’ (lower case ‘L’), ‘I’ (capital ‘I’) and ‘1’, ‘S’ and ‘5’, ‘Z’ and ‘2’, and ‘n’ and ‘h’.</p></li>
<li><p>Adopt or develop coding guidelines to define a common coding style and to avoid the above dangerous practices.</p></li>
</ul>
<h2 id="WXQ">6.18 Dead Store [WXQ]</h2>
<h3 id="applicability-to-language">6.18.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 clause 6.18 exists in C++.</p>
<p>The language definition permits the compiler to eliminate effects of the abstract machine that are not observable, in particular, dead stores. For example, the often-attempted write operations to non-volatile member variables in a destructor that are not subsequently used can be elided by the compiler.</p>
<p>C++ compilers and static analysis tools do exist that detect and generate warnings for dead stores.</p>
<p>The error in ISO/IEC 24772-1:2019 subclause 6.18.3 that the planned reader misspells the name of the store is possible but unlikely in C++ since the language specifies that all objects shall be declared and typed, and the existence of two objects with almost identical names and compatible types (for assignment) in the same scope would be readily detectable. See 6.17 [NAI] Choice of clear names, 6.20 Identifier name reuse [YOW], and 6.21 Namespace issues [BJL]</p>
<h3 id="guidance-to-language-users">6.18.2 Guidance to language users</h3>
<ul>
<li><p>Follow the advice of ISO/IEC 24772-1 clause 6.18.</p></li>
<li><p>Use compilers and static analysis tools to identify dead stores in the program.</p></li>
<li><p>Provide sufficient synchronization to non-const variables that are accessed by multiple execution agents. See clause 6.61 Concurrent data access [CGX]</p></li>
</ul>
<h2 id="unused-variable-yzs">6.19 Unused Variable [YZS]</h2>
<h3 id="applicability-to-language">6.19.1 Applicability to language</h3>
<p>The vulnerability as documented in TR 24772-1 clause 6.19 exists in C++.</p>
<h3 id="guidance-to-language-users">6.19.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance of ISO/IEC TR 24772-1:2019 clause 6.19.5.</p></li>
<li><p>Resolve all compiler warnings for unused variables.</p></li>
</ul>
<h2 id="identifier-name-reuse-yow">6.20 Identifier Name Reuse [YOW]</h2>
<h3 id="applicability-to-language">6.20.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.20 exists in C++, except for the second issue of limited identifier length. In C++ all characters in an identifier are significant.</p>
<p>C++ provides the scope resolution operator <code class="sourceCode cpp">::</code> to access identifier from non-local scopes.</p>
<p>Overloading and specialization of functions is a cornerstone of C++ generic programming. In this context, the reuse of function names is essential. See clause 6.41 for inheritance issues associated with name reuse.</p>
<p>Overloaded function names and operators considered in an expression are not restricted to a simple scope hierarchy, because of argument-dependent lookup (ADL). In generic code the unqualified function or operator selected can come from a scope based on the type of the arguments and not from the current scope hierarchy. The rules for which namespaces are eligible for lookup unqualified functions and operators are intricate, but required to make overloaded operators work.</p>
<p>In addition, if implicit conversions can happen on arguments, the overload selected by ADL can be different from programmer expectation even in non-generic code, especially when an argument is of a type that can be implicitly converted to another type where a corresponding overload is defined. Visibility on a namespace-level of such an operator overload may make it eligible, even if neither argument matches the parameter types directly. In the best case this leads to a compile error due to ambiguities, but it can also result in perfectly compiling code executing an unexcepted overload.</p>
<p>The following example demonstrates part of the problem:</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;typeinfo&gt;</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> Y {</span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print(T i){</span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">typeid</span>(T).name()&lt;&lt; <span class="st">&quot;:&quot;</span> &lt;&lt; i ;</span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> println(T x){</span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a>    print(x); <span class="co">// expects to call Y::print</span></span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout&lt;&lt;<span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb116-13"><a href="#cb116-13" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb116-14"><a href="#cb116-14" aria-hidden="true" tabindex="-1"></a>} </span>
<span id="cb116-15"><a href="#cb116-15" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> X {</span>
<span id="cb116-16"><a href="#cb116-16" aria-hidden="true" tabindex="-1"></a>   <span class="kw">struct</span> A{</span>
<span id="cb116-17"><a href="#cb116-17" aria-hidden="true" tabindex="-1"></a>        A(<span class="dt">double</span>){}</span>
<span id="cb116-18"><a href="#cb116-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="co">// make this a hidden friend</span></span>
<span id="cb116-19"><a href="#cb116-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ostream &amp; <span class="kw">operator</span> &lt;&lt; (<span class="bu">std::</span>ostream &amp; out, A <span class="at">const</span> &amp;a){</span>
<span id="cb116-20"><a href="#cb116-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> out &lt;&lt; <span class="st">&quot;An A as expected</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb116-21"><a href="#cb116-21" aria-hidden="true" tabindex="-1"></a>        } </span>
<span id="cb116-22"><a href="#cb116-22" aria-hidden="true" tabindex="-1"></a>    };</span>
<span id="cb116-23"><a href="#cb116-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> print(A a){ <span class="co">// not expected to be called by println</span></span>
<span id="cb116-24"><a href="#cb116-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Surprise happens!&quot;</span>;</span>
<span id="cb116-25"><a href="#cb116-25" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb116-26"><a href="#cb116-26" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb116-27"><a href="#cb116-27" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main(){</span>
<span id="cb116-28"><a href="#cb116-28" aria-hidden="true" tabindex="-1"></a>    X::A a{<span class="fl">3.14</span>};</span>
<span id="cb116-29"><a href="#cb116-29" aria-hidden="true" tabindex="-1"></a>    Y::println(<span class="dv">42</span>); <span class="co">// i:42 - calls Y::print</span></span>
<span id="cb116-30"><a href="#cb116-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; a; <span class="co">// An A as expected - calls X::operator&lt;&lt;</span></span>
<span id="cb116-31"><a href="#cb116-31" aria-hidden="true" tabindex="-1"></a>    Y::println(a);  <span class="co">// Surprise happens! - calls X::print</span></span>
<span id="cb116-32"><a href="#cb116-32" aria-hidden="true" tabindex="-1"></a>    Y::println(<span class="dv">42</span><span class="bu">u</span>);<span class="co">// u:42 - calls Y::print</span></span>
<span id="cb116-33"><a href="#cb116-33" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The above code calls the overload <code>print(A)</code> from println since it is pulled in by ADL. On the other hand, ADL is required to work to allow the output operator for type <code>X::A</code> to work.</p>
<p>The consideration of implicit conversions together with ADL can be suppressed by defining operator overloads as class members or as <em>hidden friends</em>. The latter is achieved by declaring all corresponding overloads as <code class="sourceCode cpp"><span class="kw">friend</span></code> functions in the class that take the class’ objects as arguments. Generic base classes can provide mix-in facilities for <em>hidden friends</em> by taking the argument type that is the derived class as template parameter.</p>
<h3 id="guidance-to-language-users">6.20.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance of ISO/IEC TR 24772-1:2019 clause 6.20, with the exclusion of guidance related to truncated identifiers.</p></li>
<li><p>Qualify names to disambiguate potential conflicts between names introduced from different scopes.</p></li>
<li><p>Document argument-dependent lookup usage where name qualification is not desirable.</p></li>
<li><p>Limit the visibility of overloaded operators or functions for class types by defining them as member functions or <em>hidden friends</em>.</p></li>
<li><p>Place overloaded operators that are not class members and cannot be provided as <em>hidden friends</em> together with their argument type in a namespace that is not the global namespace, so that they are picked up by ADL.</p></li>
<li><p>Use modern integrated development environments that inform about the declaration of any identifier occurrence.</p></li>
<li><p>Enable compiler diagnostics that inform about the hiding of declarations.</p>
<ul>
<li><pre><code>  DCL60-CPP. Obey the one-definition</code></pre>
<p>rule (6.21)</p></li>
<li><pre><code>  DCL40-C. Do not create incompatible declarations of the same</code></pre>
<p>function or object (6.21)</p></li>
</ul></li>
</ul>
<h2 id="namespace-issues-bjl">6.21 Namespace Issues [BJL]</h2>
<h3 id="applicability-to-language">6.21.1 Applicability to language</h3>
<p>The vulnerability described in ISO/IEC TR 24772-1:2019 clause 6.21 exists in C++. The situations where it exists are related to the following cases:</p>
<ul>
<li><p>Overloading, where clause 6.20 applies;</p></li>
<li><p>Overriding, where clause 6.41 applies.</p></li>
</ul>
<p>In those cases, C++ compilers are required to diagnose an ambiguity if it exists.</p>
<p>However, overload resolution applies preference rules in order to select among multiple matching functions as a means to resolve the ambiguity among these functions. Hence, for calls that are not perfect matches, the user cannot guarantee in the presence of later changes which function is called, as another, better match can be introduced subsequently. The call in question then changes its binding without warning upon its next compilation. For cases, where the preference rules do not resolve the ambiguity, the resulting error message by the compiler avoids the vulnerability.</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo (<span class="dt">long</span>);</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a><span class="co">// void foo (int);</span></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar ()</span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a>  foo (<span class="dv">0</span>);         <span class="co">// The call to &#39;foo(long)&#39; requires implicitly conversion</span></span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a>                   <span class="co">// from &#39;int&#39; to &#39;long&#39;.   The function &#39;foo(int)&#39; </span></span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a>                   <span class="co">// would be a &quot;better match&quot; and so would silently</span></span>
<span id="cb119-10"><a href="#cb119-10" aria-hidden="true" tabindex="-1"></a>                   <span class="co">// be chosen when subsequently introduced</span></span>
<span id="cb119-11"><a href="#cb119-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>A new declaration may become visible in a number of situations involving the addition of:</p>
<ul>
<li>a new overload,</li>
<li>a using directive</li>
<li>a declaration into a namespace that is searched as part of “Argument Dependent Lookup”</li>
<li>a non-template function that is preferred to a function template</li>
</ul>
<p>A using directive broadens the possible scopes that will be examined for names during lookup. Where lookup searches a namespace referred to by a using directive, all names in that namespace will be visible some of which may be unwanted. A using declaration, on the other hand, declares only the specified name into the scope of the using declaration.</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> NS1</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f1 (<span class="dt">int</span>);</span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f2 (<span class="dt">int</span>);        <span class="co">// Added later</span></span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> NS2</span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> <span class="kw">namespace</span> NS1;  <span class="co">// &#39;f1&#39; needed</span></span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f2 (<span class="dt">long</span>);</span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> bar ()</span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a>    f1(<span class="dv">0</span>);              <span class="co">// Calls &#39;NS1::f1&#39;</span></span>
<span id="cb120-13"><a href="#cb120-13" aria-hidden="true" tabindex="-1"></a>    f2(<span class="dv">0</span>);              <span class="co">// Unintentionally calls &#39;NS1::f2&#39;</span></span>
<span id="cb120-14"><a href="#cb120-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb120-15"><a href="#cb120-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb120-16"><a href="#cb120-16" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> NS3</span>
<span id="cb120-17"><a href="#cb120-17" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb120-18"><a href="#cb120-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> NS1::f1;        <span class="co">// &#39;f1&#39; needed</span></span>
<span id="cb120-19"><a href="#cb120-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f2 (<span class="dt">long</span>);</span>
<span id="cb120-20"><a href="#cb120-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> bar ()</span>
<span id="cb120-21"><a href="#cb120-21" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb120-22"><a href="#cb120-22" aria-hidden="true" tabindex="-1"></a>    f1(<span class="dv">0</span>);              <span class="co">// Calls &#39;NS1::f1&#39;</span></span>
<span id="cb120-23"><a href="#cb120-23" aria-hidden="true" tabindex="-1"></a>    f2(<span class="dv">0</span>);              <span class="co">// Calls &#39;NS3::f2&#39; as expected</span></span>
<span id="cb120-24"><a href="#cb120-24" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb120-25"><a href="#cb120-25" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Overload resolution the compiler only considers conversions for the explicitly specified arguments and does not take default parameters into account:</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">short</span>, <span class="dt">int</span> = <span class="dv">0</span>);</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">int</span>, <span class="dt">short</span> = <span class="dv">0</span>);</span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f2 ()</span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>);       <span class="co">// OK, calls &#39;f1(1, 0)&#39; as &#39;1 -&gt; int&#39; is better match than &#39;1 -&gt; short&#39;</span></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>, <span class="dv">0</span>);    <span class="co">// Ambiguous</span></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h3 id="guidance-to-language-users">6.21.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance of clauses 6.20.2 and 6.41.2 as applicable.</p></li>
<li><p>Consider using fully qualified names for calls that rely on an implicit conversions.</p></li>
<li><p>Prefer using declarations to using directives.</p></li>
<li><p>Do not overload and use default arguments for the same set of functions.</p></li>
<li><p>Do not overload templates and non-templates (???)</p></li>
</ul>
<p><code>Note Start</code> Do these really relate to this rule? - DCL60-CPP. Obey the one-definition rule (6.21) - DCL40-C. Do not create incompatible declarations of the same function or object (6.21)</p>
<p>Is there other guidance that would help here? - Analyse called functions between API upgrades? - Remove implicit conversions for called functions? - Changes to APIs should rename funcsets that have additional overloads?</p>
<p><code>Note End</code></p>
<h2 id="initialization-of-variables-lav">6.22 Initialization of Variables [LAV]</h2>
<h3 id="applicability-to-language">6.22.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 exists in C++.</p>
<p>For local objects and dynamically allocated objects with trivial type defining/allocating the object without initialization leaves the object with an indeterminate value. A subsequent read of such a variable, before it has been written is undefined behavior. Defining local variables as <code class="sourceCode cpp"><span class="at">const</span></code>, enforces initialization by the compiler. If determining the initial value of a variable requires complex logic, putting that logic into an immediately-invoked lambda expression that provides the initial value, permits the variable to be initialized when defined. Furthermore, a class with a user-defined constructor can chose to leave non-static data members of trivial type uninitialized. If such a class does not prevent access to such a member with indeterminate value, using the class can cause undefined behavior. This even happens when an object of that class is a subobject of another class that does not define a constructor. In addition some of the rules of initialization in C++ are complicated. There exists, no initialization (see above), zero-initialization, value-initialization, default-initialization, list initialization, aggregate inialization, member initialization, base-class initialization, constant initialization (<code class="sourceCode cpp"><span class="kw">constexpr</span></code> and <code class="sourceCode cpp"><span class="kw">constinit</span></code>), static initialization, dynamic initialization, etc.</p>
<p>Namespace-scope variables with dynamic initialization can cause undefined behavior if the initialization depends on other such variables. If the dependency is in the same translation unit the sequencing is defined in definition order, however, there is no sequencing across translation unit boundaries.</p>
<p>Consider:</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A {</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>  A (<span class="dt">int</span> i ) : <span class="va">i_</span> { i }  {  }</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> <span class="va">i_</span>;</span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> B {</span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a>  B (A <span class="at">const</span> &amp; a) : <span class="va">j_</span>{a.<span class="va">i_</span>} { }</span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> <span class="va">j_</span>;</span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-11"><a href="#cb122-11" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> A a;</span>
<span id="cb122-12"><a href="#cb122-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-13"><a href="#cb122-13" aria-hidden="true" tabindex="-1"></a>B b (a);     <span class="co">//  #1</span></span>
<span id="cb122-14"><a href="#cb122-14" aria-hidden="true" tabindex="-1"></a>A a { <span class="dv">42</span> };  <span class="co">//  #2</span></span></code></pre></div>
<p>If #1 and #2 are in the same translation unit, then <code>a</code> in #1 is incompletely initialized (zero initailized). If #1 and #2 are in different translation units, then the order of initialization of <code>a</code>(#2) relative to <code>b</code>(#1) is unspecified.</p>
<p>Note, however, that the initialization order for function local statics is defined.</p>
<p>Consider:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>A &amp; getA ();</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>B b (getA());</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>A &amp; getA ()</span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">static</span> A a { <span class="dv">42</span> }; </span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> a; <span class="co">// can cause data races</span></span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>See C++ Core Guidelines ES.20 and CERT C++ Coding Guidelines EXP53-CPP. Note that ES.20 and EXP53 are complementary. Both point out that you should always initialize before reading, but ES.20 uses the narrow sense of initialize while EXP53 includes assignment.</p>
<h3 id="guidance-to-language-users">6.22.2 Guidance to language users</h3>
<ul>
<li>Follow the guidance provided in ISO IEC 24772-1 subclause 6.22.5</li>
<li>Initialize every object defined, including data members.</li>
<li>Do not depend on the order of dynamic initialization of namespace-scope variables, unless the initialization order is guaranteed by the language.</li>
<li>Consider not using namespace-scope variables (see <span id="CGA">6.61</span>).</li>
<li>If the use of uninitialized variables is unavoidable, employ tools, including the compiler, that detect reads of variables with indeterminate values.</li>
</ul>
<h2 id="operator-precedence-and-associativity-jcw">6.23 Operator Precedence and Associativity [JCW]</h2>
<h3 id="applicability-to-language">Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.23 is applicable to C++.</p>
<p>Operator precedence and associativity in C++ are determined by the C++ grammar. There are four operators that cannot be overloaded (user-defined)</p>
<ul>
<li><p><code class="sourceCode cpp">::</code> ;</p></li>
<li><p><code class="sourceCode cpp">.</code> ;</p></li>
<li><p><code class="sourceCode cpp">.\*</code> ; and</p></li>
<li><p><code class="sourceCode cpp">?:</code> .</p></li>
</ul>
<p>Due to the large number of operators, one is recommended to consult an operator precedence table when needed, e.g., <a href="https://en.cppreference.com/w/cpp/language/operator_precedence"><span data-custom-style="Hyperlink">https://en.cppreference.com/w/cpp/language/operator_precedence</span></a>. For example, in C++, the bitwise logical and shift operators are sometimes incorrectly treated as having the same precedence as arithmetic operations even though the bitwise operators have lower precedence. For example, the following (correct) expression subtracts one from <code class="sourceCode cpp">x</code> and then checks if the result is zero:</p>
<p><code class="sourceCode cpp">x - <span class="dv">1</span> == <span class="dv">0</span></code></p>
<p>which is equivalent to <code class="sourceCode cpp">(x - <span class="dv">1</span>) == <span class="dv">0</span></code>,i.e., <code class="sourceCode cpp">x - <span class="dv">1</span></code> is done first, then that result is compared to <code class="sourceCode cpp"><span class="dv">0</span></code>. Programmers mistakenly thinking the bitwise operations have the same precedence as arithmetic ones might write:</p>
<p><code class="sourceCode cpp">x &amp; <span class="dv">1</span> == <span class="dv">0</span></code></p>
<p>intending to perform <code class="sourceCode cpp">(x &amp; <span class="dv">1</span>) == <span class="dv">0</span></code>, but precedence rules result in this evaluating <code class="sourceCode cpp">x &amp; (<span class="dv">1</span> == <span class="dv">0</span>)</code> instead. This would have been easily fixed by using parenthesis to ensure the proper evaluation of an expression.</p>
<p>In addition to the aforementioned, C++ also permits operators to be overloaded when used with user-defined types. While it is not possible to change the precedence, associativity, and number of operands of overloaded operators [C++17, Clause 16.5 [over.oper], para. 6], overloaded operators can be executed differently than built-in operators. For example, overloaded operators lose any built-in operator short-circuiting properties and sequence order guarantees. Similarly overloaded operators and their arguments' evaluations behave as normal function calls, differing from built-in operator evaluation.</p>
<p>Note: overloaded assignment falls into this category.</p>
<p>C++ overloading of operators can cause significant issues. One hazard up-to the C++20 standard is that the overloaded comparison operators do not automatically connect the inverse operator, such as:</p>
<ul>
<li><p><code class="sourceCode cpp">==</code> and <code class="sourceCode cpp">!=</code>;</p></li>
<li><p><code class="sourceCode cpp">\&lt;</code> and <code class="sourceCode cpp">\&gt;=</code>;</p></li>
<li><p><code class="sourceCode cpp">\&gt;</code> and <code class="sourceCode cpp">\&lt;=;</code></p></li>
<li><p>etc.</p></li>
</ul>
<p>Unless the declarer declares all relevant operators, unexpected results occur. In addition, overloaded operators <code class="sourceCode cpp">&amp;&amp;</code> and <code class="sourceCode cpp">\|\|</code> do not have shortcut semantics and thus behave differently. This is problematic since the safety of evaluating a right-hand operand of a short circuit operator often depends on the result of the left-hand operand, e.g. an existence test before the value is read.</p>
<pre><code>&lt;!--
This needs to be adjusted to C++20 changes for comparison, should include combined assignment in examples instead. Peter
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.23.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance provided in ISO/IEC TR 24772-1:2019 Clause 6.23.5 [JCW].</p></li>
<li><p>Enable all C++ compiler/tool warnings and static analysis tool diagnostics concerning possible issues with precedence and associativity to help avoid and detect mistakes.</p></li>
<li><p>Even if technically unnecessary, use parentheses around operator (sub)expressions that are known to be or felt likely to be sources of error.</p></li>
<li><p>Avoid overloading the following operators:</p>
<ul>
<li><pre><code>  `&amp;&amp;` ;</code></pre></li>
<li><pre><code>  `||` ;</code></pre></li>
<li><pre><code>  `,` ;</code></pre></li>
</ul></li>
<li><p>Break up complex expressions and use temporary variables to make complex expressions easier to understand and maintain.</p></li>
</ul>
<h2 id="side-effects-and-order-of-evaluation-of-operands-sam">6.24 Side-effects and Order of Evaluation of Operands [SAM]</h2>
<h3 id="applicability-to-language">6.24.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.24 exists in C++.</p>
<p>The evaluation of an expression includes: (i) its value computation; and (ii) its side-effects. The value computation is the value returned by the expression, e.g., the valuation of <code>3 * 2 + 1</code> is <code>7</code>. The side-effect of an expression are</p>
<ul>
<li><p>Write accesses to objects in that expression,</p></li>
<li><p>Reading a volatile object,</p></li>
<li><p>Calling a library I/O function, and</p></li>
<li><p>Calling a function that does any of the above.</p></li>
</ul>
<p>For example consider:</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i = <span class="dv">2</span>;</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> j = i++;</span></code></pre></div>
<p>the evaluation of i++ is 2 and the side-effects are the writing of 3 to i and the initialization of j.</p>
<p>Within an expression, one must ensure an object is stored only once to avoid undefined behaviour, e.g.,</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>i = i++ + <span class="dv">5</span>; <span class="co">// undefined behaviour (before C++17)</span></span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>k = i++ + i\--; <span class="co">// undefined behaviour in all versions of C++</span></span></code></pre></div>
<p>and expressions modifying objects can only read the object to determine the value to be stored (e.g., ++i requires reading the value), i.e., other accesses are undefined behaviour, e.g.,</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>my_array\[i\] = i++; <span class="co">// undefined behaviour (before C++17)</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>Starting with C++<span class="dv">17</span>, the evaluation order of an expression involving</span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a>overloaded operators preserves the sequenced before behaviour of the</span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a>built-in <span class="kw">operator</span>:</span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-7"><a href="#cb131-7" aria-hidden="true" tabindex="-1"></a><span class="er">```</span>{.cpp}</span>
<span id="cb131-8"><a href="#cb131-8" aria-hidden="true" tabindex="-1"></a>my_array[i] = i++;</span>
<span id="cb131-9"><a href="#cb131-9" aria-hidden="true" tabindex="-1"></a>my_array[i++] = i++;</span></code></pre></div>
<p>say <code class="sourceCode cpp">i = <span class="dv">10</span></code> before the expression</p>
<p>evaluate RHS <code>i++</code> – <code>i</code> is <code>11</code></p>
<p>evaluate <code>my_array[i++]</code> //evaluates <code>my_array\[11\]</code>, then assigns <code>i</code> to <code>12</code></p>
<p><code>my_array[11]</code> is assigned <code>10</code></p>
<p>This occurs because assignment is sequenced after the value computation of the right and left operands and before the value computation of the assignment expression and, the right operand is sequenced before the left operand. [C++17, Clause 8.18 [expr.ass], para. 1] Since this is the built-in operator, this statement can be thought of as:</p>
<blockquote>
<p>Compute value of right-hand-side: <code>i++</code> (e.g., integer value).</p>
<p>Compute value of left-hand-side: <code>my_array[i]</code> (e.g., memory address).</p>
<p>Apply side-effects of <code>i++</code>.</p>
<p>Apply side-effects of the assignment.</p>
</blockquote>
<p>In general, one should follow commonly-stated C/C++ advice of never reading from and writing to the same object within an expression to avoid potential vulnerabilities. Often breaking the expression into separate statements achieves clear and clean semantics, e.g.,</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a>++i;</span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>my_array[i] = i;</span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a>my_array[i] = i;</span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>++i;</span></code></pre></div>
<p>makes it unambiguous what the value of i is during the array assignment and eliminates the possibility of vulnerabilities.</p>
<p>In addition, it is important to note that overloading an operator disables short-circuiting behaviours (e.g., built-in boolean operators): those operators' operands are all evaluated before the operator itself.</p>
<p>The C++ built-in (two-argument) Boolean operators (e.g., <code class="sourceCode cpp">&amp;&amp;</code> and <code class="sourceCode cpp">\|\|</code>)as well as <code>&lt;type_traits&gt;</code>’s <code class="sourceCode cpp"><span class="bu">std::</span>conjunction</code> and <code class="sourceCode cpp"><span class="bu">std::</span>disjunction</code> operations are all short-circuiting, i.e., if the value of an earlier (from left-to-right) operand of an operation determines the result of the operation, then all remaining arguments are not evaluated.</p>
<pre><code>&lt;!--
Conjunction and disjunction operate at compile time and the short-circuiting is about template instantiations that might lead to compile errors otherwiese. This is not a runtime safety issue. I suggest dropping that (Peter)_
--&gt;</code></pre>
<p>Typically this allows one to write code like this, e.g.,</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> *p;</span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (p != <span class="kw">nullptr</span> &amp;&amp; *p != <span class="dv">0</span>) {</span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* do something */</span></span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>i.e., if <code class="sourceCode cpp">p</code> is <code class="sourceCode cpp"><span class="kw">nullptr</span></code>, then <code class="sourceCode cpp">*p != <span class="dv">0</span></code> is never executed, thus, avoiding undefined behaviour. Only when <code>p</code> is not <code class="sourceCode cpp"><span class="kw">nullptr</span></code> is *p != 0 is evaluated. It must be stressed that this only applies to the built-in <code class="sourceCode cpp">&amp;&amp;</code> and <code>||</code> operators: user-defined operator overloads as functions always evaluate all operands first.</p>
<p>Consequently should one want to always evaluate all operands of a boolean expression, one should not write code like this:</p>
<p><code class="sourceCode cpp"><span class="dt">bool</span> x = foo() &amp;&amp; bar();</code></p>
<p>where <code>foo()</code> and <code>bar()</code> are functions that return something convertible to <code>bool</code>. In this expression, if <code>foo()</code> returns <code class="sourceCode cpp"><span class="kw">false</span></code>, then <code>bar()</code> will never be executed; –only when <code>foo()</code> returns <code class="sourceCode cpp"><span class="kw">true</span></code> will <code>bar()</code> be executed. Similarly for <code>||</code>:</p>
<p><code class="sourceCode cpp"><span class="dt">bool</span> y = foo() || bar();</code></p>
<p>i.e., only when <code class="sourceCode cpp">foo()</code> returns <code class="sourceCode cpp"><span class="kw">false</span></code> will <code class="sourceCode cpp">bar()</code> be executed if <code class="sourceCode cpp">foo()</code> returns <code class="sourceCode cpp"><span class="kw">true</span></code> then <code class="sourceCode cpp">bar()</code> will never be executed. Thus, if both <code class="sourceCode cpp">foo()</code> and <code class="sourceCode cpp">bar()</code> are both required to be executed, then execute them in separate statements first, e.g.,</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> foo_result = foo();</span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> bar_result = bar();</span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> x = foo_result &amp;&amp; bar_result;</span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> y = foo_result \|\| bar_result;</span></code></pre></div>
<pre><code>&lt;!--
Stephen: My write-up here is lengthy but should help get more terse
wording\... but I note this: C++ operator information is in C++17 Clause
8 and Clause 16.5, \... Also per 16.5.1 para 2. unary and binary forms
of the same operator are considered to have the same name so one can
hide another from an enclosing scope. Thus, this is also another
possible vulnerability.\]
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.24.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance provided in ISO/IEC TR 24772-1:2019 Clause 6.24.5.</p></li>
<li><p>Write expressions so that the same effects will occur under any order of evaluation that C++ permits since side effects can be dependent on an implementation specific order of evaluation.</p></li>
<li><p>Avoid overloading logical operators (&amp;&amp; and ||), as these overloaded versions will not short-circuit.</p></li>
<li><p><em>Ensure that</em> ++, --, @= <em>are used as solitary items in a statement.</em></p></li>
<li><p>Be aware to which C++ standard a compiler is compiling code against. This determines the semantics of all operator (overloaded and built-in) expressions.</p></li>
<li><p>Avoid placing multiple operations with side effects in a single expression.</p></li>
<li><p>Write simple code expressions and statements so that within any expression or statement an object is one of:</p>
<ul>
<li><pre><code>  Read from;</code></pre></li>
<li><pre><code>  Only modified once; or</code></pre></li>
<li><pre><code>  Only read and modified by: a single increment; a single</code></pre>
decrement; a single simple assignment; or a single compound assignment.</li>
</ul></li>
<li><p>Be aware that different versions of C++ have different evaluation order specifications and program accordingly.</p></li>
</ul>
<h2 id="KOA">6.25 Likely Incorrect Expression [KOA]</h2>
<h3 id="applicability-to-language">6.25.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.25 exists in C++.</p>
<p>C++ has several instances of operators which are similar in structure, but different in meaning. The most common quoted example for C-based languages is the replacement of “<code>==</code>” with “<code>=</code>” in an expression, or confusion between:</p>
<ul>
<li><code>&amp;</code> and <code>&amp;&amp;</code>;</li>
<li><code>|</code> and <code>||</code>;</li>
<li><code>&lt;</code>, <code>&lt;&lt;</code>, and <code>&lt;&lt;=</code>; and</li>
<li><code>&gt;</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;=</code>.</li>
</ul>
<p>The typographical similarity can lead to code like the following, where it is unclear, if the expression as spelled is actually intended, or if the author has typos in it, meaning a different operator instead:</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f(<span class="dt">unsigned</span> i, <span class="dt">unsigned</span> j)</span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (i &gt; <span class="dv">1</span>) &amp; (j = <span class="dv">1</span>); <span class="co">// (&gt;&gt;, &amp;&amp;, ==) ?</span></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>As a general rule, the use of <code>=</code>, <code>+=</code>, <code>-=</code> in an expression when the operator is not the final assignment to a variable is unsafe since the assignment operator creates side-effects within the expression which are difficult to analyze by a human reader and can be have different results depending upon the order of evaluation of terms within the expression.</p>
<p>But even in assignment expression flipping the assignment symbol with the operator can itself lead to valid code that was not intended:</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i{<span class="dv">42</span>};</span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>i += <span class="dv">22</span>; <span class="co">// i becomes 64</span></span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a>i =+ <span class="dv">22</span>; <span class="co">// i becomes 22</span></span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a>i =- <span class="dv">22</span>; <span class="co">// i becomes -22</span></span></code></pre></div>
<p>C++ provides significant freedom in constructing statements. This freedom, if misused, can result in unexpected results and potential vulnerabilities.</p>
<p>The flexibility of C++ can obscure the intent of a programmer. Consider:</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x,y;</span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a><span class="co">/* ... */</span></span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (x = y){</span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* ... */</span></span>
<span id="cb143-5"><a href="#cb143-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>A fair amount of analysis may need to be done to determine whether the programmer intended to do an assignment as part of the if statement (valid in C++) or whether the programmer made the common mistake of using an <code class="sourceCode cpp">=</code> (assignment) instead of a <code class="sourceCode cpp">==</code> (equality). The major issue with assignment inside of a term of an expression is that it creates side effects that can cause the expression to evaluate in different orders and create different results on different compilers, or even in different executions with the same implementation.</p>
<p>In order to prevent this confusion, move assignments in contexts that are easily misunderstood outside of Boolean expression. This would change the example code to:</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x,y;</span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a><span class="co">/* … */</span></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>x = y;</span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (x == <span class="dv">0</span>) {</span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* ... */</span></span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>This would clearly state what the programmer meant and that the assignment of y to x was intended.</p>
<p>Additional confusion occurs in the use of the logical <code>&amp;&amp;</code>/<code>||</code> operators and the bitwise <code>&amp;</code>/<code>|</code> operators. The compiler will implicitly convert arithmetic expressions to <code>bool</code> for operands of the logical operators. Similarly, operands of <code>bool</code> type will be promoted to <code>int</code> for operands of the bitwise operators (see <a href="#FLC">Conversion Errors [FLC]</a>).<br />
It may not be clear whether the programmer intended to use the logical operator <code>&amp;&amp;</code> or bitwise operator <code>&amp;</code> instead:</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> f(<span class="dt">unsigned</span> i, <span class="dt">unsigned</span> j)</span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (i &gt; <span class="dv">0</span>) &amp; j;</span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Using the alternative tokens <code>and</code> / <code>or</code> in lieu of <code>&amp;&amp;</code> and <code>||</code> reduces the possibility of confusion.</p>
<p>Programmers can easily get in the habit of inserting the “<code>;</code>” statement terminator at the end of statements. However, inadvertently doing this can drastically alter the meaning of code, even though the code is valid as in the following example:</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a,b;</span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* … */</span></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (a == b);  <span class="co">// the semi-colon will make this a null statement</span></span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* ... */</span></span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>Because of the misplaced semi-colon, the code block following the if will always be executed. In this case, it is extremely likely that the programmer did not intend to put the semi-colon there.</p>
<p>Unary ‘<code>+</code>’ on a variable is (almost) a no-op, and is possibly a mistype of ‘<code>++</code>’. A unary ‘<code>-</code>’ on a variable will switch its sign, unless applied to a variable of an unsigned type, in which case the result is the value subtracted from 2<sup>n</sup> where n is the number of bits in the unsigned type.</p>
<h3 id="guidance-to-language-users">6.25.2 Guidance to language users</h3>
<p>— Follow the guidance contained in ISO/IEC TR 24772-1:2019, 6.25.5.</p>
<ul>
<li><p>Simplify expressions to aid in code readability and help future maintainers understand the intent and nuances of the code. For example,</p>
<ul>
<li>by extracting intermediate results into const variables with a meaningful name, or</li>
<li>by extracting a subexpression into a function with a meaningful name.</li>
</ul></li>
<li><p>Avoid assignments embedded within other statements and expressions, as these can be problematic.</p></li>
<li><p>Spell unary operators (e.g., <code>-</code>) with a leading blank in expressions to avoid them being misread as combined operators. In addition avoid the use of unary plus, since it is almost always a no-op for built-in types.</p></li>
<li><p>Use alternative tokens for the logical operators.</p></li>
</ul>
<!---   Give null statements a source line of their own. This, combined with
    enforcement by static analysis, would make clearer the intention
    that the statement was meant to be a null statement.
-->
<!-- this seems not to belong here in expressions-->
<ul>
<li><p>Consider the adoption of a coding standard that limits the use of the assignment statement within an expression.</p></li>
<li><p>Follow the following C++ Core guidelines:</p>
<ul>
<li>ES 40 Avoid complicated expressions</li>
<li>ES 41 If in doubt about operator precedence, parenthesize</li>
<li>ES 44 Do not depend on order of evaluation</li>
</ul></li>
</ul>
<h2 id="dead-and-deactivated-code-xyq">6.26 Dead and Deactivated Code [XYQ]</h2>
<h3 id="applicability-to-language">6.26.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 clause 6.26 exists in C++.</p>
<h3 id="guidance-to-language-users">6.26.2 Guidance to language users</h3>
<ul>
<li>Follow the guidance of ISO/IEC TR 24772-1:2019 clause 6.26.5.</li>
</ul>
<h2 id="switch-statements-and-static-analysis-cll">6.27 Switch Statements and Static Analysis [CLL]</h2>
<h3 id="applicability-to-language">6.27.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.27 exists in C++.</p>
<p>Because of the way in which the switch-case statement in C++ is structured, it can be relatively easy to unintentionally omit the break statement between cases causing unintended execution of statements for some cases.</p>
<p>The switch statement has the form:</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> abc = someExpression();</span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* … */</span></span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> (abc) {</span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>       <span class="cf">case</span> <span class="dv">1</span>:</span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>          sval = “a”;</span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a>           <span class="cf">break</span>;</span>
<span id="cb147-7"><a href="#cb147-7" aria-hidden="true" tabindex="-1"></a>       <span class="cf">case</span> <span class="dv">2</span>:</span>
<span id="cb147-8"><a href="#cb147-8" aria-hidden="true" tabindex="-1"></a>           sval = “b”;</span>
<span id="cb147-9"><a href="#cb147-9" aria-hidden="true" tabindex="-1"></a>           <span class="cf">break</span>;</span>
<span id="cb147-10"><a href="#cb147-10" aria-hidden="true" tabindex="-1"></a>       <span class="cf">case</span> <span class="dv">3</span>:</span>
<span id="cb147-11"><a href="#cb147-11" aria-hidden="true" tabindex="-1"></a>           sval = “c”;</span>
<span id="cb147-12"><a href="#cb147-12" aria-hidden="true" tabindex="-1"></a>           <span class="cf">break</span>;</span>
<span id="cb147-13"><a href="#cb147-13" aria-hidden="true" tabindex="-1"></a>       <span class="cf">default</span>:</span>
<span id="cb147-14"><a href="#cb147-14" aria-hidden="true" tabindex="-1"></a>           <span class="cf">throw</span> SomeException();</span>
<span id="cb147-15"><a href="#cb147-15" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>If there isn’t a default case and the switched expression doesn’t match any of the cases, then control simply shifts to the next statement after the switch statement block. Unintentionally omitting a break statement between two cases will cause subsequent cases to be executed until a break or the end of the switch block is reached. This could cause unexpected results.</p>
<p>The attribute <code class="sourceCode cpp">[[<span class="at">fallthrough</span>]]</code> expresses the programmer’s intent that the code where it is placed is intended to fall through. If this attribute is not used, compilers typically diagnose the absence of a break statement.</p>
<h3 id="guidance-to-language-users">6.27.2 Guidance to language users</h3>
<ul>
<li><p>Apply the guidance provided in ISO/IEC TR 24772-1:2019 clause 6.27.5</p></li>
<li><p>Use <code class="sourceCode cpp">[[<span class="at">fallthrough</span>]]</code> wherever fall-through is intended.</p></li>
<li><p>Terminate every case with either a flow control transfer or <code class="sourceCode cpp">[[<span class="at">fallthrough</span>]]</code> as illustrated in the following example:</p>
<pre><code>```{.cpp}
int i;
. . .
switch (i) {
       case 1: 
                     [[fallthrough]]; // documents the intended fallthrough.
       case 2:
            i++;    
            break;
        case 3: 
            j++; 
          [[fallthrough]]; // documents the intended fallthrough.
       case 4: //other code
            return 42;
       default: throw CaseNotFound();   
      }
```</code></pre></li>
<li><p>Adopt a style that permits your language processor and analysis tools to verify that all cases are covered. Where this is not possible, use a default clause that diagnoses the error.</p></li>
</ul>
<blockquote>
<p>See also the C++ Core Guidelines ES.78</p>
</blockquote>
<h2 id="demarcation-of-control-flow-eoj">6.28 Demarcation of Control Flow [EOJ]</h2>
<h3 id="applicability-to-language">6.28.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.28 exists in C++.</p>
<p>C++ lacks a keyword to be used as an explicit terminator. Therefore, it may not be readily apparent which statements are part of a loop construct or an if statement.</p>
<p>Consider the following sections of code:</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foo(<span class="dt">int</span> a, <span class="at">const</span> <span class="dt">int</span> *b) {</span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i=<span class="dv">0</span>;</span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// . . .</span></span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true" tabindex="-1"></a>        a = <span class="dv">0</span>;</span>
<span id="cb149-5"><a href="#cb149-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">10</span>; i++);</span>
<span id="cb149-6"><a href="#cb149-6" aria-hidden="true" tabindex="-1"></a>        {</span>
<span id="cb149-7"><a href="#cb149-7" aria-hidden="true" tabindex="-1"></a>            a = a + b[i];</span>
<span id="cb149-8"><a href="#cb149-8" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb149-9"><a href="#cb149-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> c = <span class="dv">0</span>;</span>
<span id="cb149-10"><a href="#cb149-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x = <span class="dv">0</span>;</span>
<span id="cb149-11"><a href="#cb149-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;<span class="dv">10</span>; i++)</span>
<span id="cb149-12"><a href="#cb149-12" aria-hidden="true" tabindex="-1"></a>            c = c + b[i];</span>
<span id="cb149-13"><a href="#cb149-13" aria-hidden="true" tabindex="-1"></a>            x+= c; </span>
<span id="cb149-14"><a href="#cb149-14" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>At first it may appear that, after the first loop, <code class="sourceCode cpp">a</code> will be a sum of the numbers <span data-custom-style="Code">b[0]</span> to <span data-custom-style="Code">b[9]</span>. However, even though the code is laid out so that the <span data-custom-style="Code">a = a + b[i]</span> code appears to be within the for loop, the “<code class="sourceCode cpp">;</code>” at the end of the for statement causes the loop to be on a null statement (the “<code class="sourceCode cpp">;</code>”) and the</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a>a = a + b[i];</span></code></pre></div>
<p>statement to only be executed once. Similarly, the indentation leads us to believe that that assignment to x is part of the second loop, but it is not. These mistakes may be readily apparent during development or testing. More subtle cases may not be as readily apparent leading to unexpected results.</p>
<blockquote>
<p><code class="sourceCode cpp"><span class="cf">if</span></code> statements in C++ are also susceptible to control flow problems since there isn’t a requirement in C++ for there to be an else statement for every if statement. An <code class="sourceCode cpp"><span class="cf">else</span></code> statement in C++ always belong to the most recent <code class="sourceCode cpp"><span class="cf">if</span></code> statement without an <code class="sourceCode cpp"><span class="cf">else</span></code>. However, the situation could occur where it is not readily apparent to which <code class="sourceCode cpp"><span class="cf">if</span></code> statement an <code class="sourceCode cpp"><span class="cf">else</span></code> belongs due to the way the code is indented or aligned.</p>
<p>Similar issues arise for <code class="sourceCode cpp"><span class="cf">if</span></code>-statements, particularly during maintenance, for example:</p>
</blockquote>
<pre><code>```{.cpp}
int a,b,i;
// . . . 
if (i == 10){
       a = 5;       
       b = 10; // added later, but correct since within the {…}
      }
      else 
          a = 10;   
          b = 5;    // added later, intended to be part of the else clause
```</code></pre>
<blockquote>
<p>If the assignments to b were added later and were expected to be part of each <code class="sourceCode cpp"><span class="cf">if</span></code> and <code class="sourceCode cpp"><span class="cf">else</span></code> clause (they are indented as such), the above code is incorrect: the assignment to <code class="sourceCode cpp">b</code> that was intended to be in the <code class="sourceCode cpp"><span class="cf">else</span></code> clause is unconditionally executed.</p>
</blockquote>
<h3 id="guidance-to-language-users">6.28.2 Guidance to language users</h3>
<ul>
<li>Follow the rules provided in ISO/IEC TR 24772-1:2019 clause 6.28.5.</li>
</ul>
<blockquote>
<p>Enclose the bodies of <code class="sourceCode cpp"><span class="cf">if</span></code>, <code class="sourceCode cpp"><span class="cf">else</span></code>, <code class="sourceCode cpp"><span class="cf">while</span></code>, <code class="sourceCode cpp"><span class="cf">for</span></code>, and similar in braces. This will reduce confusion and potential problems when modifying the software.</p>
</blockquote>
<ul>
<li><p>Declare loop variables in the initializer of the loop statement</p></li>
<li><p>Prefer the standard library algorithms over hand-crafted loops.</p></li>
</ul>
<blockquote>
<p>See also the C++ Core Guidelines ES.85, ES.71, ES.74, ES.1 and ES.2</p>
</blockquote>
<h2 id="loop-control-variables-tex">6.29 Loop Control Variables [TEX]</h2>
<h3 id="applicability-to-language">6.29.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.29 exists in C++.</p>
<p>C++ allows the modification of loop control variables within non range-based loops. Though this is usually not considered good programming practice as it can cause unexpected problems, the flexibility of C++ expects the programmer to use this capability responsibly.</p>
<p>Since the modification of a loop control variable within a loop is infrequently encountered, reviewers of C++ code may not expect it and hence miss noticing the modification. Modifying the loop control variable can cause unexpected results if not carefully done. In C++, the following is valid:</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a;</span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; <span class="dv">10</span>; i++){</span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (a &gt; <span class="dv">7</span>)</span>
<span id="cb152-5"><a href="#cb152-5" aria-hidden="true" tabindex="-1"></a>        i = <span class="dv">10</span>;</span>
<span id="cb152-6"><a href="#cb152-6" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb152-7"><a href="#cb152-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>which would cause the for loop to exit once a is greater than 7 regardless of the number of iterations that have occurred.</p>
<p>C++ also permits the use of multiple variable of the same type in the loop header</p>
<p>In a range-based for loop, the control variable is not available.</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>array a {<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">5</span>};</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a> <span class="cf">for</span> (<span class="kw">auto</span> x : a) {</span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a> }</span></code></pre></div>
<h3 id="guidance-to-language-users">6.29.2 Guidance to language users</h3>
<ul>
<li><p>Apply the guidance of ISO/IEC TR 24772-1:2019 clause 6.29.5.</p></li>
<li><p>Do not modify a loop control variable within a loop. Even though the capability exists in C, it is still considered to be a poor programming practice.</p></li>
<li><p>Use a range for loop in preference to general loops</p></li>
<li><p>Alternatively, use std library functions like <code>copy</code>, <code>accumulate</code>, <code>transform</code>, <code>for_each</code>, etc. in preference to general loops.</p></li>
<li><p>Something about multiple loop control variables in the same loop?</p></li>
</ul>
<p>Note: See also the C++ Core Guidelines ES.71, ES.86,</p>
<h2 id="off-by-one-error-xzh">6.30 Off-by-one Error [XZH]</h2>
<h3 id="applicability-to-language">6.30.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.30 exists in C++.</p>
<p>Arrays are a common place for off by one errors to manifest. In C++, arrays are indexed starting at 0, causing the common mistake of looping from 0 to the size of the array as in:</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> foo() {</span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a[<span class="dv">10</span>];</span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i;</span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i=<span class="dv">0</span>, i&lt;=<span class="dv">10</span>, i++)</span>
<span id="cb154-5"><a href="#cb154-5" aria-hidden="true" tabindex="-1"></a>      ...</span>
<span id="cb154-6"><a href="#cb154-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="dv">0</span>);</span>
<span id="cb154-7"><a href="#cb154-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>C++ mitigates the issue of sentinel values in strings document in TR 24772-1 by providing the <code class="sourceCode cpp">string</code> class and the <code class="sourceCode cpp">string_view</code> class.</p>
<p>C++ does not flag accesses outside of array bounds, so an off by one error may not be as detectable in C++ as in some other languages. Several good and freely available tools can be used to help detect accesses beyond the bounds of arrays that are caused by an off by one error. However, such tools will not help in the case where only a portion of the array is used, and the access is still within the bounds of the array.</p>
<p>C++ mitigates these issues by providing</p>
<ul>
<li><p>Range-based for loops</p></li>
<li><p><code class="sourceCode cpp">std</code> algorithms</p></li>
<li><p>Iterator style loops terminated by <code class="sourceCode cpp">!=</code></p></li>
<li><p>Container classes</p></li>
<li><p><code class="sourceCode cpp">gsl::span</code> (soon to be <code class="sourceCode cpp"><span class="bu">std::</span>span</code>)</p></li>
</ul>
<h3 id="guidance-to-language-users">6.30.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance of ISO/IEC TR 24772-1:2019 clause 6.30.5.</p></li>
<li><p>Use careful programming, testing of border conditions, and static analysis tools to detect off-by-one errors in C++.</p></li>
<li><p>Use range-based for loops, std algorithms, iterator style loops terminated by !=, or container classes in preference to C-style arrays and structures.</p></li>
</ul>
<blockquote>
<p>See also the C++ Core guidelines ES.1, ES.42, ES.71, SL.con.3 (more to come)</p>
</blockquote>
<h2 id="structured-programming-ewd">6.31 Structured Programming [EWD]</h2>
<h3 id="applicability-to-language">6.31.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.31 exists in C++.</p>
<p>It is as easy to write structured programs in C++ as it is not to. C++ contains the goto statement, which can create unstructured code. Also, C has <code class="sourceCode cpp"><span class="cf">continue</span></code>, <code class="sourceCode cpp"><span class="cf">break</span></code>, and <code class="sourceCode cpp"><span class="cf">return</span></code> that can create a complicated control flow, when used in an undisciplined manner. Spaghetti code can be more difficult for static analyzers to analyze and is sometimes used on purpose to intentionally obfuscate the functionality of software. Code that has been modified multiple times by an assortment of programmers to add or remove functionality or to fix problems can be prone to become unstructured.</p>
<p>Because unstructured code in can cause problems for analyzers, both automated and human, of code, problems with the code may not be detected as readily or at all as would be the case if the software was written in a structured manner.</p>
<pre><code>&lt;1--
IMHO, a static analyzer worth its money would do any CFA DFA based on basic blocks and should not be bothered by gotos etc. Peter.
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.31.2 Guidance to language users</h3>
<ul>
<li><p>Write clear and concise structured code to make code as understandable as possible.</p></li>
<li><p>Avoid the use of <code>longjmp</code></p></li>
</ul>
<pre><code>&lt;!--
The guidance &quot;avoid the useof longjmp&quot; comes out of nowhere. It needs documentation in 6.31.1
--&gt;</code></pre>
<ul>
<li>Avoid the use of <code class="sourceCode cpp"><span class="cf">goto</span></code> except in the case of exiting a nested loop.</li>
</ul>
<p>See also the C++ Core guidelines ES.76, ES.77, SL.C.1</p>
<h2 id="passing-parameters-and-return-values-csj">6.32 Passing Parameters and Return Values [CSJ]</h2>
<h3 id="applicability-to-language">6.32.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.32 exists in C++. However, the language also provides appropriate mitigation.</p>
<p>C++ provides both <em>call by copy</em> (aka <em>call by value</em>) and <em>call by reference</em> parameter passing. The argument is evaluated to initialize the formal parameter (in the first case) or bound to the formal parameter (in the second case) of the function that is being called. A formal parameter behaves like a local variable, however, changes to a non-const reference parameter affect the bound object.</p>
<p>The rich type system of C++ allows types that when passed by value still have <em>call by reference</em> semantics, for example, pointer types, <code>std::reference_wrapper</code>, or class types with pointer or reference member variables.</p>
<p>C++ assumes that pointer or reference parameters of different types never alias, even if the underlying object representations are identical, i.e., for a function declared as <code class="sourceCode cpp"><span class="dt">void</span> f(<span class="dt">int</span> *pi, <span class="dt">long</span> *pl)</code> the compiler will assume that <code>pi</code> and <code>pl</code> always refer to different objects, even if <code class="sourceCode cpp"><span class="kw">sizeof</span>(<span class="dt">int</span>) == <span class="kw">sizeof</span>(<span class="dt">long</span>)</code>. Two parameters may refer to the same object if they have pointer or reference type, and the target types are the same or related. This means, aliasing between reference parameters or with a reference result needs to be taken into account in user code. For example, in an assignment expression the left and right hand side can refer to the same object. This implies that user-defined assignment operators must take precautions against self-assignment or document that it is forbidden.</p>
<p>Modern C++ ensures that in many cases the need for and overhead of copying value arguments or results is elided by the compiler, especially from temporary objects.</p>
<p>The use of <code class="sourceCode cpp"><span class="at">const</span></code> lvalue-reference parameters combines the efficiency of <em>call by reference</em> with the guarantee that the underlying input parameter is not changed (marking it as an <em>in</em> parameter). A non-const reference parameter must be considered an <em>inout</em> parameter. Rvalue-reference parameters are <em>inout</em> parameters that allow <em>transfer-of-ownership</em> semantics. At their call site it is best to assume that the argument object is in an indeterminate state and has to be reassigned before subsequent use. There is no language mechanism for marking <em>out</em> parameters, one would use the return mechanism. Instead of multiple <em>out</em> parameters a <code class="sourceCode cpp"><span class="kw">struct</span></code>, <code class="sourceCode cpp"><span class="bu">std::</span>pair</code>, or <code class="sourceCode cpp"><span class="bu">std::</span>tuple</code> can be used as a return type and eventually decomposed at the call site to its constituents via a <em>structured binding</em>.</p>
<p>Member functions take the <code class="sourceCode cpp">*<span class="kw">this</span></code> object as an implicit reference parameter. The kind of reference can be specified through qualification of the member function. However, in addition to lvalue-reference, const-lvalue-reference, and rvalue-reference qualification, there exists an oddity with respect to normal reference parameters:</p>
<ul>
<li>without a qualification a member function can be called on rvalues and non-const lvalues, and</li>
<li>with a const-qualification a member function can be called on const lvalues and rvalues.</li>
</ul>
<p>This means, unqualified member functions are callable on temporaries (rvalues) and thus can have side effects, but also can return an lvalue-reference to said temporary by returning <code>*this</code> (or members of <code>*this</code>), which can lead to dangling if such a reference is used beyond the expression of the function call returning it. For example, the compiler-provided assignment operators of a class are unqualified member functions that return an lvalue-reference to <code class="sourceCode cpp">*<span class="kw">this</span></code>.</p>
<p>Rvalue-reference parameters in a context where their actual type is deduced from the call site, are called <em>forwarding references</em>. A forwarding references will either be deduced to an lvalue-reference or an rvalue-reference depending on the argument at the call site.</p>
<p>The C++ preprocessor macros use a <em>call by name</em> parameter passing; a call to the macro replaces the macro by the body of the macro. This is called <em>macro expansion</em>. Macro expansion is applied to the program source text and amounts to the substitution of the formal parameters with the actual parameter expressions. Formal parameters are often parenthesized to avoid syntax issues after the expansion. Call by name parameter passing reevaluates the actual parameter expression each time the formal parameter is read.</p>
<h3 id="guidance-to-language-users">6.32.2 Guidance to language users</h3>
<ul>
<li><p>Follow the advice of ISO/IEC TR 24772-1:2019 clause 6.32.5.</p></li>
<li><p>Prefer pass-by-value and pass-by-const-reference over other means of parameter declaration.</p></li>
<li><p>Prefer reference parameters over corresponding pointer parameters.</p></li>
<li><p>Use pass by non-const reference only when side-effects on the argument are intended (<em>inout</em>-parameter).</p></li>
<li><p>Always reassign a variable passed by rvalue-reference before subsequent use after the call.</p></li>
<li><p>Use forwarding reference parameters only, if perfect forwarding is needed in the body of a function template or generic lambda.</p></li>
<li><p>Define member functions that have side effects on <code class="sourceCode cpp">*<span class="kw">this</span></code> or return a potentially dangling object referring to <code>*this</code> or its members with the appropriate lvalue-ref-qualification. Either delete the rvalue-ref-qualified overload if a const-ref-qualified overload exists to avoid calling the function on temporary objects, or define the rvalue-ref-qualified overload as returning by value.</p></li>
<li><p>Document the referents of potentially dangling objects created by or modified by a function if any potentially dangling object outlives the invocation of that function.</p></li>
<li><p>Document any allowable aliasing between the referents of function parameters of potentially dangling type. Absent such documentation, avoid passing aliased parameters. In particular, aliasing is expected and allowed in these classes of functions:</p>
<ul>
<li><p>Assignment and compound assignment operators: the right parameter may alias the left parameter. The function result always refers to the left parameter unless overloaded differently. In the case of self-assignment the stored value should not change.</p></li>
<li><p>Functions named <code class="sourceCode cpp">swap</code>: The two parameters to be swapped may refer to the same object.</p></li>
<li><p>Shift operators used for input and output: the result always refers to the left parameter.</p></li>
<li><p>Prefix increment and decrement operators: the result always refers to the parameter.</p></li>
</ul></li>
<li><p>Do not use function-like macros. If used, surround all macro parameters in the replacement text with parenthesis.</p></li>
</ul>
<h2 id="dangling-references-to-stack-frames-dcm">6.33 Dangling References to Stack Frames [DCM]</h2>
<h3 id="applicability-to-language">6.33.1 Applicability to language</h3>
<p>C++ allows one variable to refer to another variable. For example, a pointer variable can contain the address of another variable; a reference can be bound to a variable; and an iterator can point to a portion of a variable (in this case a container). Should the referencing variable outlive the referenced variable, the subsequent operations through the referencing variable will have undefined behavior.</p>
<p>For example</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> *bad_pointer() {</span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a = <span class="dv">0</span>;</span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> &amp;a;</span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a> }</span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-6"><a href="#cb157-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span>&amp; bad_reference() {</span>
<span id="cb157-7"><a href="#cb157-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a = <span class="dv">0</span>;</span>
<span id="cb157-8"><a href="#cb157-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> a;</span>
<span id="cb157-9"><a href="#cb157-9" aria-hidden="true" tabindex="-1"></a> }</span>
<span id="cb157-10"><a href="#cb157-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-11"><a href="#cb157-11" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">3</span>&gt;::iterator bad_iterator()</span>
<span id="cb157-12"><a href="#cb157-12" aria-hidden="true" tabindex="-1"></a> {</span>
<span id="cb157-13"><a href="#cb157-13" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">3</span>&gt; a = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };</span>
<span id="cb157-14"><a href="#cb157-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> a.begin();</span>
<span id="cb157-15"><a href="#cb157-15" aria-hidden="true" tabindex="-1"></a> }</span>
<span id="cb157-16"><a href="#cb157-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-17"><a href="#cb157-17" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> bad_lambda() {</span>
<span id="cb157-18"><a href="#cb157-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x = <span class="dv">0</span>;</span>
<span id="cb157-19"><a href="#cb157-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [&amp;] { x = <span class="dv">1</span>; };</span>
<span id="cb157-20"><a href="#cb157-20" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb157-21"><a href="#cb157-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-22"><a href="#cb157-22" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> erroneous_use() {</span>
<span id="cb157-23"><a href="#cb157-23" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; *bad_pointer();</span>
<span id="cb157-24"><a href="#cb157-24" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; bad_reference();</span>
<span id="cb157-25"><a href="#cb157-25" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; *bad_iterator();</span>
<span id="cb157-26"><a href="#cb157-26" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; bad_lambda()();</span>
<span id="cb157-27"><a href="#cb157-27" aria-hidden="true" tabindex="-1"></a> }</span></code></pre></div>
<p><em>need to say something about lifetime extension, returning references, range for vulnerability with dangling references from temporaries. Peter</em></p>
<h3 id="guidance-to-language-users">6.33.2 Guidance to language users</h3>
<ul>
<li><p>Do not assign the address of an object, or reference to any entity where the referencing entity persists after the object has ceased to exist. This is done in order to avoid the possibility of a dangling reference.</p></li>
<li><p>Do not return the address of a local variable as the result of a function call.</p></li>
<li><p>Do not return a local variable as the result of a function returning a reference type</p></li>
<li><p>Avoid capturing by reference in lambdas that will be used non-locally, including return, or passing it to another thread, or stored in dynamic memory</p></li>
</ul>
<p>See also C++ Core Guidelines F.53, …</p>
<h2 id="OTR">6.34 Subprogram Signature Mismatch [OTR]</h2>
<h3 id="applicability-to-language">6.34.1 Applicability to language</h3>
<p>In general, there must be a match between the number of parameters in a function call and the number of arguments in the function definition. For issues related to macro signatures, see subclause <a href="NMP">Pre-processor directives[NMP]</a>.</p>
<p>The number of arguments can be different to the number of parameters in a function where: - a function template includes a <em>function parameter pack</em>, or - a function parameter includes a default argument, or - a function parameter-declaration-clause ends with an ellipsis, <code>f(\...)</code>.</p>
<p>Calling a function template with a <em>function parameter pack</em> results in a specialization of the function with the parameter types matching the corresponding argument types.</p>
<p>The compiler will ensure for variadic templates that the type and number of arguments is correct.</p>
<p>A call to a function with default arguments can provide fewer arguments than parameters as long as the parameters for which no explicit argument is provided include a default argument.</p>
<p>Where a function parameter-declaration-clause ends with an ellipsis, additional arguments can be accessed through the mechanisms provided by <code>&lt;cstdarg&gt;</code>. No information about the number or types of the parameters is supplied by the compiler. The use of this feature outside of special situations can be the basis for vulnerabilities.</p>
<p>Undefined behavior can arise, for example:</p>
<ul>
<li>Arguments with integral or enumeration type that are passed to an ellipsis parameter will undergo integral promotions, and so the type of the parameter is <code>int</code> and not <code>short</code>. The use of <code>short</code> with <code>va_arg</code> is therefore invalid.</li>
</ul>
<div class="sourceCode" id="cb158"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;cstdarg&gt;</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">int</span> cnt, ...)</span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">va_list</span> ap;</span>
<span id="cb158-6"><a href="#cb158-6" aria-hidden="true" tabindex="-1"></a>  va_start (ap, cnt);</span>
<span id="cb158-7"><a href="#cb158-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-8"><a href="#cb158-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">short</span> i = va_arg (ap, <span class="dt">short</span>);  <span class="co">// Invalid type</span></span>
<span id="cb158-9"><a href="#cb158-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-10"><a href="#cb158-10" aria-hidden="true" tabindex="-1"></a>  va_end(ap);</span>
<span id="cb158-11"><a href="#cb158-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<ul>
<li>In the following case, <code>f1</code> assumes that there will be two parameters after the named parameter.</li>
</ul>
<div class="sourceCode" id="cb159"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstdarg&gt;</span></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">int</span> cnt, ...)</span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">va_list</span> ap;</span>
<span id="cb159-6"><a href="#cb159-6" aria-hidden="true" tabindex="-1"></a>  va_start (ap, cnt);</span>
<span id="cb159-7"><a href="#cb159-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-8"><a href="#cb159-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i = va_arg (ap, <span class="dt">int</span>);</span>
<span id="cb159-9"><a href="#cb159-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> j = va_arg (ap, <span class="dt">int</span>);</span>
<span id="cb159-10"><a href="#cb159-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-11"><a href="#cb159-11" aria-hidden="true" tabindex="-1"></a>  va_end(ap);</span>
<span id="cb159-12"><a href="#cb159-12" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb159-13"><a href="#cb159-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-14"><a href="#cb159-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f2 ()</span>
<span id="cb159-15"><a href="#cb159-15" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb159-16"><a href="#cb159-16" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>);  <span class="co">// OK</span></span>
<span id="cb159-17"><a href="#cb159-17" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>, <span class="dv">2</span>);     <span class="co">// results in undefined behaviour</span></span>
<span id="cb159-18"><a href="#cb159-18" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>These issues cannot occur where default arguments or variadic function templates are used.</p>
<p>The C++ Name mangling ensures that function signatures match accross translation units.</p>
<p>This does not apply to other mangling schemes. For example, parameters do not form part of the mangled name for functions declared with the <code>extern "C"</code> linkage specification. Thus such a function can be invoked with incorrect parameter types due to an incorrect redeclaration of the function:</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="co">// library.cc</span></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> <span class="dt">void</span> foo (<span class="dt">unsigned</span>, <span class="dt">unsigned</span>)</span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb161"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="co">// main.cc</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> <span class="dt">void</span> foo (<span class="dt">unsigned</span>);</span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main ()</span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a>  foo (<span class="bn">0xffffffff</span>);  <span class="co">// Calling function that is</span></span>
<span id="cb161-8"><a href="#cb161-8" aria-hidden="true" tabindex="-1"></a>                     <span class="co">// defined to take 2 parameters</span></span>
<span id="cb161-9"><a href="#cb161-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h3 id="guidance-to-language-users">6.34.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1:2019 clause 6.34.5.</p></li>
<li><p>Do not use functionality from <code>&lt;cstdarg&gt;</code>; use variadic function templates instead.</p></li>
<li><p>When using functions declared with <code>extern "C"</code> linkage specifications, use static analysis tools to ensure that all such declarations of equally named functions have identical signatures.</p></li>
</ul>
<p>Note: See also C++ Core Guidelines F.55.</p>
<h2 id="recursion-gdl">6.35 Recursion [GDL]</h2>
<h3 id="applicability-to-language">6.35.1 Applicability to language</h3>
<p>C++ permits recursion, hence is subject to the problems described in ISO/IEC TR 24772-1:2019 clause 6.35.</p>
<h3 id="guidance-to-language-users">6.35.2 Guidance to language users</h3>
<ul>
<li>Apply the guidance described in TR 24772-1 clause 6.35.5.</li>
</ul>
<h2 id="ignored-error-status-and-unhandled-exceptions-oyb">6.36 Ignored Error Status and Unhandled Exceptions [OYB]</h2>
<h3 id="applicability-to-language">6.36.1 Applicability to language</h3>
<p>The vulnerabilities described in ISO/IEC TR 24772-1:2019 clause 6.36 exist in C++.</p>
<p>By default, C++ has the C weakness of permitting the call to a function that returns an error code without capturing the return value in a variable. For example</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a>errnum foo( <span class="dt">int</span> a, <span class="dt">int</span> b);</span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a>. . .</span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a>foo(x, y); <span class="co">// failure to capture the return error code.</span></span></code></pre></div>
<p>C++ offers as a mitigating mechanism the [[nodiscard]] attribute. This attribute indicates that the function result must not be discarded.</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a>[[<span class="at">nodiscard</span>]] errnum foo( <span class="dt">int</span> a, <span class="dt">int</span> b);</span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a>. . .</span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a>foo(x, y);  <span class="co">// compile error.</span></span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>( <span class="kw">auto</span> e = foo(a,b); e == <span class="dv">0</span>) { <span class="co">// no compile error</span></span>
<span id="cb163-6"><a href="#cb163-6" aria-hidden="true" tabindex="-1"></a><span class="co">// success</span></span>
<span id="cb163-7"><a href="#cb163-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb163-8"><a href="#cb163-8" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> {</span>
<span id="cb163-9"><a href="#cb163-9" aria-hidden="true" tabindex="-1"></a><span class="co">// handle errors</span></span>
<span id="cb163-10"><a href="#cb163-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>&lt;!--
Should we include a discussion about C++ error_code??? AI -- Michael Wong
--&gt;</code></pre>
<p>The header <code>&lt;system_error&gt;</code> defines types and functions used to report error conditions originating from the operating system, streams I/O, <a href="https://en.cppreference.com/w/cpp/thread/future"><code>std::future</code></a>, or other low-level APIs.</p>
<p>Defined in header <code>&lt;system_error&gt;</code> since C++11.</p>
<p>std::error_category serves as the base class for specific error category types, such as <a href="https://en.cppreference.com/w/cpp/error/system_category"><code class="sourceCode cpp"><span class="bu">std::</span>system_category</code></a>, <a href="http://en.cppreference.com/w/cpp/io/iostream_category"><code class="sourceCode cpp"><span class="bu">std::</span>iostream_category</code></a>, etc. Each specific category class defines the <code>error_code</code> - error_condition mapping and holds the explanatory strings for all error_conditions. The objects of error category classes are treated as singletons, passed by reference.</p>
<p><code>std::error_code</code> is a platform-dependent error code. Each <code>std::error_code</code> object holds an error code originating from the operating system or some low-level interface and a pointer to an object of type <a href="https://en.cppreference.com/w/cpp/error/error_category"><code class="sourceCode cpp"><span class="bu">std::</span>error_category</code></a>, which corresponds to the said interface. The error code values may be not unique across different error categories.</p>
<pre><code>&lt;!--
Discuss global error states, such as errno (which is thread-local) but still static.
---&gt;</code></pre>
<p>Global state for error codes is hard to manage and it is easy to forget to check it (C++ Core Guidelines E.28).</p>
<p>C++ offers a set of library-defined exceptions for error conditions that may be detected by checks that are performed by the standard library. In addition, the programmer may define exceptions that are appropriate for their application. These exceptions are handled using an exception handler. Exceptions may be handled in the environment where the exception occurs or may be propagated out to an enclosing scope.</p>
<h3 id="guidance-to-language-users">6.36.2 Guidance to language users</h3>
<ul>
<li><p>Follow the mitigation mechanisms of subclause 6.36.5 of ISO/IEC TR 24772-1:2019.</p></li>
<li><p>Check the returned error status upon return from a function. The C standard library functions provide an error status as the return value and sometimes in an additional global error value.</p></li>
<li><p>Use static analysis tools to detect and report missing or ineffective error detection or handling.</p></li>
<li><p>Avoid error handling based on global state.</p></li>
<li><p>Use <code class="sourceCode cpp">[[<span class="at">nodiscard</span>]]</code> to prevent callers from ignoring error values.</p></li>
<li><p>Prefer throwing exceptions to returning error values.</p></li>
<li><p>Use destructors to manage the finalization of the current context upon exit, whether erroneous or not.</p></li>
<li><p>Return error values from each enclosing function until an alternative strategy is available. Consider throwing an exception in lieu of returning an error value.</p></li>
<li><p>Handle exceptions at each function where an alternative strategy is available. In functions where no alternative strategy is available, do not catch the exception.</p></li>
<li><p>Consider termination as a last resort strategy for main or for noexcept functions.</p></li>
<li><p>Notify higher level constructs before a thread is allowed to terminate.</p></li>
<li><p>Consider the use of an <code>exception_ptr</code> object to transport an exception from the terminating thread to another thread for further processing.</p></li>
</ul>
<p>See also C++ Core Guidelines E.1, E.2, E.5, E.6, E.13, E.17, E.19, E.25, and E.28.</p>
<h2 id="type-breaking-reinterpretation-of-data-amv">6.37 Type-breaking Reinterpretation of Data [AMV]</h2>
<h3 id="applicability-to-language">6.37.1 Applicability to language</h3>
<p><em>This subclause requires a complete rewrite to have it reflect C++ issues.</em></p>
<p>The primary way in C that a reinterpretation of data is accomplished is through a union which may be used to interpret the same piece of memory in multiple ways. If the use of the union members is not managed carefully, then unexpected and erroneous results may occur.</p>
<p>C allows the use of pointers to memory so that an integer pointer could be used to manipulate character data. This could lead to a mistake in the logic that is used to interpret the data leading to unexpected and erroneous results.</p>
<p>C Part says</p>
<p><em>Wait for Gabriel</em> <em>to help analyze this.</em></p>
<h3 id="guidance-to-language-users">6.37.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1:2019 clause 6.38.5.</p></li>
<li><p>When using unions, implement an explicit discriminant and check its value before accessing the data in the union.</p></li>
<li><p>Ensure through static analysis that arbitrary pointer casts return a type compatible with the source.<span data-custom-style="annotation reference"></span></p></li>
<li><p>Avoid the use of C-style casts and reinterpret_cast</p></li>
</ul>
<h2 id="deep-vs.-shallow-copying-yan">6.38 Deep vs. Shallow Copying [YAN]</h2>
<h3 id="applicability-to-language">6.38.1 Applicability to Language</h3>
<p>The vulnerability described in ISO/IEC TR 24772-1:2019 clause 6.38 exists in C++.</p>
<p>The vulnerability only arises in C++ when there is a mismatch between the object’s copy semantics and the programmer’s intent. (references to Core Guidelines C.22)</p>
<p>C++ objects, by default, are copied member-wise. Each class type may define its own copy, move and assignment operations, allowing a class author to choose an appropriate depth for these operations. Class member types should be chosen to have copy and move semantics that support the semantics of the enclosing class.</p>
<pre><code>&lt;!--
This may belong elsewhere -- TBD\&gt; C++ provides the &quot;string view&quot;
mechanism as safer pointers to strings. Updates through string view are
prohibited, but the initial non &quot;view&quot; value can be updated and this
change will be seen by all viewers, even if they are dependent on fixed
value.
--&gt;</code></pre>
<p>Note: in C++, this is more commonly known as member-wise copying vs semantic copying, or owning vs observing rights.</p>
<pre><code>&lt;!--
Note: Why CERT does not address this issue -- involves programmer intent
and not readily tool-checkable.
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.38.2 Guidance to language users</h3>
<ul>
<li><p>Prefer the composition of most types from types that have either value semantics or semantics that support the intended copy and move semantics of the enclosing type.</p></li>
<li><p>When the above is not achievable, ensure that the copy assignment operator, copy constructor, move assignment operator, move constructor and destructor provide the desired semantics.</p></li>
<li><p>Avoid the use of raw pointers with the copy operation and (finish or delete)</p></li>
<li><p>Follow the guidance of C++ core guidelines C.20, C.22, C.32, C.67</p></li>
<li><p><em>&lt;This may belong elsewhere – TBD&gt;</em> Avoid updating the value of a string while there are valid string views in existence.</p></li>
</ul>
<h2 id="memory-leak-and-heap-fragmentation-xyl">6.39 Memory Leak and Heap Fragmentation [XYL]</h2>
<h3 id="applicability-to-language">6.39.1 Applicability to language</h3>
<p>The memory leak vulnerability documented in ISO/IEC TR24772-1:2019 clause 6.39 exists in C++, unless the programmer takes steps to avoid it.</p>
<p>C++ uses destructors, and a pattern called <em>Resource Acquisition Is Initialization (RAII)</em> which performs recovery of resources. Destructors (and therefore memory and resource releases) are deterministically ordered with respect to other events on their thread. Object destructors will not be called</p>
<ul>
<li><p>When an unhandled exception escapes its thread of execution</p></li>
<li><p>Under conditions of abnormal termination</p></li>
</ul>
<p>See CERT ERR50-CPP for list of cases.</p>
<p>The steps mentioned above will mitigate most memory leak issues.</p>
<p>The mechanisms <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr</code> and <code class="sourceCode cpp"><span class="bu">std::</span>shared_future</code> and similarly constructed reference-counting user code do not detect cycles which will cause leaks because the shared pointers (and hence what they point to) will not be destroyed.</p>
<pre><code>&lt;!--
need to clarify to rely on memory managing types, containers, and unique ptr, shared ptr is often bad , Peter
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.39.2 Guidance to language users</h3>
<ul>
<li><p>Use containers and smart pointers in preference to direct (manual) memory management.</p></li>
<li><p>Follow C++ Core guidelines section R and CERT MEM51.</p></li>
<li><p>For heap fragmentation issues, follow the guidance of ISO/IEC TR 24772-1:2019 clause 6.39.5. In particular, create pools of fixed size with user-defined operators new and operators delete.</p></li>
<li><p>Use dynamic analysis tools to detect cycles.</p></li>
<li><p>Break cycles, for example by using <code class="sourceCode cpp"><span class="bu">std::</span>weak_ptr</code> or appropriate weak pointers.</p></li>
<li><p>Use <code class="sourceCode cpp"><span class="bu">std::</span>abort()</code> or <code class="sourceCode cpp"><span class="bu">std::</span>terminate()</code> and related functions only in extreme situations. See CERT ERR50-CPP for list of cases.</p></li>
<li><p>Use debugging tools such as leak detectors to help identify unreachable memory.</p></li>
</ul>
<h2 id="SYM">6.40 Templates and Generics [SYM]</h2>
<h3 id="applicability-to-language">6.40.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1 clause 6.40 exists in C++. C++ provides the facility <em>Templates</em> to support the generic programming methodology. C++ Templates can be variadic templates. C++ Templates can accept as arguments types, templates, and values, including addresses of global variables. <em>Concepts</em> improve template argument checking at compile time.</p>
<p>Programming language compilers help programmers avoid run-time errors by performing static analysis on the code and generating diagnostics that prevent run-time errors. Therefore, the goal of the C++ language is to help transition code towards compile-time analysis instead of relying on runtime executions that result in run-time failures. Templates are one of the favourable mechanisms to achieve this goal of maximizing compile-time analysis to reduce or eliminate run-time analysis.</p>
<p>When used appropriately, they are suitable for embedded and safety critical systems;</p>
<ul>
<li><p>They provide type safe generic in contrast to legacy void*-based or macro-based genericity;</p></li>
<li><p>They have no runtime overhead for inline operations; and</p></li>
<li><p>They have no memory used or code generated for unused operations which are both critical in limited resource systems.</p></li>
</ul>
<p>Excessive use of templates can lead to cognitive overload in terms of learning, understanding and the maintainability of the code. This clause provides explanation and guidance to mitigate problems that can arise.</p>
<p>From ISO/IEC TR 24772-1:2019 clause 6.40.1 (or .3) "Confusion, and hence potential vulnerability, can arise where the instantiated code is apparently invalid, but does not result in a compiler error. For example, a generic class defines a set of members, a subset of which rely on a particular property of the instantiation type (such as a generic container class with a sort member function, only the sort function relies on the instantiating type having a defined relational operator). In some languages, such as C++, if the generic is instantiated with a type that does not meet all the requirements but the program never subsequently makes use of the subset of members that rely on the property of the instantiating type, the code will compile and execute (for example, the generic container is instantiated with a user defined class that does not define a relational operator, but the program never calls the sort member of this instantiation). When the code is reviewed the generic class will appear to reference a member of the instantiating type that does not exist."</p>
<p>The above paragraph does not correctly characterise the issue. In an implicit instantiation of a class template, only those functions that are ODR (one definition rule)-used are instantiated. Therefore, a template argument need not provide all of the operations used by all possible member functions of the class template. This case is exhibited in the standard library. std::vector&lt;T&gt;::emplace requires an accessible constructor of T. The Factory pattern makes constructors of a class C inaccessible to anyone but the factory functions. Still it is desirable to use std::vector with objects of type C. In this case, emplace cannot be used, which is clearly the intended behaviour of the class because objects of type C should only be constructed by the factory functions.</p>
<p>It is the nature of templates that every method that is not called is not compiled. If the program is changed such that a function is later ODR-used and the program recompiled, Three possible outcomes are:</p>
<ul>
<li><p>The program compiles and executes safely;</p></li>
<li><p>The program fails to compile; or</p></li>
<li><p>The program executes erroneously.</p></li>
</ul>
<p>Vulnerabilities that arise from the third case are covered elsewhere in the document(list), however, in the case of templates, the fact that code is written and may not be instantiated for a long time since code that invokes it has not been written, errors may not appear until later.</p>
<p>Features such as concepts and <code class="sourceCode cpp"><span class="kw">static_assert</span></code> can be used to mitigate the issue.</p>
<pre><code>&lt;!--
Mitigation* *-- ensure complete coverage of Template code with unit tests
--&gt;</code></pre>
<p>The third case is not specific to templates, except that the problem may be hidden is addressed in 6.2.</p>
<p>In the above paragraph, cases can arise where the programmer has not provided a type with all of the operations needed to function correctly in the template. For example,</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt; <span class="kw">typename</span> ForwardIterator , <span class="kw">typename</span> Value &gt;</span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a>   ForwardIterator find (ForwardIterator first, ForwardIterator last, <span class="at">const</span> Value &amp; val)</span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a>   {</span>
<span id="cb170-4"><a href="#cb170-4" aria-hidden="true" tabindex="-1"></a>       <span class="cf">while</span> ( first != last &amp;&amp; * first == val )</span>
<span id="cb170-5"><a href="#cb170-5" aria-hidden="true" tabindex="-1"></a>       ++ first ;</span>
<span id="cb170-6"><a href="#cb170-6" aria-hidden="true" tabindex="-1"></a>       <span class="cf">return</span> first</span>
<span id="cb170-7"><a href="#cb170-7" aria-hidden="true" tabindex="-1"></a>   }</span></code></pre></div>
<p>The standard says that</p>
<ul>
<li><p>the first template argument must be a forward iterator.</p></li>
<li><p>the second template argument type must be comparable to the value type of that iterator using <code class="sourceCode cpp">==</code>.</p></li>
</ul>
<p>These requirements are implicit and all the compiler has to go by is their use in the function body. The result is great flexibility, splendid generated code for correct calls, and spectacularly bad error messages for incorrect calls. The obvious solution is to specify the first two requirements as part of the template’s interface:</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt; forward_iterator Iter , <span class="kw">typename</span> Value &gt;</span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a>          <span class="kw">requires</span> equality_comparable &lt;Value, Iter :: <span class="dt">value_type</span> &gt;</span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a>forward_iterator find ( Iter first, Iter last, <span class="at">const</span> Value &amp; val );</span></code></pre></div>
<p>This is roughly what C++20 offers. Note the equality_comparable concept. It captures the required relationship between the two template arguments.</p>
<p>The general C++11 <code class="sourceCode cpp"><span class="kw">static_assert</span></code> can also be used:</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span> ( Equality_comparable &lt;<span class="dt">int</span> &gt;);       <span class="co">// succeeds</span></span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span> &lt; Eeqality_comparable &lt;<span class="dt">int</span> ,<span class="dt">long</span> &gt;); <span class="co">// succeeds</span></span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> S { <span class="dt">int</span> a; };</span>
<span id="cb172-4"><a href="#cb172-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span> ( Equality_comparable &lt;S&gt;);         <span class="co">// fails because structs don&#39;t</span></span>
<span id="cb172-5"><a href="#cb172-5" aria-hidden="true" tabindex="-1"></a>                                                       <span class="co">// automatically get == &amp; !=</span></span></code></pre></div>
<p><code class="sourceCode cpp"><span class="kw">static_assert</span> ( Equality_comparable \&lt;<span class="dt">int</span> \&gt;);</code></p>
<p><strong><u>Discussion of “ranges”</u></strong></p>
<p>Using the example above, the first two function arguments must denote a sequence. To express this requirement (that [first:last) is a sequence), requires a library extension. C++20 offers that in the Ranges standard-library component (§9.3.5). Hence in the example below we replace iterators with ranges:</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt; range R, <span class="kw">typename</span> Value &gt;</span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a><span class="kw">requires</span> equality_comparable &lt;Value , Range :: <span class="dt">value_type</span> &gt;</span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a>forward_iterator find (R r, <span class="at">const</span> Value &amp; val )</span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb173-5"><a href="#cb173-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> first = begin (r);</span>
<span id="cb173-6"><a href="#cb173-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">auto</span> last = end (r);</span>
<span id="cb173-7"><a href="#cb173-7" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> ( first != last &amp;&amp; * first == val )</span>
<span id="cb173-8"><a href="#cb173-8" aria-hidden="true" tabindex="-1"></a>   ++ first ;</span>
<span id="cb173-9"><a href="#cb173-9" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> first</span>
<span id="cb173-10"><a href="#cb173-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p><span data-custom-style="annotation reference"></span></p>
<p><strong>Other issues</strong></p>
<p>Overload resolution of templates differs from the overload resolution of non-template code. This can result in methods or operators being chosen that are unexpected by the developer.</p>
<p>A template constructor is never a copy or move constructor and hence does not prevent the implicit definition of a copy or move constructor even if the constructor looks similar.</p>
<p>There are cases, however, where the instantiation of a template with a parameter that matches syntactic but not semantic requirements, such as ++ for a pointer, will compile and execute but will be wrong and can result in undefined behaviour. Other examples relate to incomplete class types, see subclause <a href="#IHN">Type system [IHN]</a>.</p>
<pre><code>&lt;!--
Another issue -- likely to be placed elsewhere and referenced here

Standard vector construction issue where braces are replaced with curly
braces. (Paul)

Guidance -- use braces initially and only use other format if the
compiler fails ???
--&gt;</code></pre>
<pre><code>&lt;!--
(Examples needed)
--&gt;</code></pre>
<pre><code>&lt;!--
Core guidelines (fill in references)

I.9 T.10, T.11, 12, 13, T.20, T.21, T.22, T.23, T.24, T.25, T.26, T.30,
T.31 -- forward to Clive.

(*We may wish to summarize)*
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.40.2 Guidance to language users</h3>
<ul>
<li>Use static analysis tools to diagnose the use of inappropriate types in a template interface</li>
</ul>
<pre><code>&lt;!--
-   *Cyclic dependencies and ODR (one definition rule) use ...*
--&gt;</code></pre>
<ul>
<li><p>Consider using <em>concepts</em> for each template type parameter</p></li>
<li><pre><code>  Create and use concepts that specify &quot;meaningful&quot; semantics</code></pre></li>
<li><p>Write templates that check if a specific template argument fulfills the minimal syntactic requirements for the template, for example by using static_assert with type_traits.</p></li>
<li><p>Be aware that a constructor template or assignment operator function template will not replace compiler-provided special member functions</p></li>
<li><p>For generic operator functions, consider providing them as hidden friends through<span data-custom-style="annotation reference"></span> mix-in class templates.</p></li>
</ul>
<blockquote>
<p>As an example, the following class template defines equality operators for single-element structs (Template parameter U):</p>
</blockquote>
<div class="sourceCode" id="cb179"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> U&gt;</span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Eq{</span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span></span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">operator</span>==(U <span class="at">const</span> &amp;l, U <span class="at">const</span>&amp; r) <span class="kw">noexcept</span> {</span>
<span id="cb179-5"><a href="#cb179-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> &amp;[vl]=l;</span>
<span id="cb179-6"><a href="#cb179-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> &amp;[vr]=r;</span>
<span id="cb179-7"><a href="#cb179-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> vl == vr;</span>
<span id="cb179-8"><a href="#cb179-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb179-9"><a href="#cb179-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span></span>
<span id="cb179-10"><a href="#cb179-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">operator</span>!=(U <span class="at">const</span> &amp;l, U <span class="at">const</span>&amp; r) <span class="kw">noexcept</span> {</span>
<span id="cb179-11"><a href="#cb179-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> !(l==r);</span>
<span id="cb179-12"><a href="#cb179-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb179-13"><a href="#cb179-13" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb179-14"><a href="#cb179-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-15"><a href="#cb179-15" aria-hidden="true" tabindex="-1"></a><span class="co">// usage of the above, check that type X obtains operator== and operator!=</span></span>
<span id="cb179-16"><a href="#cb179-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-17"><a href="#cb179-17" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> X: Eq&lt;X&gt;{</span>
<span id="cb179-18"><a href="#cb179-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> val;</span>
<span id="cb179-19"><a href="#cb179-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="kw">explicit</span></span>
<span id="cb179-20"><a href="#cb179-20" aria-hidden="true" tabindex="-1"></a>    X(<span class="dt">int</span> v):val{v}{}</span>
<span id="cb179-21"><a href="#cb179-21" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb179-22"><a href="#cb179-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-23"><a href="#cb179-23" aria-hidden="true" tabindex="-1"></a>   <span class="kw">static_assert</span>(X{<span class="dv">42</span>} != X{<span class="dv">43</span>} &amp;&amp; X{<span class="dv">42</span>} == X{<span class="dv">42</span>} );</span></code></pre></div>
<p>The advantage in using the above mechanism is that these overloads are only visible comparing objects of type X, and not for other types. Implementing them as free functions increases likelihood that implicit conversions will result in the wrong function being called.</p>
<ul>
<li>Use qualified-id or this-&gt; to refer to names that may be found in a dependent base</li>
</ul>
<blockquote>
<p><em>Needs an example and explanation in 6.40.1 (AI Paul)</em></p>
</blockquote>
<ul>
<li><p>For template specialization, declared the specialization:</p>
<ol type="1">
<li><p>In the same file as the primary template; or</p></li>
<li><p>In the same file as the user-defined type for which the specialization is declared.</p></li>
</ol></li>
<li><p>Do not specialize function templates, except when specialization is on a non-deduceable template parameter</p></li>
</ul>
<h2 id="RIP">6.41 Inheritance [RIP]</h2>
<h2 id="applicability-to-language">6.41.1 Applicability to language</h2>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.41 is applicable to C++.</p>
<p>Inheritance, the ability to create enhanced and/or restricted object classes based on existing object classes, can introduce a number of vulnerabilities, both inadvertent and malicious. Because inheritance allows the overriding of methods of the parent class and because object-oriented systems are designed to separate and encapsulate code and data, it can be difficult to determine where in the hierarchy an invoked method is actually defined.</p>
<p>Also, since an overriding method does not need to call the method in the parent class that has been overridden, essential manipulation of class data may be bypassed.</p>
<p>This can be especially dangerous in copy assignment operator and move assignment operators and in particular when private data components (that is, data components not visible to methods of subclasses) of the parent class are left unchanged. Serious violations of type invariants can arise as a consequence.</p>
<p>Multiple inheritance adds additional complexities to the resolution of method invocations.</p>
<p>The use of inheritance can lead to an exploitable application vulnerability or negatively impact system safety in several ways:</p>
<ul>
<li><p>Execution of malicious redefinitions, which can occur through the insertion of a class into the class hierarchy that overrides commonly called methods in the parent classes.</p>
<ul>
<li><pre><code>  mitigation -- make member functions</code></pre>
<p><code class="sourceCode cpp"><span class="kw">final</span></code>,</p></li>
<li><pre><code>  reduce the use of inheritance</code></pre></li>
</ul></li>
<li><p>Accidental override, where a member function is defined that inadvertently overrides a member function that has already been defined in a parent class.</p>
<ul>
<li><pre><code>  Mitigation -- use `override`{.cpp} and</code></pre>
<code class="sourceCode cpp"><span class="kw">final</span></code> keywords on member functions to generate compiler diagnostics when overriding is accidental</li>
</ul></li>
<li><p>Accidental failure to override, when a method is incorrectly named or the parameters are not defined properly, and thus does not override a member function in a parent class.</p>
<ul>
<li><pre><code>  Mitigation -- use `override`{.cpp} and</code></pre>
<code class="sourceCode cpp"><span class="kw">final</span></code> keywords on member functions to generate compiler diagnostics when overriding is accidental</li>
</ul></li>
<li><p>Breaking of class invariants, which can be caused by redefining methods that assign, move, or validate class data without including the assigning, moving or validating in the overriding member function. This applies particularly to class invariants involving data of the parent class not visible in methods of the subclass. Inherited methods of the parent that have access to these “private” components will likely fail, if the components are set inappropriately.</p>
<ul>
<li><pre><code>  Mitigation -- if any class invariant depends upon a value of a</code></pre>
data member, then make that member private</li>
</ul></li>
<li><p>Direct reading and writing of visible class members when matching getting and setting member functions include additional functionality.</p>
<ul>
<li><pre><code>  Guidance: make data members private and provide a public</code></pre>
interface to access them that preserves class invariants.</li>
</ul></li>
</ul>
<p>These vulnerabilities can increase dramatically as the complexity of the hierarchy increases, especially in the use of multiple inheritance.</p>
<p>As member functions are inherited from multiple chains of ancestors, the determination of which member function implementations exist and are being called, becomes increasingly more difficult for the programmer. Understanding which member functions and data members apply to a given (sub)class becomes exceedingly difficult if these methods or components are inherited homographs (i.e., data components with identical names or member functions with identical signatures). Misunderstandings lead to inadvertent coding errors. The complexity increases even more when multiple inheritance is used to model “has-a” relationships (see subclause <a href="#BLP">Violations of the Liskov substitution principle[BLP]</a>: member functions never intended to be applicable to instances of a subclass are inherited nevertheless. For example, an instance of class aircraftCarrier may be “turn”ed merely because it obtained its propulsion screw by a “has-a”-inheritance with “turn” being an obviously meaningful method for the class of propulsionScrew. Meanwhile the user has a quite different expectation of what it means to turn an aircraft carrier. The complications increase if the carrier inherits twice from the class propulsionScrew because it has two propulsion screws.</p>
<p>Changes in the execution of methods can be introduced by adding an unrelated but homographic member function (with signatures involving implicitly convertible types) anywhere is the hierarchies of ancestor classes during maintenance of the code. Malicious implementations can thus be added with each release of an object-oriented library and affect the behaviour of previously verified code. (see subclause <a href="#BLP">Violations of the Liskov substitution principle [BLP]</a></p>
<ul>
<li><p>Guidance: Keep inheritance hierarchies short</p></li>
<li><p>Guidance: Qualify the program to invoke member functions in explicit parent classes.</p></li>
<li><p>Mitigation: use the ‘= delete’ construct to prevent a member function from being called due to an inheritance.</p></li>
</ul>
<h2 id="guidance-to-language-users">6.41.2 Guidance to language users</h2>
<ul>
<li><p>Follow the guidance of ISO/IEC TR 24772-1:2019 clause 41.5.</p></li>
<li><p>Avoid the use of multiple inheritance whenever possible.</p></li>
<li><p>Avoid access to data components when getting and setting functions are available for them.</p></li>
<li><p>Keep inheritance hierarchies short and narrow</p></li>
<li><p>Prefer non-virtual functions to virtual functions</p></li>
<li><p>Use <code class="sourceCode cpp"><span class="kw">override</span></code> and <code class="sourceCode cpp"><span class="kw">final</span></code> keywords on member functions to generate compiler diagnostics when overriding is accidental</p></li>
<li><p>Use the ‘= delete’ construct to prevent a member function from being called due to an inheritance.</p></li>
<li><p>If any class invariant depends upon a value of a data member, then make that member private</p></li>
<li><p>Make data members private and provide a public interface to access them that preserves class invariants</p></li>
<li><p>Provide complete documentation of all encapsulated data, and how each method affects that data for each object in the hierarchy.</p></li>
<li><p>Inherit only from trusted sources, and, whenever possible, check the version of the parent classes during compilation and/or initialization.</p></li>
<li><p>Provide a member function that provides versioning information for each class.</p></li>
<li><p>Prohibit the use of public inheritance for “has-a” relationships. Use composition instead for “has-a”-relationships.</p></li>
<li><p>Delegate assigning and moving of the parent’s data components by calling the corresponding operation of the parent type. You must delegate in particular when the parent has data components not visible to methods of the subclass. Alternatively, prohibit assignment and motion for classes intended to be base types. <em>(clarify – this has 2 possible meanings)</em></p></li>
<li><p>Avoid the creation of base classes that are both virtual and non-virtual in the same hierarchy.</p></li>
</ul>
<h2 id="BLP">6.42 Violations of the Liskov Substitution Principle or the Contract Model [BLP]</h2>
<h3 id="applicability-to-language">6.42.1 Applicability to language</h3>
<p>This vulnerability applies to C++ . It can be mitigated by a style of programming that uses wrapper functions to check preconditions, calls a virtual function to perform the required functionality and subsequently checks the postconditions before returning. An example is provided below.</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Base  {</span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">private</span>:</span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a>     <span class="kw">virtual</span> <span class="dt">int</span> function_to_override( <span class="dt">int</span> x ) = <span class="dv">0</span>;</span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">// ...</span></span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-6"><a href="#cb186-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span>:</span>
<span id="cb186-7"><a href="#cb186-7" aria-hidden="true" tabindex="-1"></a>     <span class="dt">int</span> interface_to_overridden_function( <span class="dt">int</span> x ) {</span>
<span id="cb186-8"><a href="#cb186-8" aria-hidden="true" tabindex="-1"></a>           check_preconditions( x );</span>
<span id="cb186-9"><a href="#cb186-9" aria-hidden="true" tabindex="-1"></a>           <span class="at">const</span> <span class="kw">auto</span> saved = data_saved_for_postcondition( x );</span>
<span id="cb186-10"><a href="#cb186-10" aria-hidden="true" tabindex="-1"></a>           <span class="kw">auto</span> result = function_to_override( x );</span>
<span id="cb186-11"><a href="#cb186-11" aria-hidden="true" tabindex="-1"></a>           check_postconditions( x, saved, result );</span>
<span id="cb186-12"><a href="#cb186-12" aria-hidden="true" tabindex="-1"></a>           <span class="cf">return</span> result;</span>
<span id="cb186-13"><a href="#cb186-13" aria-hidden="true" tabindex="-1"></a>         }</span>
<span id="cb186-14"><a href="#cb186-14" aria-hidden="true" tabindex="-1"></a>     <span class="co">// ...      </span></span>
<span id="cb186-15"><a href="#cb186-15" aria-hidden="true" tabindex="-1"></a> };</span></code></pre></div>
<h3 id="guidance-to-language-users">6.42.2 Guidance to language users</h3>
<ul>
<li><p>Obey all preconditions and postconditions of each member function, whether they are specified in the language or not.</p></li>
<li><p>Prohibit the strengthening of preconditions (specified or not) by overriding member functions.</p></li>
<li><p>Prohibit the weakening of postconditions (specified or not) by overriding member functions.</p></li>
<li><p>Prohibit the use of public inheritance for “has-a” relationships. Use composition for “has-a”-relationships instead.</p></li>
<li><p>Use static analysis tools that identify misuse of inheritance in the contract model.</p></li>
<li><p>Ensure that all invariants of a derived class are preserved by all public operations on its public base classes. If this cannot be ensured, make the base class private, or avoid inheritance.</p></li>
</ul>
<blockquote>
<p>See also C++ Core Guidelines C.120, C.121, C.122, C.126, C.127, and C.129 through C.133.</p>
</blockquote>
<h2 id="redispatching-pph">6.43 Redispatching [PPH]</h2>
<h3 id="applicability-to-language">6.43.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.43 exists in C++ for virtual functions, except for constructors and destructors which are not dispatching. An example of the infinite recursion is:</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A {</span>
<span id="cb187-4"><a href="#cb187-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb187-5"><a href="#cb187-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A::f()</span><span class="sc">\n</span><span class="st">&quot;</span>; }</span>
<span id="cb187-6"><a href="#cb187-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> g() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A::g()</span><span class="sc">\n</span><span class="st">&quot;</span>; A::f(); }  <span class="co">//call to f() will not dispatch.</span></span>
<span id="cb187-7"><a href="#cb187-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> h() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A::h()</span><span class="sc">\n</span><span class="st">&quot;</span>; }</span>
<span id="cb187-8"><a href="#cb187-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> i() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A::i()</span><span class="sc">\n</span><span class="st">&quot;</span>; h(); } <span class="co">//call to h() will dispatch</span></span>
<span id="cb187-9"><a href="#cb187-9" aria-hidden="true" tabindex="-1"></a>                                                      <span class="co">//showing the vulnerability</span></span>
<span id="cb187-10"><a href="#cb187-10" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb187-11"><a href="#cb187-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-12"><a href="#cb187-12" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B : <span class="kw">public</span> A {</span>
<span id="cb187-13"><a href="#cb187-13" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb187-14"><a href="#cb187-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f() <span class="kw">override</span> { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;B::f()</span><span class="sc">\n</span><span class="st">&quot;</span>; g(); }</span>
<span id="cb187-15"><a href="#cb187-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> h() <span class="kw">override</span> { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;B::h()</span><span class="sc">\n</span><span class="st">&quot;</span>; i(); }</span>
<span id="cb187-16"><a href="#cb187-16" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb187-17"><a href="#cb187-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-18"><a href="#cb187-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main() {</span>
<span id="cb187-19"><a href="#cb187-19" aria-hidden="true" tabindex="-1"></a>    B b;</span>
<span id="cb187-20"><a href="#cb187-20" aria-hidden="true" tabindex="-1"></a>    A * pA = &amp;b;</span>
<span id="cb187-21"><a href="#cb187-21" aria-hidden="true" tabindex="-1"></a>    pA-&gt;f(); <span class="co">// no problem</span></span>
<span id="cb187-22"><a href="#cb187-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;---</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb187-23"><a href="#cb187-23" aria-hidden="true" tabindex="-1"></a>    pA-&gt;h(); <span class="co">// infinite recursion</span></span>
<span id="cb187-24"><a href="#cb187-24" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In C++, the call to a member function can be qualified, as shown in the above example, and avoids the vulnerability.</p>
<h3 id="guidance-to-language-users">6.43.2 Guidance to language users</h3>
<ul>
<li><p>At a call site, consider whether virtual dispatch is desired. If not, construct the call using the qualified name.</p></li>
<li><p>Be suspicious of any call from a virtual member function of the derived class to any member function of any of its base classes.</p></li>
</ul>
<h2 id="BKK">6.44 Polymorphic variables [BKK]</h2>
<h3 id="applicability-to-language">6.44.1 Applicability to language</h3>
<p>This vulnerability as described in ISO/IEC TR 24772-1:2019 applies to C++. In addition to the upcast and downcast issues addressed in that document, this clause also addresses cross-casting, which is unique to C++. For further type system related issues see subclause <a href="#IHN">Type System[IHN]</a>.</p>
<p>C++ provides language mitigations to help avoid the problems as follows:</p>
<p>Since C++ supports multiple inheritance, up-casting, down-casting, and cross-casting operations can be used to switch to different (pointer/reference) types in the inheritance hierarchy of a specific object, i.e.,</p>
<ul>
<li><p><em>up-casting</em> is casting an object to an ancestor type in the object's type inheritance hierarchy.</p></li>
<li><p><em>down-casting</em> is casting an object to a descendent type in the object's type inheritance hierarchy, and,</p></li>
<li><p><em>cross-casting</em> is casting an object to a sibling/cousin (possibly removed) type in the object's type inheritance hierarchy with multiple inheritance.</p></li>
<li><p>Unsafe casts, which include C-style casts and <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>, can cast to unrelated arbitrarily structured types. This allows reading and modifying arbitrary memory areas. See subclause [[6.11 Pointer Casting and Pointer Type Changes] [HFC](#HFC) for more details.</p></li>
</ul>
<blockquote>
<p>Developers should be aware that virtual member functions can be overridden in derived classes, even if they are private.</p>
</blockquote>
<p>Given the following:</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Z { <span class="dt">int</span> z; <span class="kw">virtual</span> ~Z() { } };</span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Y { <span class="dt">int</span> y; <span class="kw">virtual</span> ~Y() { } };</span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A : Z { <span class="dt">int</span> a; };</span>
<span id="cb188-4"><a href="#cb188-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> B : <span class="kw">virtual</span> A { <span class="dt">int</span> b; };</span>
<span id="cb188-5"><a href="#cb188-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> C : <span class="kw">virtual</span> A, Y { <span class="dt">int</span> c; };</span>
<span id="cb188-6"><a href="#cb188-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> D : B, C { <span class="dt">int</span> d; };</span>
<span id="cb188-7"><a href="#cb188-7" aria-hidden="true" tabindex="-1"></a>D d_inst;</span></code></pre></div>
<p>then these examples demonstrate upcasts, downcasts, and crosscasts:</p>
<p><strong>Upcasts:</strong></p>
<div class="sourceCode" id="cb189"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a>B* b_ptr = &amp;d_inst; <span class="co">// implicit</span></span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a>C&amp; c_ref = d_inst; <span class="co">// implicit</span></span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a>Z* z_ptr = <span class="kw">static_cast</span>&lt;Z*&gt;(&amp;d_inst);</span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true" tabindex="-1"></a>Y* y_ptr = <span class="kw">dynamic_cast</span>&lt;Y*&gt;(&amp;d_inst);</span></code></pre></div>
<p><strong>Downcasts:</strong></p>
<div class="sourceCode" id="cb190"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a>D&amp; d_ref = <span class="kw">dynamic_cast</span>&lt;D&amp;&gt;(*y_ptr);</span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a>D* d_ptr = <span class="kw">static_cast</span>&lt;D*&gt;(b_ptr);</span></code></pre></div>
<p><strong>Crosscasts:</strong></p>
<div class="sourceCode" id="cb191"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a>C* c_ptr = <span class="kw">dynamic_cast</span>&lt;C*&gt;(b_ptr);</span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a>Y* y_ptr2 = <span class="kw">dynamic_cast</span>&lt;Y*&gt;(b_ptr);</span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true" tabindex="-1"></a>C* c_ptr = <span class="kw">static_cast</span>&lt;C*&gt; (<span class="kw">static_cast</span>&lt;D*&gt;(b_ptr));</span></code></pre></div>
<p>and notes the following about such:</p>
<p>Upcasts:</p>
<ul>
<li><p>are the only ones that can be performed implicitly</p></li>
<li><p>can cause object slicing when a copy of a base class object is created from a derived class object.</p></li>
<li><p>can also be done with <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> or <code class="sourceCode cpp"><span class="kw">static_cast</span></code></p></li>
</ul>
<p>Downcasts</p>
<ul>
<li><p>are explicit;</p></li>
<li><p>can be done safely with <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code></p></li>
<li><p><code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> requires appropriate portions of inheritance to be polymorphic (i.e. has <code class="sourceCode cpp"><span class="kw">virtual</span></code> members);</p></li>
<li><p>can be done using <code class="sourceCode cpp"><span class="kw">static_cast</span></code> which is unchecked and may be unsafe;</p></li>
</ul>
<p>Crosscasts:</p>
<ul>
<li><p>are explicit</p></li>
<li><p>can be done safely with a single call to <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> which requires appropriate portions of inheritance to be polymorphic (i.e. has <code class="sourceCode cpp"><span class="kw">virtual</span></code> members).</p></li>
<li><p>can often be done with a chain of <code class="sourceCode cpp">static_casts</code> traversing the inheritance hierarchy, which is almost always unsafe.</p></li>
</ul>
<p>Deleting derived objects via a base class pointer is undefined behavior, unless the base class declares a virtual destructor.</p>
<h3 id="guidance-to-language-users">6.44.2 Guidance to language users</h3>
<ul>
<li><p>Follow the advice provided in ISO/IEC 24772-1 clause 6.44.5.</p></li>
<li><p>In a base class declaring virtual member functions, define a virtual defaulted destructor (Core Guidelines C.35) and make the class non-copyable (Core Guidelines C.130).</p></li>
<li><p>Avoid designs relying on downcasts or crosscasts; rely on proper virtual member functions in the base classes instead.</p></li>
<li><p>Avoid explicit upcast, rely on implicit conversion.</p></li>
<li><p>If a downcast or a crosscast is needed, prefer using <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> since it is checked.</p></li>
<li><p>Ensure that all invariants of a derived class are preserved by all public operations on its public base classes. If this cannot be ensured, make the base class private, or avoid inheritance.</p></li>
<li><p>Do not attempt to navigate class hierarchies using C-style casts or <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>.</p></li>
<li><p>Do not delete a polymorphic object without a virtual destructor. This includes using <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr&lt;base&gt;</code> from a unique pointer allocated with <code class="sourceCode cpp"><span class="bu">std::</span>make_unique&lt;derived&gt;()</code></p></li>
</ul>
<blockquote>
<p>See also C++ Core Guidelines ES.48, ES.49, C.146, C.147, C.148 and C.153. source: OOP52-CPP?</p>
</blockquote>
<h2 id="extra-intrinsics-lrm">6.45 Extra Intrinsics [LRM]</h2>
<p>This vulnerability does not apply to C++ for the following reasons:</p>
<ul>
<li>When adding intrinsics, implementors are required to follow a specific name pattern that users are not allowed to use in definitions. See C++ standard clause 5.10 [Lex.name].</li>
</ul>
<p>Operations for swap, sin, cos, conversions float &lt;-&gt; double, saturation,</p>
<h2 id="argument-passing-to-library-functions-trj">6.46 Argument Passing to Library Functions [TRJ]</h2>
<h3 id="applicability-to-language">6.46.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.46 is applicable to C++.</p>
<p>Libraries that supply objects or functions are in most cases not required to check the validity of parameters passed to them. In those cases where parameter validation is required there might not be adequate parameter validation.</p>
<p>When calling a library, either the calling function or the library may make assumptions about parameters. For example, it may be assumed by a library that a parameter is non-zero so division by that parameter is performed without checking the value. Sometimes some validation is performed by the calling function, but the library may use the parameters in ways that were unanticipated by the calling function resulting in a potential vulnerability. Even when libraries do validate parameters, their response to an invalid parameter is usually undefined and can cause unanticipated results.</p>
<p>This vulnerability applies in particular to C++ libraries which are designed for high efficiency; responsibility for satisfying the preconditions for most functions rests with the caller. When these preconditions are not met, the result will be undefined behaviour. In addition, error conditions are specified by the language for specific functions, such as raising an exception, returning an error code or a known value, such as NaN.</p>
<h3 id="guidance-to-language-users">6.46.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1 clause 6.47.5.</p></li>
<li><p>Use translation modes provided the implementation to perform addition analysis or checking, such as contracts checks, or instrumentation of executing code.</p></li>
<li><p>Pay attention to the distinction between precondition violation and error conditions in library documentation. The former results in undefined behaviour; the latter results in defined but possibly unwanted behaviour.</p></li>
</ul>
<h2 id="inter-language-calling-djs">6.47 Inter-language Calling [DJS]</h2>
<h3 id="applicability-to-language">6.47.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.47 is applicable to C++.</p>
<p>C++ is a multi-paradigm language with a number of features that do not interface simply with other language systems. It is left to the implementation team the task of converting the results of these paradigms to constructs that can cross an interface for further processing in other languages.</p>
<p>C++ compilers provide an application binary interface (ABI) that delineates areas of interoperability with other languages or other C++ compiler/runtime systems. An ABI includes calling conventions, data layout, error and exception handling and return conventions, name mangling, data model, initialization of memory, and linkage to operating systems and libraries.</p>
<p>C++ compilers implement a C++ language linkage and a C language linkage. It is implementation-defined what other languages the implementation supports. Alternatively, other language systems provide linkages to C systems[^3](Ada has developed a standard for interfacing with C. Fortran has included a Clause 15 that explains how to call C functions.), leaving the developer the task of channeling everything through this common language system.</p>
<h3 id="guidance-to-language-users">6.47.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance contained in ISO/IEC TR 24772-1:2019 clause 6.47.5</p></li>
<li><p>Use standard layout types for the interoperable interfaces.</p>
<ul>
<li><pre><code>  Use language linkage facilities that support the languages being</code></pre>
<p>used.</p></li>
<li><pre><code>  EXP56-CPP. Do not call a function with a mismatched language</code></pre>
<p>linkage (-&gt; 6.47)</p></li>
<li><pre><code>  EXP60-CPP. Do not pass a nonstandard-layout type object across</code></pre>
<p>(-&gt; 6.47 ?)<br />
execution boundaries</p></li>
</ul></li>
<li><p>Be aware that the static initialization phase and dynamic initialization for every language system are required before the system begins execution</p></li>
<li><p>Be aware that C++ exceptions are not usually compatible with exceptions in other languages.</p></li>
<li><p>Segregate outgoing cross-language interfacing code into functions that present a C++ interface to the C++ code and implements that interface by calling code compatible with the other language system. Similarly implement incoming cross-language interfaces by providing simplified functions that presents a simplified (C or other language) interface and is implemented by calling C++ code with the correct style.</p></li>
<li><p>Separate the interfacing code from the code containing the main functionality</p></li>
</ul>
<p>See also the C++ Core Guidelines CPL.3.</p>
<p><em>AI 63-6 – group – add the guidance from 6.47.2 Interoperability into the Core Guidelines.</em></p>
<h2 id="dynamically-linked-code-and-self-modifying-code-nyy">6.48 Dynamically-linked Code and Self-modifying Code [NYY]</h2>
<h3 id="applicability-to-language">6.48.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.48 is applicable to C++.</p>
<h3 id="guidance-to-language-users">6.48.2 Guidance to language users</h3>
<p>Follow the guidance of ISO/IEC TR 24772-1:2019 clause 6.48.5.</p>
<h2 id="library-signature-nsq">6.49 Library Signature [NSQ]</h2>
<h3 id="applicability-to-language">6.49.1 Applicability to language</h3>
<p>The vulnerability as enumerated in ISO/IEC TR 24772-1:2019 clause 6.49 applies to C++.</p>
<p>As a mitigation, the C++ ‘<code class="sourceCode cpp"><span class="at">extern</span> <span class="st">&quot;C&quot;</span></code>’ linkage specifier usually provides simple interoperability with libraries using the C application binary interface (ABI).</p>
<h3 id="guidance-to-language-users">6.49.2 Guidance to language users</h3>
<p>From Part 1, 6.49.5</p>
<ul>
<li><p>Follow the guidance of ISO/IEC TR 24772-1:2019 clause 6.49.5.</p></li>
<li><p>Follow the advice of clause 6.47.2 as applicable.</p></li>
</ul>
<h2 id="unanticipated-exceptions-from-library-routines-hjw">6.50. Unanticipated Exceptions from Library Routines [HJW]</h2>
<h3 id="applicability-to-language">6.50.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 clause 6.50 exists for C++. In particular the issue of the failing dynamic initialization of namespace-scope objects exists in C++.</p>
<p>When dynamic initialization of a namespace-scope object fails with an exception, the exception cannot be caught and the program is terminated. Function-scope static objects, in contrast, are initialized the first time execution passes through the declaration. Using function-scope static objects in preference to dynamic initialization ensures that there is always an enclosing function that could catch the exception.</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="dt">exception_prone_type</span> troubling_object;</span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a><span class="co">// An exception from the constructor could cause termination.</span></span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a><span class="co">// The following function always returns a reference to the same object,</span></span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a><span class="co">// which is initialized the first time this function is called.</span></span>
<span id="cb195-5"><a href="#cb195-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-6"><a href="#cb195-6" aria-hidden="true" tabindex="-1"></a><span class="co">// If initialization fails, it will be retried on the next call.</span></span>
<span id="cb195-7"><a href="#cb195-7" aria-hidden="true" tabindex="-1"></a><span class="dt">exception_prone_type</span>&amp; safer_object()</span>
<span id="cb195-8"><a href="#cb195-8" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb195-9"><a href="#cb195-9" aria-hidden="true" tabindex="-1"></a>   <span class="at">static</span> <span class="dt">exception_prone_type</span> the_safer_object;</span>
<span id="cb195-10"><a href="#cb195-10" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> the_safer_object;</span>
<span id="cb195-11"><a href="#cb195-11" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<h3 id="guidance-to-language-users">6.50.2 Guidance to language users</h3>
<ul>
<li><p>Expect functions not marked <code class="sourceCode cpp"><span class="kw">noexcept</span></code> to throw exceptions of arbitrary type. Note that all destructors are implicitly <code class="sourceCode cpp"><span class="kw">noexcept</span></code>.</p></li>
<li><p>Follow the advice of clause 6.36.2 for catching and handling exceptions.</p></li>
<li><p>Prefer function-scope static objects to namespace-scope objects for objects needing dynamic initialization.</p></li>
</ul>
<h2 id="NMP">6.51 Pre-processor Directives [NMP]</h2>
<h3 id="applicability-to-language">6.51.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.51 applies to C++.</p>
<p>The C++ pre-processor allows the use of macros that are text-replaced before compilation.</p>
<p>Function-like macros look similar to functions but have different semantics. Because the arguments are text-replaced, expressions passed to a function-like macro may be evaluated multiple times. This can result in unintended and undefined behaviour if the arguments have side effects or are pre-processor directives. Additionally, the arguments and body of function-like macros should be fully parenthesized to avoid unintended and undefined behaviour.</p>
<p>The following code example demonstrates undefined behaviour when a function-like macro is called with arguments that have side-effects (in this case, the increment operator) .</p>
<div class="sourceCode" id="cb196"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CUBE</span>(X)<span class="pp"> </span>((X)<span class="pp"> </span><span class="er">\</span>*<span class="pp"> </span>(X)<span class="pp"> </span><span class="er">\</span>*<span class="pp"> </span>(X))</span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb196-3"><a href="#cb196-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i = <span class="dv">2</span>;</span>
<span id="cb196-4"><a href="#cb196-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a = <span class="dv">81</span> / CUBE(++i);</span></code></pre></div>
<p>The above example could expand to:</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a = <span class="dv">81</span> / ((++i) * (++i) * (++i));</span></code></pre></div>
<p>which has undefined behaviour so this macro expansion is difficult to predict.</p>
<p>Another mechanism of failure can occur when the arguments within the body of a function-like macro are not fully parenthesized. The following example shows the CUBE macro without parenthesized arguments.</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CUBE</span>(X)<span class="pp"> </span>(X<span class="pp"> </span><span class="er">\</span>*<span class="pp"> </span>X<span class="pp"> </span><span class="er">\</span>*<span class="pp"> </span>X)</span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a = CUBE(<span class="dv">2</span> + <span class="dv">1</span>);</span></code></pre></div>
<p>This example expands to:</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a = (<span class="dv">2</span> + <span class="dv">1</span> * <span class="dv">2</span> + <span class="dv">1</span> * <span class="dv">2</span> + <span class="dv">1</span>)</span></code></pre></div>
<p>which evaluates to 7 instead of the intended 27.</p>
<h3 id="guidance-to-language-users">6.51.2 Guidance to language users</h3>
<ul>
<li><p>Replace function-like macros with <code class="sourceCode cpp"><span class="kw">constexpr</span></code> inline functions where possible.</p></li>
<li><p>Replace normal macros with <code class="sourceCode cpp"><span class="kw">constexpr</span></code> variables where possible.</p></li>
<li><p>Replace conditional compilation with the preprocessor with <code class="sourceCode cpp"><span class="cf">if</span> <span class="kw">constexpr</span></code> where possible, e.g., in function bodies. This includes cases, where compile-time define of a macro (as empty) controls if a macro definition is used to expand to an empty statement or another statement.</p></li>
<li><p>Replace preprocessor include directives with module <code class="sourceCode cpp"><span class="kw">import</span></code> where possible.</p></li>
<li><p>Prefer <code class="sourceCode cpp"><span class="bu">std::</span>source_location</code> mechanisms over employing macros that use <code class="sourceCode cpp"><span class="ot">__LINE__</span></code>, <code class="sourceCode cpp"><span class="ot">__FILE__</span></code>, or <code class="sourceCode cpp"><span class="ot">__func__</span></code>.</p></li>
<li><p>If a function-like macro must be used, ensure that its parameters and body are parenthesized.</p></li>
<li><p>In a function-like macro, ensure that each argument is evaluated at most once.</p></li>
<li><p>Do not embed pre-processor directives or side-effects such as an assignment, increment/decrement, volatile access, or function call in a function-like macro.</p></li>
<li><p>Macros should only be used for <em>include guards</em>, to control conditional compilation, or when the macro’s definition requires token pasting (<code>##</code>.{.cpp}) or stringification (<code class="sourceCode cpp"><span class="er">#</span></code>) of macro arguments.</p></li>
<li><p>Macro paramters that are used as argument for <code class="sourceCode cpp"><span class="pp">#</span><span class="er">#</span></code> or <code class="sourceCode cpp"><span class="er">#</span></code> should not be used otherwise in the macro.</p></li>
</ul>
<h2 id="suppression-of-language-defined-run-time-checking-mxb">6.52 Suppression of Language-defined Run-time Checking [MXB]</h2>
<h3 id="applicability-to-language">6.52.1 Applicability to language</h3>
<p>With the exception of the macro <code>assert</code>, the vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.52 does not apply to C++, because there is no language-defined runtime checking. Macro assert is defined by the standard but is invoked by the programmer, hence is not a language-defined check.</p>
<p>C++ libraries, however, often provide run-time checks which meet the criteria of this vulnerability. Also, compilers and other tools commonly provide means to perform such runtime checks.</p>
<h3 id="guidance-to-language-users">6.51.2 Guidance to language users</h3>
<p>Follow the advice provided in ISO/IEC TR 24772-1:2019 clause 6.52.5 with respect to library and compiler-provided checks. Note that this will almost always require explicitly enabling the checks.</p>
<h2 id="provision-of-inherently-unsafe-operations-skl">6.53 Provision of Inherently Unsafe Operations [SKL]</h2>
<h3 id="applicability-to-language">6.53.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.53 applies to C++. In particular, anything described by ISO/IEC 14882:2017 as “undefined behaviour” is unsafe.</p>
<h3 id="guidance-to-language-users">6.53.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1:2019 clause 6.53.5.</p></li>
<li><p>Enable checks that warn about unsafe operations.</p></li>
<li><p>Use static analysis tools to detect unsafe constructs.</p></li>
</ul>
<h2 id="obscure-language-features-brs">6.54 Obscure Language Features [BRS]</h2>
<h3 id="applicability-of-language">6.54.1 Applicability of language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.54 applies to C++.</p>
<p>C++ is a rich language and provides facilities for a wide range of application areas. Because some areas are specialized, it is possible that a programmer not versed in a special area can misuse features for that area.</p>
<h3 id="guidance-to-language-users">6.54.2 Guidance to language users</h3>
<ul>
<li>Follow the guidelines of ISO/IEC TR 24772-1:2019 clause 6.54.5.</li>
</ul>
<p>$incldue 6.55.UnspecifiedBehaviour-BQF.md</p>
<h2 id="EWF">6.56 Undefined Behaviour [EWF]</h2>
<h3 id="applicability-to-language">6.56.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.56 applies to C++. In ISO/IEC 14882:2017, the terms “undefined behaviour” and “ill-formed, no diagnostic required” expose situations to be avoided.</p>
<h3 id="guidance-to-language-users">6.56.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1:2019 clause 6.56.5.</p></li>
<li><p>Augment static analysis tool usage with runtime tools such as ASAN (address sanitizer) and related tools.</p></li>
<li><p>Use static analysis tools to help identify occurrences of undefined behaviour.</p></li>
<li><p>Use multiple compilers/tools and different optimization levels to increase your chance of identifying constructs that have undefined behaviours.</p></li>
<li><p>Where the language provides defined behaviour mechanisms and undefined behaviour mechanisms, ensure that you use the ones with defined behaviours.</p></li>
</ul>
<pre><code>&lt;!--
    Note: This document is dedicated to explaining these issues.
--&gt;</code></pre>
<h2 id="implementationdefined-behaviour-fab">6.57 Implementation–defined Behaviour [FAB]</h2>
<h3 id="applicability-to-language">6.57.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.57 applies to C++. In ISO/IEC 14882, the term “implementation-defined” is used to describe implementation-defined behaviour. In addition, the C++ standard provides a dedicated index titled, “Index of implementation-defined behavior”.</p>
<h3 id="guidance-to-language-users">6.57.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1:2019 clause 6.57.5.</p></li>
<li><p>Eliminate to the extent possible any reliance on implementation-defined behaviour from programs in order to increase portability. Even programs that are specifically intended for a particular implementation may in the future be ported to another environment or sections reused for future implementations.</p></li>
<li><p>Use multiple compilers/tools to increase your chance of identifying constructs that have implementation-defined behaviours.</p></li>
<li><p>Refer to “Index of implementation-defined behavior” for the definitive list of C++ implementation-defined behaviours and understand the relevant compiler documentation for each of these behaviours.</p></li>
</ul>
<h2 id="deprecated-language-features-mem">6.58 Deprecated Language Features [MEM]</h2>
<h3 id="applicability-to-language">6.58.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1 clause 6.58 applies to C++. Appendix D “Compatibility features” of ISO/IEC 14882:2020 enumerates the deprecated features. The C++ attribute <code class="sourceCode cpp">[[<span class="at">deprecated</span>]]</code> allows library writers and users to mark deprecated declarations.</p>
<p>Although backward compatibility is sometimes offered as an option for compilers so one can avoid changes to code to be compliant with current language specifications, updating the legacy software to the current standard is a better option.</p>
<h3 id="guidance-to-language-users">6.58.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1 clause 6.58.5.</p></li>
<li><p>Enable compiler options or static analysis tools that identify the use of deprecated features.</p></li>
<li><p>Apply the <code class="sourceCode cpp">[[<span class="at">deprecated </span>(<span class="st">&quot;*reason*&quot;</span>)]]</code> attribute to obsolete declarations that exist only for backward compatibility.</p></li>
</ul>
<h2 id="concurrency-activation-cga">6.59 Concurrency – Activation [CGA]</h2>
<h3 id="applicability-to-language">6.59.1 Applicability to language</h3>
<p>This vulnerability does not apply to C++, as long as the standard library facilities for creating threads are used.</p>
<p>Creating a thread using <code class="sourceCode cpp"><span class="bu">std::</span>thread</code> or <code class="sourceCode cpp"><span class="bu">std::</span>jthread</code> is synchronized with the thread creation site.</p>
<p>Other vulnerabilities can be created when creating a thread object:</p>
<ul>
<li>6.61 Concurrent Data Access,</li>
<li>6.14 and 6.33 dangling of data reference, if data is passed to the thread function as reference or pointer, instead of passing a copy.</li>
<li>6.36 undhandle exception leading to premature termination of the program, if the thread object is destroyed and the spawned thread is neither joined nor detached. Creating a new thread through <code class="sourceCode cpp"><span class="bu">std::</span>async</code> will implicitly join.</li>
</ul>
<h3 id="guidance-to-language-users">6.59.2 Guidance to language users</h3>
<ul>
<li><p>If you are using a non-standard thread facilities, e.g., by making use of <code>std::thread::native_handle</code> follow the guidelines of TR 24772-1 clause 6.60.5.</p></li>
<li><p>Use <code class="sourceCode cpp"><span class="bu">std::</span>jthread</code> for thread creation, or always <code>.join()</code> or <code>.detach()</code> a created <code>std::thread</code>.</p></li>
<li><p>Pass all thread function arguments by value, or ensure their lifetime outlasts the running thread. In the latter case proper synchronization is required.</p></li>
</ul>
<h2 id="concurrency-directed-termination-cgt">6.60 Concurrency – Directed termination [CGT]</h2>
<h3 id="applicability-to-language">6.60.1 Applicability to language</h3>
<p>What about tasks? Explain std::function A functor is a class that can be called like a throw-away parallel object. Can also use in lambda expressions. The creating thread can only retrieve results by using a shared variable or using explicit thread calls to</p>
<p>A thread in C++ runs until completion, either a normal completion or as the result of an unhandled exception. There is no mechanism in the language to terminate another thread. If the threading model is POSIX or some other underlying paradigm, the underlying threading service calls can be used to terminate a thread.</p>
<p>C++ threads use a fork-join model. This means that the initiating thread will wait for the completion of the initiated thread at the join place at the end of the scope that created the initiated thread if a call to join the terminating thread has been made; otherwise the initiating task will have no indication of when the created thread completes.</p>
<p>Programmed mechanisms can be constructed to cause another thread to complete or to raise an exception, such as setting a shared variable to a known state that the target thread reads and then terminates itself.</p>
<p>Are there any language-defined ways to check on the progress of a thread or know if it is executable? Can always use underlying mechanism where available. Future mechanism provides for communication with the spawned thread to know if it terminated returning a value or returning an exception.</p>
<h2 id="guidance-to-language-users">6.60.2 Guidance to language users</h2>
<p>Follow the guidance of 24772-1 Clause 6.59.5</p>
<h2 id="CGX">6.61 Concurrent Data Access [CGX]</h2>
<h3 id="applicability-to-language">6.61.1 Applicability to language</h3>
<p>C++ has threading and shared access to variables which have the vulnerabilities described in ISO/IEC TR 24772-1:2019 clause 6.61.1. C++ provides features such as atomic (type template) that guarantee the internal consistency of the data and to prevent corruption of data due to potentially interleaved updates to data elements.</p>
<p>What about concurrent data access between tasks?</p>
<p>Programmers should be aware that conversions or manipulations of data items are not always atomic, such as the conversion of an object as part of a computation</p>
<p><em>Need the C++ definition of atomic (indivisible access and memory ordering)</em></p>
<p><em>and volatile.</em></p>
<p>The C++ <span data-custom-style="typ">atomic</span> capability can be applied to any basic data type equivalent to <span data-custom-style="typ">char</span>, <span data-custom-style="typ">short</span>, <span data-custom-style="typ">int</span>, <span data-custom-style="typ">long</span>, and <span data-custom-style="typ">long</span> <span data-custom-style="typ">long</span>. When the C++ <span data-custom-style="typ">std::atomic</span> facilities are used, the language guarantees that simultaneous updates and reads to an atomic element will be well-behaved. Atomic does not guarantee the order in which competing reads and/or updates will occur. In order to manage order of access, synchronized locks are required. In order to use the atomic capabilities, each variable must be declared to be of one of the <span data-custom-style="typ">std::atomic</span> types, and the member functions used to compare, load, store or exchange values in an atomic variable.</p>
<p>We also need to move the notion of creating SHARED POINTERS FROM 6.13 TO HERE.</p>
<p>A volatile qualifier on a variable is used to indicate that updates to the variable may happen at any time and outside of program control, hence two subsequent reads on such a variable may return different results.</p>
<p>Programmers should be aware that even simple data accesses on modern architectures can involve instruction reordering, cache issues, and data alignment issues, hence the acquisition time and order are highly nondeterministic, especially when being accessed by concurrent threads. Any data structure that can be shared between threads should be shown to be accessed by at most one thread at a time or should be protected by synchronization mechanisms such as locks (see <a href="#CGM">Lock Protocol Errors [CGM]</a>) or atomicity.</p>
<p>Most concurrent programming algorithms require some level of synchronization between threads or tasks when exchanging information, synchronization that “<span data-custom-style="typ">atomic</span>” does not provide. Mechanisms such as monitors, mailboxes, or mutexes (lock with a queue), futures, condition variables, and locks control scheduling of threads or tasks to control order-of-access and to enforce higher levels of cooperation between schedulable entities<span data-custom-style="annotation reference"></span>.</p>
<p>Atomic tied to memory orders.</p>
<p>Mutexes provide mutual exclusion and guaranteed visibility (consistency) of the shared data.</p>
<p>Mutex is a lock-and-release that is usually hidden.</p>
<p>Encapsulate mutexes and data</p>
<p>Thread-level storage (official term thread_local) has lifetime of the thread. Can exist at local scope or global scope.</p>
<p>For massively parallel concurrency – concurrent access mechanisms not applicable.</p>
<p>No resource management</p>
<p>Exception and exception handling (has some impact on threading)</p>
<p>Memory management issues more complex under concurrency</p>
<p>Volatile should be used for signal handlers to prevent the optimization of replicated accesses to volatile memory. (other) and does not guarantee that the object value will be available to other threads.</p>
<p>Controlling access to shared data (protected or including</p>
<p>Use of volatile (keyword type qualifier) for signal handlers (communicating with hardware?). Prefer volatile for communicating with hardware?</p>
<p>For signal handling, <code class="sourceCode cpp"><span class="at">volatile</span> <span class="dt">sig_atomic_t</span></code> or atomic variables can be used to prevent this vulnerability.</p>
<h3 id="guidance-to-language-users">6.61.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance of ISO/IEC TR 24772-1 clause 6.62.5.</p></li>
<li><p>Use mutexes, condition variables (convar) in preference to atomic variables to protect data from simultaneous access.</p></li>
<li><p>Use volatile only for synchronizing abstract machine state from memory.</p></li>
<li><p>Avoid the use of volatile for synchronizing access to shared memory between threads (which needs mutex, condvar, or atomics)</p>
<ul>
<li><pre><code>  See C++ Core guidelines CP.8, CP.200,</code></pre>
CP.111,<span data-custom-style="annotation reference"></span></li>
</ul></li>
<li><p>Avoid relaxed atomic operations whenever possible. Prefer the sequentially consistent std::memory_order_seq_cst instead .</p></li>
<li><p>Use mutexes appropriately to protect accesses to non-atomic shared objects.</p></li>
<li><p>Use <code class="sourceCode cpp"><span class="at">volatile</span> <span class="dt">sig_atomic_t</span></code> to protect data shared with signal handlers in a single-threaded environment.</p></li>
</ul>
<h2 id="concurrency-premature-termination-cgs">6.62 Concurrency – Premature Termination [CGS]</h2>
<h3 id="applicability-to-language">6.62.1 Applicability to language</h3>
<h3 id="section"></h3>
<p>A thread will terminate when it completes its assigned method, or when it raises an exception, or when it has been explicitly terminated (how is this done)</p>
<p>Joining a thread causes the joining thread to await the joined thread’s termination before continue. Useful for executing in parallel and then proceeding after the dispatched work is complete, but does not notify the joining task if the termination was premature.</p>
<p>In C++ 2020, methods are provided to instruct one or more threads to terminate. This is not premature termination since the requested thread terminates itself.</p>
<p>C++ 2020 provides callbacks in the form of stop_callback to notify the setting thread when a thread of interest has been terminated. It also provides stop_token for a thread to query it is being instructed to terminate.</p>
<p>Any thread can re-throw an exception to be caught by the creator of the terminating thread, (but the parent may have terminated first).</p>
<p>The semantics of C++ is that all children of the main program will terminate if the main program terminates. It is necessary to join the main program to all its children to ensure that children are not silently terminated prematurely.</p>
<h3 id="guidance-to-language-users">6.62.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of TR 24772-1 clause 6.63.5.</p></li>
<li><p>Use low-level operating system primitives or other APIs where available to check that a required thread is still active.</p></li>
<li><p>Make the main program join all created threads that need to complete normally.</p></li>
</ul>
<h2 id="CGM">6.63 Protocol Lock Errors [CGM]</h2>
<h3 id="applicability-to-language">6.63.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1 clause 6.63 is applicable to C++.</p>
<p>This subclause requires a complete rewrite to have it reflect C++ issues.</p>
<p>Difference between threads and tasks. Can threads and tasks coexist?</p>
<p>Deadlock with single mutex,</p>
<p>The C standard does not provide hidden protocols. Although the vulnerability does not apply to the C language, there could exist an application vulnerability if a program uses synchronization mechanisms incorrectly. For example:</p>
<p>atomic int a;</p>
<p>int b;</p>
<p>/* . . . */</p>
<p>a += b; // This operation is an atomic read-modify-write of the variable ‘a’.</p>
<p>a = a + b; // This statement contains two accesses to ‘a’ and is not atomic.</p>
<h3 id="guidance-to-language-users">6.63.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of TR 24772-1 clause 6.63.5.</p></li>
<li><p>Be aware of the operation of each synchronization mechanism, such as the cases where accesses to atomic variables may occur more than once in a statement.</p></li>
<li><p>Use higher level building blocks (such as TBB) in preference to …</p></li>
<li><p>Use the C++ Task mechanism in preference to threads …</p></li>
<li><p>Always put the acquisition and release of mutexes and the data access in a wrapper function. (i.e. <em>Do not call member functions of std::mutex, std::timed_mutex, std::recursive_mutex, std::recursive_timed_mutex, std::shared_mutex and std::shared_timed_mutex objects directly.)</em></p></li>
<li><p><em>Use std::lock(), std::try_lock() or std::scoped_lock to acquire multiple mutexes in same scope. (std::lock() permits multiple mutexes at the same time).</em></p></li>
<li><p>Use std::lock() only where multiple locks must be locked together and use std::lock_guard with the std::adopt_lock argument for all mutexes (needs example) see std::lock() example on cppreference.com.</p></li>
<li><p><em>Wrap mutex locks std::lock or std::try_lock with std<strong>::</strong>lock_guard, std::unique_lock or std::shared_lock with adopt_lock tag within the same scope</em></p></li>
<li><p>If explicit locking are used, ensure that the lock is released on every exit path, including exceptions. Use lock_guard, scope_lock and unique_lock in preference to lock(), unlock(), and try_lock(),</p></li>
<li><p><strong><em>Do not use platform specific multi-threading facilities</em></strong></p></li>
<li><p><strong><em>A thread shall not access objects whose lifetime has expired</em></strong></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.kj1vcao94oy1"><u>0.4.4 [12] Do not destroy objects of the following types std::mutex, std::timed_mutex, std::recursive_mutex, std::recursive_timed_mutex, std::shared_mutex, std::shared_timed_mutex if object is in locked or shared locked state Do not destroy a mutex while it is locked</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.1kfv9jdgd8ib"><u>0.4.5 [13] Mutexes locked with std::lock or std::try_lock shall be wrapped with std::lock_guard, std::unique_lock or std::shared_lock with adopt_lock tag within the same scope Ensure actively held locks are released on exceptional conditions</u> <u>12</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.729gvquxakq8"><u>0.4.6 [14] Do not call virtual functions and callable objects passed by argument of the function within the scope of locked mutex Never call unknown code while holding a lock (e.g., a callback)</u> <u>12</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.920crsa3sscx"><u>0.4.7 [15] Avoid deadlock by locking in a predefined order</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.xufkh9tsiuk8"><u>0.4.8 [16] Objects of std::lock_guards, std::unique_locks, std::shared_lock and std::scoped_lock classes shall always be named Remember to name your lock_guards and unique_locks</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.d6qklu5mi3fn"><u>0.4.9 [17] Define a mutex together with the data it guards. Use synchronized_value&lt;T&gt; where possible</u> <u>13</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.isn3bwogdp97"><u>0.4.10 [18] Do not speculatively lock a non-recursive mutex that is already owned by the calling thread</u> <u>14</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.einwxosnxvhf"><u>0.4.11 [19] There shall be no code path which results in locking of the non-recursive mutex within the scope when this mutex is already locked Within the scope of a lock, ensure that no static path results in a lock of the same mutex</u> <u>14</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.vq776pxv4nn5"><u>0.4.12 [20] The order of nested locks unlock shall form a DAG Ensure that order of nesting of locks in a project forms a DAG</u> <u>15</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.7pf8azwmy8l4"><u>0.4.13 [21] std::recursive_mutex and std::recursive_timed_mutex should not be used Do not use std::recursive_mutex</u> <u>17</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.z9k66jbl65u6"><u>0.4.14 [22] There should be a code path, where at least one member functions is called for std::unique_lock objects Only use std::unique_lock when std::lock_guard cannot be used</u> <u>18</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.3icrgfn0r3ae"><u>0.5 Conditional variable</u> <strong><u>19</u></strong></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.g0cdm0bk7l9l"><u>0.5.1 [23] std::condition_variable::wait, std::condition_variable::wait_for, std::condition_variable::wait_until shall always be called with a condition predicate</u> <u>19</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.ul4y0p7eoih1"><u>0.5.2 [24] Wrap functions that can spuriously wake up in a loop</u> <u>20</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.13kr181fh926"><u>0.5.3 [25] std::conditional_variable::notify_one() can be used if all threads must perform the same set of operations after waking up Preserve thread safety and liveness when using condition variables</u> <u>21</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.yt0hxah53p9e"><u>0.5.4 [26] Do not use std::condition_variable_any on a std::mutex</u></a></p></li>
<li><p>[<span data-custom-style="Hyperlink">0.10.1 [35] Source CCG Rule CP.100: Don't use lock-free programming unless you absolutely have to</span></p>
<p><span data-custom-style="Hyperlink">27</span>](https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.3hq5f8vdw7d)</p></li>
<li><p>0.10.2 [36] Source CCG Rule CP.101: Distrust your hardware/compiler combination</p></li>
<li><p>0.10.3 [37] Source CCG Rule CP.102: Carefully study the literature</p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.ca8el9ehijae"><span data-custom-style="Hyperlink">0.10.4 [38] Source CCG Rule CP.110: Do not write your own double-checked locking for initialization</span></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.9syx86lze887"><span data-custom-style="Hyperlink">0.10.5 [39] Source HIC Rule 18.2.4 Use std::call_once to ensure a function is called exactly once (rather than the Double-Checked Locking pattern)</span></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.gg4jn12ygzi5"><span data-custom-style="Hyperlink">0.10.6 [40] Source CCG Rule CP.111: Use a conventional pattern if you really need double-checked locking</span></a></p></li>
<li></li>
</ul>
<h2 id="uncontrolled-format-string-shl">6.64 Uncontrolled Format String [SHL]</h2>
<h3 id="applicability-to-language">6.64.1 Applicability to language</h3>
<p>C++ inherits the C libraries which provide a large family of input and output functions that use a control string to interpret the data read or format the output. These strings include all the feature described in ISO/IEC TR 24772-1:2019 clause 6.64.1.</p>
<p>C++ provides type-safe alternatives for input/output, which do not use format strings and which should be used in preference, such as</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> aNumber{};</span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span>(<span class="bu">std::</span>cin){ <span class="co">// is input still available</span></span>
<span id="cb202-3"><a href="#cb202-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Enter a whole number, please:&quot;</span>;</span>
<span id="cb202-4"><a href="#cb202-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="bu">std::</span>cin &gt;&gt; aNumber) { <span class="co">// no format string needed</span></span>
<span id="cb202-5"><a href="#cb202-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &gt;&gt; <span class="st">&quot;Thank you, the number can be represented as &quot;</span></span>
<span id="cb202-6"><a href="#cb202-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>format(<span class="st">&quot;0b</span><span class="sc">{0:b}</span><span class="st"> </span><span class="sc">{0:d}</span><span class="st"> 0</span><span class="sc">{0:o}</span><span class="st"> 0x</span><span class="sc">{0:x}</span><span class="st">&quot;</span>, aNumber);</span>
<span id="cb202-7"><a href="#cb202-7" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> { <span class="co">// input failed</span></span>
<span id="cb202-8"><a href="#cb202-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin.clear();  <span class="co">// re-enable input</span></span>
<span id="cb202-9"><a href="#cb202-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string line;</span>
<span id="cb202-10"><a href="#cb202-10" aria-hidden="true" tabindex="-1"></a>    getline(<span class="bu">std::</span>cin,line); <span class="co">// skip to eol</span></span>
<span id="cb202-11"><a href="#cb202-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb202-12"><a href="#cb202-12" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In addition, operator overloading of output operators allows to extend formatting abilities to user-defined types.</p>
<h3 id="guidance-to-language-users">6.64.2 Guidance to language users</h3>
<p>Avoid the C library facilities provided by <strong><code>&lt;cstdio&gt;</code></strong>.</p>
<p>Use the mechanisms provided by the standard library as described in ISO/IEC 14882 20.20 Formatting [format] or similar libraries, if <em>printf-style</em> formatting of output or strings is desired, or when the formatting facilities of <code>std::ostream</code> are inadequate.</p>
<p>Read untrusted input as plain characters and then check for validity, before any conversion to numbers or program entities occurs, using facilities that do not require format strings and that check and report error conditions.</p>
<h1 id="UJO">6.65 Modifying constants [UJO]</h1>
<h3 id="applicability-to-language">6.65.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 clause 6.65 exists in C++.</p>
<p>An object can be declared as <code class="sourceCode cpp"><span class="at">const</span></code>, denoting that its value will not change in its lifetime:</p>
<p><code class="sourceCode cpp"><span class="dt">int</span> <span class="at">const</span> i = <span class="dv">0</span>;</code></p>
<p>A object that is not <code class="sourceCode cpp"><span class="at">const</span></code>-qualified can be accessed through a path that is <code class="sourceCode cpp"><span class="at">const</span></code>-qualified:</p>
<div class="sourceCode" id="cb203"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a>  T k = <span class="dv">0</span>;</span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a>  T <span class="at">const</span> &amp; j = k;                <span class="co">// &#39;j&#39; is a const reference to &#39;k&#39;</span></span>
<span id="cb203-3"><a href="#cb203-3" aria-hidden="true" tabindex="-1"></a>  T <span class="at">const</span> * p = &amp;k;               <span class="co">// &#39;p&#39; is a pointer to const &#39;k&#39;</span></span>
<span id="cb203-4"><a href="#cb203-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const_cast</span>&lt;T <span class="at">const</span> &amp;&gt;(k);       <span class="co">// The type of the expression is const</span></span></code></pre></div>
<p>The checking for the correctness of <code class="sourceCode cpp"><span class="at">const</span></code> is enforced based on the access-path and not the type of the target object. For example, the following are ill-formed as the access path of the left-hand expression is <code class="sourceCode cpp"><span class="at">const</span></code>-qualified:</p>
<div class="sourceCode" id="cb204"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a>  i = <span class="dv">0</span>; <span class="co">// T const i;</span></span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a>  j = <span class="dv">0</span>; <span class="co">// T const &amp;j</span></span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true" tabindex="-1"></a>  *p = <span class="dv">0</span>; <span class="co">// T const *p</span></span>
<span id="cb204-4"><a href="#cb204-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const_cast</span>&lt;T <span class="at">const</span> &amp;&gt;(k) = <span class="dv">0</span>; <span class="co">// T k i.e. not const</span></span></code></pre></div>
<p>Note that the object <code class="sourceCode cpp">k</code> referred to by <code class="sourceCode cpp">j</code>, <code class="sourceCode cpp">*p</code> and the <code class="sourceCode cpp"><span class="kw">const_cast</span>,</code> is not constant. In each case the access path could be changed to remove <code class="sourceCode cpp"><span class="at">const</span></code> making the program well-formed: <code class="sourceCode cpp"><span class="kw">const_cast</span>&lt;T&amp;&gt; (j) = <span class="dv">0</span>; <span class="co">// well-formed</span></code></p>
<p>While it is possible to remove the const-qualification for an access path, attempting to modify a const object this way is undefined-behavior(see <span id="EWF">Undefined Behavior [EWF]</span>) : <code class="sourceCode cpp"><span class="kw">const_cast</span>&lt;T&amp;&gt; (i) = <span class="dv">0</span>; <span class="co">// undefined behavior</span></code></p>
<p>We distinguish between qualifications on the pointer’s type (pointer type) and qualifications on the type being referenced (pointer type).</p>
<p>A pointer type can be qualified as <code class="sourceCode cpp"><span class="at">const</span></code>, however the qualification only applies to the pointer type and not the pointee’s type. A reference type is implicitly immutable, only the referred type can be <code class="sourceCode cpp"><span class="at">const</span></code> qualified.</p>
<div class="sourceCode" id="cb205"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> T = <span class="dt">int</span>;</span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> T1 = T &amp;;</span>
<span id="cb205-3"><a href="#cb205-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> T2 = T *;</span>
<span id="cb205-4"><a href="#cb205-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> S1 = T1 <span class="at">const</span>;  <span class="co">// The const is ignored, S1 has type &#39;T &amp;&#39;</span></span>
<span id="cb205-5"><a href="#cb205-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> S2 = T2 <span class="at">const</span>;  <span class="co">// The const applies to the pointer type,</span></span>
<span id="cb205-6"><a href="#cb205-6" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// S2 has type &#39;T * const&#39;</span></span>
<span id="cb205-7"><a href="#cb205-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-8"><a href="#cb205-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> foo (S1 s1, S2 s2)</span>
<span id="cb205-9"><a href="#cb205-9" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb205-10"><a href="#cb205-10" aria-hidden="true" tabindex="-1"></a>    s1 = <span class="dv">0</span>;            <span class="co">// well-formed</span></span>
<span id="cb205-11"><a href="#cb205-11" aria-hidden="true" tabindex="-1"></a>    *s2 = <span class="dv">0</span>;           <span class="co">// well-formed</span></span>
<span id="cb205-12"><a href="#cb205-12" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>A common misconception is that a member function qualified with <code class="sourceCode cpp"><span class="at">const</span></code> cannot modify any of its members. The following badly defined class introduces a non-<code class="sourceCode cpp"><span class="at">const</span></code> access path to a potentially const object:</p>
<div class="sourceCode" id="cb206"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> A</span>
<span id="cb206-2"><a href="#cb206-2" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb206-3"><a href="#cb206-3" aria-hidden="true" tabindex="-1"></a>    A * pA;                <span class="co">// Pointer to non-const A</span></span>
<span id="cb206-4"><a href="#cb206-4" aria-hidden="true" tabindex="-1"></a>    T array[<span class="dv">2</span>];            <span class="co">// Array of type T</span></span>
<span id="cb206-5"><a href="#cb206-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-6"><a href="#cb206-6" aria-hidden="true" tabindex="-1"></a>    A () : pA{<span class="kw">this</span>}{}      <span class="co">// pA provides access path to non-const</span></span>
<span id="cb206-7"><a href="#cb206-7" aria-hidden="true" tabindex="-1"></a>                           <span class="co">// this.</span></span>
<span id="cb206-8"><a href="#cb206-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-9"><a href="#cb206-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f () <span class="at">const</span></span>
<span id="cb206-10"><a href="#cb206-10" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb206-11"><a href="#cb206-11" aria-hidden="true" tabindex="-1"></a>      <span class="co">// pA = nullptr;     // ill-formed</span></span>
<span id="cb206-12"><a href="#cb206-12" aria-hidden="true" tabindex="-1"></a>      <span class="co">// array[0] = 0;     // ill-formed</span></span>
<span id="cb206-13"><a href="#cb206-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-14"><a href="#cb206-14" aria-hidden="true" tabindex="-1"></a>      pA-&gt;array[<span class="dv">0</span>] = <span class="dv">0</span>;    <span class="co">// compiles, but undefined behavior</span></span>
<span id="cb206-15"><a href="#cb206-15" aria-hidden="true" tabindex="-1"></a>                           <span class="co">// if executed on a const object</span></span>
<span id="cb206-16"><a href="#cb206-16" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb206-17"><a href="#cb206-17" aria-hidden="true" tabindex="-1"></a>  };</span></code></pre></div>
<p>In the const member function f, naming array directly results in a const-qualified access path and so an attempt to modify it is ill-formed. However, the type of pA is <code class="sourceCode cpp">A * <span class="at">const</span></code>, that is a <code class="sourceCode cpp"><span class="at">const</span></code> pointer to a non-const <code class="sourceCode cpp">A</code>. An attempt to modify <code class="sourceCode cpp">pA</code> is ill-formed, however, modification of the value pointed to by <code class="sourceCode cpp">pA</code> is not a const-qualified access path and so is not ill-formed.</p>
<p>It is undefined behavior to attempt to modify a const object. The programmer can incorrectly assume that a call to a const member function will not modify the object. However, as has been shown above, there is no guarantee that this is the case. The following example, therefore, will compile but has undefined behavior as a result of the modification of the const object:</p>
<div class="sourceCode" id="cb207"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> foo ()</span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a>  { </span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a>     A a1 {} ;</span>
<span id="cb207-4"><a href="#cb207-4" aria-hidden="true" tabindex="-1"></a>     A <span class="at">const</span> a2 {} ;</span>
<span id="cb207-5"><a href="#cb207-5" aria-hidden="true" tabindex="-1"></a>     a1.f();           <span class="co">// OK - &#39;a1&#39; is not const</span></span>
<span id="cb207-6"><a href="#cb207-6" aria-hidden="true" tabindex="-1"></a>     a2.f();           <span class="co">// compiles but has undefined behavior</span></span>
<span id="cb207-7"><a href="#cb207-7" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>C++ classes wrapping pointer or reference members can be used to provide transitivity of <code class="sourceCode cpp"><span class="at">const</span></code> within <code class="sourceCode cpp"><span class="at">const</span></code> member functions. This is shown by the <code class="sourceCode cpp">MyRef</code> type in the following example:</p>
<div class="sourceCode" id="cb208"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; </span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MyRef</span>
<span id="cb208-3"><a href="#cb208-3" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb208-4"><a href="#cb208-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb208-5"><a href="#cb208-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">operator</span> T&amp;() &amp;;</span>
<span id="cb208-6"><a href="#cb208-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">operator</span> T <span class="at">const</span> &amp;() <span class="at">const</span> &amp;;</span>
<span id="cb208-7"><a href="#cb208-7" aria-hidden="true" tabindex="-1"></a>  MyRef &amp; <span class="kw">operator</span>=(T <span class="at">const</span> &amp;) &amp;;</span>
<span id="cb208-8"><a href="#cb208-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-9"><a href="#cb208-9" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span>:</span>
<span id="cb208-10"><a href="#cb208-10" aria-hidden="true" tabindex="-1"></a>  T &amp; <span class="va">m_t</span>;</span>
<span id="cb208-11"><a href="#cb208-11" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb208-12"><a href="#cb208-12" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb208-13"><a href="#cb208-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A {</span>
<span id="cb208-14"><a href="#cb208-14" aria-hidden="true" tabindex="-1"></a>  A();</span>
<span id="cb208-15"><a href="#cb208-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-16"><a href="#cb208-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f1() {</span>
<span id="cb208-17"><a href="#cb208-17" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_i</span> = <span class="dv">0</span>;</span>
<span id="cb208-18"><a href="#cb208-18" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_j</span> = <span class="dv">0</span>;</span>
<span id="cb208-19"><a href="#cb208-19" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_j</span> ++;</span>
<span id="cb208-20"><a href="#cb208-20" aria-hidden="true" tabindex="-1"></a>    ++<span class="va">m_j</span>;</span>
<span id="cb208-21"><a href="#cb208-21" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb208-22"><a href="#cb208-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-23"><a href="#cb208-23" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f() <span class="at">const</span> {</span>
<span id="cb208-24"><a href="#cb208-24" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_i</span> = <span class="dv">0</span>;     <span class="co">// compiles, but undefined behavior</span></span>
<span id="cb208-25"><a href="#cb208-25" aria-hidden="true" tabindex="-1"></a>                 <span class="co">// if &#39;m_i&#39; refers to a const object</span></span>
<span id="cb208-26"><a href="#cb208-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-27"><a href="#cb208-27" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_j</span> = <span class="dv">0</span>;     <span class="co">// ill-formed</span></span>
<span id="cb208-28"><a href="#cb208-28" aria-hidden="true" tabindex="-1"></a>    ++ <span class="va">m_j</span>;      <span class="co">// ill-formed</span></span>
<span id="cb208-29"><a href="#cb208-29" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb208-30"><a href="#cb208-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-31"><a href="#cb208-31" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> &amp; <span class="va">m_i</span>;</span>
<span id="cb208-32"><a href="#cb208-32" aria-hidden="true" tabindex="-1"></a>  MyRef&lt;<span class="dt">int</span>&gt; <span class="va">m_j</span>;</span>
<span id="cb208-33"><a href="#cb208-33" aria-hidden="true" tabindex="-1"></a>};<span class="er">```</span></span>
<span id="cb208-34"><a href="#cb208-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-35"><a href="#cb208-35" aria-hidden="true" tabindex="-1"></a>Attempts to modify the object referenced by <span class="er">`</span><span class="va">m_j</span><span class="er">`</span>{.cpp} are ill-formed</span>
<span id="cb208-36"><a href="#cb208-36" aria-hidden="true" tabindex="-1"></a>when they occur in the <span class="at">const</span> member function <span class="er">`</span>f2<span class="er">`</span>{.cpp}.</span>
<span id="cb208-37"><a href="#cb208-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-38"><a href="#cb208-38" aria-hidden="true" tabindex="-1"></a>C++ container iterator types, <span class="er">`</span>iterator<span class="er">`</span>{.cpp} <span class="kw">and</span> <span class="er">`</span>const_iterator<span class="er">`</span>{.cpp},</span>
<span id="cb208-39"><a href="#cb208-39" aria-hidden="true" tabindex="-1"></a>are examples of use of <span class="kw">this</span> pattern.</span>
<span id="cb208-40"><a href="#cb208-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-41"><a href="#cb208-41" aria-hidden="true" tabindex="-1"></a>If a member variable is declared with the <span class="er">`</span>mutable<span class="er">`</span>{.cpp} keyword,</span>
<span id="cb208-42"><a href="#cb208-42" aria-hidden="true" tabindex="-1"></a>then it can still be modified, even <span class="cf">if</span> the containing object is</span>
<span id="cb208-43"><a href="#cb208-43" aria-hidden="true" tabindex="-1"></a><span class="er">`</span>const<span class="er">`</span>{.cpp}.  This is preferable to use <span class="er">`</span>mutable<span class="er">`</span>{.cpp} rather than</span>
<span id="cb208-44"><a href="#cb208-44" aria-hidden="true" tabindex="-1"></a>removing the constness of the containing object </span>
<span id="cb208-45"><a href="#cb208-45" aria-hidden="true" tabindex="-1"></a>(see [Conversion Errors [FLC] ]{<span class="er">#FLC}).  </span></span>
<span id="cb208-46"><a href="#cb208-46" aria-hidden="true" tabindex="-1"></a>Members declared <span class="er">`</span>mutable<span class="er">`</span>{.cpp} typically should <span class="kw">not</span></span>
<span id="cb208-47"><a href="#cb208-47" aria-hidden="true" tabindex="-1"></a>contribute to the value of the object.  The following is a common</span>
<span id="cb208-48"><a href="#cb208-48" aria-hidden="true" tabindex="-1"></a>example where a mutex member is declared <span class="er">`</span>mutable<span class="er">`</span>{.cpp} to allow</span>
<span id="cb208-49"><a href="#cb208-49" aria-hidden="true" tabindex="-1"></a>locking in a <span class="er">`</span>const<span class="er">`</span>{.cpp} member function:</span>
<span id="cb208-50"><a href="#cb208-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-51"><a href="#cb208-51" aria-hidden="true" tabindex="-1"></a><span class="er">```</span>{.cpp}</span>
<span id="cb208-52"><a href="#cb208-52" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;mutex&gt;</span></span>
<span id="cb208-53"><a href="#cb208-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-54"><a href="#cb208-54" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MyQueue</span>
<span id="cb208-55"><a href="#cb208-55" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb208-56"><a href="#cb208-56" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb208-57"><a href="#cb208-57" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> empty () <span class="at">const</span> </span>
<span id="cb208-58"><a href="#cb208-58" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb208-59"><a href="#cb208-59" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>lock_guard sg (<span class="va">m_mutex</span>); <span class="co">// lock the mutex, which requires m_mutex to be writable</span></span>
<span id="cb208-60"><a href="#cb208-60" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="va">m_head</span> != <span class="kw">nullptr</span>;</span>
<span id="cb208-61"><a href="#cb208-61" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb208-62"><a href="#cb208-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-63"><a href="#cb208-63" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb208-64"><a href="#cb208-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-65"><a href="#cb208-65" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span>:</span>
<span id="cb208-66"><a href="#cb208-66" aria-hidden="true" tabindex="-1"></a>  <span class="at">mutable</span> <span class="bu">std::</span>mutex <span class="va">m_mutex</span>;</span>
<span id="cb208-67"><a href="#cb208-67" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> * <span class="va">m_head</span> { <span class="kw">nullptr</span> };</span>
<span id="cb208-68"><a href="#cb208-68" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div>
<h3 id="guidance-to-language-users">6.65.2 Guidance to language users</h3>
<p>In addition to the general advice of TR 24772-1 clause 6.65:</p>
<ul>
<li><p>Do not cast-away <code class="sourceCode cpp"><span class="at">const</span></code>.</p></li>
<li><p>Leverage the C++ type system to restrict the operations on a type in a way that emulates <em>logical const</em> and document where used</p></li>
<li><p>Be aware that, while <code class="sourceCode cpp"><span class="at">const</span></code> means “read only”, C++ permits <code class="sourceCode cpp"><span class="at">const</span></code> values to be modified as shown in clause 6.65.1; and</p></li>
<li><p>Consider the use of “constexpr” wherever possible to move the detection</p></li>
<li><p>Apply <code class="sourceCode cpp"><span class="at">mutable</span></code> only to member variables that do not influence the external behavior of an object.</p></li>
</ul>
<!-- -->
<h1 id="language-specific-vulnerabilities-for-c">7. Language specific vulnerabilities for C</h1>
<p>7.2 Copy/move semantics from Classes. (Peter Sommerlad’s paper at http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1412r0.pdf</p>
<h1 id="implications-for-standardization">8. Implications for standardization</h1>
<p>Future standardization efforts should consider:</p>
<ul>
<li><pre><code>Moving in the direction over time to being a more strongly typed</code></pre>
<p>language. Much of the use of weak typing is simply convenience to the developer in not having to fully consider the types and uses of variables. Stronger typing forces good programming discipline and clarity about variables while at the same time removing many unexpected run time errors due to implicit conversions. This is not to say that C should be strictly a strongly typed language – some advantages of C are due to the flexibility that weaker typing provides. It is suggested that when enforcement of strong typing does not detract from the good flexibility that C offers (for example, adding an integer to a character to step through a sequence of characters) and is only a convenience for programmers (for example, adding an integer to a floating-point number), then the standard should specify the stronger typed solution.</p></li>
<li><pre><code>A common warning in Annex I should be added for floating-point</code></pre>
<p>expressions being used in a Boolean test for equality.</p></li>
<li><pre><code>Modifying or deprecating many of the C standard library functions</code></pre>
<p>that make assumptions about the occurrence of a string termination character.</p></li>
<li><pre><code>Define a string construct that does not rely on the null termination</code></pre>
<p>character.</p></li>
<li><pre><code>Defining an array type that does automatic bounds checking.</code></pre></li>
<li><pre><code>Deprecating less safe functions such as strcpy() and strcat() where</code></pre>
<p>a more secure alternative is available.<span data-custom-style="annotation reference"></span></p></li>
<li><pre><code>Defining safer and more secure replacement functions such as</code></pre>
<p>memncpy() and memncmp() to complement the memcpy() and memcmp() functions (see <em>6.11.6 Implications for standardization</em>)</p></li>
<li><pre><code>Defining an array type that does automatic bounds checking.</code></pre></li>
<li><pre><code>Defining functions that contain an extra parameter in memcpy() and</code></pre>
<p>memmove() for the maximum number of bytes to copy. In the past, some have suggested that the size of the destination buffer be used as an additional parameter. Some critics state that this solution is easy to circumvent by simply repeating the parameter that was used for the number of bytes to copy as the parameter for the size of the destination buffer. This analysis and criticism is correct. What is needed is a failsafe check as to the maximum number of bytes to copy. There are several reasons for creating new functions with an additional parameter. This would make it easier for static analysis to eliminate those cases where the memory copy could not be a problem (such as when the maximum number of bytes is demonstrably less than the capacity of the receiving buffer). Manual analysis or more involved static analysis could then be used for the remaining situations where the size of the destination buffer may not be sufficient for the maximum number of bytes to copy. This extra parameter may also help in determining which copies could take place among objects that overlap. Such copying is undefined according to the C standard. It is suggested that safer versions of functions that include a restriction max_n on the number of bytes n to copy (for example, void *memncpy(void * restrict s1,const void * restrict s2,size_t n), const size_t max_n) be added to the standard in addition to retaining the current corresponding functions (for example, memcpy(void * restrict s1,const void * restrict s2,size_t n))). The additional parameter would be consistent with the copying function pairs that have already been created such as strcpy()/strncpy() and strcat()/strncat(). This would allow a safer version of memory copying functions for those applications that want to use them in to facilitate both safer and more secure code and more efficient and accurate static code reviews<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p></li>
<li><pre><code>Restrictions on pointer arithmetic that could eliminate common</code></pre>
<p>pitfalls. Pointer arithmetic is error-prone and the flexibility that it offers is useful, but some of the flexibility is simply a shortcut that if restricted could lessen the chance of a pointer arithmetic based error.</p></li>
<li><pre><code>Defining a standard way of declaring an attribute to indicate that a</code></pre>
<p>variable is intentionally unused.</p></li>
<li><pre><code>A common warning in Annex I should be added for variables with the</code></pre>
<p>same name in nested scopes.</p></li>
<li><pre><code>Creating a few standardized precedence orders. Standardizing on a</code></pre>
<p>few precedence orders will help to eliminate the confusing intricacies that exist between languages. This would not affect current languages as altering precedence orders in existing languages is too onerous. However, this would set a basis for the future as new languages are created and adopted. Stating that a language uses “ISO precedence order A” would be useful rather than having to spell out the entire precedence order that differs in a conceptually minor way from some other languages, but in a major way when programmers attempt to switch between languages.</p></li>
<li><pre><code>Deprecating the goto statement. The use of the goto construct is</code></pre>
<p>often spotlighted as the antithesis of good structured programming. Though its deprecation will not instantly make all C code structured, deprecating the goto and leaving in place the restricted goto variations (for example, break and continue) and possibly adding other restricted goto’s could assist in encouraging safer and more secure C programming in general.</p></li>
<li><pre><code>Defining a &quot;fallthru&quot; construct that will explicitly bind multiple</code></pre>
<p>switch cases together and eliminate the need for the break statement. The default would be for a case to break instead of falling through to the next case. Granted this is a major shift in concept, but if it could be accomplished, less unintentional errors would occur.</p></li>
<li><pre><code>Defining an identifier type for loop control that cannot be modified</code></pre>
<p>by anything other than the loop control construct would be a relatively minor addition to C that could make C code safer and encourage better structured programming.</p></li>
<li><pre><code>Defining a standardized interface package for interfacing C with</code></pre>
<p>many of the top programming languages and a reciprocal package should be developed of the other top languages to interface with C.</p></li>
<li><pre><code>Joining with other languages in developing a standardized set of</code></pre>
<p>mechanisms for detecting and treating error conditions so that all languages to the extent possible could use them. Note that this does not mean that all languages should use the same mechanisms as there should be a variety ( label parameters, auxiliary status variables), but each of the mechanisms should be standardized.</p></li>
<li><pre><code>Since fault handling and exiting of a program is common to all</code></pre>
<p>languages, it is suggested that common terminology such as the meaning of fail safe, fail hard, fail soft, and so on along with a core API set such as exit, abort, and so on be standardized and coordinated with other languages.</p></li>
<li><pre><code>Deprecating unions. The primary reason for the use of unions to save</code></pre>
<p>memory has been diminished considerably as memory has become cheaper and more available. Unions are not statically type safe and are historically known to be a common source of errors, leading to many C programming guidelines specifically prohibiting the use of unions.</p></li>
<li><pre><code>Creating a recognizable naming standard for routines such that one</code></pre>
<p>version of a library does parameter checking to the extent possible and another version does no parameter checking. The first version would be considered safer and more secure and the second could be used in certain situations where performance is critical and the checking is assumed to be done in the calling routine. A naming standard could be made such that the library that does parameter checking could be named as usual, say “library_xyz” and an equivalent version that does not do checking could have a “_p” appended, such as “library_xyz_p”. Without a naming standard such as this, a considerable number of wasted cycles will be conducted doing a double check of parameters or even worse, no checking will be done in both the calling and receiving routines as each is assuming the other is doing the checking.</p></li>
<li><pre><code>Creating an Annex that lists deprecated features.</code></pre></li>
</ul>
<h1 id="bibliography">Bibliography</h1>
<div data-custom-style="Bibliography1">
<p>[1] ISO/IEC Directives, Part 2, <em>Rules for the structure and drafting of International Standards</em>, 2004</p>
</div>
<div data-custom-style="Bibliography1">
<p>[2] ISO/IEC TR 10000‑1, <em>Information technology — Framework and taxonomy of International Standardized Profiles — Part 1: General principles and documentation framework</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[3] ISO 10241 (all parts), <em>International terminology standards</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[4] ISO/IEC 9899:2011, <em>Information technology</em> — <em>Programming languages —</em> C</p>
</div>
<div data-custom-style="Bibliography1">
<p>[5] ISO/IEC 9899:2011/Cor.1:2012, <em>Technical Corrigendum 1</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[6] ISO/IEC 30170:2012, <em>Information technology</em> — <em>Programming languages —</em> Ruby</p>
</div>
<div data-custom-style="Bibliography1">
<p>[7] ISO/IEC/IEEE 60559:2011, <em>Information technology – Microprocessor Systems – Floating-Point arithmetic</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[8] ISO/IEC 1539-1:2010, <em>Information technology — Programming languages —</em> Fortran — Part 1: Base language</p>
</div>
<div data-custom-style="Bibliography1">
<p>[9] ISO/IEC 8652:1995, <em>Information technology — Programming languages —</em> Ada</p>
</div>
<div data-custom-style="Bibliography1">
<p>[10] ISO/IEC 14882:2011, <em>Information technology</em> — <em>Programming languages —</em> C++</p>
</div>
<div data-custom-style="Bibliography1">
<p>[11] R. Seacord, <em>The CERT C Secure Coding Standard</em>. Boston,MA: Addison-Westley, 2008.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[12] Motor Industry Software Reliability Association. <em>Guidelines for the Use of the C Language in Vehicle Based Software</em>, 2012 (third edition)16F<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[13] ISO/IEC TR24731–1, <em>Information technology — Programming languages, their environments and system software interfaces — Extensions to the C library — Part 1: Bounds-checking interfaces</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[14] ISO/IEC TR 15942:2000, <em>Information technology — Programming languages — Guide for the use of the Ada programming language in high integrity systems</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[15] Joint Strike Fighter Air Vehicle: C++ Coding Standards for the System Development and Demonstration Program. Lockheed Martin Corporation. December 2005.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[16] Motor Industry Software Reliability Association. <em>Guidelines for the Use of the C++ Language in critical systems</em>, June 2008</p>
</div>
<div data-custom-style="Bibliography1">
<p>[17] ISO/IEC TR 24718: 2005, <em>Information technology — Programming languages — Guide for the use of the Ada Ravenscar Profile in high integrity systems</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[18] L. Hatton, Safer C: developing software for high-integrity and safety-critical systems. McGraw-Hill 1995</p>
</div>
<div data-custom-style="Bibliography1">
<p>[19] ISO/IEC 15291:1999, <em>Information technology — Programming languages — Ada Semantic Interface Specification (ASIS)</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[20] Software Considerations in Airborne Systems and Equipment Certification. Issued in the USA by the Requirements and Technical Concepts for Aviation (document RTCA SC167/DO-178B) and in Europe by the European Organization for Civil Aviation Electronics (EUROCAE document ED-12B).December 1992.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[21] IEC 61508: Parts 1-7, Functional safety: safety-related systems. 1998. (Part 3 is concerned with software).</p>
</div>
<div data-custom-style="Bibliography1">
<p>[22] ISO/IEC 15408: 1999 Information technology. Security techniques. Evaluation criteria for IT security.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[23] J Barnes, High Integrity Software - the SPARK Approach to Safety and Security. Addison-Wesley. 2002.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[25] Steve Christy, <em>Vulnerability Type Distributions in CVE</em>, V1.0, 2006/10/04</p>
</div>
<div data-custom-style="Bibliography1">
<p>[26] <em>ARIANE 5: Flight 501 Failure</em>, Report by the Inquiry Board, July 19, 1996 <a href="http://esamultimedia.esa.int/docs/esa-x-1819eng.pdf"><span data-custom-style="Hyperlink">http://esamultimedia.esa.int/docs/esa-x-1819eng.pdf</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[27] Hogaboom, Richard, <em>A Generic API Bit Manipulation in C</em>, Embedded Systems Programming, Vol 12, No 7, July 1999 <a href="http://www.embedded.com/1999/9907/9907feat2.htm"><span data-custom-style="Hyperlink">http://www.embedded.com/1999/9907/9907feat2.htm</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[28] Carlo Ghezzi and Mehdi Jazayeri, Programming Language Concepts, 3<sup>rd</sup> edition, ISBN-0-471-10426-4, John Wiley &amp; Sons, 1998</p>
</div>
<div data-custom-style="Bibliography1">
<p>[29] Lions, J. L. <a href="http://en.wikisource.org/wiki/Ariane_501_Inquiry_Board_report"><span data-custom-style="Hyperlink">ARIANE 5 Flight 501 Failure Report</span></a>. Paris, France: European Space Agency (ESA) &amp; National Center for Space Study (CNES) Inquiry Board, July 1996.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[30] Seacord, R. <em>Secure Coding in C and C++</em>. Boston, MA: Addison-Wesley, 2005. See <a href="http://www.cert.org/books/secure-coding"><span data-custom-style="Hyperlink">http://www.cert.org/books/secure-coding</span></a> for news and errata.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[31] John David N. Dionisio. Type Checking. <a href="http://myweb.lmu.edu/dondi/share/pl/type-checking-v02.pdf"><span data-custom-style="Hyperlink">http://myweb.lmu.edu/dondi/share/pl/type-checking-v02.pdf</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[32] MISRA Limited. "<a href="http://www.misra.org.uk/"><span data-custom-style="Hyperlink">MISRA C</span></a>: 2012 Guidelines for the Use of the C Language in Critical Systems." Warwickshire, UK: MIRA Limited, March 2013 (ISBN 978-1-906400-10-1 and 978-1-906400-11-8).</p>
</div>
<div data-custom-style="Bibliography1">
<p>[33] The Common Weakness Enumeration (CWE) Initiative, MITRE Corporation, (<a href="http://cwe.mitre.org/"><span data-custom-style="Hyperlink">http://cwe.mitre.org/</span></a>)</p>
</div>
<div data-custom-style="Bibliography1">
<p>[34] Goldberg, David, <em>What Every Computer Scientist Should Know About Floating-Point Arithmetic</em>, ACM Computing Surveys, vol 23, issue 1 (March 1991), ISSN 0360-0300, pp 5-48.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[35] IEEE Standards Committee 754. IEEE Standard for Binary Floating-Point Arithmetic, ANSI/IEEE Standard 754-2008. Institute of Electrical and Electronics Engineers, New York, 2008.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[36] Robert W. Sebesta, Concepts of Programming Languages, 8<sup>th</sup> edition, ISBN-13: 978-0-321-49362-0, ISBN-10: 0-321-49362-1, Pearson Education, Boston, MA, 2008</p>
</div>
<div data-custom-style="Bibliography1">
<p>[37] Bo Einarsson, ed. Accuracy and Reliability in Scientific Computing, SIAM, July 2005 <a href="http://www.nsc.liu.se/wg25/book"><span data-custom-style="Hyperlink">http://www.nsc.liu.se/wg25/book</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[38] GAO Report, Patriot <em>Missile Defense: Software Problem Led to System Failure at Dhahran, Saudi Arabia</em>, B-247094, Feb. 4, 1992, <a href="http://archive.gao.gov/t2pbat6/145960.pdf"><span data-custom-style="Hyperlink">http://archive.gao.gov/t2pbat6/145960.pdf</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[39] Robert Skeel, <em>Roundoff Error Cripples Patriot Missile</em>, SIAM News, Volume 25, Number 4, July 1992, page 11, <a href="http://www.siam.org/siamnews/general/patriot.htm"><span data-custom-style="HTML Typewriter"><u>http://www.siam.org/siamnews/general/patriot.htm</u></span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[40] CERT. <em>CERT C++ Secure Coding Standard</em>.  <a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637%20"><span data-custom-style="Hyperlink">https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637</span></a> (2009).</p>
</div>
<div data-custom-style="Bibliography1">
<p>[41] Holzmann, Garard J., Computer, vol. 39, no. 6, pp 95-97, Jun., 2006, <em>The Power of 10: Rules for Developing Safety-Critical Code</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[42] P. V. Bhansali, A systematic approach to identifying a safe subset for safety-critical software, ACM SIGSOFT Software Engineering Notes, v.28 n.4, July 2003</p>
</div>
<div data-custom-style="Bibliography1">
<p>[43] Ada 95 Quality and Style Guide, SPC-91061-CMC, version 02.01.01. Herndon, Virginia: Software Productivity Consortium, 1992. Available from: <a href="http://www.adaic.org/docs/95style/95style.pdf"><span data-custom-style="Hyperlink">http://www.adaic.org/docs/95style/95style.pdf</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[44] Ghassan, A., &amp; Alkadi, I. (2003). Application of a Revised DIT Metric to Redesign an OO Design. <em>Journal of Object Technology</em> , 127-134.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[45] Subramanian, S., Tsai, W.-T., &amp; Rayadurgam, S. (1998). Design Constraint Violation Detection in Safety-Critical Systems. The 3rd IEEE International Symposium on High-Assurance Systems Engineering , 109 - 116.</p>
</div>
<p>[46] Lundqvist, K and Asplund, L., “<em>A Formal Model of a Run-Time Kernel for Ravenscar</em>”, The 6th International Conference on Real-Time Computing Systems and Applications – RTCSA 1999</p>
<p>[47] ISO/IEC TS 17961, <em>Information technology – Programming languages, their environments and system software interfaces – C secure coding rules</em></p>
<p>[48] GNU Project. GCC Bugs “Non-bugs” http://gcc.gnu.org/bugs.html#nonbugs_c (2009).</p>
<h1 id="index">Index</h1>
<div data-custom-style="Bibliography1">
<p>LHS (left-hand side), 22</p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>::: {custom-style=“footnote text”} <span data-custom-style="footnote reference"></span> This has been addressed by WG 14 in an optionally normative annex in the current working paper<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>::: {custom-style=“footnote text”} <span data-custom-style="footnote reference"></span> The first edition should not be used or quoted in this work.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
