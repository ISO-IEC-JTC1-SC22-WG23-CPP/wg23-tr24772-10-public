<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>tr24772-10-C++</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div data-custom-style="zzCover">
<p>ISO/IEC JTC 1/SC 22/WG23 N1012</p>
</div>
<div data-custom-style="zzCover">
<p>Date: 2020-11-23</p>
</div>
<div data-custom-style="zzCover">
<p>ISO/IEC TR 24772–10<br />
Notes on this document</p>
</div>
<p>Effective 23 November 2020, this document is being moved to “github”. Contact <span data-custom-style="Hyperlink">Stephen.michell@maurya.on.ca</span> to gain access.</p>
<p>This document is a draft of a Guidance to avoiding programming language vulnerabilities in C++.</p>
<p>At this point in time, the following clauses are essentially completed first pass.</p>
<ul>
<li><pre><code>6.2 type system</code></pre></li>
<li><pre><code>6.3 Bit representation</code></pre></li>
<li><pre><code>6.4 Floating Point</code></pre></li>
<li><pre><code>6.5 Enumerator issues \[CCB\],</code></pre></li>
<li><pre><code>6.6 Conversion errors</code></pre></li>
<li><pre><code>6.7 String termination</code></pre></li>
<li><pre><code>6.8 Buffer boundary violation</code></pre></li>
<li><pre><code>6.9 Unchecked array indexing</code></pre></li>
<li><pre><code>6.10 Unchecked array copying (needs to be revisited)</code></pre></li>
<li><pre><code>6.11 Pointer type conversions</code></pre></li>
<li><pre><code>6.12 Pointer arithmetic</code></pre></li>
<li><pre><code>6.13 Null pointer dereference \[XYH\],</code></pre></li>
<li><pre><code>6.14 Dangling reference to heap</code></pre></li>
<li><pre><code>6.15 Arithmetic wrap-around error</code></pre></li>
<li><pre><code>6.16 Using shift operations for multiplication and division</code></pre></li>
<li><pre><code>6.17 Choice of clear names \[NAI\]</code></pre></li>
<li><pre><code>6.18 Dead Store</code></pre></li>
<li><pre><code>6.19 Unused variables</code></pre></li>
<li><pre><code>6.20 Identifier name reuse</code></pre></li>
<li><pre><code>6.21 Namespace Issues</code></pre></li>
<li><pre><code>6.22 Initialization of variables \[LAV\]</code></pre></li>
<li><pre><code>6.23 Operator precedence and associativity</code></pre></li>
<li><pre><code>6.24 Side effects and order of evaluation</code></pre></li>
<li><pre><code>6.25 Likely incorrect expression</code></pre></li>
<li><pre><code>6.26 Dead store,</code></pre></li>
<li><pre><code>6.27 Switch statements and static analysis</code></pre></li>
<li><pre><code>6.28 Demarcation of control flow</code></pre></li>
<li><pre><code>6.29 Loop control variables</code></pre></li>
<li><pre><code>6.30 Off-by-one errors</code></pre></li>
<li><pre><code>6.31 Structured programming</code></pre></li>
<li><pre><code>6.32 Passing parameters and return values</code></pre></li>
<li><pre><code>6.33 Dangling references to stack frames</code></pre></li>
<li><pre><code>6.34 Subprogram signature mismatch</code></pre></li>
<li><pre><code>6.35 Recursion</code></pre></li>
<li><pre><code>6.36 Ignored error status and unhandled exceptions</code></pre></li>
<li><pre><code>6.37 Type breaking reinterpretation of data</code></pre></li>
<li><pre><code>6.38 Deep vs shallow copying \[YAN\]</code></pre></li>
<li><pre><code>6.39 Memory leak and heap fragmentation</code></pre></li>
<li><pre><code>6.41 Inheritance</code></pre></li>
<li><pre><code>6.42 Violations of the Liskov substitution principle</code></pre></li>
<li><pre><code>6.43 Redispatching</code></pre></li>
<li><pre><code>6.44 Polymorphic variables</code></pre></li>
<li><pre><code>6.45 Extra intrinsics</code></pre></li>
<li><pre><code>6.46 Argument passing to library functions</code></pre></li>
<li><pre><code>6.47 Inter-language calling</code></pre></li>
<li><pre><code>6.48 Dynamically-linked code and self-modifying code \[NYY\]</code></pre></li>
<li><pre><code>6.49 Library Signature</code></pre></li>
<li><pre><code>6.50 Unanticipated exceptions from library routines</code></pre></li>
<li><pre><code>6.51 Pre-processor directives</code></pre></li>
<li><pre><code>6.52 Suppression of language-defined run-time checking</code></pre></li>
<li><pre><code>6.53 Provision of inherently unsafe operations</code></pre></li>
<li><pre><code>6.54 Obscure language features</code></pre></li>
<li><pre><code>6.55 Unspecified behaviour</code></pre></li>
<li><pre><code>6.56 Undefined behaviour</code></pre></li>
<li><pre><code>6.57 Implementation-defined behaviour</code></pre></li>
<li><pre><code>6.58 Deprecated language features</code></pre></li>
<li><pre><code>6.59 Concurrency \-- Activation</code></pre></li>
<li><pre><code>6.60 Concurrency -- Directed termination</code></pre></li>
<li><pre><code>6.64 Uncontrolled format string</code></pre></li>
</ul>
<div data-custom-style="Normal (Web)">
<p>TBD</p>
</div>
<ul>
<li><pre><code>6.2 Type system -- issues being fed from 6.40 and elsewhere</code></pre></li>
<li><pre><code>6.61 Concurrent data access</code></pre></li>
<li><pre><code>6.62 Concurrency -- Premature termination</code></pre></li>
<li><pre><code>6.63 Protocol lock errors</code></pre></li>
</ul>
<div data-custom-style="Normal (Web)">
<p>Participants at meeting 23 November 2020</p>
</div>
<p>Stephen Michell</p>
<p>Paul Preney</p>
<p>Peter Sommerlad</p>
<p>Richard Corden</p>
<p>Erhard Ploedereder</p>
<p>Clive Pygott</p>
<p>Michael Wong</p>
<!-- Here we include stuff... with pandoc-include filter -->
<div data-custom-style="zzCover">
<p>Edition 1</p>
</div>
<div data-custom-style="zzCover">
<p>ISO/IEC JTC 1/SC 22/WG 23</p>
</div>
<div data-custom-style="zzCover">
<p>Secretariat: ANSI</p>
</div>
<div data-custom-style="Bibliography1">
<p>Information Technology — Programming languages — Guidance to avoiding vulnerabilities in programming languages – Part 10 – Vulnerability descriptions for the programming language C++</p>
</div>
<div data-custom-style="zzCover">
<p>Document type: International standard</p>
</div>
<div data-custom-style="zzCover">
<p>Document subtype: if applicable</p>
</div>
<div data-custom-style="zzCover">
<p>Document stage: (10) development stage</p>
</div>
<div data-custom-style="zzCover">
<p>Document language: E</p>
</div>
<p><em>Élément introductif — Élément principal — Partie n: Titre de la partie</em></p>
<div data-custom-style="zzCover">
<p>Warning</p>
</div>
<div data-custom-style="zzCover">
<p>This document is not an ISO International Standard. It is distributed for review and comment. It is subject to change without notice and may not be referred to as an International Standard.</p>
</div>
<div data-custom-style="zzCover">
<p>Recipients of this draft are invited to submit, with their comments, notification of any relevant patent rights of which they are aware and to provide supporting documentation.</p>
</div>
<div data-custom-style="zzCopyright">
<p><strong>Copyright notice</strong></p>
</div>
<div data-custom-style="zzCopyright">
<p>This ISO document is a working draft or committee draft and is copyright-protected by ISO. While the reproduction of working drafts or committee drafts in any form for use by participants in the ISO standards development process is permitted without prior permission from ISO, neither this document nor any extract from it may be reproduced, stored or transmitted in any form for any other purpose without prior written permission from ISO.</p>
</div>
<div data-custom-style="zzCopyright">
<p>Requests for permission to reproduce this document for the purpose of selling it should be addressed as shown below or to ISO’s member body in the country of the requester:</p>
</div>
<div data-custom-style="zzCopyright">
<p><em>ISO copyright office</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>Case postale 56, CH-1211 Geneva 20</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>Tel. + 41 22 749 01 11</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>Fax + 41 22 749 09 47</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>E-mail copyright@iso.org</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>Web www.iso.org</em></p>
</div>
<div data-custom-style="zzCopyright">
<p>Reproduction for sales purposes may be subject to royalty payments or a licensing agreement.</p>
</div>
<div data-custom-style="zzCopyright">
<p>Violators may be prosecuted.</p>
</div>
<div data-custom-style="zzContents">
<p>Contents Page</p>
</div>
<div data-custom-style="toc 1">
<p><a href="#foreword"><span data-custom-style="Hyperlink">Foreword</span> vii</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#introduction"><span data-custom-style="Hyperlink">Introduction</span> viii</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#scope"><span data-custom-style="Hyperlink">1. Scope</span> 1</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#normative-references"><span data-custom-style="Hyperlink">2. Normative references</span> 1</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#terms-and-definitions-symbols-and-conventions"><span data-custom-style="Hyperlink">3. Terms and definitions, symbols and conventions</span> 1</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#terms-and-definitions"><span data-custom-style="Hyperlink">3.1 Terms and definitions</span> 1</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#language-concepts"><span data-custom-style="Hyperlink">4. Language concepts</span> 4</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#section"><span data-custom-style="Hyperlink">5. Avoiding programming language vulnerabilities in C++</span> 4</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#specific-guidance-for-c-vulnerabilities"><span data-custom-style="Hyperlink">6. Specific Guidance for C++ Vulnerabilities</span> 6</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#general"><span data-custom-style="Hyperlink">6.1 General</span> 6</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#type-system-ihn"><span data-custom-style="Hyperlink">6.2 Type System [IHN]</span> 6</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#bit-representations-str"><span data-custom-style="Hyperlink">6.3 Bit Representations [STR]</span> 7</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#floating-point-arithmetic-plf"><span data-custom-style="Hyperlink">6.4 Floating-point Arithmetic [PLF]</span> 8</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#enumerator-issues-ccb"><span data-custom-style="Hyperlink">6.5 Enumerator Issues [CCB]</span> 8</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc1165233"><span data-custom-style="Hyperlink">6.6 Conversion Errors [FLC]</span> 9</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#string-termination-cjm"><span data-custom-style="Hyperlink">6.7 String Termination [CJM]</span> 10</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc1165235"><span data-custom-style="Hyperlink">•</span> <span data-custom-style="Hyperlink">Use std::string or similar, in preference to C-style arrays of chars</span> 11</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#buffer-boundary-violation-hcb"><span data-custom-style="Hyperlink">6.8 Buffer Boundary Violation [HCB]</span> 11</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unchecked-array-indexing-xyz"><span data-custom-style="Hyperlink">6.9 Unchecked Array Indexing [XYZ]</span> 12</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unchecked-array-copying-xyw"><span data-custom-style="Hyperlink">6.10 Unchecked Array Copying [XYW]</span> 13</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#pointer-type-conversions-hfc"><span data-custom-style="Hyperlink">6.11 Pointer Type Conversions [HFC]</span> 13</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#pointer-arithmetic-rvg"><span data-custom-style="Hyperlink">6.12 Pointer Arithmetic [RVG]</span> 15</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#null-pointer-dereference-xyh"><span data-custom-style="Hyperlink">6.13 NULL Pointer Dereference [XYH]</span> 16</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dangling-reference-to-heap-xyk"><span data-custom-style="Hyperlink">6.14 Dangling Reference to Heap [XYK]</span> 16</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#arithmetic-wrap-around-error-fif"><span data-custom-style="Hyperlink">6.15 Arithmetic Wrap-around Error [FIF]</span> 18</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#using-shift-operations-for-multiplication-and-division-pik"><span data-custom-style="Hyperlink">6.16 Using Shift Operations for Multiplication and Division [PIK]</span> 18</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#choice-of-clear-names-nai"><span data-custom-style="Hyperlink">6.17 Choice of Clear Names [NAI]</span> 19</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dead-store-wxq"><span data-custom-style="Hyperlink">6.18 Dead Store [WXQ]</span> 19</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unused-variable-yzs"><span data-custom-style="Hyperlink">6.19 Unused Variable [YZS]</span> 20</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#identifier-name-reuse-yow"><span data-custom-style="Hyperlink">6.20 Identifier Name Reuse [YOW]</span> 20</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc310518176"><span data-custom-style="Hyperlink">6.21 Namespace Issues [BJL]</span> 21</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#initialization-of-variables-lav"><span data-custom-style="Hyperlink">6.22 Initialization of Variables [LAV]</span> 21</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#operator-precedence-and-associativity-jcw"><span data-custom-style="Hyperlink">6.23 Operator Precedence and Associativity [JCW]</span> 21</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#side-effects-and-order-of-evaluation-of-operands-sam"><span data-custom-style="Hyperlink">6.24 Side-effects and Order of Evaluation of Operands [SAM]</span> 21</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#likely-incorrect-expression-koa"><span data-custom-style="Hyperlink">6.25 Likely Incorrect Expression [KOA]</span> 22</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dead-and-deactivated-code-xyq"><span data-custom-style="Hyperlink">6.26 Dead and Deactivated Code [XYQ]</span> 24</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#switch-statements-and-static-analysis-cll"><span data-custom-style="Hyperlink">6.27 Switch Statements and Static Analysis [CLL]</span> 24</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#demarcation-of-control-flow-eoj"><span data-custom-style="Hyperlink">6.28 Demarcation of Control Flow [EOJ]</span> 25</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#loop-control-variables-tex"><span data-custom-style="Hyperlink">6.29 Loop Control Variables [TEX]</span> 26</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#off-by-one-error-xzh"><span data-custom-style="Hyperlink">6.30 Off-by-one Error [XZH]</span> 27</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#structured-programming-ewd"><span data-custom-style="Hyperlink">6.31 Structured Programming [EWD]</span> 28</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#passing-parameters-and-return-values-csj"><span data-custom-style="Hyperlink">6.32 Passing Parameters and Return Values [CSJ]</span> 28</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dangling-references-to-stack-frames-dcm"><span data-custom-style="Hyperlink">6.33 Dangling References to Stack Frames [DCM]</span> 29</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#subprogram-signature-mismatch-otr"><span data-custom-style="Hyperlink">6.34 Subprogram Signature Mismatch [OTR]</span> 30</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#recursion-gdl"><span data-custom-style="Hyperlink">6.35 Recursion [GDL]</span> 31</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#ignored-error-status-and-unhandled-exceptions-oyb"><span data-custom-style="Hyperlink">6.36 Ignored Error Status and Unhandled Exceptions [OYB]</span> 31</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#type-breaking-reinterpretation-of-data-amv"><span data-custom-style="Hyperlink">6.37 Type-breaking Reinterpretation of Data [AMV]</span> 32</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#deep-vs.-shallow-copying-yan"><span data-custom-style="Hyperlink">6.38 Deep vs. Shallow Copying [YAN]</span> 33</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#memory-leak-and-heap-fragmentation-xyl"><span data-custom-style="Hyperlink">6.39 Memory Leak and Heap Fragmentation [XYL]</span> 33</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#templates-and-generics-sym"><span data-custom-style="Hyperlink">6.40 Templates and Generics [SYM]</span> 34</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#inheritance-rip"><span data-custom-style="Hyperlink">6.41 Inheritance [RIP]</span> 35</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#applicability-to-language-39"><span data-custom-style="Hyperlink">6.41.1 Applicability to language</span> 35</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-37"><span data-custom-style="Hyperlink">6.41.2 Guidance to language users</span> 37</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#violations-of-the-liskov-substitution-principle-or-the-contract-model-blp"><span data-custom-style="Hyperlink">6.42 Violations of the Liskov Substitution Principle or the Contract Model [BLP]</span> 37</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#applicability-to-language-40"><span data-custom-style="Hyperlink">6.42.1 Applicability to language</span> 37</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-38"><span data-custom-style="Hyperlink">6.42.2 Guidance to language users</span> 38</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#redispatching-pph"><span data-custom-style="Hyperlink">6.43 Redispatching [PPH]</span> 38</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#applicability-to-language-41"><span data-custom-style="Hyperlink">6.43.1 Applicability to language</span> 38</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-39"><span data-custom-style="Hyperlink">6.43.2 Guidance to language users</span> 39</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#polymorphic-variables-bkk"><span data-custom-style="Hyperlink">6.44 Polymorphic variables [BKK]</span> 39</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#applicability-to-language-42"><span data-custom-style="Hyperlink">6.44.1 Applicability to language</span> 40</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-40"><span data-custom-style="Hyperlink">6.44.2 Guidance to language users</span> 41</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#extra-intrinsics-lrm"><span data-custom-style="Hyperlink">6.45 Extra Intrinsics [LRM]</span> 42</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#argument-passing-to-library-functions-trj"><span data-custom-style="Hyperlink">6.46 Argument Passing to Library Functions [TRJ]</span> 42</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#inter-language-calling-djs"><span data-custom-style="Hyperlink">6.47 Inter-language Calling [DJS]</span> 42</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dynamically-linked-code-and-self-modifying-code-nyy"><span data-custom-style="Hyperlink">6.48 Dynamically-linked Code and Self-modifying Code [NYY]</span> 45</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#library-signature-nsq"><span data-custom-style="Hyperlink">6.49 Library Signature [NSQ]</span> 46</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unanticipated-exceptions-from-library-routines-hjw"><span data-custom-style="Hyperlink">6.50</span> <span data-custom-style="Hyperlink">Unanticipated Exceptions from Library Routines [HJW]</span> 47</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#pre-processor-directives-nmp"><span data-custom-style="Hyperlink">6.51 Pre-processor Directives [NMP]</span> 48</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#suppression-of-language-defined-run-time-checking-mxb"><span data-custom-style="Hyperlink">6.52 Suppression of Language-defined Run-time Checking [MXB]</span> 49</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#provision-of-inherently-unsafe-operations-skl"><span data-custom-style="Hyperlink">6.53 Provision of Inherently Unsafe Operations [SKL]</span> 49</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#obscure-language-features-brs"><span data-custom-style="Hyperlink">6.54 Obscure Language Features [BRS]</span> 49</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unspecified-behaviour-bqf"><span data-custom-style="Hyperlink">6.55 Unspecified Behaviour [BQF]</span> 50</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#undefined-behaviour-ewf"><span data-custom-style="Hyperlink">6.56 Undefined Behaviour [EWF]</span> 50</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#implementationdefined-behaviour-fab"><span data-custom-style="Hyperlink">6.57 Implementation–defined Behaviour [FAB]</span> 51</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#deprecated-language-features-mem"><span data-custom-style="Hyperlink">6.58 Deprecated Language Features [MEM]</span> 52</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#concurrency-activation-cga"><span data-custom-style="Hyperlink">6.59 Concurrency – Activation [CGA]</span> 52</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#concurrency-directed-termination-cgt"><span data-custom-style="Hyperlink">6.60 Concurrency – Directed termination [CGT]</span> 52</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc1165297"><span data-custom-style="Hyperlink">6.60.1 Applicability to language</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-55"><span data-custom-style="Hyperlink">6.60.2 Guidance to language users</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc1165299"><span data-custom-style="Hyperlink">6.61 Concurrent Data Access [CGX]</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#concurrency-premature-termination-cgs"><span data-custom-style="Hyperlink">6.62 Concurrency – Premature Termination [CGS]</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#protocol-lock-errors-cgm"><span data-custom-style="Hyperlink">6.63 Protocol Lock Errors [CGM]</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#uncontrolled-format-string-shl"><span data-custom-style="Hyperlink">6.64 Uncontrolled Format String [SHL]</span> 54</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#language-specific-vulnerabilities-for-c"><span data-custom-style="Hyperlink">7. Language specific vulnerabilities for C</span> 54</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#implications-for-standardization"><span data-custom-style="Hyperlink">8. Implications for standardization</span> 54</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#bibliography"><span data-custom-style="Hyperlink">Bibliography</span> 57</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#index"><span data-custom-style="Hyperlink">Index</span> 60</a></p>
</div>
<h1 id="foreword">Foreword</h1>
<p>ISO (the International Organization for Standardization) and IEC (the International Electrotechnical Commission) form the specialized system for worldwide standardization. National bodies that are members of ISO or IEC participate in the development of International Standards through technical committees established by the respective organization to deal with particular fields of technical activity. ISO and IEC technical committees collaborate in fields of mutual interest. Other international organizations, governmental and non-governmental, in liaison with ISO and IEC, also take part in the work. In the field of information technology, ISO and IEC have established a joint technical committee, ISO/IEC JTC 1.</p>
<p>International Standards are drafted in accordance with the rules given in the ISO/IEC Directives, Part 2.</p>
<p>The main task of the joint technical committee is to prepare International Standards. Draft International Standards adopted by the joint technical committee are circulated to national bodies for voting. Publication as an International Standard requires approval by at least 75 % of the national bodies casting a vote.</p>
<p>In exceptional circumstances, when the joint technical committee has collected data of a different kind from that which is normally published as an International Standard (“state of the art”, for example), it may decide to publish a Technical Report. A Technical Report is entirely informative in nature and shall be subject to review every five years in the same manner as an International Standard.</p>
<p>Attention is drawn to the possibility that some of the elements of this document may be the subject of patent rights. ISO and IEC shall not be held responsible for identifying any or all such patent rights.</p>
<p>ISO/IEC TR 24772-10, was prepared by Joint Technical Committee ISO/IEC JTC 1, <em>Information technology</em>, Subcommittee SC 22, <em>Programming languages, their environments and system software interfaces</em>.</p>
<h1 id="introduction">Introduction</h1>
<div data-custom-style="zzHelp">
<p>This Technical Report provides guidance for the programming language C++, so that application developers using or considering C++ will be better able to avoid the programming constructs that lead to vulnerabilities in software written in the C++ language and their attendant consequences. This guidance can also be used by developers to select source code evaluation tools that can discover and eliminate some constructs that could lead to vulnerabilities in their software. This report can also be used in comparison with companion Technical Reports and with the language-independent report, TR 24772–1, to select a programming language that provides the appropriate level of confidence that anticipated problems can be avoided.</p>
</div>
<div data-custom-style="zzHelp">
<p>This technical report part is intended to be used with TR 24772–1, which discusses programming language vulnerabilities in a language independent fashion. It is also intended to be used with TR 24772-3, which discusses how the vulnerabilities introduced in TR 24772-1 are manifested in C, which is a subset of C++.</p>
</div>
<p>It should be noted that this Technical Report is inherently incomplete. It is not possible to provide a complete list of programming language vulnerabilities because new weaknesses are discovered continually. Any such report can only describe those that have been found, characterized, and determined to have sufficient probability and consequence.</p>
<div data-custom-style="Bibliography1">
<p><strong>Information Technology — Programming Languages — Guidance to avoiding vulnerabilities in programming languages — Vulnerability descriptions for the programming language C++</strong></p>
</div>
<h1 id="scope">1. Scope</h1>
<p>This Technical Report specifies software programming language vulnerabilities to be avoided in the development of systems where assured behaviour is required for security, safety, mission-critical and business-critical software. In general, this guidance is applicable to the software developed, reviewed, or maintained for any application.</p>
<p>Vulnerabilities described in this Technical Report document the way that the vulnerability described in the language-independent TR 24772–1 are manifested in C++.</p>
<h1 id="normative-references">2. Normative references</h1>
<p>The following referenced documents are indispensable for the application of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.</p>
<p>ISO/IEC 14882:2014 — <em>Programming Languages—C</em> ++</p>
<p>ISO/IEC TR24772–3 -- Information Technology — Programming Languages — Guidance to avoiding vulnerabilities in programming languages — Vulnerability descriptions for the programming language C</p>
<h1 id="terms-and-definitions">3. Terms and definitions</h1>
<p>&lt;!- SGM - removed "symbols and conventions from title and renumbered from [3.1.x] to [3.x] –&gt;</p>
<p>For the purposes of this document, the terms and definitions given in ISO/IEC 2382, in TR 24772–1, in 14882:2014 and the following apply. Other terms are defined where they appear in <em>italic</em> type.</p>
<p>The following terms are in alphabetical order, with general topics referencing the relevant specific terms.</p>
<p><strong><u>3.1</u></strong></p>
<p><u>TBD</u></p>
<p><strong><u>3.2</u></strong></p>
<p><u>access</u>:</p>
<p>an execution-time action to read or modify the value of an object.</p>
<blockquote>
<p>Note 1: Where only one of two actions is meant, read or modify. Modify includes the case where the new value being stored is the same as the previous value. Expressions that are not evaluated do not access objects</p>
</blockquote>
<p><strong><u>3.3</u></strong></p>
<p><u>access protection</u>:</p>
<p><strong><u>3.4</u></strong><br />
</p>
<p><strong><u>alignment</u></strong><br />
</p>
<p>requirement that objects of a particular type be located on storage boundaries with addresses that are particular multiples of a byte address</p>
<p><strong><u>3.5</u></strong></p>
<p><strong><u>argument</u></strong><br />
expression in the comma-separated list bounded by the parentheses in a function call expression, or a sequence of preprocessing tokens in the comma-separated list bounded by the parentheses in a function-like macro invocation</p>
<blockquote>
<p>Note 1: Also called actual argument</p>
<p>Note 2: An argument replaces a <em>formal parameter</em> as the call is realized.</p>
</blockquote>
<p><strong><u>3.6</u></strong></p>
<p><strong><u>argument dependent lookup</u></strong><br />
</p>
<p>lookup that finds additional overloads from the namespaces of the types of the arguments used in unqualified function calls</p>
<p><strong><u>3.7</u></strong></p>
<p><strong><u>class</u></strong><br />
a user-defined type declared with the class-key ‘class’ or ‘struct’ {.ul}</p>
<p><strong><u>3.8</u></strong></p>
<p><strong><u>correctly rounded result</u></strong><br />
</p>
<p>representation in the result format that is nearest in value, subject to the current rounding mode, to what the result would be given unlimited range and precision</p>
<p><strong><u>3.9</u></strong></p>
<p><strong><u>diagnostic message</u></strong><br />
</p>
<p>informational message that is either an error or warning about an issue detected by the implementation</p>
<p><strong><u>3.10</u></strong><br />
</p>
<p><strong>[erroneous behaviour]</strong><br />
</p>
<p>well-defined behavior that the implementation is recommended to diagnose</p>
<p><strong><u>3.11</u></strong><br />
<strong><u>erroneous value</u></strong><br />
</p>
<p>value of an object not declared <code class="sourceCode cpp">[[<span class="at">indeterminate</span>]]</code> and who’s value has not yet been set and can lead to erroneous behaviour if produced by an evaluation</p>
<p><strong><u>3.12</u></strong><br />
</p>
<p><strong><u>explicit template specialization</u></strong><br />
</p>
<p>a template specialization that defines a distinct implementation for the specified arguments</p>
<p><strong>[3.13]</strong><br />
</p>
<p><strong><u>formal parameter</u></strong><br />
</p>
<p>object declared as part of a function declaration or definition that acquires a value on entry to the function, or an identifier from the comma-separated list bounded by the parentheses immediately following the macro name in a function-like macro definition.</p>
<p><strong>[3.14] friend{.ul}</strong><br />
</p>
<p>function or class that can access the private and protected members of a specific class</p>
<p><strong>[3.15] hidden friend{.ul}</strong><br />
</p>
<p>friend function that is only declared within a class or class template definition and hence is only found by ADL</p>
<p><strong><u>3.16</u></strong><br />
</p>
<p><strong><u>Implementation</u></strong><br />
</p>
<p>specific toolchain that is used to build and support the execution of the C++ program</p>
<p><strong><u>3.17</u></strong><br />
</p>
<p><strong><u>implementation-defined behaviour</u></strong><br />
</p>
<p>behaviour, for a well-formed program construct and correct data, that depends on the implementation and that each implementation documents</p>
<p><strong><u>3.18</u></strong><br />
</p>
<p><strong><u>implementation limit</u></strong><br />
</p>
<p>capacity restriction imposed upon programs by the implementation.</p>
<p><strong><u>3.19</u></strong><br />
<strong><u>indeterminate value</u></strong><br />
</p>
<p>value of an object declared <code class="sourceCode cpp">[[<span class="at">indeterminate</span>]]</code> and who’s value has not yet been set and can lead to undefined behaviour if produced by an evaluation</p>
<p><strong><u>3.20</u></strong><br />
<strong><u>indeterminately sequenced</u></strong><br />
</p>
<p>sequenced in a way that one of two evaluations will be executed before the other but in an unspecified order</p>
<p><strong><u>3.21</u></strong><br />
<strong><u>locale-specific behaviour</u></strong><br />
</p>
<p>behaviour that depends on local conventions of nationality, culture, and language that each implementation documents</p>
<p><strong><u>3.22</u></strong><br />
<strong><u>namespace</u></strong><br />
optionally-named entity that can contain scoped declarations</p>
<p>[ensure that this is put into clause 4 on general concepts]</p>
<p><strong><u>3.23</u></strong><br />
<strong><u>object</u></strong><br />
</p>
<p>region of data storage in the execution environment that has a type</p>
<p><strong><u>3.24</u></strong><br />
<strong><u>overload</u></strong><br />
</p>
<p>a function or operator sharing a name with others but distinguished by having a different namespace, parameter list, qualifier set or other relevant property</p>
<p><strong><u>3.25</u></strong><br />
<strong><u>overload resolution</u></strong><br />
</p>
<p>a mechanism for selecting the best function to call given a list of expressions that are to be the arguments of the call and a set of functions that can be called based on the context of the call.</p>
<p>[Need a clause 4 discussion?]</p>
<p><strong><u>3.26</u></strong><br />
<strong><u>override</u></strong><br />
</p>
<p>replace the implementation of a virtual (inheritable??) function in a derived class</p>
<p><strong><u>3.27</u></strong><br />
<strong><u>pointer-like-type</u></strong><br />
</p>
<p>set of types whose values depend upon the existence and value of another object, such as references, pointers, iterators and views</p>
<p><strong><u>3.28</u></strong><br />
</p>
<p><strong><u>protected</u></strong><br />
</p>
<p>member of a class that is visible only to the class itself, derived classes and friends</p>
<p><strong><u>3.29</u></strong><br />
</p>
<p><strong><u>private</u></strong><br />
</p>
<p>member of a class that is visible only to the class itself and friends</p>
<p><strong><u>3.30</u></strong><br />
</p>
<p><strong><u>public</u></strong><br />
</p>
<p>visible without restriction</p>
<p><strong><u>3.31</u></strong><br />
</p>
<p><strong><u>storage duration</u></strong><br />
</p>
<p>property of an object that defines the minimum potential lifetime of the storage containing the object, including static storage duration, thread storage duration, automatic storage duration and dynamic storage duration</p>
<p><strong><u>3.32</u></strong><br />
</p>
<p><strong><u>standard library</u></strong><br />
</p>
<p>[TBD] [Is this really necessary?]</p>
<p><strong><u>3.33</u></strong><br />
</p>
<p><strong><u>template</u></strong><br />
</p>
<p>family of classes, functions or variables, or an alias for a family of types, or a concept</p>
<p>[also template specialization or explicit template specialization]</p>
<p><strong><u>3.34</u></strong><br />
</p>
<p><strong><u>template specialization</u></strong><br />
</p>
<p>a named template together with a set of arguments that produces a concrete instance of the entity</p>
<p><strong><u>3.35</u></strong><br />
</p>
<p><strong><u>undefined behaviour</u></strong><br />
</p>
<p>use of a non-portable or erroneous program construct or erroneous data, for which the language standard imposes no requirements</p>
<blockquote>
<p>Note: Undefined behaviour ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message). An example of, undefined behaviour is the behaviour on integer overflow.</p>
</blockquote>
<p><strong><u>3.36</u></strong><br />
</p>
<p><strong><u>unspecified behaviour</u></strong><br />
</p>
<p>use of an unspecified value or other behaviour where the language standard provides two or more possibilities and imposes no further requirements on which is chosen in any instance, such as the order in which the arguments to a function are evaluated</p>
<p><strong><u>3.37</u></strong><br />
</p>
<p><strong><u>unspecified value</u></strong><br />
</p>
<p>valid value of the relevant type where the language standard imposes no requirements on which value is chosen in any instance</p>
<p><strong><u>3.38</u></strong><br />
</p>
<p><strong><u>value</u></strong><br />
</p>
<p>precise meaning of the contents of an object when interpreted as having a specific type</p>
<p><strong><u>3.39</u></strong><br />
</p>
<p><strong><u>virtual</u></strong><br />
</p>
<p><u>TBD</u></p>
<p><strong><u>3.40</u></strong><br />
</p>
<p><strong><u>wide character</u></strong><br />
</p>
<p>bit representation capable of representing any character in the current locale</p>
<p><span data-custom-style="annotation reference"></span></p>
<h1 id="language-concepts">4. Language concepts</h1>
<p><u><em>This clause requires a rewrite. See C++ Core Guidelines CPL for a good explanation of the differences</em>.</u></p>
<h2 id="overview">4.1 Overview</h2>
<p><em><strong>THIS REQUIRES MORE WORK</strong></em></p>
<p>Define unchecked (random) access in clause 3 or explain C++ approach. Likely needs a new subclause. Indexing into raw memory is a random access with no checking. In the standard library, the [] operator does random access without checking. The function <code class="sourceCode cpp">at</code> was added to provide range checking, including throwing an exceptiion if the check fails.</p>
<p>C++ is a strongly- and statically-typed language: all variables and expressions must have a type. C++ also permits implicit and explicit conversions between types.</p>
<p>C++ has a rich type system with many nuances. In addition to the C base types (int, long, float, double, char, and arrays with their C-style vulnerabilities), C++ provides the following:</p>
<ul>
<li><pre><code>Distinct types for char, signed char, unsigned char</code></pre></li>
<li><pre><code>bool with a true Boolean context</code></pre></li>
<li><pre><code>enum with fixed underlying type</code></pre></li>
<li><pre><code>Classes as the primary user-defined types</code></pre></li>
<li><pre><code>Arrays</code></pre></li>
<li><pre><code>References in addition to pointers</code></pre></li>
<li><pre><code>Parameterized types</code></pre></li>
</ul>
<p>C++ provides library acilities that mitigate many vulnerabilities that are in the base language types, such as <span class="cpp">std::string</span> rather than char</p>
<ul>
<li><pre><code>Use of the `explicit`{.cpp} keyword for constructors and conversion
operators</code></pre></li>
<li><pre><code>`operator bool()`{.cpp} discussion</code></pre></li>
<li><pre><code>many built-in implicit conversions, refer to TR 24772-3 clause 6.2
and other clauses (C)</code></pre></li>
<li><pre><code>conversion to bool and null pointer conversions</code></pre></li>
<li><pre><code>legacy code operator void\* - change to explicit operator bool</code></pre></li>
<li><pre><code>C-style casts break type safety.</code></pre></li>
<li><pre><code>static_cast</code></pre></li>
<li><pre><code>explicit casts highlight mismatches between the design and
implementation.</code></pre></li>
<li><pre><code>const and volatile</code></pre></li>
<li><pre><code>constexpr -- needs a writeup -- (in C++:11 , encouraged heavy stack
use and possible exhaustion).</code></pre></li>
</ul>
<p>Narrowly tailored number-like class types, such as time_point and duration, improve safety by providing only safe and appropriate operations. User-defined types tailored to a particular use case can provide additional safety.</p>
<p>C++ was initially defined as a syntactic superset of the C programming language: adding object oriented features such as classes, encapsulation, dynamic dispatch, namespaces and templates. It was a “syntactic superset” because whilst there is a core of C++ that is syntactically identical to C, it has always been the case that there are subtle semantic differences between the two, for example:</p>
<ul>
<li><p>Historically, C permitted the use of a function before its declaration (though this is now deprecated in C) . This is illegal in C++</p></li>
<li><p>Where a struct is defined within another struct, in C the inner declaration is in effect made at file scope, so the definition is available for use later in the program. In C++, the inner declaration name is qualified by that of the parent, so without qualification, the inner struct cannot be used later in the program, as in the following example</p></li>
</ul>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S1 {</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">struct</span> S2 {...} m1;</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>   ...</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S2 v1; /\* legal in C <span class="kw">not</span> C++ \*/</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>S1::S2 v2 <span class="co">// legal in C++ not C</span></span></code></pre></div>
<p>Subsequently, the two languages have diverged, both adding features not present in the other. Not withstanding that, there is still a significant syntactic and semantic overlap between C and C++, so the starting point for this report has been the equivalent for C. However, in many cases, the additional features of C++ provide mechanisms for avoiding the vulnerabilities inherited from C, and these are reflected in the following sections.</p>
<p><em>Include discussions of Object orientation, <strong>static</strong>, and <strong>const,</strong> scoped enumerations</em></p>
<h2 id="type-system">4.2 Type System</h2>
<ul>
<li>implicit conversions</li>
<li>templates? Bring tutorial material from clause 6.2/[#IHN] Type system clause 6.6/[#FLC] Conversion errors, clause 6.11/[#HFC] Pointer type conversions, clause 6.37[#AMV] Type breaking reinterpretation of data clause 6.41[#RIP] Inheritance (includes Mix-ins and multiple inheritance) clause 6.44/[#BKK] Polymorphic variables</li>
</ul>
<p>Mix-ins (6.20, 6.40, 6.41)</p>
<h3 id="inheritance">Inheritance</h3>
<p>C++ supports user-defined class types with one or more base classes. Dynamic polymorphism requires public bases defining virtual member functions.</p>
<p>C++ provides access specifiers that allow inheritance to restrict the visibility of inherited members in their subclasses.</p>
<p>A member declared in a class hides all members of the same name in any of its base classes. Such names can be reintroduced by the <code>using</code> declaration. For example:</p>
<pre><code>    struct Base {
       int f(int i);
    };

    struct Derived : public Base {
       // using Base::f;
       int f(char c);
       int g() {
          return f(123); // Surprise, f(char) is called
      }
};</code></pre>
<p>If the <code>using declaration</code> is uncommented above, then <code>Base::f(int)</code> is called.</p>
<p>For multiple inheritance users can request virtual inheritance, which causes data members inherited from the same ancestor class along multiple inheritance paths to be present only once; otherwise the data members are replicated and referring to them is ambiguous unless qualified by the name of the base class from which they are inherited. When members of equal name are inherited from multiple sources, C++ rejects an unqualified use of the common name as ambiguous as long as they are not hidden.</p>
<p><em><strong>THIS REQUIRES MORE WORK</strong></em></p>
<p>A particular area that is misunderstood is integral promotion. It can be confusing because promotion can result in changing the internal representation of an unsigned type to/from a signed type. For expressions formed with operands of unscoped enumeration type or integral types with a conversion rank smaller than <code class="sourceCode cpp"><span class="dt">int</span></code>, <em>integral promotion</em> occurs before further implicit conversions happen. <em>Integral promotion</em> on unsigned types can convert these to the signed type <code class="sourceCode cpp"><span class="dt">int</span></code>. Undefined behavior <a href="#EWF">[EWF]</a> can occur due to signed integer arithmetic overflow even when the operands are of an unsigned type. Assume for example, - signed and unsigned short occupies 16 bits - signed and unsigned int occupies 32 bits then the following code causes undefined behavior:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">unsigned</span> <span class="dt">short</span> <span class="at">const</span> x = <span class="bn">0xfff0</span>;</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>   x * x;                           <span class="co">// signed integer overflow, result will not fit in signed 32 bit int</span></span></code></pre></div>
<p>Note: C++ also uses the term promotion to apply to a subset of conversion that apply to intergral and floating point types.</p>
<p>Implicit, i.e., automatic, conversions to a type <code>T</code> can be performed, for example, in the following situations:</p>
<ol type="a">
<li><p>If the declaration, <code class="sourceCode cpp">T t=e;</code>, is defined for some expression, <code>e</code>, and some invented variable, <code>t</code> [C++17, Clause 7 [conv], para 3];</p></li>
<li><p>In expressions involving operands of operators (e.g., <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, etc.) subject to the requirements of each operators' operands [C++20, Clause 7.3 [conv], para 2.1];</p></li>
<li><p>For example, the expression, <code>5 + 6.5</code>, has operands of type <code class="sourceCode cpp"><span class="dt">int</span></code> and <code class="sourceCode cpp"><span class="dt">double</span></code>. Per language rules, the integer operand will be implicitly converted to <code class="sourceCode cpp"><span class="dt">double</span></code>, i.e., the expression becomes <code class="sourceCode cpp"><span class="dt">double</span>(<span class="dv">5</span>) + <span class="fl">6.5</span></code>, i.e., <code>5.0 + 6.5</code>.</p></li>
<li><p>In boolean contexts, such as</p>
<ul>
<li>operands of logical operators,</li>
<li>the condition of the conditional operator, and</li>
<li>the condition of the if-statement or loop-statements, contextual conversion to bool implicitly happens from arithmetic types, pointers, and classes with a possibly explicit <code>operator bool()</code>. [C++17, Clause 7 [conv], para 4];</li>
</ul></li>
<li><p>In the expression of a switch statement: the implicit conversion will be to an integral type [C++17, Clause 7 [conv], para 2.3];</p></li>
<li><p>In an expression that initializes an object (e.g., an argument to a function call, the expression in a return statement) [C++17, Clause 7 [conv], para 2.4];</p></li>
<li><p>When a non-<code class="sourceCode cpp"><span class="kw">explicit</span></code> class/struct/union constructor can be invoked on an object resulting in some desired type, <code>T</code>, from initial objects passed to the constructor; and</p></li>
<li><p>When a conversion operator has not been declared <code class="sourceCode cpp"><span class="kw">explicit</span></code>, it can be implicitly invoked on an object resulting in some desired type, <code>T</code>, from an initial type.</p></li>
</ol>
<h2 id="symbol-lookup-and-overload-resolution">4.2 Symbol Lookup and Overload Resolution</h2>
<p><em><strong>THIS REQUIRES MORE WORK</strong></em></p>
<ul>
<li>special members</li>
<li>templates?</li>
</ul>
<p>scopes, names, ADL, using</p>
<!-- from issue https://github.com/ISO-IEC-JTC1-SC22-WG23-CPP/wg23-tr24772-10/issues/80 -->
<p>Add to clause 4 “Language concepts” an issue on C++ symbol lookup issues considering the following: 1. Minimize the set of names that are available to avoid referring to an item that was not the intended target 2. hidden friends 3. ADL (argument dependent lookup) 4. Lack of this-&gt; in class templates 5. Minimizing lexical scope and visibility 6. Minimizing names in global scopes 7. Minimizing use of “using” directives</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> NS {</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">template</span> &lt;<span class="kw">typename</span> S, <span class="kw">typename</span> Q&gt; <span class="kw">friend</span> <span class="dt">void</span> add (S, Q);</span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> B {</span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a>    B(<span class="dt">int</span>);</span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a>    B (NS::A&lt;<span class="dt">int</span>&gt; <span class="at">const</span> &amp;);</span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-15"><a href="#cb84-15" aria-hidden="true" tabindex="-1"></a>B &amp; add(B <span class="at">const</span> &amp; lhs, B <span class="at">const</span> &amp; rhs);</span>
<span id="cb84-16"><a href="#cb84-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-17"><a href="#cb84-17" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar (NS::A&lt;<span class="dt">int</span>&gt; &amp; a, B <span class="at">const</span> &amp; b)</span>
<span id="cb84-18"><a href="#cb84-18" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb84-19"><a href="#cb84-19" aria-hidden="true" tabindex="-1"></a>    add(a, b);</span>
<span id="cb84-20"><a href="#cb84-20" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>A C++ program may span multiple scopes, and when a function is called, the compiler may have many choices to select from to resolve the actual function that will be called. The set of names found for a function depend upon whether the name is qualified or if it is unqualified.</p>
<p>Unqualified lookup begins the search in the current scope and works its way out to the global scope and stops when it finds the first matching name. The search will include: - Names directly visible; - (Non-dependent) base classes if the scope is for a member; - Names introduced by the <code class="sourceCode cpp"><span class="kw">using</span></code> declaration; - Names introduced by the <code class="sourceCode cpp"><span class="kw">using</span></code> directive; and - Members of inline namespaces After these steps, Argument-Dependent Lookup (ADL) occurs. In ADL, the scope(s) of type of the function’s arguments are also searched. This search also includes <code class="sourceCode cpp">friends</code> that would not normally be found. ADL never finds member functions.</p>
<p>Unqualified name lookup in templates has two phases: - When the template is initially parsed, names are looked up as above, excluding dependent bases; and - When the template is instantiated, ADL is performed for function names, but ADL does not find member functions.</p>
<p>A qualified name lookup takes place when: - the name includes its scope (e.g <code class="sourceCode cpp">a::foo</code>); or - the name is used in a class member access expression (<code class="sourceCode cpp"><span class="kw">this</span>-&gt;foo</code>). Qualified lookup only searches: - Names directly visible; - (Non-dependent) base classes if the scope is for a member; - Names introduced by the <code class="sourceCode cpp"><span class="kw">using</span></code> declaration; - Names introduced by the <code class="sourceCode cpp"><span class="kw">using</span></code> directive; - Members of inline namespaces; and - Names that can be resolved when a template is instantiated.</p>
<p>Overload resolution</p>
<h2 id="lifetime">4.4 Object Lifetime</h2>
<p>In principle, the lifetime of an object (recursively including subobjects) begins immediately after its constructor completes creating the object and ends immediately before its destructor is called.</p>
<p>Accessing an object outside of its lifetime is undefined behaviour, see <a href="#undefined">4.7</a>.</p>
<p>C++ distinguishes references from objects. A reference has a lifetime that begins immediately after it is initialized and ends when the scope or the object containing it ends. If the lifetime of an object designated by a reference ends before the lifetime of the reference ends, the reference is dangling and further access to its referent is undefined behaviour.</p>
<p>An object of <em>implicit lifetime type</em> is implicitly created when declared or allocated. For class types that are not implicit lifetime types at least one constructor must complete for the lifetime of the object to begin.</p>
<p>Each object has one of the following types of storage durations which influences its lifetime: - static - includes global and static variables; once lifetime has started the object is guaranteed to exist until the program ends. - thread - once lifetime has started, exists on a per-thread basis until the containing thread ends. - automatic - includes non-static local variables and temporary objects; its context defines its lifetime. - dynamic - storage for objects is acquired from dynamic memory allocation and its lifetime is explicitly controlled.</p>
<p>The lifetime of an object can be prematurely terminated by explicitly - calling its destructor - reusing its storage, for example, in a placement new expression - releasing its storage</p>
<p>Reusing or releasing an object’s storage does not call its destructor: this must be done explicitly. The correct behaviour of a program often depends on the destructor being invoked for each object of class type. Improper management of objects with dynamic storage duration can cause memory leaks.</p>
<h2 id="initialization">4.5 Initialization</h2>
<p>C++ provides a number of ways that an object can be initialized, e.g.,</p>
<ul>
<li>Value initialization, e.g., <code class="sourceCode cpp"><span class="bu">std::</span>string s1{};</code></li>
<li>Direct initialization, e.g., <code class="sourceCode cpp"><span class="bu">std::</span>string s2{<span class="st">&quot;hello&quot;</span>};</code></li>
<li>Copy initialization, e.g., <code class="sourceCode cpp"><span class="bu">std::</span>string s3 = s2;</code></li>
<li>Move initialization, e.g., <code class="sourceCode cpp"><span class="bu">std::</span>string s4{<span class="bu">std::</span>move(s3)};</code></li>
<li>List initialization, e.g., <code class="sourceCode cpp"><span class="bu">std::</span>string s5{<span class="ch">&#39;a&#39;</span>, <span class="ch">&#39;b&#39;</span>, <span class="ch">&#39;c&#39;</span>};</code></li>
<li>Aggregate initialization, e.g., <code class="sourceCode cpp"><span class="dt">char</span> a[<span class="dv">3</span>] = {<span class="ch">&#39;a&#39;</span>, <span class="ch">&#39;b&#39;</span>};</code></li>
<li>Reference initializing, i.e., reference binding, e.g., <code class="sourceCode cpp"><span class="dt">char</span>&amp; c = a[<span class="dv">0</span>];</code></li>
<li>Zero initialization, e.g., via value initialization: <code class="sourceCode cpp"><span class="dt">int</span> i{};</code></li>
<li>Default initialization, e.g., <code class="sourceCode cpp"><span class="bu">std::</span>string s6;</code></li>
</ul>
<p>These many forms of initialization typically guarantee that subsequent access to the object will be well-defined. However, in some cases the value of an object can be indeterminate after its lifetime has started unless an initializer is specified, e.g., a local <code class="sourceCode cpp"><span class="dt">int</span></code> variable without an initializer (see 6.22 Missing initialization of variables <a href="#LAV">[LAV]</a>).</p>
<!--// In any case, an object should not be accessed until its initialization is complete (including concurrency???). Richard C thinks that https://eel.is/c++draft/basic.start.dynamic#5 means that there is no danger of one thread accessing a dynamically initialized global variable before the initialization has taken place - is that the case? heavily discussed on 20251110-->
<p>When a function is called, each function parameter is initialized with its corresponding argument. The initialization of a function parameter, including every associated value computation and side effect, is indeterminately sequenced with respect to that of any other function parameter (see 6.24 Side-effects and Order of Evaluation of Operands <a href="#SAM">[SAM]</a>. On the other hand, the value computation and side effects of arguments in <em>list initialization</em> are evaluated in the order they appear from left to right.</p>
<p>Using the <code class="sourceCode cpp"><span class="kw">constexpr</span></code> or <code class="sourceCode cpp"><span class="kw">constinit</span></code> keyword when defining a variable guarantees its initialization at compile-time.</p>
<h1 id="avoiding-programming-language-vulnerabilities-in-c">5. Avoiding programming language vulnerabilities in C++</h1>
<blockquote>
<p>In addition to the generic programming rules from ISO/IECTR 24772-1 clause 5.4, additional rules from this section apply specifically to the C++ programming language. The recommendations of this section are restatements of recommendations from clause 6, but represent ones stated frequently, or that are considered as particularly noteworthy by the authors. Clause 6 of this document contains the full set of recommendations, as well as explanations of the problems that led to the recommendations made.</p>
</blockquote>
<blockquote>
<p>Every guidance provided in this section, and in the corresponding Part section, is supported by material in Clause 6 of this document, as well as other important recommendations.</p>
</blockquote>
<blockquote>
<p><strong><em>TBD</em></strong></p>
</blockquote>
<table style="width:94%;">
<colgroup>
<col style="width: 44%" />
<col style="width: 5%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th>Index</th>
<th></th>
<th>Reference[]{custom- style=“annotation reference”}</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>2</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>3</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>4</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>5</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>6</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Need to consider C++-11, 14 and 17.</p>
<h1 id="specific-guidance-for-c-vulnerabilities">6. Specific Guidance for C++ Vulnerabilities</h1>
<h2 id="general">6.1 General</h2>
<p>This clause contains specific advice for C++ about the possible presence of vulnerabilities as described in TR 24772-1, and provides specific guidance on how to avoid them in C++ code. This section mirrors TR 24772-1 clause 6 in that the vulnerability “Type System [IHN]” is found in 6.2 of TR 24772–1, and C++ specific guidance is found in clause 6.2 and subclauses in this TR.</p>
<p>As part of its design (and with few exceptions), C++ has a common subset with the complete C language. For code portions written in the common subset, the vulnerabilities described and the advice given in ISO/IEC TR 24772-3:2020, <em>Part 3 – Vulnerability descriptions for the programming language C</em>, apply, except when this document provides refined advice. The following subclauses usually do not further acknowledge the issues from the subset since those have been adequately addressed in the referenced document. However, C++ provides mechanisms to mitigate many of the problems that arise. Please refer to the respective clauses of this document for these mitigations and related guidelines.</p>
<h2 id="IHN">6.2 Type System [IHN]</h2>
<h3 id="applicability-to-language">6.2.1 Applicability to language</h3>
<p>C++ is a statically typed language. In some ways, C++ is both strongly and weakly typed, as it requires all objects/expressions to have a type, but allows for some implicit conversions of values from one type to another type. The following cases require special consideration:</p>
<ul>
<li><p>The implicit conversions between arithmetic types (including <code class="sourceCode cpp"><span class="dt">bool</span></code>) that can silently truncate values or produce objects with less precision (for details see <a href="#FLC">Conversion Errors [FLC]</a>), such as <em>integral promotion</em> from small (unsigned) integer types (e.g. <code class="sourceCode cpp"><span class="dt">unsigned</span> <span class="dt">char</span></code>) to the signed integer type <code class="sourceCode cpp"><span class="dt">int</span></code> that can lead to operations with undefined behavior <a href="#EWF">[EWF]</a>, where unsigned arithmetic is defined with modulo semantics.</p></li>
<li><p>The standard types used to represent text characters ( <code>char</code>, <code>char8_t</code>, <code>wchar_t</code>, <code>char16_t</code>, <code>char32_t</code>) are treated as arithmetic types even when used to represent text and thus are subject to implicit conversions to and from other arithmetic types. Using values of character types in arithmetic expressions, especially together with other types can be confusing. Furthermore, using values of such types or sequences of such values with their corresponding string types with relational operators might not provide an expected sorting order, depending on the language or the encoding the text represents. Libraries for text processing might take such locale-specific or text-representation-specific behavior into account, whereas the built-in operators of the language don’t.</p></li>
<li><p>Conversions during function overload resolution are considered explicit conversions, when there is not a direct match of argument type with parameter type. Such conversions can lead to ambiguities that result in a compile error, but there can also be a single best matching overload that does not correspond to developer’s expectation including conversion of argument types (see <a href="#YOW">Identifier Name Reuse [YOW]</a>). Even where the code presently corresponds to programmer expectation, a later addition of code can create a new “better match”, potentially resulting in a silent change of behaviour (see <a href="#BJL">Namespace issues [BJL]</a>, and <a href="#FLC">Conversion Errors [FLC]</a>).</p></li>
<li><p>Values of an unscoped enumeration convert to their underlying integral type in arithmetic expressions (see <a href="#CCB">Enumerator Issues [CCB]</a>).</p></li>
<li><p>Built-in array types as well as function types will decay to a pointer type. For array types this is problematic, because the array’s extent is lost (see <a href="#XYZ">Unchecked Array Indexing [XYZ]</a> and <a href="#RVG">Pointer Arithmetic [RVG]</a>)</p></li>
<li><p>Pointer types implicitly convert to pointer-to-void (see <a href="#HFC">Pointer Type Conversions [HFC]</a>).</p></li>
<li><p>Pointer and reference types referring a derived class object can implicitly convert to a pointer or reference to one of its public base classes respectively (see <a href="#BKK">Polymorphic Variables [BKK]</a>).</p></li>
<li><p>User-defined class types can define conversion operators and converting constructors that can be called with a single argument. If these member functions are not declared with the keyword <code class="sourceCode cpp"><span class="kw">explicit</span></code> they are eligible for use in implicit conversions.</p></li>
<li><p>Implicit conversions from an arithmetic type to <code class="sourceCode cpp"><span class="dt">bool</span></code> often indicate a missing comparison. Conversions from <code class="sourceCode cpp"><span class="dt">bool</span></code> in arithmetic expression can obfuscate code. For example, the following code relies on <code class="sourceCode cpp"><span class="kw">false</span></code> converting to/from zero and <code class="sourceCode cpp"><span class="kw">true</span></code> to one and from non-zero:</p></li>
</ul>
<div class="sourceCode" id="cb85"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> fluxcompensation(<span class="dt">double</span> flux, <span class="dt">bool</span> compensate){</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (flux) { <span class="co">// double to bool conversion</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> delta = compute_delta();</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="at">const</span> compensate_v = <span class="fl">1.4</span>;</span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> flux + delta * compensate; <span class="co">// bool to double conversion</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>  } </span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="fl">1.</span>;</span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<ul>
<li>In a boolean context, conversions that would not occur implicily can take place, specifically, a pointer-to-bool conversion and the application of an <code class="sourceCode cpp"><span class="kw">explicit</span> <span class="kw">operator</span> <span class="dt">bool</span>()</code> conversion operator. These conversions are idiomatic C++ in boolean contexts; however, some prefer explicit tests to show intent, for example, <code class="sourceCode cpp"><span class="cf">if</span> (p) { *p = <span class="dv">42</span>; }</code> vs. <code class="sourceCode cpp"><span class="cf">if</span> (p != <span class="kw">nullptr</span>) { *p = <span class="dv">42</span>; }</code>.</li>
</ul>
<p>Note that type aliases (<code class="sourceCode cpp"><span class="kw">using</span></code>, and <code class="sourceCode cpp"><span class="kw">typedef</span></code>) do not define a different type from their alias just a different name and thus do not incur any conversion between the alias and the aliased type.</p>
<p>Instead of using the built-in arithmetic types or generic library types such as <code class="sourceCode cpp"><span class="bu">std::</span>string</code> for your domain values, C++ permmitts wrapping them in user-defined-class types as so-called <em>strong types</em>. For integral values, <code class="sourceCode cpp"><span class="kw">enum</span> <span class="kw">class</span></code> types can also be used. Strong types provide only those operator overloads and conversions for each such type that make sense in the application domain. User-defined-literal operators help with providing constants of appropriate strong types. Such strong types provide full control of conversions and operations available, avoiding semantically unsound operations that the built-in or other generic types might provide.</p>
<p>For example, a very simple strong type representation of temperature values can be implemented as follows:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Celsius {</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> value;</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Fahrenheit {</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> value;</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>Fahrenheit convert_to_fahrenheit(Celsius c){</span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> { <span class="dv">9</span>*c.value/<span class="dv">5</span>+<span class="dv">32</span>};</span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a><span class="co">//...</span></span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>Celsius wrong = convert_to_fahrenheit({<span class="fl">20.</span>}); <span class="co">// doesn&#39;t compile</span></span></code></pre></div>
<p>In a realistic scenario using a library for strong type support eases the definition and use of strong types.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.2.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1:2024, 6.2.5. and provided in the different related clauses of this document.</p></li>
<li><p>Be aware of the rules of the type system, overload resolution, and implicit conversions to avoid vulnerabilities.</p></li>
<li><p>Enable compiler warnings regarding implicit conversions and use static analysis tools that provide such warnings.</p></li>
<li><p>Define as <code class="sourceCode cpp"><span class="kw">explicit</span></code> any constructor of a class that can be called with a single argument of a different type .</p></li>
<li><p>Define any conversion operator as <code class="sourceCode cpp"><span class="kw">explicit</span></code></p></li>
<li><p>Use strong types for domain values instead of the built-in types and on system boundaries, e.g., for input, convert a read value immediately to the appropriate strong type.</p></li>
<li><p>UIse a braced-initializer when defining variables of an arithmetic type to prevent a potential narrowing conversion from the initial value’s type.</p></li>
<li><p>Avoid the use of the following text-representing character types, <code>char</code>, <code>char8_t</code>, <code>wchar_t</code>, <code>char16_t</code> and <code>char32_t</code>, in arithmetic or relational expressions; use an appropriate text processing library instead for character classification, conversion, comparison, and further processing.</p></li>
<li><p>Use a consistent style in a project with respect to implicit pointer conversions in boolean contexts.</p></li>
</ul>
<h2 id="bit-representations-str">6.3 Bit Representations [STR]</h2>
<h3 id="applicability-to-language">6.3.1 Applicability to language</h3>
<p>The vulnerabilities documented in ISO/IEC 24772-1:2024 clause 6.3 is applicable to C++. The “endianness” of integer types and packing of bit fields are implementation-defined properties and not portable.</p>
<p>The standard library type <code class="sourceCode cpp"><span class="bu">std::</span>endian</code> provides a portable check the endianness of a platform that code can use to operate on individual bytes of a machine word in the correct order.</p>
<p>There is no portable mapping from bitfields in a struct to individual bits in a machine word. Therefore, C++ bitfields should not be used to directly map to bits in hardware, even though the compiler provides suitable mapping and manipulation operations. A further complication is that accessing a bitfield cannot easily be performed atomically, because any non-participating bits of a memory location need to be read before the relevant bits can be mutated through masking, and the complete memory location must be written again. It is possible to simulate bitfields with a defined layout through library class types that implement the required masking operations.</p>
<p>For individual bits, <code class="sourceCode cpp"><span class="bu">std::</span>bitset&lt;N&gt;</code> and <code class="sourceCode cpp"><span class="bu">std::</span>vector&lt;<span class="dt">bool</span>&gt;</code> can provide suitable representations at run time, but do not support a direct mapping to machine words. In addition, be aware that <code class="sourceCode cpp"><span class="bu">std::</span>vector&lt;<span class="dt">bool</span>&gt;</code> does not in general behave like a <code>std::vector</code> which can cause generic code to behave in unexpected ways.</p>
<p>The shift operations can result in undefined behavior <a href="#EWF">[EWF]</a> when shifting by a negative or too large value, or when shifting a signed operand. Bit operations should only be used on appropriate unsigned integral types with a known width, while being careful of potential integral promotion that might change a small unsigned operand type to be promoted to a signed integer type. C++ provides a rich set of bitwise operators that can be used to address the issues of bit manipulation in a portable way. When bitwise memory operations are needed, it is good practice to encapsulate such operations in a class type’s member functions.</p>
<p>When raw bit pattrens are used to mask or manipulate memory locations, as is permitted in C++, the reader or maintainer is left to guess the intent of the original programmer. Often such patterns are then used in different code units and finding and updating such bit masks is problematic. As an alternative, C++ supports named constants in enumeration types with the appropriate underlying type and value.</p>
<p>The use of a bit shift of an integral value produces a multiplication or division by a power of two in hardware but should not be used in arithmetic expressions to implement such an operation as it obfuscates the arithmentic operation. Compilers automatically implement multiplication in the most efficient way.</p>
<p>Except for specific situations (trivial types), objects of class type can not be assumed to have a layout appropriate to be manipulated on a byte or bitwise level. Depending on the size and alignment of its data members a class type can have padding bytes between members. The absence of padding in a trivially copyable type <code>T</code> can be checked with a <code>static_assert(std::has_unique_object_representations_v&lt;T&gt;)</code>.</p>
<p><code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code> can be used to reinterpret suitably sized trivial types on a bitwise level, i.e., for accessing the binary representation of a floating point value. However, for types with padding bits that do do not participate in an object’s value representation, the corresponding bits in a <code>bit_cast</code> result have indeterminate values. If those bits are used to compare for equality, with the function <code class="sourceCode cpp">memcmp</code> for instance, the padding bits may differ and cause false negatives. Malicious code could use such padding bits as a <em>secret channel</em> which might be accessed through copying the underlying bytes.</p>
<p>See C++ Core Guidelines ES101 use unsigned types for bit manipulation.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.3.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Apply the avoidance mechanisms of ISO/IEC 24772-3 clause 6.3.2</p></li>
<li><p>Prohibit the use of shift operations to implement multiplication or division by powers of two.</p></li>
<li><p>Use built-in bitwise operations only with operands of unsigned integral types or enums with an unsigned underlying type.</p></li>
<li><p>When performing bitwise operations on operands of an unsigned type that gets promoted to a signed integral type, cast the result to the corresponding unsigned type immediately.</p></li>
<li><p>Ensure that the right-hand operand of a shift operation is not negative or greater than the number of bits the left-hand operand. Use static analysis tools or other means to prove that the right hand operand of the shift is not out of bounds.</p></li>
<li><p>Prefer <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code> over other means such as <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> to access the binary representation of an object.</p></li>
<li><p>Prefer abstractions in a class type encapsulating bit manipulations using unsigned types of well-defined width, such as <code class="sourceCode cpp"><span class="bu">std::</span>bitset</code>, over non-portable bitfields.</p></li>
<li><p>Forbid the use of <code class="sourceCode cpp"><span class="bu">std::</span>memcmp</code>, <code class="sourceCode cpp"><span class="bu">std::</span>memcpy</code>, or <code class="sourceCode cpp"><span class="bu">std::</span>memmove</code> on objects of type <code>T</code> unless <code class="sourceCode cpp"><span class="bu">std::</span>has_unique_object_representations_v&lt;T&gt;</code> is true.</p></li>
</ul>
<h2 id="floating-point-arithmetic-plf">6.4 Floating-point Arithmetic [PLF]</h2>
<h3 id="applicability-to-language">6.4.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1 clause 6.4 is applicable to C++.</p>
<p>The C++ standard assumes IEC 60559 if <code class="sourceCode cpp"><span class="bu">std::</span>numeric_limits<span class="bu">\</span>&lt;T&gt;::is_iec559</code> is true for the types in use. In the absence of this, C++ makes few guarantees about the behaviour of floating point numbers. In particular <code class="sourceCode cpp"><span class="bu">std::</span>less</code> is not a total order; <code class="sourceCode cpp"><span class="bu">std::</span>equal</code> is not equivalent to substitutability (NaNs compare unequal to themselves, but neither less nor greater, and negative zero compares equal to positive zero).</p>
<p>Sorting floating point numbers with the built-in operators violates the preconditions of sorting predicates in the presence of NaN values and may raise floating point errors. The default sorting predicate <code>std::less</code> is suspect to this precondition violation, resulting in undefined behavior <a href="#EWF">[EWF]</a> when sorting a range of floating point values that contains NaNs.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.4.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Apply the avoidance mechanisms of ISO/IEC 24772-1 clause 6.4.5</p></li>
<li><p>Verify compliance to ISO/IEC/IEEE 60559:2011 at compile time through <code class="sourceCode cpp"><span class="bu">std::</span>numeric_limits&lt;T&gt;::is_iec559</code>. Other numeric characteristics such as <code>min()</code>, <code>max()</code>, existence of NaNs, <code>has_denorm</code>, and infinities can be determined in this class template.</p></li>
<li><p>Be aware that the default comparisons in the standard library can produce wrong results when used on floating point members.</p></li>
</ul>
<h2 id="CCB">6.5 Enumerator Issues [CCB]</h2>
<h3 id="applicability-to-language">6.5.1 Applicability to language</h3>
<p>The vulnerability documented in ISO IEC 24772-1 clause 6.5 applies to C++, as C++ allows the specification of the values underlying a member of an enumeration type.</p>
<p>C++ provides scoped (<code class="sourceCode cpp"><span class="kw">enum</span> <span class="kw">class</span></code>) and unscoped (<code class="sourceCode cpp"><span class="kw">enum</span></code>) enumeration types, where an underlying integral type can be specified. Unscoped enumeration types without an <em>enum-base</em> have a non-fixed underlying type that only guarantees values in the range of the provided enumerators are valid. The latter can cause non-representable values to be assigned to a variable of such an unscoped enumeration type. For enumeration types with a fixed underlying type all values of the underlying integral type are valid. See ISO IEC 24772-3 for vulnerabilities associated with unscoped enums with no fixed underlying type, except an explicit conversion is required to convert an integer to an enumeration type object.</p>
<p>Casting a value to an enumeration type is undefined behavior <a href="#EWF">[EWF]</a> unless the source value is within the range of values of an enumeration type. See CERT INT50-CPP. (remove CERT reference???)</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Color  {red=<span class="dv">1</span>, green, blue};</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="dt">short</span> i = red; <span class="co">// implicit conversion</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>Color g { Color(green + blue) }; <span class="co">// Undefined-defined behaviour since 5 will not fit into</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>                                 <span class="co">// the smallest bitfield to hold red, green and blue</span></span></code></pre></div>
<p>C++ does not support implicit conversion of a scoped enum to other types, hence, operations (such as arithmetic operations) must be explicitly provided.</p>
<p>In the following example, based upon the above definition,</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo () { </span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>  i + red ;        <span class="co">// well-formed for unscoped enum, ill-formed for scoped enum.</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Scoped enums, on the other hand, require that the conversions to/from the enumeration type must be explicit, as shown below:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> Color : <span class="dt">short</span> { red, green, blue };</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a><span class="dt">short</span> i = <span class="kw">static_cast</span>&lt;<span class="dt">short</span>&gt;(Color::red);</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>Color <span class="kw">operator</span>+(Color a, <span class="dt">short</span> b)</span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> <span class="kw">static_cast</span>&lt;Color&gt;((<span class="kw">static_cast</span>&lt;<span class="dt">short</span>&gt;(a) + b) % <span class="dv">3</span>);</span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Unscoped enumeration types implicitly promote to an integral type and can be used as the index of an array without a cast. Without a user-specified mapping to an underlying representation, there will be “holes” as documented in ISO IEC 24772-1:2024 clause 6.5 and ISO IEC TR 24772-3 clause 6.5.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.5.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Prefer <em>scoped enumerations</em> with an explicit fixed underlying type.</p>
<ul>
<li><pre><code>  See CPP Core Guidelines Enum.3 &quot;Prefer class enums over &#39;plain&#39;</code></pre>
<p>enums".</p></li>
<li><pre><code>  See AUTOSAR A7-2-3 &quot;Enumerations shall be declared as scoped</code></pre>
<p>enum classes"</p></li>
<li><pre><code>  See MISRA C++ 8.5.3 </code></pre></li>
<li><pre><code>  See MISRA C++ 28.5.5 </code></pre></li>
</ul></li>
<li><p>If <em>unscoped enumerations</em> are used, follow the general advice of TR 24772-3 clause 6.5.2 as well as the following:</p>
<ul>
<li><p>For an enumeration type with a fixed underlying type, avoid assigning integer values that are outside the range of the enumeration’s underlying type.</p></li>
<li><p>For an enumeration type with no fixed underlying type, avoid assigning integer values that cannot be represented by the enumeration type.</p></li>
<li><p>Avoid casting integer values to enumeration type values, but if unavoidable, ensure that it corresponds to a named enumerator.</p></li>
</ul></li>
</ul>
<h2 id="FLC">6.6 Conversion Errors [FLC]</h2>
<h3 id="applicability-to-language">6.6.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO IEC 24772-1 clause 6.6 applies to C++. C++ includes some of the conversion mechanisms of C as documented in ISO IEC TR 24772-3 6.6, however C++ type conversion mechanisms differ from the mechanisms of C, as documented in ISO IEC 14882 Annex C. This subclause highlights differences where C++ provides mitigations of potential vulnerabilities found in C.</p>
<p>In C++, some conversions are explicit while others are implicit. Conversions can change: - the size of a type, - whether or not the type is signed, and - possibly other properties of the type. A narrowing conversion is when the target type cannot represent all the values of the original type.</p>
<p>Many errors are associated with implicit conversions. For a comprehensive overview see clause 7.3 [conv] of [C++23]</p>
<p>Explicit conversions use one of the mechanisms provided by C++ through a</p>
<ul>
<li>type conversion operator
<ul>
<li><code class="sourceCode cpp"><span class="kw">static_cast</span></code>,</li>
<li><code class="sourceCode cpp"><span class="kw">const_cast</span></code>,</li>
<li><code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code>,</li>
<li><code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>),</li>
</ul></li>
<li>constructor notation with
<ul>
<li>parentheses (e.g., <code class="sourceCode cpp"><span class="dt">double</span>(<span class="dv">42</span>)</code>) or</li>
<li>braces (e.g., int{‘a’}) which prevents narrowing conversions, or</li>
</ul></li>
<li>a C-style cast (<code class="sourceCode cpp">(<span class="dt">int</span>)<span class="fl">3.14</span></code>).</li>
</ul>
<p>The C-style cast is problematic since: - It is not easily identified in code using search tools, and - Compiler checks for correctness are effectively nonexistant. In C++, a C-style cast is defined in terms of the C++ cast operators <code class="sourceCode cpp"><span class="kw">const_cast</span></code>, <code class="sourceCode cpp"><span class="kw">static_cast</span></code>, and <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>. In some cases, it is unspecified which cast is used, for example when a cast operation involves an incomplete type. A <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> can be used for the conversion which can produce an incorrect result. If the C-style cast is used instead of one of the C++-style casts, the cast expected by the programmer cannot be guaranteed to be the cast actually performed, and hence should be avoided.</p>
<p>Unlike C++'s other cast notations, <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> relies on run-time type information generated by the compiler to ensure the requested conversion is valid. If the cast is not valid, then <code class="sourceCode cpp"><span class="kw">nullptr</span></code> is returned for pointer types, otherwise an exception is thrown. [C++20, Clause 8.2.7 [expr.dynamic.cast]] Thus, <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> is safer to use when converting down or across a hierarchy. (see <a href="#HFC">Pointer Type Conversions [HFC]</a> and <a href="#BKK">Polymorphic Variables [BKK]</a>)</p>
<p>An implicit conversion to a class type can occur for a class with constructors that can be invoked with a single argument, as in the following example:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>      {<span class="kw">public</span>:</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>        C(<span class="dt">int</span> x=<span class="dv">10</span>, <span class="dt">float</span> y=<span class="dv">0</span>){...}</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>      };</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo(C param){...}</span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar( <span class="dt">bool</span> b){ foo(b);} </span></code></pre></div>
<p>In the example above, it can be surprising that <code class="sourceCode cpp">foo()</code> is called with a boolean.</p>
<p>This implicit conversion to a class object is the default behaviour of constructors that can be called with a single parameter. The <code class="sourceCode cpp"><span class="kw">explicit</span></code> keyword can be used before the constructor to prevent this happening, as in:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">explicit</span> C(<span class="dt">int</span> x=<span class="dv">10</span>, <span class="dt">float</span> y=<span class="dv">0</span>){...}</span></code></pre></div>
<p>The call <code class="sourceCode cpp">foo(b)</code> would now be illegal.</p>
<p>Implications of casting away <code class="sourceCode cpp"><span class="at">const</span></code> using <code>const_cast</code> are described in section <a href="#UJO">Modifying Constants [UJO]</a>.</p>
<p>Other implicit conversions can result in data loss or erroneous values. This is an issue with implicit conversions since they are automatic: the programmer does not explicitly write code to perform the conversion. For example, a common problem is mixing signed and unsigned integral types in arithmetic expressions. This can be problematic since the ranges of signed and unsigned integer types differ and the behaviour of signed integer arithmetic on overflow is undefined <a href="#EWF">[EWF]</a> whereas unsigned integer arithmetic wraps on overflow. See subclause 4.2 for a discussion of integral promotions in C++.</p>
<p>The issues described are not restricted to narrowing conversions, as shown below:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">long</span> l_64 = i_32 + i_32; <span class="co">// &#39;+&#39; operation preformed in 32 bits</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>                         <span class="co">// widened after the operation completes (and potentially overflows). </span></span></code></pre></div>
<p>This can be avoided by converting at least one operand to the wider type as part of the operation. Note that <code class="sourceCode cpp"><span class="kw">auto</span></code> directs the compiler to use the appropriate type based on the initializer expression. Subsequent use of the auto object (such as in standard mathematical operations) can lead to implicit conversions that are not obvious in the context local to the expression. Additional problems arise as a result of implicit conversions between <code>bool</code> and other types, thus hiding the fact when a wrong operator is used accidentally:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f(<span class="dt">unsigned</span> i, <span class="dt">unsigned</span> j)</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (i &gt; <span class="dv">1</span>) &amp; (j = <span class="dv">1</span>); <span class="co">// (&gt;&gt;, &amp;&amp;, ==) ?</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In the example above, all combinations of the corresponding operators will compile with different resulting types and results.</p>
<p>Similar issues arise in conversions between character types (char, char8_t, …) and other types. Character types are provided to represent text in whatever character representation is needed.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f(<span class="dt">char</span> c)</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (c &lt; <span class="dv">0</span>) <span class="co">// can be always false on some platforms.</span></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>    {}</span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In addition to the use of <em>strong types</em> (see <a href="#IHN">Type System [IHN]</a>), the implicit conversions and multitude of possible operations of integral types can be mitigated by using scoped enumeration types with the corresponding integer type as its underlying type. For example, <code class="sourceCode cpp"><span class="bu">std::</span>byte</code> is defined to address individual <code class="sourceCode cpp"><span class="dt">unsigned</span> <span class="dt">char</span></code> elements (bytes) in memory without participating in arithmetic or bitwise operations.</p>
<p>Because C++ allows function and operator overloading, the effect of implicit conversions provides an additional mechanism of failure, by selecting an unwanted overload during overload resolution due to implicit conversions. This can influence failure modes with lookup as described in section <a href="#BJL">Namespace Issues [BJL]</a>. // Add overload resolution reference!!</p>
<p>C++ also provides a library function <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code>. This function provides the ability to preserve the bit representation when converting between unrelated types.<br />
If such is meaningful, then <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code> reduces the risk of some undefined behaviours compared with other type punning approaches such as casts or unions.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.6.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Apply the avoidance mechanisms of ISO/IEC 24772-1 clause 6.6.5:</p></li>
<li><p>Prohibit C-style casts; use C++ type conversion operators instead, as they document intent and disallow some unsafe conversions. (see C++ Core Guidelines ES.49)</p></li>
<li><p>Avoid casts and type punning (see C++ Core guidelines ES.48), and treat every cast as a candidate for refactoring. If type punning is required, use <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code>.</p></li>
<li><p>Avoid narrowing conversions. (see C++ Core Guidelines ES.46)</p></li>
<li><p>Prefer the use of braces over the use of parentheses for initialization or explicit conversions from numeric types to prevent narrowing. (see C++ Core Guidelines ES.23 and ES.64)</p></li>
<li><p>Declare <code class="sourceCode cpp"><span class="kw">explicit</span></code></p>
<ul>
<li>constructors callable with a single argument; and</li>
<li>conversion functions. (see C++ Core guidelines C.46 and C.164)</li>
</ul></li>
<li><p>Avoid casting away <code class="sourceCode cpp"><span class="at">const</span></code>. See subclause <a href="#UJO">Modifying Constants [UJO]</a><br />
(see C++ Core Guidelines ES.50)</p></li>
<li><p>Avoid arithmetic operations on operands that can be promoted. In partcular, be aware of the arithmetic operators that promote their operands, and the types are subject to promotion.</p></li>
<li><p>Avoid widening the result of an arithmetic operation; prefer instead to widen the type of one or more of the operands</p></li>
<li><p>Prohibit mixing signed and unsigned arithmetic (see C++ Core Guidelines ES100)</p></li>
<li><p>Avoid implicit conversions between <code>bool</code> and other types.</p></li>
<li><p>Avoid implicit conversions between character types and other types.</p></li>
<li><p>Use <em>strong types</em> (see subclause <a href="#IHN">Type System [IHN]</a>) to limit implicit conversions and unwanted operations.</p></li>
<li><p>When using <code class="sourceCode cpp"><span class="kw">auto</span></code> ensure that you know the type that <code class="sourceCode cpp"><span class="kw">auto</span></code> deduces type and resist using <code class="sourceCode cpp"><span class="kw">auto</span></code> for the predefined types</p></li>
</ul>
<h2 id="CJM">6.7 String Termination [CJM]</h2>
<h3 id="applicability-to-language">6.7.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 exists in C++ when C-style strings are used. For example, passing a non-null-terminated character array to an interface that requires a null-terminated string can result in undefined behaviour <a href="#EWF">[EWF]</a>. C++ provides alternative string processing capabilities that do not exhibit those vulnerabilities.</p>
<p>C++ provides a class template for string processing, <code class="sourceCode cpp"><span class="bu">std::</span>basic_string</code>, that manages the space for the string and the string length and always includes a string termination character. For example, when concatenating, the <code class="sourceCode cpp"><span class="bu">std::</span>basic_string</code> object will increase in size to contain the resulting string. Futhermore, as the string is guaranteed to have a string termination character, using its underlying raw pointer as a C-style string will mitigate this vulnerability because the string termination character is present.</p>
<p>C++ provides the library class templates <code class="sourceCode cpp"><span class="bu">std::</span>basic_stringview</code> and <code class="sourceCode cpp"><span class="bu">std::</span>span</code> that implement reference semantics to non-owned buffers. These types do not rely on a string termination character to determine the length of the string, thus, use of these types avoids those vulnerabilities. However, using its underlying raw pointer as a C-style string can result in these vulnerabilities because the string termination character is not guaranteed to be present.</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo(<span class="bu">std::</span>string <span class="at">const</span>&amp; s, <span class="bu">std::</span>string_view <span class="at">const</span>&amp; sv)</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>  puts(s.data());  <span class="co">// okay string has termination character</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>  puts(sv.data()); <span class="co">// not okay; string termination not guaranteed</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h3 id="avoidance-mechanisms-for-language-users">6.7.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Avoid C-style strings.</p></li>
<li><p>If using C-style strings is unavoidable, apply the avoidance mechanisms of ISO/IEC 24772-3 clause 6.7.2.</p></li>
<li><p>Ensure that explicit overflow checks are performed for all string operations.</p></li>
<li><p>Prefer using a string type, e.g., <code class="sourceCode cpp"><span class="bu">std::</span>string</code>, that manages the memory of its string and handles termination in order to mitigate against this vulnerability.</p></li>
<li><p>Prohibit the use of the underlying raw pointer of a <code class="sourceCode cpp"><span class="bu">std::</span>string_view</code> or a <code class="sourceCode cpp"><span class="bu">std::</span>span</code> with interfaces that expect C-style strings.</p></li>
<li><p>Use static analysis tools to help identify occurrences of undefined behaviour.</p></li>
</ul>
<h2 id="HCB">6.8 Buffer Boundary Violation [HCB]</h2>
<h3 id="applicability-to-language">6.8.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1 clause 6.8 exists in C++ when arrays are managed using raw pointers or indexing. The range of valid raw pointers to a plain array <code>a</code> are from the first element to one past the last element of the array, i.e., in the range [<code class="sourceCode cpp"><span class="bu">std::</span>begin(a)</code>..<code class="sourceCode cpp"><span class="bu">std::</span>end(a)</code>). An object <code>o</code> can be treated as a single element array with respect to pointers referring to it.</p>
<p>C++ provides facilities to encapsulate code that is exposed to this vulnerability. The standard library defines features that mitigate or circumvent this vulnerability. For example, <code class="sourceCode cpp"><span class="bu">std::</span>string</code>, <code class="sourceCode cpp"><span class="bu">std::</span>vector</code>, <code class="sourceCode cpp"><span class="bu">std::</span>deque</code>, and <code class="sourceCode cpp">iostreams</code> manage buffers internally; using “range-for” such as <code class="sourceCode cpp"><span class="cf">for</span> (<span class="kw">auto</span> &amp;e :</code><em><code>some container</code></em><code class="sourceCode cpp">)</code> and the algorithm library to access elements <code>e</code> of the container without the possibility of a buffer boundary violation.</p>
<p>However, the member function <code class="sourceCode cpp">data()</code> of the contiguous sequence containers returns a non-const pointer to the underlying elements. This allows manipulating the underlying memory directly, bypassing the safety features of the container leading to this vulnerability. For example, <code>std::string::data()</code> returns a non-const <code class="sourceCode cpp"><span class="dt">char</span>*</code>.</p>
<p>When working directly with iterators referring a container, one need to ensure that those iterators are and remain valid. For example, for a container <code>c</code> incrementing an iterator beyond the <code>end(c)</code> iterator or dereferencing the iterator denoted by <code>end(c)</code> are undefined behavior <a href="#EWF">[EWF]</a>.</p>
<p>In general, validity of iterators requires programmer care to prevent out-of-bounds access of the underlying container:</p>
<p>For example, using algorithms and iterators correctly to convert an input string to lower case:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string to_lowercase(<span class="bu">std::</span>string_view s){</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string result{};</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>    transform(</span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>        begin(s), end(s), <span class="co">// input range #1</span></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>back_inserter(result), <span class="co">// output iterator #2</span></span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a>        [](<span class="dt">char</span> c){ <span class="cf">return</span> <span class="bu">std::</span>tolower(c);});</span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result;</span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The above example, passes two ranges of characters to the transform algorithm. Potential errors due to a boundary violation could be caused by the following changes:</p>
<ul>
<li>wrong input range #1, e.g., passing unrelated iterators,</li>
<li>insufficient space in output range #2, e.g., passing <code class="sourceCode cpp">begin(result)</code> instead of <code class="sourceCode cpp">back_inserter(result)</code>,</li>
</ul>
<p>The second problem occurs in the following code if the length of s is longer than 31:</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string to_lowercase(<span class="bu">std::</span>string_view s){</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string result{<span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span>, <span class="dv">31</span>};</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>    transform(</span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>        begin(s), end(s), </span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>        begin(result), <span class="co">// error, only space for 31 characters </span></span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>        [](<span class="dt">char</span> c){ <span class="cf">return</span> <span class="bu">std::</span>tolower(c);});</span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result; <span class="co">// size(result) == 31</span></span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>An additional problem occurs when performing an operation that invalidates an in-use iterator, such as the iterator internally used by the range-for statement below:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string to_lowercase(<span class="bu">std::</span>string s){</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (<span class="kw">auto</span> &amp;c:s){</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>       s.append(<span class="bu">std::</span>tolower(c)); <span class="co">// error, invalidates in-use iterator</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s;</span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Another way that overflows can occur is through the use of C-style strings, which can be treated as arrays of characters, but mishandling of the <code>nul</code> termination can make overflows possible. See clause <span id="CJM">6.7 String Termination[CJM]</span>.</p>
<p>Since plain (C-style) arrays when passed as function arguments decay to pointers the array dimension is lost. C++ provides several means of keeping the array dimension available to the called function:</p>
<ul>
<li>use <code>std::array</code> as parameter type,</li>
<li>use <code>std::views::counted</code> or another view as parameter type,</li>
<li>use <code>std::span</code> as parameter type for plain arrays,</li>
<li>use <code>std::string_view</code> as parameter type in favour of <code>char const*</code>, or</li>
<li>pass plain arrays by reference to a function template and deduce the dimension.</li>
</ul>
<p>For further explanation and examples, see</p>
<ul>
<li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR50-CPP.+Guarantee+that+container+indices+and+iterators+are+within+the+valid+range">SEI CTR50-CPP</a></li>
<li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR53-CPP.+Use+valid+iterator+ranges">SEI CTR53-CPP</a></li>
<li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR55-CPP.+Do+not+use+an+additive+operator+on+an+iterator+if+the+result+would+overflow">SEI CTR55-CPP</a></li>
<li><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#i13-do-not-pass-an-array-as-a-single-pointer">C++ core guidelines I.13</a></li>
</ul>
<h3 id="avoidance-mechanisms-for-language-users">6.8.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.8.5.</p></li>
<li><p>Avoid C-style arrays. If unavoidable, guidance for the use of C-style arrays is provided in TR 24772-3 clause 6.8.2.</p></li>
<li><p>Avoid container functions, such as <code class="sourceCode cpp">data()</code>, that bypass the safety features of the respective containers.</p></li>
<li><p>To model a fixed-size array, use a library class such as <code class="sourceCode cpp"><span class="bu">std::</span>array</code>.</p></li>
<li><p>To model arrays with dynamically changing size, use containers of the standard library, such as <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> or <code class="sourceCode cpp"><span class="bu">std::</span>deque</code>.</p></li>
<li><p>Avoid using a pointer parameter or a pointer-and-size parameter pair for representing a contiguous buffer; instead use a range parameter, for example, <code class="sourceCode cpp"><span class="bu">std::</span>views<span class="bu">::</span>counted</code>, <code class="sourceCode cpp"><span class="bu">std::</span>span</code>, or <code class="sourceCode cpp"><span class="bu">std::</span>string_view</code>.</p></li>
<li><p>Prefer using range-based or iterator-based algorithms, such as those of the standard library, over pointer-manipulating or indexing loops.</p></li>
<li><p>Use the range-based for loop construct to iterate within the defined bounds of a range.</p></li>
<li><p>Ensure that ranges and iterators used by range-for or passed to algorithms are and remain valid.</p></li>
<li><p>When performing random access by indexing, use the avoidance mechanisms of clause <a href="#XYZ">6.9.2</a>.</p></li>
<li><p>Use static analysis tools to detect buffer boundary violations.</p></li>
</ul>
<h2 id="XYZ">6.9 Unchecked Array Indexing [XYZ]</h2>
<h3 id="applicability-to-language">6.9.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2022 6.9 exists in C++ when an access is performed using <code>operator[]</code>.</p>
<p>C-style arrays, C-style pointers, random-access iterators, and some standard library containers allow element access via <code>operator[]</code> which is unchecked. However, those standard library containers also provide an access function <code>at()</code> that behaves like <code>operator[]</code>, but performs a check that the access is within the bounds of the container and throws an exception otherwise.</p>
<p>For issues associated with exception handling and error handling, see clause <a href="#OYB">6.36</a> Ignored error status and unhandled exceptions.</p>
<p>The parameter type for contiguous sequences <code>std::span</code> does not provide a checked version of indexing and therefore should only be used via its iterator/range API. With the introduction of the <code>at()</code> function in C++ 26, a checked version of indexing is available. For more information on the use of <code>std::span</code> see <a href="#HCB">6.8</a></p>
<h3 id="avoidance-mechanisms-for-language-users">6.9.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Apply the avoidance mechanisms of ISO/IEC 24772-1:2022 clause 6.9.5.</p></li>
<li><p>Follow the advice from clause <a href="#HCB">6.8.2</a>.</p></li>
<li><p>Prefer the <code>at()</code> member function of the standard library containers over <code>operator[]</code> and handle the bounds violation exceptions.</p></li>
<li><p>If indexing cannot be avoided, use static analysis or explicit checks to establish that bounds violations do not occur.</p></li>
</ul>
<h2 id="XYW">6.10 Unchecked Array Copying [XYW]</h2>
<h3 id="applicability-to-language">6.10.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC 24772-1:2022 exists in C++, but can be mitigated using features provided by the language.</p>
<p>A buffer overflow occurs when some number of elements is copied from one buffer to another and the amount being copied is greater than is allocated for the destination buffer. This is a special case of <span id="HCB">6.8 Buffer Boundary Violation [HCB]</span>. The C library functions or hand-written loops for copying bytes or C-style strings are especially prone to this vulnerability.</p>
<p>As with clause 6.8 [HCB], in most cases the vulnerability can be avoided by using library classes, such as <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> or <code class="sourceCode cpp"><span class="bu">std::</span>string</code>, which provide a copy operations operator that adjust the size of the target to fit the object being copied.</p>
<p>The standard library algorithms that copy into a target range can suffer from this vulnerability. In the case of potential overflow, the programmer must either ensure automatic extension of the underlying container, such as by using <code class="sourceCode cpp"><span class="bu">std::</span>back_inserter(container)</code> as the output iterator, or ensure that the output range has sufficient space available. In the case of overlapping input and output ranges, the suitable copying algorithm must be selected, depending on the relative ordering of the ranges. In general, this situation can be avoided by using a more appropriate algorithm, for example, <code class="sourceCode cpp"><span class="bu">std::</span>rotate</code>.</p>
<p>For arrays with fixed sizes the assignment operator or copy-constructor of <code class="sourceCode cpp"><span class="bu">std::</span>array</code> is the means of safe array copying.</p>
<p>If a system requires its own container types with dynamic size, a naïve implementation might attempt to keep the copying external, like with C-style arrays. Such external copying should be avoided.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.10.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1:2022 clause 6.10.5.</p></li>
<li><p>Use standard library containers instead of C-style arrays, such as <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> or <code class="sourceCode cpp"><span class="bu">std::</span>array</code>, that provide copying mechanisms that ensure the target array is large enough for the indicated source.</p></li>
<li><p>When using standard library algorithms that copy into an output range, ensure that either the output range is extended automatically or has sufficient space available.</p></li>
<li><p>Sidestep the need to use a copy algorithm on overlapping ranges, by selecting a more appropriate algorithm, such as <code class="sourceCode cpp"><span class="bu">std::</span>rotate</code>.</p></li>
<li><p>If a system requires its own container types with dynamic size, ensure that their copy operations are correct and do not require loops or algorithms for copying their content.</p></li>
<li><p>If copying C-style arrays is unavoidable, statically show that an access outside of the array cannot occur, or alternatively perform range checking before copying the array.</p></li>
<li><p>Avoid using the copying functions from the headers <cstring></p></li>
</ul>
<h2 id="HFC">6.11 Pointer Type Conversions [HFC]</h2>
<h3 id="applicability-to-language">6.11.1 Applicability to language</h3>
<p>The vulnerabilites as described in ISO/IEC TR 24772-1:2019 clause 6.11.1 applies to C++. In addition to pointers, C++ references are also vulnerable and the issues below include references when pointers are mentioned. In places where references cannot be substituted the corresponding code won’t compile.</p>
<p>In general casting pointers breaks the type system and should be avoided.</p>
<p>In C++, a C-style cast is defined in terms of the C++ cast operators <code class="sourceCode cpp"><span class="kw">const_cast</span></code>, <code class="sourceCode cpp"><span class="kw">static_cast</span></code>, and <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>. In addition, certain placement new expressions that do not initialize the storage can act like <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>. In some cases, it is unspecified which cast is used, for example, when a cast operation involves an incomplete type, a <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> may be used for the conversion which can produce an incorrect result.</p>
<p>Especially, <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> has the problem that it takes the original pointer value as a pointer of the target type rather than the original type. The C++ standard defines most cases where that happens as undefined behavior <a href="#EWF">[EWF]</a>. For example, the lifetime model of C++ might result in accessing the target type object outside of its lifetime (see 4.4). Other run-time issues can be caused by alignment violations. Using <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span>&lt;<span class="bu">std::</span>byte*&gt;</code> to access the underlying memory of an object by casting its address permits access to the raw memory. However, casting the address of a piece of raw memory with the correct alignment and size to an object pointer and accessing that object is undefined behavior for most types, because doing so, will not start the lifetime of the object (see 4.4).</p>
<p><code class="sourceCode cpp"><span class="kw">static_cast</span></code> only works, where conversion of the source type to the target type are related. However, with pointer types the compiler cannot always check that the actual object type corresponds to the desired target type, causing invalid casts. Naïvely assuming that addresses of a derived object and its base object are identical is wrong in most cases. For example, with multiple inheritance, the address of an object may be different than one of its base class sub-objects. Using the generic pointer type <code class="sourceCode cpp"><span class="dt">void</span>*</code> (which is common in C APIs) allows converting between arbitrary pointer types using <code class="sourceCode cpp"><span class="kw">static_cast</span></code>. Most conversions via <code class="sourceCode cpp"><span class="dt">void</span> *</code> where the originial object type and the final target type are different are undefined behavior in C++. C++ allows <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> to a pointer to an incomplete type or a <code class="sourceCode cpp"><span class="kw">static_cast</span></code> from <code class="sourceCode cpp"><span class="dt">void</span> *</code> to a pointer to an incomplete type. Pointers to objects can implicitly convert to <code class="sourceCode cpp"><span class="dt">void</span> *</code> (cv-qualified accordingly).</p>
<p>In general, the C++ standard only defines <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> to obtain the pointer back to the original type. It is implementation-defined if that bidirectional <code class="sourceCode cpp"><span class="dt">void</span> *</code> conversion also works for function pointers <a href="#FAB">Implementation-defined behaviour [FAB]</a>. A <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> can be used to convert a pointer from the integral types <code class="sourceCode cpp"><span class="bu">std::</span>uintptr_t</code>/<code class="sourceCode cpp"><span class="bu">std::</span>intptr_t</code>, but only if the value of the integer value was previously obtained by converting a valid pointer to said integral type. Casting an arbitrary integral value to a pointer is undefined behavior.</p>
<p>Casting along the inheritance relationships with <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> is safe, but requires the dynamic type to be known, which is the case when the types declare virtual member functions. Within a constructor or destructor only the static type of the current class is relevant, because the lifetime of any derived class object hasn’t started or has already ended. See subclause <a href="#BKK">Polymorphic Variables [BKK]</a>.</p>
<p>Conversions involving <code class="sourceCode cpp"><span class="at">const</span></code> and/or <code class="sourceCode cpp"><span class="at">volatile</span></code> properties of a type are permitted using <code class="sourceCode cpp"><span class="kw">const_cast</span></code> (see <a href="#UJO">Modifying constants [UJO]</a>). Adding <code class="sourceCode cpp"><span class="at">const</span></code> with <code class="sourceCode cpp"><span class="kw">const_cast</span></code> is safe.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.11.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.11.5.</p></li>
<li><p>Avoid the C-style cast, <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>, and casts to and from <code>void*</code>.</p></li>
<li><p>For conversions that remove the <code class="sourceCode cpp"><span class="at">const</span></code> qualification, see the guidance in clause <a href="#UJO">Modifying constants [UJO]</a>.</p></li>
<li><p>When downcasting or crosscasting see the guidance in <a href="#BKK">Polymorphic Variables [BKK]</a>.</p></li>
<li><p>If pointer and reference conversions cannot be avoided, treat compiler warnings that are issued for such conversions as hard errors.</p></li>
<li><p>Ensure through static analysis that arbitrary pointer casts return a type compatible with the source.</p></li>
</ul>
<h2 id="RVG">6.12 Pointer Arithmetic [RVG]</h2>
<h3 id="applicability-to-language">6.12.1 Applicability to language</h3>
<p>The vulnerabilites described in ISO/IEC 24772-1:2022 clause 6.12.1 also apply to C++. The vulnerabilities caused by out-of-bounds access are covered in clause <a href="#HCB">6.8</a>.</p>
<p>Pointers to functions, pointers to members, and pointers to <code class="sourceCode cpp"><span class="dt">void</span></code> do not allow pointer arithmetic.</p>
<p>The set of valid pointers referring to an array consists of the pointers to each array element plus the pointer just past the end of the array, however dereferencing a pointer one past the end of the array is undefined behaviour <a href="#EWF">[EWF]</a>. A pointer to a single object is considered to point to an array of size one with respect to pointer arithmetic.</p>
<p>Adding or subtracting an integral value to a pointer value must yield a result that is a valid pointer refering to the same array, otherwise the behavior is undefined. Note: the built-in indexing operator is defined in terms of pointer arithmetic.</p>
<p>Subtraction of two pointers has undefined behaviour unless both pointers refer to the same array or are both null.</p>
<p>Comparison of two pointers with one of the operators <code class="sourceCode cpp">&lt; &gt; &lt;= &gt;= &lt;=&gt;</code> has unspecified behaviour unless both pointers refer to the same underlying array or object. The standard library function objects for comparison, like <code>std::less&lt;&gt;</code>, provide a strict total order of pointers of a given type.</p>
<p>Iterators as defined by the standard library suffer from similar vulnerabilities as pointer arithmetic. Comparison and subtraction of two iterators, or computing <code>std::distance</code> cause undefined behavior for iterators that refer to different ranges. Forming an iterator that is outside of its underlying range similarly is undefined behavior.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.12.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Avoid explicit pointer arithmetic, especially on a pointer to a single object.</p></li>
<li><p>Prefer calling range-based algorithms over pointer arithmetic.</p></li>
<li><p>Use the avoidance mechanisms of <a href="#HCB">6.8.2</a>.</p></li>
<li><p>Compare arbitrary pointers to objects with the standard library comparison function objects instead of the operators <code class="sourceCode cpp">&lt; &gt; &lt;= &gt;= &lt;=&gt;</code>.</p></li>
</ul>
<h2 id="XYH">6.13 NULL Pointer Dereference [XYH]</h2>
<h3 id="applicability-to-language">6.13.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.13 exists in C++. Dereferencing a pointer with the value of <code class="sourceCode cpp"><span class="kw">nullptr</span></code> is undefined behavior <a href="#EWF">[EWF]</a>.</p>
<p>Using pointers is inherently problematic especially for function parameters and return values, due to the following issues:</p>
<ul>
<li>is a <code class="sourceCode cpp"><span class="kw">nullptr</span></code> value valid in context?</li>
<li>is there protection against dereference of a <code class="sourceCode cpp"><span class="kw">nullptr</span></code> value?</li>
<li>is it a single object or an array of objects? (<code class="sourceCode cpp">T[]</code> as a function parameter type is identical to <code class="sourceCode cpp">T*</code>)</li>
<li>what is the lifetime of the target of the pointer?</li>
<li>who has ownership of the target object?</li>
</ul>
<p>Using values instead of pointers sidesteps all pointer vulnerabilities, especially when returned from a function. For example, standard library containers like <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> have value semantics and do not suffer from this vulnerability.</p>
<p>C++ references cannot be null in a well-defined program and solve the null-dereferencing vulnerability. They are particularly useful as function parameters. Using a reference as function return type requires the caller to avoid accessing an object outisde of its lifetime (see <a href="#XYK">[XYK]</a>, <a href="#DCM">[DCM]</a>).</p>
<p>If absence of a value is necessary, a class type for optional values such as <code class="sourceCode cpp"><span class="bu">std::</span>optional</code> provides well-defined behaviour and single-object ownership. In case of attempting to access the value of an empty <code class="sourceCode cpp"><span class="bu">std::</span>optional</code> an exception is thrown.</p>
<p>Note: Be aware that <code class="sourceCode cpp">optional&lt;T&amp;&gt;</code> is not supported by the standard library. For representing optional references <code class="sourceCode cpp"><span class="bu">std::</span>optional&lt;<span class="bu">std::</span>reference_wrapper&lt;T&gt;&gt;</code> or a non-standard implementation of <code class="sourceCode cpp">optional</code> supporting references can be used.</p>
<p>If dynamically allocated objects are required, <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr&lt;T&gt;</code> can be used for lifetime-management and for transferring ownership. When shared ownership of such objects is necessary, <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr&lt;T&gt;</code> is a solution. Using <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr&lt;T <span class="at">const</span>&gt;</code> provides value semantics for immutable heap-allocated objects thus sidestepping most of the issues of pointers above. Constructing a smart pointer through the factories <code class="sourceCode cpp"><span class="bu">std::</span>make_unique</code> or <code class="sourceCode cpp"><span class="bu">std::</span>make_shared</code> will return a non-null smart pointer or throw an exception and thus prevent the vulnerability of null pointers, in contrast to legacy allocation mechanisms and some overloads of <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">new</span></code>. However, in general dereferencing a <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr</code> or <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr</code> equal to <code class="sourceCode cpp"><span class="kw">nullptr</span></code> causes undefined behaviour, for example, when such a smart pointer is default constructed or a <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr</code> is in a moved-from state. For further information see also <a href="#XYL">[XYL]</a>.</p>
<!-- See C++ Core Guidelines ES.65 and section R: Resource Management, and CERT EXP34-C "Do not
dereference null pointers" -->
<h3 id="avoidance-mechanisms-for-language-users">6.13.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Avoid the need for pointers by using values.</p></li>
<li><p>Prefer references over pointers for parameters.</p></li>
<li><p>Use <code class="sourceCode cpp"><span class="bu">std::</span>optional</code> instead of a pointer to represent a potentially empty value.</p></li>
<li><p>Use containers with value semantics instead of plain arrays such as <code class="sourceCode cpp"><span class="bu">std::</span>array</code>, <code class="sourceCode cpp"><span class="bu">std::</span>vector</code>.</p></li>
<li><p>Use <code class="sourceCode cpp">make_unique()</code> or <code class="sourceCode cpp">make_shared()</code> for dynamically allocating objects.</p></li>
<li><p>If using objects of pointer-like types that may be a <code class="sourceCode cpp"><span class="kw">nullptr</span></code> value is unavoidable, use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.13.5.</p></li>
<li><p>Use static and dynamic analysis tools to detect potential violations of this guideline.</p></li>
</ul>
<h2 id="XYK">6.14 Dangling Reference to Heap [XYK]</h2>
<h3 id="applicability-to-language">6.14.1 Applicability to language</h3>
<p>The vulnerability as expressed in ISO/IEC TR 24772-1:2019 and ISO/IEC TR 24772-3:2020 C exists in C++. C++, however, provides mechanisms to mitigate the vulnerability. In contrast to C, where the mere existance of reachable memory for an object is sufficient to access it, the lifetime model of C++ makes it <em>undefined behaviour</em> <a href="#EWF">[EWF]</a> to access an object outside of its lifetime See <a href="#lifetime">4.4</a>. This results in undefined behavior when an object access is attempted before one of its constructors is finished or after its destruction. For example, container types like <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> or wrapper types like <code class="sourceCode cpp"><span class="bu">std::</span>optional</code> might have memory for an object available, that is not constructed or has ended its lifetime. For similar situations that result from accessing temporary objects or variables outside of their lifetime see subclause <a href="#DCM">[DCM]</a>. If such a temporary or local object manages heap memory (e.g., <code>std::vector</code>) referring to an element after the manager’s lifetime ended falls into the category of this vulnerability, but is covered there.</p>
<p>C++ provides a rich set of <em>pointer-like</em> types (potentially referring to heap memory) whose values may dangle, e.g.,</p>
<ul>
<li>References (the term value here includes references)</li>
<li>Pointers</li>
<li>Iterators</li>
<li>Views, e.g.,
<ul>
<li><code class="sourceCode cpp"><span class="bu">std::</span>string_view</code></li>
<li><code class="sourceCode cpp"><span class="bu">std::</span>span</code></li>
</ul></li>
<li><code class="sourceCode cpp"><span class="bu">std::</span>reference_wrapper</code>.</li>
</ul>
<p>In addition, a user-defined class type can be a <em>pointer-like</em> type, if a subobject is of <em>pointer-like</em> type and refers to an object (<em>target</em>) whose lifetime is different from and not managed by the current object. Sometimes, regular object types act as <em>pointer-like</em> types, e.g., indices into a container or operating system handles, and their validity can not be directly mapped to the C++ object lifetime model.</p>
<p>If the lifetime of a <em>pointer-like</em> value ends before the lifetime of its <em>target</em>, then the vulnerability does not apply to that <em>pointer-like</em> value. This is the primary C++ strategy for avoiding vulnerabilities of dangling <em>pointer-like</em> values. For example, an object argument passed as a function parameter of reference type persists throughout the function call. The lifetime guarantee of a function argument passed indirectly via a <em>pointer-like</em> type does not apply if * the target is destroyed explicitly by the called function (taking ownership of the target) or a concurrently executing operation, or if * copies of the <em>pointer-like</em> parameter outlive the function call, for example, as the return value, or in a coroutine or thread frame.</p>
<p>For objects directly allocated on the heap C++ provides smart pointers and corresponding factory functions (e.g., <code class="sourceCode cpp"><span class="bu">std::</span>make_unique()</code>) that allow transferring ownership or shared ownership to reduce the risk for dangling. However, storing the raw pointers managed by smart pointers can lead to accidental dangling, for example:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> * f(){</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> up = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">42</span>);</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> up.get(); <span class="co">// returned pointer dangles</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The C++ library containers, such as <code class="sourceCode cpp"><span class="bu">std::</span>vector</code>, manage the required heap memory for their elements. Referring to an element in a container via a <em>pointer-like</em> type is safe, as long as the container remains unchanged while the element object is accessed. In general, accessing an element in a mutated container via a <em>pointer-like</em> value obtained before the mutation is undefined behavior <a href="#EWF">[EWF]</a>. Different containers provide different validity guarantees of accessing an element via a <em>pointer-like</em> type that was obtained before a subsequent change in that container.</p>
<p>Hand-written loops are prone to attempt to access elements of a container that are non-existent, or have been relocated. Employing standard library algorithms to iterate over a range of elements from a container tends to be safer, as long as the underlying container is not accidentally changed. For example, the following code can cause a failure, due to the attempt to iterate over a changing <code class="sourceCode cpp"><span class="bu">std::</span>vector</code>:</p>
<!-- CE: https://godbolt.org/z/qxWad1ox5 -->
<div class="sourceCode" id="cb104"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector v{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>};</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>copy(begin(v),end(v),back_inserter(v)); <span class="co">// modifying v while iterating is undefined behaviour</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>copy(begin(v),end(v), <span class="bu">std::</span>ostream_iterator&lt;<span class="dt">int</span>&gt;(<span class="bu">std::</span>cout,<span class="st">&quot;, &quot;</span>));</span></code></pre></div>
<p>A C++-specific way of causing dangling_references to the heap is by means of a placement new expression (see 7.4 Placement new issues [XXX]).</p>
<h3 id="avoidance-mechanisms-for-language-users">6.14.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.14.5.</p></li>
<li><p>Prefer value types that manage heap memory, for example, <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> or <code class="sourceCode cpp"><span class="bu">std::</span>string</code>, and pass by value/return by value over the use of <em>pointer-like</em> types.</p></li>
<li><p>If value types are not feasible, adopt a style that makes explicit the ownership and lifetime of heap resources, by using <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr</code> or <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr</code> or similar manager types and allocate heap memory exclusively with their corresponding factory functions <code class="sourceCode cpp"><span class="bu">std::</span>make_unique/<span class="bu">std::</span>make_shared</code>.</p></li>
<li><p>Ensure all copies of any <em>pointer-like</em> value are no longer accessible or accessed after the referent’s lifetime ends.</p></li>
<li><p>Prohibit access of a container through an invalidated iterator, and similarly, access via other potentially dangling <em>pointer-like</em> values, e.g., views.</p></li>
<li><p>Avoid unmanaged heap allocation by <code class="sourceCode cpp"><span class="kw">new</span></code>/<code class="sourceCode cpp"><span class="kw">delete</span></code> expressions or calling C-library heap allocation functions.</p></li>
<li><p>Avoid manually ending the lifetime of an non-owned object by explicitly calling its destructor or <code class="sourceCode cpp"><span class="bu">std::</span>destroy_at</code>.</p></li>
<li><p>Use static and dynamic analysis tools to detect dangling.</p></li>
</ul>
<h2 id="FIF">6.15 Arithmetic Wrap-around Error [FIF]</h2>
<h3 id="applicability-to-language">6.15.1 Applicability to language</h3>
<p>C++ has the vulnerability as documented in ISO/IEC 24772-1 clause 6.15, since overflow situations are undefined behaviour <a href="#EWF">[EWF]</a> for signed integer arithemtic and wrap-around for unsigned integer arithmetic, which can lead to surprising results. C++ specifies that</p>
<ul>
<li>although signed integers are defined to be represented as two’s complement, signed integer overflow is undefined behaviour,</li>
<li>unsigned integer arithmetic is defined to wrap-around (modulo arithmetic) and not overflow,</li>
<li>expressions of integral type can implicitly convert to other integral types, even when passed as function arguments,</li>
<li>operands of different arithmetic types in an expression are subject to the implicit “usual arithmetic conversions” that can be confusing, and</li>
<li>integral promotion can change the type of an expression from an unsigned type to a signed type before arithmetic takes place.</li>
</ul>
<p>For example, integral promotion happens when multiplying two <code class="sourceCode cpp"><span class="dt">unsigned</span> <span class="dt">short</span></code> operands which can result in undefined behavior:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f(){</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>uint16_t x{<span class="dv">50&#39;000</span>},y{<span class="dv">50&#39;000</span>};</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x * y; <span class="co">// undefined behaviour due to overflow, returns int</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In the above, for a 16-bit <code>short</code> and a 32-bit <code>int</code>, i.e., <code>std::numeric_limits&lt;int&gt;::max()==0x7fff'ffff</code>, x and y are promoted to <code>int</code> and the multiplication then overflows which is undefined behaviour.</p>
<p>Even when operands have the same unsigned type, wrap-around arithmetic can be confusing, for example, <code>4U - 5U</code> yields a large positive value.</p>
<p>Calling a function taking a parameter of integral type with an argument of different integral type works due to implicit conversions. If a different overload with a better match becomes visible the called function can change when re-compiled (see <a href="#BJL">6.21 Namespace Issues[BJL]</a>)</p>
<p>Using brace-initialization prevents implicit narrowing conversions in contrast to other forms of initialization. For example:</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>uint16_t x{<span class="dv">500&#39;000</span>};  <span class="co">// won&#39;t compile due to narrowing</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>uint16_t y = <span class="dv">500&#39;000</span>; <span class="co">// compiles, but truncates value</span></span></code></pre></div>
<p>The mitigations for wrap-around errors in C++ are different than for C. The type system of C++ allows user-defined class and enum types with corresponding overloaded operators. Such user-defined types can individually control which implicit conversions or mixed type arithmetic they support, if any. For example, one can force arithmetic to be done with unsigned types:</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> uint16: <span class="bu">std::</span>uint16_t{};</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>uint16 <span class="kw">operator</span>*(uint16 a, uint16 b){</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">static_cast</span>&lt;uint16&gt;(<span class="kw">static_cast</span>&lt;<span class="dt">unsigned</span>&gt;(a) * <span class="kw">static_cast</span>&lt;<span class="dt">unsigned</span>&gt;(b));</span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>} <span class="co">// guarantee wrap-around</span></span></code></pre></div>
<p>High-integrity software using the built-in integral types should</p>
<ul>
<li>use integral types with a well-known range (i.e., those from <code class="sourceCode cpp">&lt;cstdint&gt;</code>),</li>
<li>refrain from relying on integral promotion and implicit conversions, and</li>
<li>guarantee that allowed variation in the range of representable values do not influence computed results.</li>
</ul>
<h3 id="avoidance-mechanisms-for-language-users">6.15.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.15.5.</p></li>
<li><p>Use appropriate user-defined types with well-defined range in place of built-in integral types, that mitigate against implicit conversions and undefined behaviour.</p></li>
<li><p>Use types with a well-defined range and have compile-time guarantees that the range of types used is sufficient, i.e., with <code class="sourceCode cpp"><span class="kw">static_assert</span></code>.</p></li>
<li><p>Avoid implicit integral promotions and integral conversions, especially on function arguments.</p></li>
<li><p>Avoid mixing integral types with different size or different signedness in the same expression.</p></li>
<li><p>Ensure that the result of any mathematical operation fits within the constraints of the types involved within the expression.</p></li>
<li><p>Use unsigned types that do not promote to <code class="sourceCode cpp"><span class="dt">int</span></code> to avoid undefined behavior due to signed integer overflow.</p></li>
<li><p>Consider the use of <code class="sourceCode cpp">numeric_limits&lt;T&gt;::is_modulo</code> to determine whether or not an integer type <code class="sourceCode cpp">T</code> wraps for the target system.</p></li>
<li><p>Document where wrap-around is expected for a type.</p></li>
<li><p>Use static and dynamic analysis tools to detect problematic expressions.</p></li>
</ul>
<h2 id="PIK">6.16 Using Shift Operations for Multiplication and Division [PIK]</h2>
<h3 id="applicability-to-language">6.16.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC 24772-1 clause 6.16 exists in C++. C++ complicates the discussion in 24772-1 clause 6.16 as a result of the integral promotion (see clause 6.06 [FLC]). A left-shift on an operand that gets promoted can result in a value outside the operand’s unpromoted type’s range.</p>
<p>Not every use of a shift operator is a bit-shift due to operator overloading.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.16.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li>use the avoidance mechanisms of ISO/IEC TR 24772-1:2019 clause 6.16 *Using Shift Operations for Multiplication and Division [PIK].</li>
<li>For promoted operands, consider converting the result of a shift operation back to the original type of the left hand operand (say using a static cast or an assignment to an object of that type) before using the result in further operations.</li>
</ul>
<h2 id="NAI">6.17 Choice of Clear Names [NAI]</h2>
<h3 id="applicability-to-language">6.17.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.17 is applicable to C++, as it is susceptible to errors resulting from the use of similarly appearing names. However, the language rules prevent using an identifier that has not been declared. There are two possible issues: the use of the identical name for different purposes (see clause <a href="#YOW">6.20 Identifier Name Reuse [YOW]</a>) and the use of similar names for different purposes.</p>
<ul>
<li><em>Mixed casing</em>: C++ distinguishes upper case and lower-case letters in names. Thus, confusion can arise through the use of <code>Item</code> and <code>item</code> as distinct declared identifiers with different meanings.</li>
<li><em>Underscores</em>: C++ permits single underscores in identifiers and they are significant. Thus, <code>BigDog</code> and <code>Big_Dog</code> are different identifiers. Multiple underscores or a leading underscore followed by an upper-case letter cause undefined behaviour <a href="#EWF">[EWF]</a>, thus <code>Big__Dog</code> and <code>_BigDog</code> should not be used.</li>
<li><em>Singular/plural forms</em>: C++ does permit the use of identifiers which differ solely in this manner such as <code>item</code> and <code>items</code>. However, C++ lets the programmer use the identifier <code>item</code> for a single object of a type <code>T</code> and the identifier <code>items</code> for an object denoting a range of items of <code>T</code>. The use of <code>item</code> where <code>items</code> was intended or vice versa usually will be detected by the compiler because of the type mismatch.</li>
<li><em>International character sets</em>: C++ compilers support unicode characters in their source character set and also in identifiers. This can lead to vulnerabilities due to (near) identical representation of distinct names (e.g., homoglyph attacks). Another potential problem is in changing the text direction from left-to-right to right-to-left. This can render code that the compiler accepts, unintelligible, and can be used as an source-code attack vector.</li>
<li>Additionally, in Unicode, the right-to-left character is encoded at U+200F RIGHT-TO-LEFT MARK (‏). In UTF-8 it is E2 80 8F. Usage is prescribed in the Unicode Bidi (bidirectional) Algorithm.[1]</li>
<li><em>Identifier length</em>: The C++ standard recommends compilers to distinguish at least 1024 significant characters for an identifier. The actual limit of compiler for identifier length is implementation-defined and thus must be documented. All characters up to the length supported by the compiler in an identifier in C++ are significant. Thus <code>Long_IdentifierA</code> and <code>Long_IdentifierB</code> are always different if the documented identifier limit is at least 16 characters.</li>
</ul>
<p>C++ permits the use of names such as <code>x</code>, <code>xx</code>, and <code>xxx</code>, possibly defined in non-obvious scopes, and a programmer can easily, by mistake, write <code>xx</code> where <code>x</code> or <code>xxx</code> was intended. Especially for overloaded functions, argument-dependent-lookup might find a function in a scope that the user did not consider. The use of the wrong name will typically result in a failure to compile so no vulnerability will arise. However, if the wrong name has a type compatible with the intended name’s type, then an incorrect executable program will be generated.</p>
<p>C++ defines reserves some names as context-specific keywords. While it is technically possible to use those names for other purposes, such use can be confusing.</p>
<p>In the global scope some namespaces (such as <code>std</code>, <code>posix</code>) are reserved and should not be used otherwise.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.17.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1:2019 clause 6.17.5.</p></li>
<li><p>Follow the rules of ISO/IEC 14882:2020 clause [lex.name] regarding names to refrain from usage.</p></li>
<li><p>Avoid the use of similar names to denote different objects of the same type.</p></li>
<li><p>Use consistency in choosing names, especially for dealing with similar names.</p></li>
<li><p>Use static analysis and tooling to enforce project-specific naming rules and detect possible similar names, for example, homoglyphs and unexpected text-direction vulnerabilities.</p></li>
<li><p>Keep the scope of names as small as reasonable.</p></li>
<li><p>Ensure that the names in your program do not exceed the compiler’s documented limit.</p></li>
<li><p>Do not differentiate names through only a mixture of case or the presence/absence of an underscore character.</p></li>
<li><p>Do not use as identifiers the contextual keywords <code class="sourceCode cpp"><span class="kw">final</span></code> , <code class="sourceCode cpp"><span class="kw">import</span></code>, <code class="sourceCode cpp"><span class="kw">module</span></code> and <code class="sourceCode cpp"><span class="kw">override</span></code> and other reserved names.</p></li>
</ul>
<h2 id="WXQ">6.18 Dead Store [WXQ]</h2>
<h3 id="applicability-to-language">6.18.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 clause 6.18 exists in C++.</p>
<p>The language definition permits the compiler to eliminate effects of the abstract machine that are not observable, in particular, dead stores. For example, the often-attempted write operations to non- volatile member variables in a destructor that are not subsequently used can be elided by the compiler.</p>
<p>C++ compilers and static analysis tools do exist that detect and generate warnings for dead stores.</p>
<p>The error in ISO/IEC 24772-1:2019 subclause 6.18.3 that the planned reader misspells the name of the store is possible but unlikely in C++ since the language specifies that all objects shall be declared and typed, and the existence of two objects with almost identical names and compatible types (for assignment) in the same scope would be readily detectable. See 6.17 [NAI] Choice of clear names, 6.20 Identifier name reuse [YOW], and 6.21 Namespace issues [BJL]</p>
<h3 id="avoidance-mechanisms-for-language-users">6.18.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.18.5.</p></li>
<li><p>Use compilers and static analysis tools to identify dead stores in the program.</p></li>
<li><p>Provide sufficient synchronization to non-const variables that are accessed by multiple execution agents. See clause 6.61 Concurrent data access [CGX]</p></li>
</ul>
<h2 id="YZS">6.19 Unused Variable [YZS]</h2>
<h3 id="applicability-to-language">6.19.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC 24772-1 clause 6.19 exists in C++.</p>
<p>A common practice for resource management in C++ relies on what is called “RAII” or “SBRM” (scope-based resource management): employing a class’ destructor to release resources managed by the object. This can lead to code without visible use of a variable being present in the source code, because all work is done by the variable’s constructor and/or destructor.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.19.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.19.5.</p></li>
<li><p>Use compiler warnings and/or static analysis tools to indicate and eliminate unused variables.</p></li>
</ul>
<h2 id="identifier-name-reuse-yow">6.20 Identifier Name Reuse [YOW]</h2>
<h3 id="applicability-to-language">6.20.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.20 exists in C++, except for the second issue of limited identifier length. In C++ all characters in an identifier are significant.</p>
<p>C++ provides the scope resolution operator <code>::{.cpp}</code> to access identifiers from non-local scopes.</p>
<p>Overloading and specialization of functions is a cornerstone of C++ generic programming. In this context, the reuse of function names is essential. See clause 6.41 for inheritance issues associated with name reuse.</p>
<p>Overloaded function names and operators considered in an expression are not restricted to a simple scope hierarchy, because of argument-dependent lookup (ADL). In generic code the unqualified function or operator selected can come from a scope based on the type of the arguments and not from the current scope hierarchy. The rules for which namespaces are eligible for lookup of unqualified functions and operators are intricate, but required to make overloaded operators work.</p>
<p>In addition, if implicit conversions can happen on arguments, the overload selected by ADL can be different from programmer expectation even in non-generic code, especially when an argument is of a type that can be implicitly converted to another type where a corresponding overload is defined. Visibility on a namespace-level of such an operator overload may make it eligible, even if neither argument matches the parameter types directly. In the best case this leads to a compile error due to ambiguities, but it can also result in perfectly compiling code executing an unexcepted overload.</p>
<p>The following example demonstrates part of the problem:</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;typeinfo&gt;</span></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> Y {</span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print(T i){</span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">typeid</span>(T).name()&lt;&lt; <span class="st">&quot;:&quot;</span> &lt;&lt; i ;</span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> println(T x){</span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a>    print(x); <span class="co">// expects to call Y::print</span></span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout&lt;&lt;<span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb108-14"><a href="#cb108-14" aria-hidden="true" tabindex="-1"></a>} </span>
<span id="cb108-15"><a href="#cb108-15" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> X {</span>
<span id="cb108-16"><a href="#cb108-16" aria-hidden="true" tabindex="-1"></a>   <span class="kw">struct</span> A{</span>
<span id="cb108-17"><a href="#cb108-17" aria-hidden="true" tabindex="-1"></a>        A(<span class="dt">double</span>){}</span>
<span id="cb108-18"><a href="#cb108-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="co">// make this a hidden friend</span></span>
<span id="cb108-19"><a href="#cb108-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ostream &amp; <span class="kw">operator</span> &lt;&lt; (<span class="bu">std::</span>ostream &amp; out, A <span class="at">const</span> &amp;a){</span>
<span id="cb108-20"><a href="#cb108-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> out &lt;&lt; <span class="st">&quot;An A as expected</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb108-21"><a href="#cb108-21" aria-hidden="true" tabindex="-1"></a>        } </span>
<span id="cb108-22"><a href="#cb108-22" aria-hidden="true" tabindex="-1"></a>    };</span>
<span id="cb108-23"><a href="#cb108-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> print(A a){ <span class="co">// not expected to be called by println</span></span>
<span id="cb108-24"><a href="#cb108-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Surprise happens!&quot;</span>;</span>
<span id="cb108-25"><a href="#cb108-25" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb108-26"><a href="#cb108-26" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb108-27"><a href="#cb108-27" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main(){</span>
<span id="cb108-28"><a href="#cb108-28" aria-hidden="true" tabindex="-1"></a>    X::A a{<span class="fl">3.14</span>};</span>
<span id="cb108-29"><a href="#cb108-29" aria-hidden="true" tabindex="-1"></a>    Y::println(<span class="dv">42</span>); <span class="co">// i:42 - calls Y::print</span></span>
<span id="cb108-30"><a href="#cb108-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; a; <span class="co">// An A as expected - calls X::operator&lt;&lt;</span></span>
<span id="cb108-31"><a href="#cb108-31" aria-hidden="true" tabindex="-1"></a>    Y::println(a);  <span class="co">// Surprise happens! - calls X::print</span></span>
<span id="cb108-32"><a href="#cb108-32" aria-hidden="true" tabindex="-1"></a>    Y::println(<span class="dv">42</span><span class="bu">u</span>);<span class="co">// u:42 - calls Y::print</span></span>
<span id="cb108-33"><a href="#cb108-33" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The above code calls the overload <code>print(A)</code> from println since it is pulled in by ADL. On the other hand, ADL is required to work to allow the output operator for type <code>X::A</code> to work.</p>
<p>The consideration of implicit conversions together with ADL can be suppressed by defining operator overloads as class members or as <em>hidden friends</em>. The latter is achieved by declaring all corresponding overloads as <code class="sourceCode cpp"><span class="kw">friend</span></code> functions in the class that take the class’ objects as arguments. Generic base classes can provide mix-in facilities for <em>hidden friends</em> by taking the argument type that is the derived class as template parameter.</p>
<h3 id="avoidance-mechanismsfor-language-users">6.20.2 Avoidance mechanismsfor language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.20.5, with the exclusion of guidance related to truncated identifiers.</p></li>
<li><p>Qualify names to disambiguate potential conflicts between names introduced from different scopes.</p></li>
<li><p>Document argument-dependent lookup usage where name qualification is not desirable.</p></li>
<li><p>Limit the visibility of overloaded operators or functions for class types by defining them as member functions or <em>hidden friends</em>.</p></li>
<li><p>Place overloaded operators that are not class members and cannot be provided as <em>hidden friends</em> together with their argument type in a namespace that is not the global namespace,so that they are picked up by ADL.</p></li>
<li><p>Use modern integrated development environments that inform about the declaration of any identifier occurrence.</p></li>
<li><p>Enable compiler diagnostics that inform about the hiding of declarations.</p>
<ul>
<li><pre><code>  DCL60-CPP. Obey the one-definition</code></pre>
<p>rule (6.21)</p></li>
<li><pre><code>  DCL40-C. Do not create incompatible declarations of the same</code></pre>
<p>function or object (6.21)</p></li>
</ul></li>
</ul>
<h2 id="BJL">6.21 Namespace Issues [BJL]</h2>
<h3 id="applicability-to-language">6.21.1 Applicability to language</h3>
<p>The vulnerability described in ISO/IEC TR 24772-1:2019 clause 6.21 exists in C++. It can occur in particular when a used library changes its API. The situations where it exists are related to the following cases:</p>
<ul>
<li>Template specialization, where clause 6.40 [#SYM] applies;</li>
<li>Overloading, where clause 6.20 [#YOW] applies;</li>
<li>Overriding, where clause 6.41 [#RIP] applies.</li>
</ul>
<p>In the case of template specialization or non-identical definitions of the same entity in different translation units (ODR-violation), ill-formed code might be the result, however, a C++ compiler is not obliged to diagnose that situation, leading to undefined behaviour <a href="#EWF">[EWF]</a>.</p>
<p>In the case of overloading and overriding cases, C++ compilers are required to diagnose an ambiguity if it exists.</p>
<p>However, overload resolution applies preference rules in order to select among multiple matching functions or function templates as a means to resolve the ambiguity among these functions. Hence, for calls that are not perfect matches, the user cannot guarantee in the presence of later changes which function is called, as another, better match can be introduced subsequently. The call in question then changes its binding without warning upon its next compilation. For cases, where the preference rules do not resolve the ambiguity, the resulting error message by the compiler avoids the vulnerability. Function template specializations are not considered during overload resolution, only the base template is considered.</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo (<span class="dt">long</span>);</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a><span class="co">// void foo (int);</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar ()</span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>  foo (<span class="dv">0</span>);         <span class="co">// The call to &#39;foo(long)&#39; requires implicitly conversion</span></span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a>                   <span class="co">// from &#39;int&#39; to &#39;long&#39;.   The function &#39;foo(int)&#39; </span></span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a>                   <span class="co">// would be a &quot;better match&quot; and so would silently</span></span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true" tabindex="-1"></a>                   <span class="co">// be chosen when subsequently introduced</span></span>
<span id="cb111-11"><a href="#cb111-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>A new declaration can impact existing code in a number of situations involving the addition of:</p>
<ul>
<li>an overload,</li>
<li>a using directive,</li>
<li>a declaration into a namespace that is searched as part of “Argument-Dependent Lookup”,</li>
<li>a non-template function that is preferred to a function template,</li>
<li>a template specialization.</li>
</ul>
<p>A <code class="sourceCode cpp"><span class="kw">using</span></code> directive broadens the possible scopes that will be examined for names during lookup. Where lookup searches a namespace referred to by a <code class="sourceCode cpp"><span class="kw">using</span></code> directive, all names in that namespace will be visible some of which may be unwanted. A using declaration, on the other hand, declares only the specified name into the scope of the <code class="sourceCode cpp"><span class="kw">using</span></code> declaration.</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> NS1</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f1 (<span class="dt">int</span>);</span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f2 (<span class="dt">int</span>);        <span class="co">// Added later</span></span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> NS2</span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> <span class="kw">namespace</span> NS1;  <span class="co">// &#39;f1&#39; needed</span></span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f2 (<span class="dt">long</span>);</span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> bar ()</span>
<span id="cb112-11"><a href="#cb112-11" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb112-12"><a href="#cb112-12" aria-hidden="true" tabindex="-1"></a>    f1(<span class="dv">0</span>);              <span class="co">// Calls &#39;NS1::f1&#39;</span></span>
<span id="cb112-13"><a href="#cb112-13" aria-hidden="true" tabindex="-1"></a>    f2(<span class="dv">0</span>);              <span class="co">// Unintentionally calls &#39;NS1::f2&#39;</span></span>
<span id="cb112-14"><a href="#cb112-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb112-15"><a href="#cb112-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb112-16"><a href="#cb112-16" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> NS3</span>
<span id="cb112-17"><a href="#cb112-17" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb112-18"><a href="#cb112-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> NS1::f1;        <span class="co">// &#39;f1&#39; needed</span></span>
<span id="cb112-19"><a href="#cb112-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f2 (<span class="dt">long</span>);</span>
<span id="cb112-20"><a href="#cb112-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> bar ()</span>
<span id="cb112-21"><a href="#cb112-21" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb112-22"><a href="#cb112-22" aria-hidden="true" tabindex="-1"></a>    f1(<span class="dv">0</span>);              <span class="co">// Calls &#39;NS1::f1&#39;</span></span>
<span id="cb112-23"><a href="#cb112-23" aria-hidden="true" tabindex="-1"></a>    f2(<span class="dv">0</span>);              <span class="co">// Calls &#39;NS3::f2&#39; as expected</span></span>
<span id="cb112-24"><a href="#cb112-24" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb112-25"><a href="#cb112-25" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<!-- from 6.40: -->
<p>Overload resolution only considers conversions for the explicitly specified arguments and does not take default parameters into account:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">short</span>, <span class="dt">int</span> = <span class="dv">0</span>);</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">int</span>, <span class="dt">short</span> = <span class="dv">0</span>);</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f2 ()</span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>);       <span class="co">// calls &#39;f1(1, 0)&#39; as &#39;1 -&gt; int&#39; is better match than &#39;1 -&gt; short&#39;</span></span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>, <span class="dv">0</span>);    <span class="co">// ambiguous, ill-formed, won&#39;t compile</span></span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The following example demonstrates a situation where the late addition of a better matching overload causes a silent change in the semantics of an existing program.</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> NS</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> A</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>  };</span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt; T foo ( T t )</span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> t;</span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> NS2 <span class="co">// separately developed and included from a header file</span></span>
<span id="cb114-14"><a href="#cb114-14" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb114-15"><a href="#cb114-15" aria-hidden="true" tabindex="-1"></a>   <span class="kw">struct</span> B</span>
<span id="cb114-16"><a href="#cb114-16" aria-hidden="true" tabindex="-1"></a>   {</span>
<span id="cb114-17"><a href="#cb114-17" aria-hidden="true" tabindex="-1"></a>   };</span>
<span id="cb114-18"><a href="#cb114-18" aria-hidden="true" tabindex="-1"></a><span class="co">// This code will be added later</span></span>
<span id="cb114-19"><a href="#cb114-19" aria-hidden="true" tabindex="-1"></a><span class="co">//  template &lt; typename T &gt; T * foo ( T * t )</span></span>
<span id="cb114-20"><a href="#cb114-20" aria-hidden="true" tabindex="-1"></a><span class="co">//  {</span></span>
<span id="cb114-21"><a href="#cb114-21" aria-hidden="true" tabindex="-1"></a><span class="co">//    return t;</span></span>
<span id="cb114-22"><a href="#cb114-22" aria-hidden="true" tabindex="-1"></a><span class="co">//  }</span></span>
<span id="cb114-23"><a href="#cb114-23" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb114-24"><a href="#cb114-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-25"><a href="#cb114-25" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> NS2;</span>
<span id="cb114-26"><a href="#cb114-26" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> NS;</span>
<span id="cb114-27"><a href="#cb114-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-28"><a href="#cb114-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar()</span>
<span id="cb114-29"><a href="#cb114-29" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb114-30"><a href="#cb114-30" aria-hidden="true" tabindex="-1"></a>  A * a;</span>
<span id="cb114-31"><a href="#cb114-31" aria-hidden="true" tabindex="-1"></a>  B * b;</span>
<span id="cb114-32"><a href="#cb114-32" aria-hidden="true" tabindex="-1"></a>  foo (a); <span class="co">// After the commented-out code is added to NS2, the binding of foo changes silently from NS::foo to NS2::foo</span></span>
<span id="cb114-33"><a href="#cb114-33" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>This issue can be avoided by avoiding <code>using namespace xxx{.cpp}</code> and explicitly qualifying each call, such as <code>NS::foo(a){.cpp}</code>.</p>
<p>Analogously, when a more specialized template is added to an imported namespace where the more general template has already been provided in another namespace, preference rules will silently prefer the more specialized template.</p>
<p>A similar situation can occur when a conflict arises between compiler-synthesized or rewritten operators and explicitly created versions of those operators, as in the following example.</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span>==(A <span class="at">const</span> &amp;) <span class="at">const</span> { <span class="cf">return</span> <span class="kw">true</span>; }   </span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Evil hijacking of !=</span></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a><span class="co">// bool operator != (A const &amp;, A const &amp;) { return true; } // #1</span></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar (A <span class="at">const</span> &amp; a) {</span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a>  a != a;                                                    <span class="co">// #2</span></span>
<span id="cb115-11"><a href="#cb115-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In the above example, the declaration of <code class="sourceCode cpp"><span class="kw">operator</span>==</code> will have a corresponding synthesised <code class="sourceCode cpp"><span class="kw">operator</span>!=</code> generated by the compiler, since there is no suitable user-declared <code class="sourceCode cpp">!=</code>. If the <code class="sourceCode cpp"><span class="kw">operator</span>!=</code> becomes visible, then the code at #2 uses the user-declared <code class="sourceCode cpp"><span class="kw">operator</span>!=</code> instead of the synthesized one, which can lead to a silent and unexpected change of behaviour. This is particularly risky when the operator is declared outside of the immediate visibility of the original definition.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.21.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of clauses 6.20.2, 6.40.2, and 6.41.2 as applicable.</p></li>
<li><p>Consider using fully qualified names for calls that rely on an implicit conversions.</p></li>
<li><p>Arguments to called functions should not be subject to implicit conversions.</p></li>
<li><p>Prefer using declarations to using directives.</p></li>
<li><p>Do not overload and use default arguments for the same set of functions.</p></li>
<li><p>Do not specialize function templates.</p></li>
<li><p>For template specialization, ensure that specializations are declared as follows:</p>
<ol type="1">
<li><p>In the same file as the primary template; or</p></li>
<li><p>In the same file as the user-defined type for which the specialization is declared.</p></li>
</ol></li>
<li><p>Define an entity in only one file to prevent ODR-violations.</p></li>
<li><p>Ensure that no ODR-violations occur, i.e., through a static analysis tool.</p></li>
<li><p>Use a version-aware analysis tool to identify situations where preference rules cause a silent change of name binding between versions.</p></li>
<li><p>Only declare equaility or relational operators as member functions or friend functions of the class</p></li>
</ul>
<h2 id="LAV">6.22 Missing Initialization of Variables [LAV]</h2>
<h3 id="applicability-to-language">6.22.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 exists in C++, however, defining variables only when they can be initialized properly with an initializer in their definition avoids reading uninitialized memory.</p>
<p>Defining/allocating objects of trivial type with automatic/dynamic storage duration without initialization leaves the object with an indeterminate value. A subsequent read of such a variable before it has been written is undefined behavior <a href="#EWF">[EWF]</a>. In addition, sub-objects of trivial type that are omitted in a constructor’s member initializer list and not initialized by the constructor’s body or by a <em>default member initializer</em> will not be initialized by that constructor. For example, the following class definitions suffer from incomplete initialization of subobjects, even though class <code>test</code> defines a default constructor:</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> base { <span class="dt">short</span> num; };                                                     </span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> test : base                                                              </span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>{                                                                               </span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">enum</span> E1 { e1a=<span class="dv">100</span>, e1b, e1c };                                                </span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> one; </span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> two; </span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> ar1[<span class="dv">2</span>]{ <span class="fl">1.1</span>, <span class="fl">2.2</span> }; </span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> ar2[<span class="dv">2</span>]; </span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a>  E1 e1; </span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a>  E1 e2;                 </span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a>  test() </span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true" tabindex="-1"></a>  : <span class="co">// base unintialized </span></span>
<span id="cb116-13"><a href="#cb116-13" aria-hidden="true" tabindex="-1"></a>  one{ <span class="dv">1</span> }</span>
<span id="cb116-14"><a href="#cb116-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// two uninitialized</span></span>
<span id="cb116-15"><a href="#cb116-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ar1 initialized through default member initializer</span></span>
<span id="cb116-16"><a href="#cb116-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ar2 uninitialized</span></span>
<span id="cb116-17"><a href="#cb116-17" aria-hidden="true" tabindex="-1"></a>  , e1{} <span class="co">// initializes to zero, not a named enumerator value </span></span>
<span id="cb116-18"><a href="#cb116-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">// e2 uninitialized</span></span>
<span id="cb116-19"><a href="#cb116-19" aria-hidden="true" tabindex="-1"></a>  { }                                  </span>
<span id="cb116-20"><a href="#cb116-20" aria-hidden="true" tabindex="-1"></a>};                                                                              </span></code></pre></div>
<p>Dynamically allocating memory for an object using <code class="sourceCode cpp">malloc</code>, or some other C-style equivalent, does not initialize the object. Interpreting such memory as an object with trivial type will result in it having an indeterminate value.<br />
An object with non-trivial type requires running a constructor for its lifetime to start correctly (see <a href="#lifetime">4.4</a>). Attempting to cast a pointer to allocated memory and using it as an object that is not implicitly defined is undefined behavior except for special sanctioned cases, see <a href="#FLC">Conversion Errors [FLC]</a> and <a href="#HFC">Pointer Type Conversion [HFC]</a>.</p>
<p>Non-local variables with static storage duration that are dynamically initialized can cause undefined behavior if the initialization depends on other such variables. If the dependency is in the same translation unit the sequencing is defined in definition order, however, the order of initialization across translation unit boundaries is unspecified, and thus undefined behaviour can occur by accessing an uninitialized variable. For example:</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A {</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>  A (<span class="dt">int</span> i ) : <span class="va">i_</span> { i }  {  }</span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> <span class="va">i_</span>;</span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> B {</span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a>  B (A <span class="at">const</span> &amp; a) : <span class="va">j_</span>{a.<span class="va">i_</span>} { }</span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> <span class="va">j_</span>;</span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb117-9"><a href="#cb117-9" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> A a;  <span class="co">// declare existance of variable &#39;a&#39;</span></span>
<span id="cb117-10"><a href="#cb117-10" aria-hidden="true" tabindex="-1"></a><span class="co">// defining variables with dynamic intialization:</span></span>
<span id="cb117-11"><a href="#cb117-11" aria-hidden="true" tabindex="-1"></a>B b { a };   <span class="co">//  #1</span></span>
<span id="cb117-12"><a href="#cb117-12" aria-hidden="true" tabindex="-1"></a>A a { <span class="dv">42</span> };  <span class="co">//  #2</span></span></code></pre></div>
<p>If #1 and #2 are in the same translation unit, then <code>a</code> in #1 is incompletely initialized (zero initialized). If #1 and #2 are in different translation units, then the order of initialization of <code>a</code>(#2) relative to <code>b</code>(#1) is indeterminate.</p>
<p>The <code>constexpr</code>-specifier for a variable ensures initialization at compile time. The <code class="sourceCode cpp"><span class="kw">constinit</span></code> specifier ensures a variable is initialized at compile time, even if it is non-const.</p>
<p>Defining non-member variables as <code class="sourceCode cpp"><span class="at">const</span></code> or as <code class="sourceCode cpp"><span class="kw">constexpr</span></code>, enforces initialization by the compiler and makes reasoning about code easier.</p>
<p>If determining the initial value of a variable requires complex logic, putting that logic into an immediately-invoked lambda expression that computes the initial value, permits the variable to be initialized when defined.</p>
<!--
In addition some of the rules of initialization in C++ are complicated.  For example, there are the 
following initialization cases:
- no initialization (see above),
- zero-initialization,
- value-initialization,
- default-initialization,
- list initialization,
- aggregate inialization,
- member initialization,
- base-class initialization,
- constant initialization (`constexpr`{.cpp} and `constinit`{.cpp}),
- static initialization,
- dynamic initialization, 
- etc...
-->
<p>See C++ Core Guidelines ES.20 and CERT C++ Coding Guidelines EXP53-CPP. Note that ES.20 and EXP53 are complementary. Both point out that you should always initialize before reading, but ES.20 uses the narrow sense of initialize while EXP53 includes assignment.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.22.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li>Use the avoidance mechanisms of ISO/IEC 24772-1 subclause 6.22.5</li>
<li>Initialize every object defined, including data members, such as by providing an initializer for each variable definition.</li>
<li>Consider defining non-member variables as <code class="sourceCode cpp"><span class="at">const</span></code> to enforce initialization, otherwise defer the definition of the variable until a sensible initial value can be provided.</li>
<li>In situations where variable initialization seems to require complex logic, encapsulate that logic either in a function or a lambda that encapsulates the complex logic and returns the initial value. In case of multiple interdependent variables, group those in a struct and return the struct.</li>
<li>Avoid using non-const variables with static storage duration (see <span id="CGX">6.61 Concurrent Data Access [CGX]</span>).</li>
<li>Define variables with static storage duration with <code class="sourceCode cpp"><span class="kw">constexpr</span></code> or <code class="sourceCode cpp"><span class="kw">constinit</span></code> whenever possible to avoid problems with dynamic initialization order.</li>
<li>Do not depend on the order of dynamic initialization of non-local variables with static storage duration, unless the initialization order is guaranteed by the language.</li>
<li>If the use of uninitialized variables is unavoidable, employ tools, including the compiler, that detect reads of variables with indeterminate values.</li>
</ul>
<h2 id="operator-precedence-and-associativity-jcw">6.23 Operator Precedence and Associativity [JCW]</h2>
<h3 id="applicability-to-language">Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.23 is applicable to C++.</p>
<p>Operator precedence and associativity in C++ are determined by the C++ grammar. There are four operators that cannot be overloaded (user-defined):</p>
<ul>
<li><p><code class="sourceCode cpp">::</code> ;</p></li>
<li><p><code class="sourceCode cpp">.</code> ;</p></li>
<li><p><code class="sourceCode cpp">.*</code> ; and</p></li>
<li><p><code class="sourceCode cpp">?:</code> .</p></li>
</ul>
<p>Due to the large number of operators, one is recommended to consult an operator precedence table when needed, e.g., <a href="https://en.cppreference.com/w/cpp/language/operator_precedence">[https://en.cppreference.com/w/cpp/language/operator_precedence]</a>. For example, in C++, the bitwise logical and shift operators are sometimes incorrectly treated as having the same precedence as arithmetic operations even though the bitwise operators have lower precedence. For example, the following (correct) expression subtracts one from <code class="sourceCode cpp">x</code> and then checks if the result is zero:</p>
<p><code class="sourceCode cpp">x - <span class="dv">1</span> == <span class="dv">0</span></code></p>
<p>which is equivalent to <code class="sourceCode cpp">(x - <span class="dv">1</span>) == <span class="dv">0</span></code>,i.e., <code class="sourceCode cpp">x - <span class="dv">1</span></code> is done first, then that result is compared to <code class="sourceCode cpp"><span class="dv">0</span></code>. Programmers mistakenly thinking the bitwise operations have the same precedence as arithmetic ones might write:</p>
<p><code class="sourceCode cpp">x &amp; <span class="dv">1</span> == <span class="dv">0</span></code></p>
<p>intending to perform <code class="sourceCode cpp">(x &amp; <span class="dv">1</span>) == <span class="dv">0</span></code>, but precedence rules result in this evaluating <code class="sourceCode cpp">x &amp; (<span class="dv">1</span> == <span class="dv">0</span>)</code> instead. This would have been easily fixed by using parenthesis to ensure the proper evaluation of an expression.</p>
<p>In addition to the aforementioned, C++ also permits operators to be overloaded when used with user-defined types. While it is not possible to change the precedence, associativity, and number of operands of overloaded operators [C++17, Clause 16.5 [over.oper], para. 6], overloaded operators can be executed differently than built-in operators. For example, overloaded operators lose any built-in operator short-circuiting properties and sequence order guarantees. Similarly overloaded operators and their arguments' evaluations behave as normal function calls, differing from built-in operator evaluation.</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A {  };</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span>&amp;&amp;(A <span class="at">const</span> &amp;, <span class="dt">int</span>);</span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> foo ();</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar (A <span class="at">const</span> &amp; a)</span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (a     &amp;&amp; foo());  <span class="co">// &#39;foo()&#39; always evaluated</span></span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="kw">false</span> &amp;&amp; foo());  <span class="co">// &#39;foo()&#39; never evaluated</span></span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (a.<span class="kw">operator</span>&amp;&amp; (<span class="kw">false</span>,foo())); <span class="co">// &#39;foo()&#39; always evaluated</span></span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Note that overloaded assignment falls into this category.</p>
<p>For issues related to the declaration of equality and relational operators see Clause 6.25 [KOA].</p>
<h3 id="avoidance-mechanisms-for-language-users">6.23.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 Clause 6.23.5 [JCW].</p></li>
<li><p>Enable all C++ compiler/tool warnings and static analysis tool diagnostics concerning possible issues with precedence and associativity to help detect and avoid mistakes.</p></li>
<li><p>Even if technically unnecessary, use parentheses around operator (sub)expressions that are known to be or felt likely to be sources of error.</p></li>
<li><p>Avoid overloading the following operators <code class="sourceCode cpp">&amp;&amp;</code>, <code class="sourceCode cpp">||</code>, <code class="sourceCode cpp">,</code> and their alternative spellings.</p></li>
<li><p>Break up complex expressions and use temporary variables to make complex expressions easier to understand and maintain.</p></li>
</ul>
<h2 id="side-effects-and-order-of-evaluation-of-operands-sam">6.24 Side-effects and Order of Evaluation of Operands [SAM]</h2>
<h3 id="applicability-to-language">6.24.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.24 exists in C++.</p>
<p>The evaluation of an expression includes: (i) its value computation; and (ii) its side-effects. The value computation is the value returned by the expression, e.g., the valuation of <code>3 * 2 + 1</code> is <code>7</code>. The side-effect of an expression are</p>
<ul>
<li>Write accesses to objects in that expression,</li>
<li>Reading a volatile object,</li>
<li>Calling a library I/O function, and</li>
<li>Calling a function that does any of the above.</li>
</ul>
<p>For example consider:</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i = <span class="dv">2</span>;</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> j = i++;</span></code></pre></div>
<p>the evaluation of i++ is 2 and the side-effects are the writing of 3 to i and the initialization of j.</p>
<p>Within an expression, one must ensure an object is stored only once to avoid undefined behaviour <a href="#EWF">[EWF]</a>, e.g.,</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>i = i++ + <span class="dv">5</span>; <span class="co">// undefined behaviour (before C++17)</span></span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>k = i++ + i\--; <span class="co">// undefined behaviour in all versions of C++</span></span></code></pre></div>
<p>and expressions modifying objects can only read the object to determine the value to be stored (e.g., ++i requires reading the value), i.e., other accesses are undefined behaviour, e.g.,</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>my_array\[i\] = i++; <span class="co">// undefined behaviour (before C++17)</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>Starting with C++<span class="dv">17</span>, the evaluation order of an expression involving</span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>overloaded operators preserves the sequenced before behaviour of the</span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>built-in <span class="kw">operator</span>:</span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a><span class="er">```</span>{.cpp}</span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a>my_array[i] = i++;</span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a>my_array[i++] = i++;</span></code></pre></div>
<p>say <code class="sourceCode cpp">i = <span class="dv">10</span></code> before the expression</p>
<p>evaluate RHS <code>i++</code> – <code>i</code> is <code>11</code></p>
<p>evaluate <code>my_array[i++]</code> //evaluates <code>my_array\[11\]</code>, then assigns <code>i</code> to <code>12</code></p>
<p><code>my_array[11]</code> is assigned <code>10</code></p>
<p>This occurs because assignment is sequenced after the value computation of the right and left operands and before the value computation of the assignment expression and, the right operand is sequenced before the left operand. [C++17, Clause 8.18 [expr.ass], para. 1] Since this is the built-in operator, this statement can be thought of as:</p>
<blockquote>
<p>Compute value of right-hand-side: <code>i++</code> (e.g., integer value).</p>
<p>Compute value of left-hand-side: <code>my_array[i]</code> (e.g., memory address).</p>
<p>Apply side-effects of <code>i++</code>.</p>
<p>Apply side-effects of the assignment.</p>
</blockquote>
<p>In general, one should follow commonly-stated C/C++ advice of never reading from and writing to the same object within an expression to avoid potential vulnerabilities. Often breaking the expression into separate statements achieves clear and clean semantics, e.g.,</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>++i;</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>my_array[i] = i;</span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>my_array[i] = i;</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>++i;</span></code></pre></div>
<p>makes it unambiguous what the value of i is during the array assignment and eliminates the possibility of vulnerabilities.</p>
<p>In addition, it is important to note that overloading an operator disables short-circuiting behaviours (e.g., built-in boolean operators): those operators' operands are all evaluated before the operator itself. Similarly, overloading the comma operator disable the guaranteed order of evaluation.</p>
<p>The C++ built-in (two-argument) Boolean operators (e.g., <code class="sourceCode cpp">&amp;&amp;</code> and <code class="sourceCode cpp">\|\|</code>) are short-circuiting, i.e., if the value of an earlier (from left-to-right) operand of an operation determines the result of the operation, then all remaining arguments are not evaluated.</p>
<p>Typically this allows one to write code like this, e.g.,</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> *p;</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (p != <span class="kw">nullptr</span> &amp;&amp; *p != <span class="dv">0</span>) {</span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* do something */</span></span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>i.e., if <code class="sourceCode cpp">p</code> is <code class="sourceCode cpp"><span class="kw">nullptr</span></code>, then <code class="sourceCode cpp">*p != <span class="dv">0</span></code> is never executed, thus, avoiding undefined behaviour. Only when <code>p</code> is not <code class="sourceCode cpp"><span class="kw">nullptr</span></code> is *p != 0 is evaluated. It must be stressed that this only applies to the built-in <code class="sourceCode cpp">&amp;&amp;</code> and <code>||</code> operators: user-defined operator overloads as functions always evaluate all operands first.</p>
<p>Consequently should one want to always evaluate all operands of a boolean expression, one should not write code like this:</p>
<p><code class="sourceCode cpp"><span class="dt">bool</span> x = foo() &amp;&amp; bar();</code></p>
<p>where <code>foo()</code> and <code>bar()</code> are functions that return something convertible to <code>bool</code>. In this expression, if <code>foo()</code> returns <code class="sourceCode cpp"><span class="kw">false</span></code>, then <code>bar()</code> will never be executed; –only when <code>foo()</code> returns <code class="sourceCode cpp"><span class="kw">true</span></code> will <code>bar()</code> be executed. Similarly for <code>||</code>:</p>
<p><code class="sourceCode cpp"><span class="dt">bool</span> y = foo() || bar();</code></p>
<p>i.e., only when <code class="sourceCode cpp">foo()</code> returns <code class="sourceCode cpp"><span class="kw">false</span></code> will <code class="sourceCode cpp">bar()</code> be executed if <code class="sourceCode cpp">foo()</code> returns <code class="sourceCode cpp"><span class="kw">true</span></code> then <code class="sourceCode cpp">bar()</code> will never be executed. Thus, if both <code class="sourceCode cpp">foo()</code> and <code class="sourceCode cpp">bar()</code> are both required to be executed, then execute them in separate statements first, e.g.,</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> foo_result = foo();</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> bar_result = bar();</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> x = foo_result &amp;&amp; bar_result;</span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> y = foo_result \|\| bar_result;</span></code></pre></div>
<p>The built-in comma operator evaluates its expressions left to right and sequences the left expression before the right. This is not the case for an overloaded comma operator, which follows the rule for a function call.</p>
<p>The order of evaluation of function arguments in C++ is unspecified. Therefore, a side-effect in one argument position can change the result of a different argument, for example:</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i = <span class="dv">0</span>;</span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> get() {<span class="cf">return</span> i;}</span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo(<span class="dt">int</span> A, <span class="dt">int</span> B);</span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar () {  </span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a>  foo (get(), ++i);  </span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In the above example, inside foo, the value of the <code class="sourceCode cpp">A</code> can be 0 or 1 depending upon which argument is evaluated first. This can be avoided if the call to <code class="sourceCode cpp">get</code> or the increment of <code class="sourceCode cpp">i</code> is made before the call to <code class="sourceCode cpp">foo</code>, i.e. forcing the order of evaluation.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.24.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.24.5.</p></li>
<li><p>Write expressions so that the same effects will occur under any order of evaluation that C++ permits since side effects can be dependent on an implementation specific order of evaluation.</p></li>
<li><p>Avoid overloading logical operators (&amp;&amp; and ||), as these overloaded versions will not short-circuit.</p></li>
<li><p>Avoid overloading the comma operator, as the overloaded version has unspecified order of evaluation of its arguments.</p></li>
<li><p>Ensure that the <code class="sourceCode cpp">++, \--, <span class="er">@</span>=</code> operators are used as solitary items in a statement.</p></li>
<li><p>Be aware to which C++ standard a compiler is compiling code against. This determines the semantics of all operator (overloaded and built-in) expressions.</p></li>
<li><p>Avoid placing multiple operations with side effects in a single expression.</p></li>
<li><p>Write simple code expressions and statements so that within any expression or statement an object is one of:</p>
<ul>
<li><pre><code>  Read from;</code></pre></li>
<li><pre><code>  Only modified once; or</code></pre></li>
<li><pre><code>  Only read and modified by: a single increment; a single</code></pre>
decrement; a single simple assignment; or a single compound assignment.</li>
</ul></li>
<li><p>Be aware that different versions of C++ have different evaluation order specifications and program accordingly.</p></li>
</ul>
<h2 id="KOA">6.25 Likely Incorrect Expression [KOA]</h2>
<h3 id="applicability-to-language">6.25.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.25 exists in C++.</p>
<p>C++ has several instances of operators which are similar in structure, but different in meaning. Examples of operators in C-based languages that can cause confusion are:</p>
<ul>
<li><code class="sourceCode cpp">==</code> and <code class="sourceCode cpp">=</code>;</li>
<li><code class="sourceCode cpp">&amp;&amp;</code> and <code class="sourceCode cpp">&amp;</code>;</li>
<li><code class="sourceCode cpp">||</code> and <code class="sourceCode cpp">|</code>;</li>
<li><code class="sourceCode cpp">&lt;</code>, <code class="sourceCode cpp">&lt;&lt;</code>, and <code class="sourceCode cpp">&lt;&lt;=</code>; and</li>
<li><code class="sourceCode cpp">&gt;</code>, <code class="sourceCode cpp">&gt;&gt;</code>, and <code class="sourceCode cpp">&gt;&gt;=</code>.</li>
</ul>
<p>The typographical similarity can lead to code like the following, where it is unclear if the expression as spelled is actually intended, or if the author has typos in it, meaning a different operator instead:</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f(<span class="dt">unsigned</span> i, <span class="dt">unsigned</span> j)</span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (i &gt; <span class="dv">1</span>) &amp; (j = <span class="dv">1</span>); <span class="co">// (&gt;&gt;, &amp;&amp;, ==)?</span></span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The following code in a production phone OS caused the “bricking” of many users phones:</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="va">key_data_</span>.has_value() &amp; !<span class="va">key_data_</span>-&gt;label().empty())</span></code></pre></div>
<p>instead of</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="va">key_data_</span>.has_value() &amp;&amp; !<span class="va">key_data_</span>-&gt;label().empty())</span></code></pre></div>
<p>or the even clearer using the alternative operator representation <code class="sourceCode cpp"><span class="kw">and</span></code> for <code class="sourceCode cpp">&amp;&amp;</code></p>
<div class="sourceCode" id="cb134"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="va">key_data_</span>.has_value() <span class="kw">and</span> !<span class="va">key_data_</span>-&gt;label().empty())</span></code></pre></div>
<p>As a general rule, the use of <code>=</code>, <code>+=</code>, <code>-=</code> in an expression when the operator is not the final assignment to a variable is unsafe since the assignment operator creates side-effects within the expression which are difficult to analyze by a human reader and can be have different results depending upon the order of evaluation of terms within the expression.</p>
<p>But even in assignment expression flipping the assignment symbol with the operator can itself lead to valid code that was not intended:</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i{<span class="dv">42</span>};</span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>i += <span class="dv">22</span>; <span class="co">// i becomes 64</span></span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a>i =+ <span class="dv">22</span>; <span class="co">// i becomes 22</span></span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a>i =- <span class="dv">22</span>; <span class="co">// i becomes -22</span></span></code></pre></div>
<p>C++ provides significant freedom in constructing statements. This freedom, if misused, can result in unexpected results and potential vulnerabilities.</p>
<p>Since the order of evaluation within expressions is only partially defined, sub-expressions with side effects on variables used within the overall expression can result in undefined behaviour <a href="#EWF">[EWF]</a>.</p>
<p>The flexibility of C++ can obscure the intent of a programmer. Consider:</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x,y;</span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a><span class="co">/* ... */</span></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (x = y){</span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* ... */</span></span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>A fair amount of analysis may need to be done to determine whether the programmer intended to do an assignment as part of the <code class="sourceCode cpp"><span class="cf">if</span></code> statement (valid in C++) or whether the programmer made the common mistake of using an <code class="sourceCode cpp">=</code> (assignment) instead of a <code class="sourceCode cpp">==</code> (equality).</p>
<p>This confusion can be corrected by moving assignments outside of Boolean contexts. This would change the example code to:</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x,y;</span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a><span class="co">/* … */</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>x = y;</span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (x == <span class="dv">0</span>) {</span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* ... */</span></span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>This would clearly state what the programmer meant and that the assignment of y to x was intended.</p>
<p>Additional confusion occurs in the use of the logical <code class="sourceCode cpp">&amp;&amp;</code> or <code class="sourceCode cpp">||</code> operators and the bitwise <code class="sourceCode cpp">&amp;</code> or <code class="sourceCode cpp">|</code> operators. The compiler will implicitly convert arithmetic expressions to <code class="sourceCode cpp"><span class="dt">bool</span></code> for operands of the logical operators. Similarly, operands of <code class="sourceCode cpp"><span class="dt">bool</span></code> type will be promoted to <code class="sourceCode cpp"><span class="dt">int</span></code> for operands of the bitwise operators (see <a href="#FLC">Conversion Errors [FLC]</a>).<br />
It may not be clear whether the programmer intended to use the logical operator <code class="sourceCode cpp">&amp;&amp;</code> or bitwise operator <code class="sourceCode cpp">&amp;</code> instead:</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> f(<span class="dt">unsigned</span> i, <span class="dt">unsigned</span> j)</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (i &gt; <span class="dv">0</span>) &amp; j;</span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Using the alternative tokens <code class="sourceCode cpp"><span class="kw">and</span></code> / <code class="sourceCode cpp"><span class="kw">or</span></code> in lieu of <code class="sourceCode cpp">&amp;&amp;</code> and <code class="sourceCode cpp">||</code> reduces the possibility of confusion. Similarly, <code>a not_eq b</code> is preferable to <code>a != b</code> since the latter is easily confused with the equally valid expression <code>a |= b</code>.</p>
<p>Programmers can easily get in the habit of inserting the <code class="sourceCode cpp">;</code> statement terminator at the end of statements. However, inadvertently doing this can drastically alter the meaning of code, even though the code is valid as in the following example:</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a,b;</span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* … */</span></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (a == b);  <span class="co">// the semi-colon will make the following code always execute</span></span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a>    {             </span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* ... */</span></span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>Because of the misplaced semi-colon, the code block following the if will always be executed. In this case, it is extremely likely that the programmer did not intend to put the semi-colon there.</p>
<p>Unary ‘<code>+</code>’{.cpp} on a variable is (almost) a no-op, and is possibly a mistype of ‘<code>++</code>’{.cpp}. A unary ‘<code>-</code>’{.cpp} on a variable will switch its sign, unless applied to a variable of an unsigned type, in which case the result is the value subtracted from 2^n where n is the number of bits in the unsigned type.</p>
<p>C++ overloading of operators can also cause confusion.</p>
<p>The language does not impose any restrictions on semantics of overloaded operators. This can cause (potentially generic) code to behave in completely unobvious ways, when such types with “unusual” operator semantics are used.</p>
<p>For example, the boost.spirit library allows code like the following to create parser rules:</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a>r = real_p &gt;&gt; *(ch_p(<span class="ch">&#39;,&#39;</span>) &gt;&gt; real_p); <span class="co">// rule that accepts a comma-separated list of real numbers</span></span></code></pre></div>
<p>This library uses C++ operator overloads to create an embedded domain-specific language for grammar rules, allowing the specification of parser rules as C++ expressions.</p>
<p>When overloaded, related operators like the compound assignment with their base operator are not longer guaranteed to keep their behavioral relationship that they have for built-in types. For example, <code class="sourceCode cpp">a += b</code> is not guaranteed to behave like <code class="sourceCode cpp">a = a + b</code>, or being defined at all.</p>
<p>Similarly for overloaded relational operators, for <code class="sourceCode cpp">a == b</code>, there is no guarantee that <code class="sourceCode cpp">a != b</code> is equivalent to <code class="sourceCode cpp">!(a == b)</code> if both are overloaded by the user.</p>
<p>Unless all relational operators for a type are defined either explicitly in a consistent way or implicitly, unexpected results can occur. A user-declared three-way comparison operator (<code class="sourceCode cpp">&lt;=&gt;</code>) is used by the compiler to synthesize the relational operators consistently. If <code class="sourceCode cpp"><span class="kw">operator</span>&lt;=&gt;</code> is defined as <code class="sourceCode cpp">=<span class="cf">default</span></code>, the equality comparison operators will also be defined; and if <code class="sourceCode cpp"><span class="kw">operator</span>==</code> with return type <code class="sourceCode cpp"><span class="dt">bool</span></code> is defined, a corresponding inequality <code class="sourceCode cpp"><span class="kw">operator</span>!=</code> is also defined implicitly.</p>
<h4 id="the-most-vexing-parse">6.25.1.2 The Most vexing parse</h4>
<p>In C++ if the syntax of a declaration can be interpreted as a function declaration in preference to an object declaration, . In the following example, the intention is to create a scoped lock object, but the compiler interprets it as a function declaration <code>lock()</code>. ```{.cpp}</p>
<p>std::scoped_lock<std::mutex> lock();</p>
<pre><code>
std::vector&lt;int&gt; v1();

std::vector&lt;int&gt; v2{};


#### 6.25.1.3 Vulnerabilities with associative containers

The subscript `operator[]`{.cpp} for a non-const object of types such as `std::map`{.cpp} guarantees that the given key will exist when the method returns, known as add-or-update behaviour. 

```{.cpp}
   bool find_elem (std::map&lt;std::string, std::string&gt; &amp; m, std::string key)
   {
       if ( m[key] != std::string { } )
       {
          return true; // key found in map
       }
       // not found
       return false;
   }</code></pre>
<p>In the above function, when a key is not already present in the map, it will be added. This can result in resource exhaustion.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.25.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<p>— Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.25.5.</p>
<ul>
<li><p>Simplify expressions to aid in code readability and help future maintainers understand the intent and nuances of the code. For example,</p>
<ul>
<li>by using parentheses around sub-expressions to limit precedence confusion,</li>
<li>by extracting intermediate results into const variables with a meaningful name, or</li>
<li>by extracting a subexpression into a function with a meaningful name.</li>
</ul></li>
<li><p>Avoid assignments embedded within other statements and expressions.</p></li>
<li><p>Spell unary operators (e.g., <code>-</code>) with a leading blank in expressions to avoid them being misread as combined operators.</p></li>
<li><p>Avoid the use of unary plus, since it is almost always a no-op for built-in types.</p></li>
<li><p>Avoid Boolean operators (<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>) with non-<code>bool</code> operands, e.g., operands of numeric types.</p></li>
<li><p>Avoid bit operators (<code>&amp;</code>, <code>|</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code> ) with anything except operands of non-<code>bool</code> unsigned types.</p></li>
<li><p>Consider using alternative tokens for the logical operators, such as <code>and</code>, <code>or</code>, and <code>not</code>, and comparison operators such as <code>equal</code> and <code>not_eq</code>.</p></li>
<li><p>If your code structure requires an empty statement <code class="sourceCode cpp">;</code> use an empty code block instead <code class="sourceCode cpp">{}</code>.</p></li>
<li><p>Prohibit conflicting side-effects in sub-expressions.</p></li>
<li><p>Avoid defining semantics of overloaded operators to deviate from the semantics of these operators for the built-in types.</p></li>
<li><p>Prefer defaulted and synthesized comparison operators over individual overloads to ensure that all of the related comparison operators behave consistently.</p></li>
<li><p>Use <code class="sourceCode cpp">find()</code> or <code class="sourceCode cpp">contains()</code> to check if a key exists in associative containers.</p></li>
</ul>
<h2 id="XYQ">6.26 Dead and Deactivated Code [XYQ]</h2>
<h3 id="applicability-to-language">6.26.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC 24772-1 clause 6.26 exists in C++.</p>
<p>The language mechanisms around templates and overload resolution can require definitions to exist that are not part of the executable program. But the mechanisms at compile time guarantee that the corresponding code never becomes part of the executable program. However, a programmer might be unaware of all details with respect to the language mechnisms and thus make subtle errors leading to code selected for the executable program that was unintended.</p>
<p>If there is code that was once needed or might be needed in the future, programmers might opt to comment or use preprocessor conditional compilation to exclude such parts. The latter might even be confusing, because an intentionally undefined macro might be defined for a specific compilation outside of the program source text. Modern version control systems are better places to keep unused code in a revision or branch and ressurect it if needed through a merge.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.26.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.26.5.</p></li>
<li><p>Use IDEs or similar tools that visualize the code that gets selected for the executable program.</p></li>
<li><p>Use modern version control to manage unused code.</p></li>
</ul>
<h2 id="switch-statements-and-static-analysis-cll">6.27 Switch Statements and Static Analysis [CLL]</h2>
<h3 id="applicability-to-language">6.27.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.27 exists in C++.</p>
<p>Because of the way in which the switch-case statement in C++ is structured, it can be relatively easy to unintentionally omit the break statement between cases causing unintended execution of statements for some cases.</p>
<p>The switch statement has the form:</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> abc = someExpression();</span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* … */</span></span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> (abc) {</span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a>       <span class="cf">case</span> <span class="dv">1</span>:</span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a>          sval = “a”;</span>
<span id="cb142-6"><a href="#cb142-6" aria-hidden="true" tabindex="-1"></a>           <span class="cf">break</span>;</span>
<span id="cb142-7"><a href="#cb142-7" aria-hidden="true" tabindex="-1"></a>       <span class="cf">case</span> <span class="dv">2</span>:</span>
<span id="cb142-8"><a href="#cb142-8" aria-hidden="true" tabindex="-1"></a>           sval = “b”;</span>
<span id="cb142-9"><a href="#cb142-9" aria-hidden="true" tabindex="-1"></a>           <span class="cf">break</span>;</span>
<span id="cb142-10"><a href="#cb142-10" aria-hidden="true" tabindex="-1"></a>       <span class="cf">case</span> <span class="dv">3</span>:</span>
<span id="cb142-11"><a href="#cb142-11" aria-hidden="true" tabindex="-1"></a>           sval = “c”;</span>
<span id="cb142-12"><a href="#cb142-12" aria-hidden="true" tabindex="-1"></a>           <span class="cf">break</span>;</span>
<span id="cb142-13"><a href="#cb142-13" aria-hidden="true" tabindex="-1"></a>       <span class="cf">default</span>:</span>
<span id="cb142-14"><a href="#cb142-14" aria-hidden="true" tabindex="-1"></a>           <span class="cf">throw</span> SomeException();</span>
<span id="cb142-15"><a href="#cb142-15" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>If there isn’t a default case and the switched expression doesn’t match any of the cases, then control simply shifts to the next statement after the switch statement block. Unintentionally omitting a break statement between two cases will cause subsequent cases to be executed until a break or the end of the switch block is reached. This could cause unexpected results.</p>
<p>The attribute <code class="sourceCode cpp">[[<span class="at">fallthrough</span>]]</code> expresses the programmer’s intent that the code where it is placed is intended to fall through. If this attribute is not used, compilers typically diagnose the absence of a break statement.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.27.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.27.5</p></li>
<li><p>Use <code class="sourceCode cpp">[[<span class="at">fallthrough</span>]]</code> wherever fall-through is intended.</p></li>
<li><p>Terminate every case with either a flow control transfer or <code class="sourceCode cpp">[[<span class="at">fallthrough</span>]]</code> as illustrated in the following example:</p>
<pre><code>```{.cpp}
int i;
. . .
switch (i) {
       case 1: 
                     [[fallthrough]]; // documents the intended fallthrough.
       case 2:
            i++;    
            break;
        case 3: 
            j++; 
          [[fallthrough]]; // documents the intended fallthrough.
       case 4: //other code
            return 42;
       default: throw CaseNotFound();   
      }
```</code></pre></li>
<li><p>Adopt a style that permits your language processor and analysis tools to verify that all cases are covered. Where this is not possible, use a default clause that diagnoses the error.</p></li>
</ul>
<blockquote>
<p>See also the C++ Core Guidelines ES.78</p>
</blockquote>
<h2 id="demarcation-of-control-flow-eoj">6.28 Demarcation of Control Flow [EOJ]</h2>
<h3 id="applicability-to-language">6.28.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.28 exists in C++.</p>
<p>C++ lacks a keyword to be used as an explicit terminator. Therefore, it may not be readily apparent which statements are part of a loop construct or an if statement.</p>
<p>Consider the following sections of code:</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foo(<span class="dt">int</span> a, <span class="at">const</span> <span class="dt">int</span> *b) {</span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i=<span class="dv">0</span>;</span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// . . .</span></span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a>        a = <span class="dv">0</span>;</span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">10</span>; i++); <span class="co">// notice the &#39;;&#39; !!</span></span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a>        {</span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a>            a = a + b[i];</span>
<span id="cb144-8"><a href="#cb144-8" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb144-9"><a href="#cb144-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> c = <span class="dv">0</span>;</span>
<span id="cb144-10"><a href="#cb144-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x = <span class="dv">0</span>;</span>
<span id="cb144-11"><a href="#cb144-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (<span class="dt">int</span> j=<span class="dv">0</span>; j&lt;<span class="dv">10</span>; j++)</span>
<span id="cb144-12"><a href="#cb144-12" aria-hidden="true" tabindex="-1"></a>            c = c + b[j];</span>
<span id="cb144-13"><a href="#cb144-13" aria-hidden="true" tabindex="-1"></a>            x += c; </span>
<span id="cb144-14"><a href="#cb144-14" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>At first it may appear that, after the first loop, <code class="sourceCode cpp">a</code> will be a sum of the numbers <code class="sourceCode cpp">b[<span class="dv">0</span>]</code> to <code class="sourceCode cpp">b[<span class="dv">9</span>]</code>. However, even though the code is laid out so that the <code class="sourceCode cpp">a = a + b[i]</code> code appears to be within the for loop, the “<code class="sourceCode cpp">;</code>” at the end of the for statement causes the loop to be on a null statement (the “<code class="sourceCode cpp">;</code>”) and the</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a>a = a + b[i];</span></code></pre></div>
<p>statement to only be executed once. Similarly, the indentation leads us to believe that that assignment to x is part of the second loop, but it is not. These mistakes may be readily apparent during development or testing. More subtle cases may not be as readily apparent leading to unexpected results.</p>
<p><code class="sourceCode cpp"><span class="cf">if</span></code> statements in C++ are also susceptible to control flow problems since there isn’t a requirement in C++ for there to be an else statement for every if statement. An <code class="sourceCode cpp"><span class="cf">else</span></code> statement in C++ always belong to the most recent <code class="sourceCode cpp"><span class="cf">if</span></code> statement without an <code class="sourceCode cpp"><span class="cf">else</span></code>. However, the situation could occur where it is not readily apparent to which <code class="sourceCode cpp"><span class="cf">if</span></code> statement an <code class="sourceCode cpp"><span class="cf">else</span></code> belongs due to the way the code is indented or aligned.</p>
<p>Similar issues arise for <code class="sourceCode cpp"><span class="cf">if</span></code>-statements, particularly during maintenance, for example:</p>
<pre><code>```{.cpp}
int a,b,i;
// . . . 
if (i == 10){
       a = 5;       
       b = 10; // added later, but correct since within the {…}
      }
      else 
          a = 10;   
          b = 5;    // added later, intended to be part 
                        // of the else clause
```</code></pre>
<p>If the assignments to b were added later and were expected to be part of each <code class="sourceCode cpp"><span class="cf">if</span></code> and <code class="sourceCode cpp"><span class="cf">else</span></code> clause (they are indented as such), the above code is incorrect: the assignment to <code class="sourceCode cpp">b</code> that was intended to be in the <code class="sourceCode cpp"><span class="cf">else</span></code> clause is unconditionally executed.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.28.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.28.5.</p></li>
<li><p>Enclose the bodies of <code class="sourceCode cpp"><span class="cf">if</span></code>, <code class="sourceCode cpp"><span class="cf">else</span></code>, <code class="sourceCode cpp"><span class="cf">while</span></code>, <code class="sourceCode cpp"><span class="cf">for</span></code>, and similar in braces. This will reduce confusion and potential problems when modifying the software.</p></li>
<li><p>Declare loop variables in the initializer of the loop statement</p></li>
<li><p>Prefer the standard library algorithms over hand-crafted loops.</p></li>
<li><p>Consider the use of source code auto-formatters before code reviews.</p></li>
</ul>
<blockquote>
<p>See also the C++ Core Guidelines ES.85, ES.71, ES.74, ES.1 and ES.2</p>
</blockquote>
<h2 id="loop-control-variables-tex">6.29 Loop Control Variables [TEX]</h2>
<h3 id="applicability-to-language">6.29.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.29 exists in C++.</p>
<p>C++ allows the modification of loop control variables within non range-based loops. This is usually not considered good programming practice as it can cause unexpected problems. The flexibility of C++ expects the programmer to use this capability responsibly.</p>
<p>Since the modification of a loop control variable within a loop is infrequently encountered, reviewers of C++ code may not expect it and hence miss noticing the modification. Modifying the loop control variable can cause unexpected results if not carefully done. In C++, the following is semantically correct, but is error-prone:</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a;</span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; <span class="dv">10</span>; i++){</span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (a &gt; <span class="dv">7</span>)</span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>        i = <span class="dv">10</span>;</span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb147-7"><a href="#cb147-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>which will cause the for loop to exit once <code class="sourceCode cpp">a</code> is greater than <code class="sourceCode cpp"><span class="dv">7</span></code> regardless of the number of iterations that have occurred.</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">int</span> i : <span class="bu">std::</span>ranges<span class="bu">::</span>iota_view{<span class="dv">1</span>,<span class="dv">10</span>})</span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (a &gt; <span class="dv">7</span>) {</span>
<span id="cb148-4"><a href="#cb148-4" aria-hidden="true" tabindex="-1"></a>       i = <span class="dv">10</span>;   <span class="co">// This changes the local variable for this loop iteration&#39;s execution</span></span>
<span id="cb148-5"><a href="#cb148-5" aria-hidden="true" tabindex="-1"></a>                 <span class="co">// but subsequent iterations are not affected</span></span>
<span id="cb148-6"><a href="#cb148-6" aria-hidden="true" tabindex="-1"></a>       }</span>
<span id="cb148-7"><a href="#cb148-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb148-8"><a href="#cb148-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb148-9"><a href="#cb148-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">int</span> <span class="at">const</span> i : <span class="bu">std::</span>ranges<span class="bu">::</span>iota_view{<span class="dv">1</span>,<span class="dv">10</span>})</span>
<span id="cb148-10"><a href="#cb148-10" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb148-11"><a href="#cb148-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (a &gt; <span class="dv">7</span>) {</span>
<span id="cb148-12"><a href="#cb148-12" aria-hidden="true" tabindex="-1"></a>       i = <span class="dv">10</span>;   <span class="co">// This is now illegal since the &#39;const int&#39; prevents assign</span></span>
<span id="cb148-13"><a href="#cb148-13" aria-hidden="true" tabindex="-1"></a>       }</span>
<span id="cb148-14"><a href="#cb148-14" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>The range for example immediately above does not have the vulnerability of the C-like for loop above.</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">1</span>; i &lt; <span class="dv">10</span>; ++i) ...</span></code></pre></div>
<p>In a range-based for loop, the control variable is not available.</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>array a {<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">5</span>};</span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="kw">auto</span> <span class="at">const</span> x : a) {</span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h3 id="avoidance-mechanisms-for-language-users">6.29.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.29.5.</p></li>
<li><p>Do not modify a loop control variable within a loop.</p></li>
<li><p>Use a range-for loop in preference to general loops.</p></li>
<li><p>Alternatively, use standard library generic algorithm functions like <code>copy</code>, <code>reduce</code>, <code>transform</code>, <code>inner_product</code>, etc. in preference to general loops.</p></li>
</ul>
<p>Note: See also the C++ Core Guidelines ES.71, ES.86.</p>
<h2 id="off-by-one-error-xzh">6.30 Off-by-one Error [XZH]</h2>
<h3 id="applicability-to-language">6.30.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.30 exists in C++.</p>
<p>Arrays are a common place for off by one errors to manifest. In C++, arrays are indexed starting at 0, causing the common mistake of looping from 0 to the size of the array as in:</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> foo() {</span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a[<span class="dv">10</span>];</span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i;</span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i=<span class="dv">0</span>, i&lt;=<span class="dv">10</span>, i++)</span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a>      ...</span>
<span id="cb151-6"><a href="#cb151-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="dv">0</span>);</span>
<span id="cb151-7"><a href="#cb151-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>C++ mitigates the issue of sentinel values in strings document in ISO/IEC 24772-1 clause 6.30 by providing the <code class="sourceCode cpp">string</code> class and the <code class="sourceCode cpp">string_view</code> class.</p>
<p>C++ does not flag accesses outside of array bounds, so an off by one error may not be as detectable in C++ as in some other languages. Several good and freely available tools can be used to help detect accesses beyond the bounds of arrays that are caused by an off by one error. However, such tools will not help in the case where only a portion of the array is used, and the access is still within the bounds of the array.</p>
<p>C++ mitigates these issues by providing</p>
<ul>
<li><p>Range-based for loops</p></li>
<li><p><code class="sourceCode cpp">std</code> algorithms</p></li>
<li><p>Iterator style loops terminated by <code class="sourceCode cpp">!=</code></p></li>
<li><p>Container classes</p></li>
<li><p><code class="sourceCode cpp">gsl::span</code> (soon to be <code class="sourceCode cpp"><span class="bu">std::</span>span</code>)</p></li>
</ul>
<h3 id="avoidance-mechanisms-for-language-users">6.30.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.30.5.</p></li>
<li><p>Use careful programming, testing of border conditions, and static analysis tools to detect off-by-one errors in C++.</p></li>
<li><p>Use range-based for loops, std algorithms, iterator style loops terminated by !=, or container classes in preference to C-style arrays and structures.</p></li>
</ul>
<blockquote>
<p>See also the C++ Core guidelines ES.1, ES.42, ES.71, SL.con.3 (more to come)</p>
</blockquote>
<h2 id="structured-programming-ewd">6.31 Structured Programming [EWD]</h2>
<h3 id="applicability-to-language">6.31.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.31 exists in C++.</p>
<p>It is as easy to write structured programs in C++ as it is not to. C++ contains the <code class="sourceCode cpp"><span class="cf">goto</span></code> statement, which can create unstructured code. It also has <code class="sourceCode cpp"><span class="cf">continue</span></code>, <code class="sourceCode cpp"><span class="cf">break</span></code>, and <code class="sourceCode cpp"><span class="cf">return</span></code> that can create a complicated control flow, when used in an undisciplined manner. Spaghetti code can be more difficult for static analyzers to analyze and is sometimes used on purpose to intentionally obfuscate the functionality of software. Code that has been modified multiple times by an assortment of programmers to add or remove functionality or to fix problems can be prone to become unstructured.</p>
<p>Because unstructured code in can cause problems for analyzers, both automated and human, of code, problems with the code may not be detected as readily or at all as would be the case if the software was written in a structured manner.</p>
<p>In C++, the <code class="sourceCode cpp"><span class="cf">break</span></code> and <code class="sourceCode cpp"><span class="cf">continue</span></code> operations only act on the innermost loop. At times, escape from nested loops is required. In such cases, the use of <code class="sourceCode cpp"><span class="cf">goto</span></code> may be simpler and easier to verify than a series of tests with <code class="sourceCode cpp"><span class="cf">break</span></code> and/or <code class="sourceCode cpp"><span class="cf">continue</span></code> operations.</p>
<p>The <code class="sourceCode cpp">setjmp</code> macro sets the current execution context into a variable, which can be use later to return to that current context using <code class="sourceCode cpp">longjmp</code> call. These calls originated from the C standard library to mimic <code class="sourceCode cpp"><span class="cf">goto</span></code> across the call stack. They do not support the relevant additions to C++ such as destructors for automatic objects, exceptions, and concurrency, and hence are incompatible with modern C++ programming.</p>
<p>A coroutine is a function that can suspend execution for later resumption (optional).</p>
<h3 id="avoidance-mechanisms-for-language-users">6.31.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.31.5.</p></li>
<li><p>Write clear and concise structured code to make code as understandable as possible.</p></li>
<li><p>Avoid the use of <code class="sourceCode cpp">setjmp</code> and <code class="sourceCode cpp">longjmp</code></p></li>
<li><p>Consider the use of coroutines as an alternative to <code class="sourceCode cpp"><span class="cf">goto</span></code> and <code class="sourceCode cpp">setjmp/longjmp</code></p></li>
</ul>
<p>See also the C++ Core guidelines ES.76, ES.77, SL.C.1</p>
<h2 id="passing-parameters-and-return-values-csj">6.32 Passing Parameters and Return Values [CSJ]</h2>
<h3 id="applicability-to-language">6.32.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC 24772-1:2024 6.32 exists in C++. However, the language also provides appropriate mitigation.</p>
<p>C++ provides both <em>call by copy</em> (aka <em>call by value</em>) and <em>call by reference</em> parameter passing. The argument is evaluated to initialize the formal parameter (in the first case) or bound to the formal parameter (in the second case) of the function that is being called. A formal parameter behaves like a local variable, however, changes to a non-const reference parameter affect the bound object.</p>
<p>The rich type system of C++ allows types that when passed by value still have <em>call by reference</em> semantics, for example, pointer types, <code>std::reference_wrapper</code>, or class types with pointer or reference member variables.</p>
<p>C++ assumes that pointer or reference parameters of different types never alias, even if the underlying object representations are identical, i.e., for a function declared as <code class="sourceCode cpp"><span class="dt">void</span> f(<span class="dt">int</span> *pi, <span class="dt">long</span> *pl)</code> the compiler will assume that <code>pi</code> and <code>pl</code> always refer to different objects, even if <code class="sourceCode cpp"><span class="kw">sizeof</span>(<span class="dt">int</span>) == <span class="kw">sizeof</span>(<span class="dt">long</span>)</code>. Two parameters may refer to the same object if they have pointer or reference type, and the target types are the same or related. This means, aliasing between reference parameters or with a reference result needs to be taken into account in user code. For example, in an assignment expression the left and right hand side can refer to the same object. This implies that user-defined assignment operators must take precautions against self-assignment or document that it is forbidden.</p>
<p>Modern C++ ensures that in many cases the need for, and the overhead of copying value arguments or results is elided by the compiler, especially from temporary objects.</p>
<p>The use of <code class="sourceCode cpp"><span class="at">const</span></code> lvalue-reference parameters combines the efficiency of <em>call by reference</em> with the guarantee that the underlying input parameter is not changed (marking it as an <em>in</em> parameter). A non-const reference parameter must be considered an <em>inout</em> parameter. Rvalue-reference parameters are <em>inout</em> parameters that allow <em>transfer-of-ownership</em> semantics. At their call site it is best to assume that the argument object is in an indeterminate state and has to be reassigned before subsequent use. There is no language mechanism for marking <em>out</em> parameters, one would use the return mechanism. Instead of multiple <em>out</em> parameters a <code class="sourceCode cpp"><span class="kw">struct</span></code>, <code class="sourceCode cpp"><span class="bu">std::</span>pair</code>, or <code class="sourceCode cpp"><span class="bu">std::</span>tuple</code> can be used as a return type and eventually decomposed at the call site to its constituents via a <em>structured binding</em>.</p>
<p>Member functions take the <code class="sourceCode cpp">*<span class="kw">this</span></code> object as an implicit reference parameter. The kind of reference can be specified through qualification of the member function. However, in addition to lvalue-reference, const-lvalue-reference, and rvalue-reference qualification, there exists an oddity with respect to normal reference parameters:</p>
<ul>
<li>without a qualification a member function can be called on rvalues and non-const lvalues, and</li>
<li>with a const-qualification a member function can be called on const lvalues and rvalues.</li>
</ul>
<p>This means, unqualified member functions are callable on temporaries (rvalues) and thus can have side effects, but also can return an lvalue-reference to said temporary by returning <code>*this</code> (or members of <code>*this</code>), which can lead to dangling if such a reference is used beyond the expression of the function call returning it. For example, the compiler-provided assignment operators of a class are unqualified member functions that return an lvalue-reference to <code class="sourceCode cpp">*<span class="kw">this</span></code>.</p>
<p>Rvalue-reference parameters in a context where their actual type is deduced from the call site, are called <em>forwarding references</em>. A forwarding references will either be deduced to an lvalue-reference or an rvalue-reference depending on the argument at the call site.</p>
<p>Aliasing is expected and allowed in some cases, such as:</p>
<pre><code>-   Assignment and compound assignment operators: the right parameter may alias the left parameter. The function result always refers to the left parameter unless overloaded differently. In the case of self-assignment the stored value should not change.

-   Functions that `swap`{.cpp} their parameters: The two parameters to be swapped may refer to the same object.

-   Shift operators used for input and output: the result always refers to the left parameter.

-   Prefix increment and decrement operators: the result always refers to the parameter.
    </code></pre>
<p>The C++ preprocessor macros use a <em>call by name</em> parameter passing; a call to the macro replaces the macro by the body of the macro. This is called <em>macro expansion</em>. Macro expansion is applied to the program source text and amounts to the substitution of the formal parameters with the actual parameter expressions. Formal parameters are often parenthesized to avoid syntax issues after the expansion. Call by name parameter passing reevaluates the actual parameter expression each time the formal parameter is read.</p>
<p>The order of evaluation of function arguments is unspecied, see <a href="#SAM">[SAM]</a></p>
<h3 id="avoidance-mechanisms-for-language-users">6.32.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Apply the avoidance mechanisms of ISO/IEC 24772-1 6.32.5.</p></li>
<li><p>Prefer pass-by-value and pass-by-const-reference over other means of parameter declaration.</p></li>
<li><p>Prefer reference parameters over corresponding pointer parameters.</p></li>
<li><p>Use pass by non-const reference only when side-effects on the argument are intended (<em>inout</em>-parameter).</p></li>
<li><p>Unless the moved-from state is well-defined, always reassign a variable passed by rvalue-reference before subsequent use after the call.</p></li>
<li><p>Use forwarding reference parameters only, if perfect forwarding is needed in the body of a function template or generic lambda.</p></li>
<li><p>Define member functions with the appropriate lvalue-ref-qualification when they have side effects on <code class="sourceCode cpp">*<span class="kw">this</span></code> or return a pointer-like object referring to <code>*this</code> or its members.</p></li>
<li><p>Either delete the rvalue-ref-qualified overload or define it as returning by value, when a const-ref-qualified overload of a member function exists that returns a pointer-like object referring to <code>*this</code> or its members.</p></li>
<li><p>Document the referents of pointer-like objects created by or modified by a function if any pointer-like object outlives the invocation of that function.</p></li>
<li><p>Document any allowable aliasing between the referents of function parameters of pointer-like type. Absent such documentation, avoid passing aliased parameters.</p></li>
<li><p>Do not use function-like macros. If used, surround all macro parameters in the replacement text with parentheses.</p></li>
</ul>
<h2 id="dangling-references-to-stack-frames-dcm">6.33 Dangling References to Stack Frames [DCM]</h2>
<h3 id="applicability-to-language">6.33.1 Applicability to language</h3>
<p>The vulnerability as expressed in ISO/IEC IS 24772-1:2024 and ISO/IEC TR 24772-3:2020 C exists in C++ by indirect access to variables with automatic storage duration or to temporary objects.</p>
<p>The lifetime model of C++ (<a href="#lifetime">4.4</a>) makes it undefined behaviour <a href="#EWF">[EWF]</a> to access an object outside of its lifetime. This results in undefined behavior, when an object access is attempted after its destruction. C++ provides a rich set of <em>pointer-like</em> types whose values may refer to temporaries or variables with automatic storage duration and can dangle (see Subclause <a href="#XYK">[XYK]</a>).</p>
<p>A C++ class type with a <em>pointer-like</em> member will behave as a <em>pointer-like</em> type, unless the class itself manages the lifetime of the object referred to by its member.</p>
<p>In general, any caller storing the <em>pointer-like</em> object returned from a function call risks dangling; such situations require thorough lifetime analysis to ensure that access via the <em>pointer-like</em> object doesn’t dangle.</p>
<p>The efficiency of return-by-value, copy-elision, and move-semantics as specified by C++ reduces the incentive to return a <em>pointer-like</em> type from a function or bind a temporary to a local reference.</p>
<p>The lifetime of a temporary object usually ends at the end of a <em>full expression</em> where it was created. Dangling can occur, when an expression including the creation of a temporary object results in a <em>pointer-like</em> value referring to the temporary object. For example, <code>std::max</code> returns the const-reference given as parameter, which might be bound to a temporary argument:</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> g(<span class="dt">int</span> i){</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="at">const</span> &amp;m = <span class="bu">std::</span>max(i,<span class="dv">20</span>);</span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> m; <span class="co">// access dangling reference to temporary if i &lt; 20</span></span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In some situations binding a reference to a temporary will extend the lifetime of the temporary.</p>
<p>This lifetime extension is not transitive across function calls, therefore, changes in the code, such as replacing a data member access with an accessor member function, can silently lead to dangling in such lifetime-extension situations.</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A{</span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a;</span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="at">const</span> &amp;getA(){<span class="cf">return</span> a;}</span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb154-5"><a href="#cb154-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> h(){</span>
<span id="cb154-6"><a href="#cb154-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> &amp;&amp; ra = A{<span class="dv">42</span>}.a; <span class="co">// lifetime extended</span></span>
<span id="cb154-7"><a href="#cb154-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="at">const</span> &amp; cra = A{<span class="dv">42</span>}.getA(); <span class="co">// dangling</span></span>
<span id="cb154-8"><a href="#cb154-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The range-based for statement contains a subtle situation with lifetime extension.<br />
A temporary in the range expression will have its lifetime extended, unless it is accessed indirectly. As a mitigation C++ permits the creation of a variable for such situations that has the scope of the range-for loop, as shown in the following example:</p>
<pre class="{cpp}"><code>extern std::vector&lt;std::string&gt; make(); // creates a vector

for(char c : make().front()) { // attempt to iterate over first string in vector
   // vector and thus contained string is already destroyed before C++23
}

for(auto range = make().front(); char c : range){ // mitigation, create a variable for the range to be iterated over
  // string to be iterated over remaings valid throughout
}</code></pre>
<p>This issue is no longer present from C++23 onwards, as temporaries within the for-range-initializer are lifetime extended until the end of the statement.</p>
<p>Returning a <em>pointer-like</em> object from a function is problematic, if the return value refers to a temporary or an object with automatic storage duration, either directly or indirectly. The following example show different situations with this problem:</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> *bad_pointer() {</span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a = <span class="dv">0</span>;</span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> &amp;a;      <span class="co">// Returning the address of a local variable &quot;a&quot;.</span></span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true" tabindex="-1"></a> }</span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-6"><a href="#cb156-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span>&amp; bad_reference(<span class="dt">int</span> b) {</span>
<span id="cb156-7"><a href="#cb156-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> b;      <span class="co">// Returning a reference to a local (parameter) variable &quot;b&quot; .</span></span>
<span id="cb156-8"><a href="#cb156-8" aria-hidden="true" tabindex="-1"></a> }</span>
<span id="cb156-9"><a href="#cb156-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-10"><a href="#cb156-10" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">3</span>&gt;::iterator bad_iterator() {</span>
<span id="cb156-11"><a href="#cb156-11" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">3</span>&gt; c = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };</span>
<span id="cb156-12"><a href="#cb156-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> c.begin();</span>
<span id="cb156-13"><a href="#cb156-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Returning an iterator that refers the first element of the local array &quot;c&quot;.</span></span>
<span id="cb156-14"><a href="#cb156-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb156-15"><a href="#cb156-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-16"><a href="#cb156-16" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> bad_lambda() {</span>
<span id="cb156-17"><a href="#cb156-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d = <span class="dv">0</span>;</span>
<span id="cb156-18"><a href="#cb156-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [&amp;] { <span class="cf">return</span> d = <span class="dv">1</span>; };</span>
<span id="cb156-19"><a href="#cb156-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Returning a lambda that captures local variable &quot;d&quot; by reference</span></span>
<span id="cb156-20"><a href="#cb156-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// and thus indirectly returns a reference to the local variable</span></span>
<span id="cb156-21"><a href="#cb156-21" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb156-22"><a href="#cb156-22" aria-hidden="true" tabindex="-1"></a><span class="kw">decltype</span>(<span class="kw">auto</span>) bad_assign(){ <span class="co">// deduces: std::string &amp;</span></span>
<span id="cb156-23"><a href="#cb156-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>string{} = <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span><span class="bu">s</span>;</span>
<span id="cb156-24"><a href="#cb156-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Returns reference to temporary object returned from copy-assignment operator</span></span>
<span id="cb156-25"><a href="#cb156-25" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb156-26"><a href="#cb156-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-27"><a href="#cb156-27" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> erroneous_use() {</span>
<span id="cb156-28"><a href="#cb156-28" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; *bad_pointer();</span>
<span id="cb156-29"><a href="#cb156-29" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; bad_reference(<span class="dv">42</span>);</span>
<span id="cb156-30"><a href="#cb156-30" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; *bad_iterator();</span>
<span id="cb156-31"><a href="#cb156-31" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; bad_lambda()();</span>
<span id="cb156-32"><a href="#cb156-32" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; bad_assign();</span>
<span id="cb156-33"><a href="#cb156-33" aria-hidden="true" tabindex="-1"></a> }</span></code></pre></div>
<p>In the examples above, the function <code>bad_assign</code> returns a <code class="sourceCode cpp"><span class="bu">std::</span>string &amp;</code> that was itself returned from the copy-assignement operator of <code class="sourceCode cpp"><span class="bu">std::</span>string</code>. Such an assignement operator (including the compiler-provied ones) can be called with a temporary as its left-hand operand, because it is an unqualified member function (for historical reasons).</p>
<p>Dangling may occur by calling a member function on a temporary that returns a <em>pointer-like</em> object referring to <code class="sourceCode cpp">*<span class="kw">this</span></code>, a sub-object of <code class="sourceCode cpp">*<span class="kw">this</span></code>, or an object managed by <code class="sourceCode cpp">*<span class="kw">this</span></code>. This can be prevented by - For a non-const member function: adding an lvalue ref-qualification (<code class="sourceCode cpp">&amp;</code>), - For a const member function: adding an lvalue ref-qualification (<code class="sourceCode cpp"><span class="at">const</span> &amp;</code>) <strong>and</strong> declaring an rvalue ref-qualified overload (<code class="sourceCode cpp">&amp;&amp;</code>) either defined as <code class="sourceCode cpp">=<span class="kw">delete</span></code> or declared to return by value.</p>
<p>In the following example, class <code class="sourceCode cpp">nta</code> declares its copy assignment with lvalue ref-qualification to avoid the situation created in the example function <code>bad_assign</code>:</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ta{}; <span class="co">// default allows assignment to temporary</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> nta{</span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a>nta &amp; <span class="kw">operator</span>=(nta <span class="at">const</span> &amp;) &amp; = <span class="cf">default</span>; <span class="co">// lvalue-ref qualified</span></span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true" tabindex="-1"></a>ta &amp; check_ta(){</span>
<span id="cb157-6"><a href="#cb157-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ta{} = ta{}; <span class="co">// returns dangling reference to temporary</span></span>
<span id="cb157-7"><a href="#cb157-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb157-8"><a href="#cb157-8" aria-hidden="true" tabindex="-1"></a>nta &amp; check_nta(){</span>
<span id="cb157-9"><a href="#cb157-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> nta{} = nta{}; <span class="co">// won&#39;t compile</span></span>
<span id="cb157-10"><a href="#cb157-10" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div>
<p>Referring to a variable with automatic storage duration from a <em>pointer-like</em> variable with static or thead-local storage duration usually means dangling, when the indirect access happens.</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> init{<span class="dv">42</span>};</span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>reference_wrapper&lt;<span class="dt">int</span> <span class="at">const</span>&gt; bad_ref = init; <span class="co">// static storage duration</span></span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bad_global_assign(){</span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (bad_ref == <span class="dv">42</span>){ <span class="co">// undefined behavior on 2nd call</span></span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a>       <span class="dt">int</span> local{<span class="dv">44</span>};</span>
<span id="cb158-6"><a href="#cb158-6" aria-hidden="true" tabindex="-1"></a>       bad_ref = local; <span class="co">// Any further access of bad_ref dangles</span></span>
<span id="cb158-7"><a href="#cb158-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb158-8"><a href="#cb158-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>A class type with <em>pointer-like</em> members can lead to dangling when those members refer to constructor arguments.</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> X{</span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> &amp;rci;</span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a>X(<span class="dt">int</span> i):rci{i}{} <span class="co">// No lifetime extension of parameter object by binding reference to it</span></span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div>
<p>Similarly, in the following example the vulnerability exists in the conversion <code class="sourceCode cpp"><span class="kw">operator</span> string_view()</code> of <code class="sourceCode cpp"><span class="bu">std::</span>string</code>, that returns a <em>pointer-like</em> type from a member function callable on a temporary object.</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string_view bad_var(<span class="st">&quot;a string&quot;</span><span class="bu">s</span>); <span class="co">// dangling view on temporary string object</span></span></code></pre></div>
<p>A C++-specific way of causing dangling_references to the stack is by means of a placement new expression (see 7.4 Placement new issues [XXX]).</p>
<h3 id="avoidance-mechanisms-for-language-users">6.33.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Prefer value types, pass-by-value, and return-by-value over <em>pointer-like</em> types and passing or returning <em>pointer-like</em> objects.</p></li>
<li><p>Prohibit the following uses of a <em>pointer-like</em> value referring to a variable with automatic storage duration or referring to a temporary object:</p>
<ul>
<li>Returning the <em>pointer-like</em> value from a function;</li>
<li>Assigning the <em>pointer-like</em> value to a <em>pointer-like</em> variable with a greater lifetime, such as a variable with static or thread storage duration, or initializing a <em>pointer-like</em> member variable from a constructor value parameter.</li>
</ul></li>
<li><p>Avoid capturing by reference in a lambda that will be used non-locally, that is</p>
<ul>
<li>returned,</li>
<li>passed to another thread or coroutine, or</li>
<li>stored in a variable with a longer lifetime than the captured variables.</li>
</ul></li>
<li><p>Avoid relying on lifetime extension of temporaries by binding them to named references; use (local) variables instead.</p></li>
<li><p>Show that the <em>range-based for</em> dangling vulnerability does not apply or take steps to avoid it, for example, use a variable representing the range and not an expression that yields a reference to a temporary.</p></li>
<li><p>Consider making member functions ref-qualified, that return <em>pointer-like</em> types to members or objects managed by the class.<br />
If required, provide an rvalue-ref-qualified overload that either returns a copy by value, or is defined as <code class="sourceCode cpp">=<span class="kw">delete</span></code> to prevent calling it on a temporary.</p></li>
<li><p>Perform lifetime analysis when using a <em>pointer-like</em> object beyond the expression that created it and ensure it is not used in a dangling situation.</p></li>
<li><p>Employ static and dynamic analysis tools to detect dangling <em>pointer-like</em> objects.</p></li>
</ul>
<h2 id="OTR">6.34 Subprogram Signature Mismatch [OTR]</h2>
<h3 id="applicability-to-language">6.34.1 Applicability to language</h3>
<p>The vulnerabilities documented in ISO IEC 24772-1 6.34 is applicable to C++ as described below.</p>
<p>In general in C++, there must be a match between the number of parameters in a function call and the number of arguments in the function definition. For issues related to macro signatures, see subclause <a href="NMP">Pre-processor directives[NMP]</a>.</p>
<p>The number of arguments can be different to the number of parameters in a function where: - a function template includes a <em>function parameter pack</em>, or - a function parameter includes a default argument, or - a function parameter-declaration-clause ends with an ellipsis, <code>f(\...)</code>.</p>
<p>Calling a function template with a <em>function parameter pack</em> results in a specialization of the function with the parameter types matching the corresponding argument types.</p>
<p>The compiler will ensure for variadic templates that the type and number of arguments is correct.</p>
<p>A call to a function with default arguments can provide fewer arguments than parameters as long as the parameters for which no explicit argument is provided include a default argument.</p>
<p>Where a function parameter-declaration-clause ends with an ellipsis, additional arguments can be accessed through the mechanisms provided by <code>&lt;cstdarg&gt;</code>.<br />
No information about the number or types of the parameters is supplied by the compiler. The use of this feature outside of special situations can be the basis for vulnerabilities. and undefined behavior <a href="#EWF">[EWF]</a> can arise, for example:</p>
<ul>
<li>Arguments with integral or enumeration type that are passed to an ellipsis parameter will undergo integral promotions, and so the type of the parameter is <code>int</code> and not <code>short</code>. The use of <code>short</code> with <code>va_arg</code> is therefore invalid.</li>
</ul>
<div class="sourceCode" id="cb161"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;cstdarg&gt;</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">int</span> cnt, ...)</span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">va_list</span> ap;</span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a>  va_start (ap, cnt);</span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-8"><a href="#cb161-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">short</span> i = va_arg (ap, <span class="dt">short</span>);  <span class="co">// Invalid type</span></span>
<span id="cb161-9"><a href="#cb161-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-10"><a href="#cb161-10" aria-hidden="true" tabindex="-1"></a>  va_end(ap);</span>
<span id="cb161-11"><a href="#cb161-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<ul>
<li>In the following case, <code>f1</code> assumes that there will be two parameters after the named parameter.</li>
</ul>
<div class="sourceCode" id="cb162"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstdarg&gt;</span></span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">int</span> cnt, ...)</span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb162-5"><a href="#cb162-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">va_list</span> ap;</span>
<span id="cb162-6"><a href="#cb162-6" aria-hidden="true" tabindex="-1"></a>  va_start (ap, cnt);</span>
<span id="cb162-7"><a href="#cb162-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-8"><a href="#cb162-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i = va_arg (ap, <span class="dt">int</span>);</span>
<span id="cb162-9"><a href="#cb162-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> j = va_arg (ap, <span class="dt">int</span>);</span>
<span id="cb162-10"><a href="#cb162-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-11"><a href="#cb162-11" aria-hidden="true" tabindex="-1"></a>  va_end(ap);</span>
<span id="cb162-12"><a href="#cb162-12" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb162-13"><a href="#cb162-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-14"><a href="#cb162-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f2 ()</span>
<span id="cb162-15"><a href="#cb162-15" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb162-16"><a href="#cb162-16" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>);  <span class="co">// OK</span></span>
<span id="cb162-17"><a href="#cb162-17" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>, <span class="dv">2</span>);     <span class="co">// results in undefined behaviour</span></span>
<span id="cb162-18"><a href="#cb162-18" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>These issues cannot occur where default arguments or variadic function templates are used.</p>
<p>The C++ Name mangling ensures that function signatures match accross translation units.</p>
<p>This does not apply to other mangling schemes. For example, parameters do not form part of the mangled name for functions declared with the <code>extern "C"</code> linkage specification. Thus such a function can be invoked with incorrect parameter types due to an incorrect redeclaration of the function:</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="co">// library.cc</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> <span class="dt">void</span> foo (<span class="dt">unsigned</span>, <span class="dt">unsigned</span>)</span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb164"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="co">// main.cc</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> <span class="dt">void</span> foo (<span class="dt">unsigned</span>);</span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main ()</span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true" tabindex="-1"></a>  foo (<span class="bn">0xffffffff</span>);  <span class="co">// Calling function that is</span></span>
<span id="cb164-8"><a href="#cb164-8" aria-hidden="true" tabindex="-1"></a>                     <span class="co">// defined to take 2 parameters</span></span>
<span id="cb164-9"><a href="#cb164-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h3 id="avoidance-mechanisms-for-language-users">6.34.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC TR 24772-1:2019 clause 6.34.5.</p></li>
<li><p>Avoid using functionality from <code>&lt;cstdarg&gt;</code>; use variadic function templates instead.</p></li>
<li><p>When using functions declared with <code>extern "C"</code> linkage specifications, use static analysis tools to ensure that all such declarations of equally named functions have identical signatures.</p></li>
</ul>
<p>Note: See also C++ Core Guidelines F.55.</p>
<h2 id="GDL">6.35 Recursion [GDL]</h2>
<h3 id="applicability-to-language">6.35.1 Applicability to language</h3>
<p>C++ permits recursion, hence is subject to the problems described in ISO/IEC 24772-1 clause 6.35.</p>
<p>C++ allows recursive <code class="sourceCode cpp"><span class="kw">constexpr</span></code> functions and <code class="sourceCode cpp"><span class="kw">consteval</span></code> functions that are evaluated at compile time where such calls don’t contribute to the vulnerability.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.35.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.35.5.</p>
<h2 id="ignored-error-status-and-unhandled-exceptions-oyb">6.36 Ignored Error Status and Unhandled Exceptions [OYB]</h2>
<h3 id="applicability-to-language">6.36.1 Applicability to language</h3>
<p>The vulnerabilities described in ISO/IEC 24772-1:2019 clause 6.36 exist in C++, however, C++ provides a mitigation.</p>
<p>C++ includes the C library, especially the header <code>&lt;cerrno&gt;</code> and thus shares C’s issues with the global error-reporting variable <code>errno</code>. See ISO/IEC 24772-3 clause 6.36 for details and guidance.</p>
<p>In addition to <code>errno</code> some C++ library features expose error conditions indirectly via a side-effect on the object the operation failed with or via side-effect on a reference parameter. For example, input stream objects will go into a <code>fail</code> state, when formatted input cannot be performed. Without resetting that fail-state of a stream, further input will continue to fail, that can cause further failures when a failure is ignored. Streams provide a non-default mode to throw exceptions on failure. Another example of error reporting via a side-effect is the filesystem library that provides overloads that take a non-const reference of <code>std::error_code</code>.</p>
<p>In general, reporting errors as side-effects, in the worst case via a global state, is too easy to accidentally ignore by developers, leading to further consistency problems in the continued execution of the program.</p>
<p>By default, C++ has the C weakness of permitting the call to a function that returns an error code without capturing the return value in a variable.</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a>errnum foo( <span class="dt">int</span> a, <span class="dt">int</span> b);</span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a>. . .</span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a>foo(x, y); <span class="co">// failure to capture the return error code.</span></span></code></pre></div>
<p>C++ offers as a mitigating mechanism the <code class="sourceCode cpp">[[<span class="at">nodiscard</span>]]</code> attribute. This attribute indicates that the function result must not be discarded. Ignoring the result of a function marked <code class="sourceCode cpp">[[<span class="at">nodiscard</span>]]</code> causes a compiler warning.</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a>[[<span class="at">nodiscard</span>]] errnum foo( <span class="dt">int</span> a, <span class="dt">int</span> b);</span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a>. . .</span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a>foo(x, y);  <span class="co">// compile error.</span></span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>( <span class="kw">auto</span> e = foo(a,b); e == <span class="dv">0</span>) { <span class="co">// no compile error</span></span>
<span id="cb166-6"><a href="#cb166-6" aria-hidden="true" tabindex="-1"></a><span class="co">// success</span></span>
<span id="cb166-7"><a href="#cb166-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb166-8"><a href="#cb166-8" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> {</span>
<span id="cb166-9"><a href="#cb166-9" aria-hidden="true" tabindex="-1"></a><span class="co">// handle errors</span></span>
<span id="cb166-10"><a href="#cb166-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In addition, the C++ library provides mechanism to extend the return type of a function with extra values for denoting an error. The simplest case is <code class="sourceCode cpp"><span class="bu">std::</span>optional&lt;T&gt;</code> that extends <code class="sourceCode cpp">T</code> with an “empty” state. Callers must check the result of functions returning an <code class="sourceCode cpp">optional</code> for the empty state, before accessing its value. This increases the chances that a reported error is detected by the caller. If additional information of the error has to be returned to the caller <code class="sourceCode cpp"><span class="bu">std::</span>expected&lt;T,AnErrorCode&gt;</code> or alternatively <code class="sourceCode cpp"><span class="bu">std::</span>variant&lt;T,AnErrorCode&gt;</code> can be used.</p>
<p>C++ offers a set of library-defined exceptions for error conditions that may be detected by checks that are performed by the standard library. In addition, the programmer may define exceptions that are appropriate for their application. These exceptions are handled using an exception handler. Exceptions may be handled in the environment where the exception occurs or may be propagated out to an enclosing scope. Exceptions that are never handled in the program result in abnormal termination of the application. In this case, it is implementation-defined whether the destruction of local objects (stack unwinding) occurs. An unhandled exception that occurs in a thread also results in the abnormal termination of the application. See 6.62 Concurrency - Premature Termination [CGS] for issues related to thread or process termination. An exception propagating out of a coroutine causes the coroutine to end in an unresumable state and the exception is not further propagated.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.36.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ developers can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 subclause 6.36.5;</p></li>
<li><p>Develop an error management strategy, including error-detection, error-reporting, and error-handling,that, based on context, selects the most appropriate mechanism(s) from the different ones provided by C++;</p></li>
<li><p>Develop an error management strategy, including error-detection, error-reporting, and error-handling that selects the most appropriate mechanism(s), depending on the context, from the different ones provided by C++;</p></li>
<li><p>Prohibit error handling based on unsynchronized global state;</p></li>
<li><p>Avoid the use of <code class="sourceCode cpp">errno</code>, but if it cannot be avoided, follow the avoidance mechanisms of ISO/IEC TR 24772-3 subclause 6.36.2;</p></li>
<li><p>Use static analysis tools to detect and report missing or ineffective error detection or handling;</p></li>
<li><p>Use <code class="sourceCode cpp">[[<span class="at">nodiscard</span>]]</code> to prevent callers from ignoring error values and configure your compiler to report violations as errors, such as <code>-Werror</code>;</p></li>
<li><p>Use a <code class="sourceCode cpp"><span class="cf">try</span>-<span class="cf">catch</span></code> function body for <code class="sourceCode cpp">main</code> or any thread-entry function with a <code class="sourceCode cpp"><span class="cf">catch</span>(...)</code> handler to guarantee stack unwinding, which guarantees the destruction of all local objects and permits control of the ultimate termination of the thread or program;</p></li>
<li><p>Use a <code class="sourceCode cpp"><span class="cf">try</span>-<span class="cf">catch</span></code> body for a coroutine with a <code class="sourceCode cpp"><span class="cf">catch</span></code> handler to prevent silent termination of the coroutine in the case of an exception, or alternatively use a coroutine type that properly supports the case where the coroutine ends with an exception;</p></li>
<li><p>Consider controlled termination as a last resort strategy for <code class="sourceCode cpp">main</code> or for <code class="sourceCode cpp"><span class="kw">noexcept</span></code> functions;</p></li>
<li><p>Consider the use of <code class="sourceCode cpp"><span class="bu">std::</span>exception_ptr</code> or an object encapsulating its mechanics like <code class="sourceCode cpp"><span class="bu">std::</span>future</code> to transport an exception from one thread to another thread for further processing.</p></li>
</ul>
<h2 id="AMV">6.37 Type-breaking Reinterpretation of Data [AMV]</h2>
<h3 id="applicability-to-language">6.37.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO IEC 24772-1 clause 6.37 applies to C++. The language mechanisms where type-breaking reinterpretation of data can happen involve unions and <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code>. <!-- reinterpret cast only between pointer and int --> For type-breaking reinterpretation involving pointers or references see <a href="#HFC">6.11 Pointer Type Conversions [HFC]</a>.</p>
<p>In C++, the issue of casting vulnerabilities are mitigated by the fact that the C++ named casts, i.e., <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>, <code class="sourceCode cpp"><span class="kw">const_cast</span></code>, <code class="sourceCode cpp"><span class="kw">static_cast</span></code>, <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code>, and <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code>, are easily identified, e.g., by text search for more careful review. C-style casts do not share this property and therefore should be prohibited. In addition, C++ named casts include some compile-time checks, and in the case of dynamic_cast run-time checks, that help avoid some but not all vulnerabilities.</p>
<p>Of the available "_cast" operations, only <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code> provides reinterpretation of data values, and only <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> allow the reintepretation of data as a different type within limits. For uses of <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> see <a href="#HFC">6.11 Pointer Type Conversions [HFC]</a>. The named casts <code class="sourceCode cpp"><span class="kw">static_cast</span></code>, <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code>, and <code class="sourceCode cpp"><span class="kw">const_cast</span></code> perform type conversions and not reintepretation of bits and thus don’t have this vulnerability but are subject to potential conversion errors (see <a href="#FLC">6.6 Conversion Errors [FLC]</a>).</p>
<p>Reading a union member that was not previously written is undefined behaviour <a href="#EWF">[EWF]</a> except for a few cases described by ISO/IEC 14882:2020 clause [class.mem.general]. The reinterpretation of data values via different union members that is common practice in C is undefined behaviour in C++. The type <code class="sourceCode cpp"><span class="bu">std::</span>variant</code> provides a similar mechanism to union but prevents reading an inactive member.</p>
<p>If there is no value of the target type corresponding to the bit representation of the source type’s value, using <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code> is undefined behaviour, such as in the following example.</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> E { one, two, four=<span class="dv">4</span> };</span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> x = <span class="bu">std::</span>bit_cast&lt;E&gt;(<span class="dv">42</span>); <span class="co">// 42 is not representable by E</span></span></code></pre></div>
<p>C++ also provides <code class="sourceCode cpp">&lt;type_traits&gt;</code>, such as <code class="sourceCode cpp"><span class="bu">std::</span>is_layout_compatible</code>, that can be used to ensure the legality of a specific <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code>.</p>
<p>A legacy means of “bit casting” is the use of <code>memcpy</code> to transfer the bytes of an object’s representation to another object of a different type. Except for cases that are well-defined with <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code>, such use of <code>memcpy</code> to reinterpret data values is undefined behaviour.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.37.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.37.5, and clauses <a href="#FLC">6.6 Conversion Errors [FLC]</a> and <a href="#HFC">6.11 Pointer Type Conversions [HFC]</a> of this document.</p></li>
<li><p>Prohibit casts that reinterpret data values.</p></li>
<li><p>Whenever possible use <code class="sourceCode cpp"><span class="bu">std::</span>variant</code> or a similar safe union type instead of <code class="sourceCode cpp"><span class="kw">union</span></code>.</p></li>
<li><p>Prefer <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code> over <code class="sourceCode cpp">memcpy</code> when reinterpreting the bit-representation of an object to a different type is unavoidable.</p></li>
<li><p>Use <code class="sourceCode cpp"><span class="bu">std::</span>is_layout_compatible</code>, and <code class="sourceCode cpp"><span class="bu">std::</span>is_trivially_copyable</code> and other <code class="sourceCode cpp">&lt;type_traits&gt;</code> to mitigate incorrect usage of <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code>.</p></li>
<li><p>Ensure through static analysis that no accidental type-breaking reinterpretation of data values occur.</p></li>
</ul>
<h2 id="deep-vs.-shallow-copying-yan">6.38 Deep vs. Shallow Copying [YAN]</h2>
<h3 id="applicability-to-language">6.38.1 Applicability to Language</h3>
<p>The vulnerability described in ISO/IEC TR 24772-1:2019 clause 6.38 exists in C++ and only arises in C++ when there is a mismatch between the type’s copy semantics and the programmer’s intent.</p>
<p>On the language level, reference semantics, that can lead to shallow copies, usually requires the use of pointer or reference types, however, an integral type can also have reference semantics, for example, when it is used as an index or as an operating system handle.</p>
<p>Such types with reference semantics are also called <em>pointer-like types</em> and they will suffer from the aliasing problematic of this vulnerability and additionally from potential dangling due to expired lifetime (<a href="#lifetime">4.4</a>) of referred objects (see <a href="#XYK">[XYK]</a>).</p>
<p>In general, relationship types with an immutable referent, such as a const-reference, do not suffer the deep vs. shallow copying semantics problem, unless mixed with relationship types with a mutable reference to the same object. However, the lifetime of a const referent is still an issue to manage (see <a href="#XYK">[XYK]</a>).</p>
<p>The standard library type <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr&lt;T&gt;</code> has shallow copy semantics when the managed type is non-const, but in contrast to other relationship types guarantees the lifetime of the referent.</p>
<p>Class types that have <em>relationship type</em> members will become <em>relationship types</em> themselves, unless the class provides deep copy semantics or disables it and manages the lifetime of the referred object (<em>manager type</em>). Such <em>relationship types</em> and <em>manager types</em> will refer to their referred/managed resources via a data member with reference semantics.</p>
<p>A <em>manager type</em> defines a non-empty, non-deleted destructor in addition to providing appropriate copy and move operations. Examples of a <em>manager types</em> are the standard library container types such as <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> that use pointers to the allocated space of their elements and copying a vector will also copy all contained elements not just the pointers. This management is achieved by replacing the compiler-provided copy-constructor and copy-assignment operator with implementations providing value semantics that perform the deep copy (<em>general manager</em>). An alternative to potentially expensive deep copies for <em>manager types</em> is the prevention of copying, either by defining move operations that transfer the ownership of a managed resources, like <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr</code> does (<em>unique manager</em>), or by preventing both copy and move operations (<em>scoped manager</em>), for example, by defining the move-assignment operator as deleted.</p>
<p>Without such replacement of copy and move operations a class type with <em>relationship type</em> members suffers from the potential confusion due to shallow copies. For example, the standard library types <code class="sourceCode cpp"><span class="bu">std::</span>span</code>, <code class="sourceCode cpp"><span class="bu">std::</span>string_view</code>, iterators, and the views of the standard ranges library are relationship types. Care must be taken to not only understand implications of their shallow copy semantics, but also about their validity depending on the lifetime of the referred ranges.</p>
<p>Using <em>relationship types</em> as function parameter types is usually safe, because language semantics guarantee the lifetime of parameter objects. Exceptions exists for thread functions and coroutines, where the initial calling context is not guaranteed to exist when parameters of relationship type are accessed.</p>
<p>Returning a relationship type from a function can be problematic, unless the lifetime of the referred object is clear. For example, returning a reference to a local variable will return a dangling reference (see <a href="#XYK">[XYK]</a> and <a href="#XYH">[XYH]</a>).</p>
<p>See also Core Guidelines C.20, C.22, C.32, C.67.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.38.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.38.5.</p></li>
<li><p>Use and create value types.</p></li>
<li><p>Consider <em>pointer-like types</em> only when the lifetime of the referent can be ensured, and</p>
<ul>
<li>when reference semantics is required, e.g., for side effects, or</li>
<li>when copying is prohibitively expensive.</li>
</ul></li>
<li><p>Be aware of <em>pointer-like types</em> and document the reference semantics of user-defined class types.</p></li>
<li><p>For <em>manager types</em>, define copy constructor, copy assignment operator, move constructor, move assignment operator, and their destructor appropriately.</p></li>
<li><p>Prefer value parameters to thread functions and coroutines.</p></li>
</ul>
<h2 id="memory-leak-and-heap-fragmentation-xyl">6.39 Memory Leak and Heap Fragmentation [XYL]</h2>
<h3 id="applicability-to-language">6.39.1 Applicability to language</h3>
<p>The memory leak vulnerability documented in ISO/IEC 24772-1:2024 clause 6.39 exists in C++, unless the programmer takes steps to avoid it. A leak occurs when an object whose lifetime (<a href="#lifetime">4.4</a>) has not ended but there are no more variables, pointers or references to that object.</p>
<p>See ISO/IEC TR 24772-3 for the vulnerabilities associated with the C functions <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code> and <code>free()</code>.</p>
<p>C++ has an additional vulnerability in that it provides multiple alternatives for allocation and deallocation.</p>
<p>Failing to match the deallocation to the corresponding allocation results in undefined behaviour <a href="#EWF">[EWF]</a>. For example, if an array <code class="sourceCode cpp"><span class="kw">new</span>[]</code> expression was used to allocate and create an array then array <code class="sourceCode cpp"><span class="kw">delete</span>[]</code> must be used for its destruction and release to avoid undefined behaviour.</p>
<p>C++ destructors allow <em>scope-based resource management</em> (RAII) (Note: - put in Terms and definitions) which mitigates memory leaks by automatically calling the destructor when the lifetime of an object ends, thereby providing the opportunity to release their memory. The standard library provides container classes that follow the <em>scope-based resource management</em> idiom for the management of memory resources. Additionally, the standard library provides the class templates <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr</code> and <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr</code> for managing heap-allocated objects.</p>
<p>Ignoring issues with constructors throwing exceptions during heap allocation with a <code class="sourceCode cpp"><span class="kw">new</span></code> expression can cause leaks. Using <em>smart pointers</em> through the factory functions <code class="sourceCode cpp"><span class="bu">std::</span>make_unique()</code> and <code class="sourceCode cpp"><span class="bu">std::</span>make_shared()</code> assists in avoiding memory leaks.</p>
<p>If using functions that manage memory using the C library mechanisms is unavoidable, wrapping such a pointer immediately into a specialization of <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr&lt;&gt;</code> that uses <code>free()</code> in its deleter object ensures that memory is correctly released when the <code>unique_ptr</code> is destroyed, for example:</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> free_deleter{</span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="kw">operator</span>()(T *p) <span class="at">const</span> {</span>
<span id="cb168-4"><a href="#cb168-4" aria-hidden="true" tabindex="-1"></a>     <span class="bu">std::</span>free(<span class="kw">const_cast</span>&lt;<span class="bu">std::</span>remove_const_t&lt;T&gt;*&gt;(p));</span>
<span id="cb168-5"><a href="#cb168-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb168-6"><a href="#cb168-6" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb168-7"><a href="#cb168-7" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb168-8"><a href="#cb168-8" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> unique_C_ptr=<span class="bu">std::</span>unique_ptr&lt;T,free_deleter&gt;;</span>
<span id="cb168-9"><a href="#cb168-9" aria-hidden="true" tabindex="-1"></a><span class="co">//...</span></span>
<span id="cb168-10"><a href="#cb168-10" aria-hidden="true" tabindex="-1"></a><span class="co">// abi::__cxa_demangle() returns a pointer to be released with free()</span></span>
<span id="cb168-11"><a href="#cb168-11" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="kw">auto</span> plain_demangle(<span class="dt">char</span> <span class="at">const</span> *name){</span>
<span id="cb168-12"><a href="#cb168-12" aria-hidden="true" tabindex="-1"></a>  unique_C_ptr&lt;<span class="dt">char</span> <span class="at">const</span>&gt; result {abi::__cxa_demangle(name,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>)};</span>
<span id="cb168-13"><a href="#cb168-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> result;</span>
<span id="cb168-14"><a href="#cb168-14" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Modern C++ provides a class hierarchy, <code class="sourceCode cpp"><span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource</code>, that contains advanced allocation strategies and removes the need for explicit allocation/deallocation from the programmer, as shown below.</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;array&gt;</span></span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstdlib&gt;</span></span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory_resource&gt;</span></span>
<span id="cb169-5"><a href="#cb169-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb169-6"><a href="#cb169-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb169-7"><a href="#cb169-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-8"><a href="#cb169-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main()</span>
<span id="cb169-9"><a href="#cb169-9" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb169-10"><a href="#cb169-10" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb169-11"><a href="#cb169-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-12"><a href="#cb169-12" aria-hidden="true" tabindex="-1"></a>array&lt;<span class="bu">std::</span>byte, <span class="dv">200&#39;000</span>&gt; buf;</span>
<span id="cb169-13"><a href="#cb169-13" aria-hidden="true" tabindex="-1"></a>pmr::monotonic_buffer_resource pool{buf.data(), buf.size()};</span>
<span id="cb169-14"><a href="#cb169-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-15"><a href="#cb169-15" aria-hidden="true" tabindex="-1"></a>pmr::vector&lt;pmr::string&gt; v{&amp;pool};</span>
<span id="cb169-16"><a href="#cb169-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i != <span class="dv">1000</span>; ++i)</span>
<span id="cb169-17"><a href="#cb169-17" aria-hidden="true" tabindex="-1"></a>v.emplace_back(<span class="st">&quot;yet another longer string&quot;</span>);</span>
<span id="cb169-18"><a href="#cb169-18" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>When using C++ allocators that are not derived from <code class="sourceCode cpp"><span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource</code> or are not part of an allocator provided by a library, care is needed to avoid vulnerabilities due to memory leaks due to issues in allocator code.</p>
<p>The library functions <code class="sourceCode cpp"><span class="bu">std::</span>construct_at()</code> and <code class="sourceCode cpp"><span class="bu">std::</span>destroy_at()</code> are simpler than and preferrable to <em>placement new</em> and destructor calls.</p>
<p>STOPPED HERE.</p>
<p>ISSUES WITH SHARED_PTR AND weak ptr or <code class="sourceCode cpp"><span class="bu">std::</span>make_shared()</code>.</p>
<p>A <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr&lt;T&gt;</code> is a reference-counted pointer to type <code>T</code>. Several shared_ptr objects can own the same object. An owned object is destroyed when the last shared_ptr that owns it is destroyed or otherwise released. A memory-leak vulnerability can occur when using shared pointers for data structures such as a doubly-linked list. In such circumstances the reference count can never drop to zero unless addition measures are taken, such as breaking the cycle using a weak pointer. (EXAMPLE HERE?)</p>
<p><More discussion needed for below></p>
<p>In a concurrent context, the issues associated with access to data structures through <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr</code> and <code class="sourceCode cpp"><span class="bu">std::</span>weak_ptr</code> are complicated by concurrent access to such structures. If shared pointers are being used in a concurrent context, locking is required in order to manage concurrent access to a single object.</p>
<p>In a concurrent context, <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr</code> (and <code class="sourceCode cpp"><span class="bu">std::</span>weak_ptr</code>) store a pointer to the owned object and the associated control block.</p>
<p><code class="sourceCode cpp"><span class="bu">std::</span>atomic&lt;<span class="bu">std::</span>shared_ptr&lt;T&gt;&gt;</code> and <code class="sourceCode cpp"><span class="bu">std::</span>atomic&lt;<span class="bu">std::</span>weak_ptr&lt;T&gt;&gt;</code> so that exclusive access to the pointer can be guaranteed.</p>
<p>Using <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr()</code> can cause memory leaks if it is used to create a cyclic data structure that is not internally connected using weak pointers. Y_shr -&gt; A -&gt; B -&gt; C -&gt; A X_shr -&gt; A shared_ptr differentiates between ownership and reference to A <code class="sourceCode cpp">Shared_ptr</code> is a smart pointer that retains shared ownership f an object through a pointer. Shared_ptr can also own zero objects. A weak_ptr is a smart pointer that holds a non-owning reference to an object that is managed by shared_ptr. A weak_ptr must be converted to a shared_ptr in order to access the referenced object.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.39.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Apply the avoidance mechanism of ISO/IEC 24772-1:2024 6.39.5</p></li>
<li><p>Refrain from using the C functions <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code> and <code>free()</code> wherever possible.</p></li>
<li><p>Avoid mixing C-based functions and C++ memory management functions.</p></li>
<li><p>Prefer C++ allocators that are derived from <code class="sourceCode cpp"><span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource</code>.</p></li>
<li><p>Prefer containers standard library containers over other forms of memory management.</p></li>
<li><p>Use smart pointers and their factory functions to allocate and manage heap memory.</p></li>
<li><p>For heap fragmentation issues, use special memory resource objects with appropriate allocation strategies.</p></li>
<li><p>If using <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr</code> in potentially cyclic data structures, break cycles using <code class="sourceCode cpp"><span class="bu">std::</span>weak_ptr</code>.</p></li>
<li><p>Use static analysis to prevent uses of C-library memory management functions and direct calls to operators <code class="sourceCode cpp"><span class="kw">new</span></code> and <code class="sourceCode cpp"><span class="kw">delete</span></code>.</p></li>
<li><p>Use dynamic analysis to detect memory leaks and issues with heap fragmentation.</p></li>
</ul>
<h2 id="SYM">6.40 Templates and Generics [SYM]</h2>
<h3 id="applicability-to-language">6.40.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1 clause 6.40 exists in C++. C++ provides the facility <em>Templates</em> to support the generic programming methodology.</p>
<p>C++ provides templates for functions, classes(types), and variables (constants). In addition one can form alias templates for class templates. Template parameters can be types, values (including addresses of global variables), and templates. C++ Templates can have variadic template parameters, that mean any number of arguments of a given kind can be used. Concepts are templates that describe constraints on template arguments and can be used to define template parameters or other deduced contexts.</p>
<p>At compile-time, templates are instantiated with concrete template arguments. Function templates as well as class template constructors can deduce the concrete template argument from the types of the function arguments used in a call. For class templates in addition to the implicit deduction guides provided by its constructors, explicit deduction guides can be specified. This mechanism of template-argument deduction allows one to use templates without explicitly mentioning a template argument for each template parameter. For class templates, only those member functions get instantiated that are actually used. Each template instantiation is checked for syntax, concept and type errors.</p>
<p>Each instantiation of a template is compiled separately, which can cause different instantiations from the same original source code to call different actual functions because of overload resolution.</p>
<p>When comes the time for instantiation of a template, there can be different speciations that match the template arguments. There is an ranking of the different (partial) speecializations that the compiler uses for selection. In case of ambiguities, the compiler will fail. This ranking can be influenced by <em>Concepts</em> and <em>SFINAE</em> (Substitution Failure Is Not An Error). If the chosen specialization compiles but behaves differently than expected, this can be a source of programmer confusion.</p>
<p><strong>To Be Continued 2 Oct 2023</strong> Templates add another level of complexity to overload resolution.</p>
<p>In case of a function overload set that includes function templates, overload resolution happens before template specialization. This means, any desired behaviour through explicit function template specialization is not considered during overload resolution, only the primary template is used there.</p>
<p>Class template and variable template specializations can provide specific code for a given set of template arguments. Such specializations must be defined in the namespace of the primary template. To prevent confusion and different compilation of identical looking template instantiations, a specialization should either be defined in the same file as the generic template, or in case of a specialization for a specific template argument type, in the file of the definition of that type.</p>
<p>Functions and lambdas that define parameters with the use of <code class="sourceCode cpp"><span class="kw">auto</span></code> are implicitly templates without using the <code class="sourceCode cpp"><span class="kw">template</span></code> keyword.</p>
<p>Variables defined with the use of <code>auto</code> keyword get their concrete type deduced from their initializer, as if they were function template parameters.</p>
<p>A constructor template or assignment operator template is never a copy or move operation and hence does not prevent the implicit definition of a copy or move operations even if it looks similar.</p>
<p>Due to the two phase compilation model of templates, name lookup can be surprising in class templates with dependent base classes. A name used in the derived class that is defined in the base might be found in an outer namespace instead.</p>
<pre><code>double foo{0};
template &lt;typename T&gt; 
struct base {
    int foo;
};
template &lt;typename T&gt; 
struct d : base&lt;T&gt;{
auto bar() {
return foo; // matches global foo not base&lt;T&gt;::foo [1]
}
};</code></pre>
<p>In the above example line [1], in place of <code>foo</code>, either <code class="sourceCode cpp"><span class="kw">this</span>-&gt;foo</code> or the fully qualified name <code class="sourceCode cpp">d::foo</code> would refer to the member of the base class.</p>
<p>When used appropriately, templates are suitable for embedded and safety critical systems;</p>
<ul>
<li>They provide type-safe generics in contrast to legacy <code class="sourceCode cpp"><span class="dt">void</span> *</code>-based or macro-based genericity;</li>
<li>They have no runtime overhead;</li>
<li>They do not have any implicit run-time memory usage; and</li>
<li>They do not generate code for unused operations.</li>
</ul>
<p>While using template greatly increases type safety, there can be requirements on template arguments that can neither be specified by concepts nor checked by a compiler. For example, sorting elements requires the comparison function to provide a <em>strict weak ordering</em> which is a property of the values of the type to be sorted by which are impossible to check at compile time for all possible value combinations.</p>
<p>C++ provides means to restrict template arguments. One is to use concepts, that can prevent instantiating a template, but allow for substituting it with an alternative. A second means is to use <code class="sourceCode cpp"><span class="kw">static_assert</span></code> in a template’s definition to prevent certain instantiations.</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> wrapper {</span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a>T x;</span>
<span id="cb171-4"><a href="#cb171-4" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span>(<span class="kw">not</span> (<span class="bu">std::</span>is_pointer_v&lt;T&gt; || <span class="bu">std::</span>is_reference_v&lt;T&gt;));</span>
<span id="cb171-5"><a href="#cb171-5" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb171-6"><a href="#cb171-6" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb171-7"><a href="#cb171-7" aria-hidden="true" tabindex="-1"></a>wrapper(T )-&gt;wrapper&lt;T&gt;;</span>
<span id="cb171-8"><a href="#cb171-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb171-9"><a href="#cb171-9" aria-hidden="true" tabindex="-1"></a>wrapper&lt;<span class="dt">int</span>&gt; w{<span class="dv">42</span>};</span>
<span id="cb171-10"><a href="#cb171-10" aria-hidden="true" tabindex="-1"></a>wrapper x{&amp;w}; <span class="co">// compile error due to static_assert</span></span>
<span id="cb171-11"><a href="#cb171-11" aria-hidden="true" tabindex="-1"></a>wrapper&lt;<span class="dt">int</span>&amp;&gt;{}; <span class="co">// compile error due to static_assert</span></span></code></pre></div>
<p>The generic nature of templates require a more elaborate approach to unit tests. Such tests should provide instantiations of the base template and all provided explicit template specializations to ensure that each code path is actually tested. Tests for non-compilability of suppressed instantiations, i.e., through concepts or static_assert, are also beneficial.</p>
<p>Templates allow to reduce the amount of boilerplate code to write, e.g., by providing consistent definitions of operators. However, defining operator function templates in namespace scope can greatly influence compile times due to potential participation in the overload set, whenever the operator is used in code. In addition such generic operator functions might be picked up in inappropriate places causing programmer confusion. Implementing them as hidden friends in a CRTP base class instead makes using operator function templates feasible (see <a href="#YOW">6.20 Identifier Name Reuse [YOW]</a>).</p>
<pre><code>template &lt;typename T&gt;
struct Plus {
friend constexpr auto operator+(T l, T const &amp;r) {
  return l += r;
}
};
struct Int: Plus&lt;Int&gt; {
constexpr auto operator+=(Int const &amp;r) {
  val += r.val;
  return *this;
}
constexpr Int(int v):val{v}{}
int val;
};
struct Short: Plus&lt;Short&gt; {
constexpr auto operator+=(Short const &amp;r) {
  val += r.val;
  return *this;
}
constexpr Short(short v):val{v}{}
short val;
};
auto x = Int{4} + Int{38};
auto y = Short{4} + Short{2};</code></pre>
<pre><code>&lt;!--

(*We may wish to summarize)*
--&gt;</code></pre>
<h3 id="avoidance-mechanisms-for-language-users">6.40.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 subclause 6.40.5. and the guidance provided in the different related sections of this document.</p></li>
<li><p>Use <code>static_assert</code> to prevent the use of inappropriate template arguments.</p></li>
<li><p>Consider using <em>concepts</em> to constrain template parameters.</p></li>
<li><p>Prefer <em>concepts</em> over <em>SFINAE</em>.</p></li>
<li><p>Be aware that a constructor template or assignment operator function template will not replace compiler-provided special member functions.</p></li>
<li><p>For generic operator functions, consider providing them as hidden friends through mix-in class templates.</p></li>
<li><p>Use <em>qualified-id</em> or <code class="sourceCode cpp"><span class="kw">this</span>-&gt;</code> to refer to names that may be found in a dependent base class.</p></li>
<li><p>For template specialization, ensure that specializations are declared as follows:</p>
<ol type="1">
<li><p>In the same file as the primary template; or</p></li>
<li><p>In the same file as the user-defined type for which the specialization is declared.</p></li>
</ol></li>
<li><p>Prohibit specializing function templates.</p></li>
</ul>
<h2 id="RIP">6.41 Inheritance [RIP]</h2>
<h2 id="applicability-to-language">6.41.1 Applicability to language</h2>
<p>The vulnerability as described in ISO/IEC 24772-1:2024 6.41 is applicable to C++.</p>
<p>In C++, inheritance is defined differently than in most other languages that support inheritance, e.g.: - There is no implicit common base class. - Defining a member with a name that is defined in a base class causes hiding the base class member in the derived class including all overloads with that name. (Full qualification via the base class name is required to access these hidden members.) - Dynamic polymorphism requires the use of references or pointers. - Private virtual member functions can be overridden in derived classes.</p>
<p>A vulnerability similar to namespace issues (see [BJL]) can arise if a new <em>final overrider</em> is defined in one of multiple parents, which can result in a silent change to the semantics of an existing program, as shown in the following example.</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A {</span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> foo ();</span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb174-4"><a href="#cb174-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-5"><a href="#cb174-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> B : <span class="kw">virtual</span> A { };</span>
<span id="cb174-6"><a href="#cb174-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-7"><a href="#cb174-7" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> C : <span class="kw">virtual</span> A {</span>
<span id="cb174-8"><a href="#cb174-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> foo () <span class="kw">override</span>; <span class="co">// late addition</span></span>
<span id="cb174-9"><a href="#cb174-9" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb174-10"><a href="#cb174-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-11"><a href="#cb174-11" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> D : B, C </span>
<span id="cb174-12"><a href="#cb174-12" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb174-13"><a href="#cb174-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> bar () {</span>
<span id="cb174-14"><a href="#cb174-14" aria-hidden="true" tabindex="-1"></a>        foo ();  <span class="co">// calls the late addition</span></span>
<span id="cb174-15"><a href="#cb174-15" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb174-16"><a href="#cb174-16" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div>
<p>The implementation of virtual member functions does not take access into account. This can lead to a potentially surprising situation where a virtual function overrides an otherwise inaccessible base class function. This is quite different than the situation for non-virtual private member functions, which cannot be accessed from outside the declaring class or any <code class="sourceCode cpp"><span class="kw">friend</span></code>s.</p>
<p>Inheriting from a non-polymorphic base class can be used to implement <em>adaptor</em> types, i.e., by limiting or extending the base’s functionality. Using private inheritance can prevent treating the derived type object as a base type object. Multiple inheritance adds an additional dimension since a class can inherit the same base class <code>A</code> indirectly via different direct base classes and can result in multiple base class sub-objects of type <code class="sourceCode cpp">A</code>, which can result in ambiguous code.</p>
<p>If all classes in a multiple inheritance hierarchy that directly inherit from <code>A</code> use the keyword <code class="sourceCode cpp"><span class="kw">virtual</span></code> when inheriting from <code>A</code>, there will be only one base class sub-object of type <code>A</code> in the most derived object. Inconsistently inheriting from <code>A</code> with and without <code>virtual</code> is confusing, because multiple base objects of type <code>A</code> exist. Even when an ambiguity does not currently exist, refering to a base class member using its qualified name reduces the chance that a future modification silently changes the program’s behaviour through accessing a different member with the same name.</p>
<p>In C++, a name declared in a virtual base and inherited multiple times but hidden on any virtual path is considered to be hidden on all virtual paths. Consequently, a hiding declaration introduced later will silently alter the semantics of code refering to this name. The vulnerability does not arise if a multiply-inherited name is found on at least one non-virtual inheritance path, since the use of the name is diagnosed as ambiguous.</p>
<p>C++ favours value-semantics for copy and move operations as well as destruction that conflicts with object-oriented polymorphic behaviour.</p>
<ul>
<li><p><strong>Virtual Destructor</strong>: Base classes that define virtual member functions will need to also define a virtual destructor and in addition need to care about the copy and move operations, otherwise deleting a dynamically-allocated derived object via a base class pointer will cause undefined behaviour <a href="#EWF">[EWF]</a>.</p></li>
<li><p><strong>Slicing</strong>: A common failure is to not eliminate implicitly callable copy and move operations in base classes that can lead to accidental copying of a base class sub-object via a base class reference that actually refers to a derived object. Preventing implicit copy and move operations in base classes defining virtual member functions is a common mitigation.</p></li>
<li><p><strong>Incomplete Copy</strong>: When a derived class defines its own non-defaulted, non-deleted copy or move operations, care must be taken to actually copy and move all base class sub-objects as well. Omitting a base class when defining copy or move constructors means the default construction of a base class object happens. Not invoking a base class assignment in the definition of copy and move assignment operators will cause the base class retaining its previous members and not obtaining the source object’s base members. None of these omissions are a compile error and none are an issue for empty bases.</p></li>
</ul>
<p>If a “using-declaration” refers to a constructor of a direct base class, all constructors of that base are candidates for the initialization of the derived class. If a base class constructor is selected to initialize the derived type, any other bases or members of the derived type will be initialized as if by an <code>= default</code> default constructor. This can leave some members uninitialzed, that can result in undefined behaviour.</p>
<p>If a using-declaration refers to a protected member of a base class, its accessibility can be changed, which destroys the encapsulation of the member.</p>
<p>If a base class overloads <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">new</span></code> and <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">delete</span></code>, any derived classes will inherit those operations. If the base class’ <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">new</span></code> and/or <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">delete</span></code> assume the size of the objects being allocated are all the size of the base class and they are not all the same size, then this can result in undefined behaviour.</p>
<p>The mechanisms of failure from ISO/IEC 24772-1:2024 clause 6.41 can be mitigated in C++ as follows:</p>
<ul>
<li><p><em>Execution of malicious redefinitions</em> can be prevented by use of <code class="sourceCode cpp"><span class="kw">final</span></code> on each member function to generate compiler diagnostics when overriding is not permitted.</p></li>
<li><p><em>Accidental redefinition</em> can be mitigated by a project mandate to use the <code class="sourceCode cpp"><span class="kw">override</span></code> or <code class="sourceCode cpp"><span class="kw">final</span></code> special identifiers when overriding a virtual member functions.</p></li>
<li><p><em>Accidental failure of redefinition</em> can be prevented by using <code>override</code> on each member function intended to be redefined to generate compiler diagnostics when overriding does not apply.</p></li>
<li><p><em>Breaking of class invariants</em> can be avoided by proper initialization even with the default constructor and by defining data members private to ensure that the functions with the appropriate functionality are called and thus class invariants are preserved. If copy and move operations are user-defined in a derived class they must ensure to call the corresponding base class operations.</p></li>
</ul>
<h2 id="avoidance-mechanisms-for-language-users">6.41.2 Avoidance mechanisms for language users</h2>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li>Apply the avoidance mechanisms of ISO/IEC 24772-1 clause 41.5.</li>
<li>Avoid multiple inheritance.</li>
<li>Ensure that shallow-copying or shallow-move of inheritance hierarchies cannot occur, e.g. by defining the appropriate member operation <code class="sourceCode cpp">=<span class="kw">delete</span></code> (see clause 6.38 Deep vs. Shallow Copying [YAN]).</li>
<li>If the implementation of copy-operations or move-operations in a derived class is mandatory, then statically ensure that all calls are to the corresponding base classes’ operations.</li>
<li>Prefer composition over inheritance.</li>
<li>Keep inheritance hierarchies shallow.</li>
<li>Avoid the use of virtual member functions unless unbounded run-time polymorphism can be justified.</li>
<li>If a class has any virtual functions, ensure it has a virtual destructor.</li>
<li>Use the special identifier <code class="sourceCode cpp"><span class="kw">override</span></code> whenever overriding a virtual member function.</li>
<li>Use the special identifier <code class="sourceCode cpp"><span class="kw">final</span></code> to prevent an unexpected overriding of that function deeper in the hierarchy.</li>
<li>Require the use of <code class="sourceCode cpp"><span class="kw">final</span></code> or <code class="sourceCode cpp"><span class="kw">override</span></code> when overriding a member function.</li>
<li>Do not assume that a private virtual function cannot be overridden.</li>
<li>Consider using fully-qualified names to address members of a base class.</li>
<li>When defining an overload that hides overloads in a base class, consider adding a <em>using declaration</em> for the name from the base class.</li>
<li>Avoid the use of using-declarations that refer to constructors in types where default initialization is not appropriate for base classes of the derived type or members of the derived type.</li>
<li>Avoid using a “using-declaration” to promote the accessability of a base class member.</li>
<li>Prohibit mixing virtual and non-virtual inheritance of the same base class in a hierarchy.</li>
<li>Preserve class invariants and declare all class members as <code class="sourceCode cpp"><span class="kw">protected</span></code> or <code class="sourceCode cpp"><span class="kw">private</span></code> whenever appropriate.</li>
<li>Use static analysis tools, including compilers from different sources, to:
<ul>
<li>detect hiding of member names in virtual base classes, and</li>
<li>identify methods that are accidentaly turned into overrides when equally-named methods are added to parents.</li>
</ul></li>
</ul>
<h2 id="BLP">6.42 Violations of the Liskov Substitution Principle or the Contract Model [BLP]</h2>
<h3 id="applicability-to-language">6.42.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC 24772-1 clause 6.42 applies to C++. C++ leaves verification of the correctness of an overridden call to the programmer.</p>
<p>The vulnerability can be mitigated by a style of programming that uses wrapper functions to check preconditions, calls a virtual function to perform the required functionality and subsequently checks the postconditions before returning.</p>
<p>An example is provided below.</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Base  {</span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">private</span>:</span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a>     <span class="kw">virtual</span> <span class="dt">int</span> function_to_override( <span class="dt">int</span> x ) = <span class="dv">0</span>;</span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">// ...</span></span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-6"><a href="#cb175-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span>:</span>
<span id="cb175-7"><a href="#cb175-7" aria-hidden="true" tabindex="-1"></a>     <span class="dt">int</span> interface_to_overridden_function( <span class="dt">int</span> x ) {</span>
<span id="cb175-8"><a href="#cb175-8" aria-hidden="true" tabindex="-1"></a>           check_preconditions( x );</span>
<span id="cb175-9"><a href="#cb175-9" aria-hidden="true" tabindex="-1"></a>           <span class="at">const</span> <span class="kw">auto</span> saved = data_saved_for_postcondition( x );</span>
<span id="cb175-10"><a href="#cb175-10" aria-hidden="true" tabindex="-1"></a>           <span class="kw">auto</span> result = function_to_override( x );</span>
<span id="cb175-11"><a href="#cb175-11" aria-hidden="true" tabindex="-1"></a>           check_postconditions( x, saved, result );</span>
<span id="cb175-12"><a href="#cb175-12" aria-hidden="true" tabindex="-1"></a>           <span class="cf">return</span> result;</span>
<span id="cb175-13"><a href="#cb175-13" aria-hidden="true" tabindex="-1"></a>         }</span>
<span id="cb175-14"><a href="#cb175-14" aria-hidden="true" tabindex="-1"></a>     <span class="co">// ...      </span></span>
<span id="cb175-15"><a href="#cb175-15" aria-hidden="true" tabindex="-1"></a> };</span></code></pre></div>
<p>A future version of the C++ standard is expected to contain “contracts”, which formalize the notion of preconditions, postconditions and contract assertions.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.42.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Apply the avoidance mechanisms of ISO/IEC 24772-1 6.42.5</p></li>
<li><p>Use static analysis tools that identify violations of preconditions and postconditions.</p></li>
<li><p>Ensure that all invariants of a derived class are preserved by all public operations on its public base classes.</p></li>
</ul>
<blockquote>
<p>See also C++ Core Guidelines C.120, C.121, C.122, C.126, C.127, and C.129 through C.133.</p>
</blockquote>
<h2 id="redispatching-pph">6.43 Redispatching [PPH]</h2>
<h3 id="applicability-to-language">6.43.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.43 exists in C++ for virtual functions, except for constructors and destructors which are not dispatching. An example of the infinite recursion is:</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A {</span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A::f()</span><span class="sc">\n</span><span class="st">&quot;</span>; }</span>
<span id="cb176-6"><a href="#cb176-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> g() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A::g()</span><span class="sc">\n</span><span class="st">&quot;</span>; A::f(); }  <span class="co">//call to f() will not dispatch.</span></span>
<span id="cb176-7"><a href="#cb176-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> h() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A::h()</span><span class="sc">\n</span><span class="st">&quot;</span>; }</span>
<span id="cb176-8"><a href="#cb176-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> i() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A::i()</span><span class="sc">\n</span><span class="st">&quot;</span>; h(); } <span class="co">//call to h() will dispatch</span></span>
<span id="cb176-9"><a href="#cb176-9" aria-hidden="true" tabindex="-1"></a>                                                      <span class="co">//showing the vulnerability</span></span>
<span id="cb176-10"><a href="#cb176-10" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb176-11"><a href="#cb176-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-12"><a href="#cb176-12" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B : <span class="kw">public</span> A {</span>
<span id="cb176-13"><a href="#cb176-13" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb176-14"><a href="#cb176-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f() <span class="kw">override</span> { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;B::f()</span><span class="sc">\n</span><span class="st">&quot;</span>; g(); }</span>
<span id="cb176-15"><a href="#cb176-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> h() <span class="kw">override</span> { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;B::h()</span><span class="sc">\n</span><span class="st">&quot;</span>; i(); }</span>
<span id="cb176-16"><a href="#cb176-16" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb176-17"><a href="#cb176-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-18"><a href="#cb176-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main() {</span>
<span id="cb176-19"><a href="#cb176-19" aria-hidden="true" tabindex="-1"></a>    B b;</span>
<span id="cb176-20"><a href="#cb176-20" aria-hidden="true" tabindex="-1"></a>    A * pA = &amp;b;</span>
<span id="cb176-21"><a href="#cb176-21" aria-hidden="true" tabindex="-1"></a>    pA-&gt;f(); <span class="co">// no problem</span></span>
<span id="cb176-22"><a href="#cb176-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;---</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb176-23"><a href="#cb176-23" aria-hidden="true" tabindex="-1"></a>    pA-&gt;h(); <span class="co">// infinite recursion</span></span>
<span id="cb176-24"><a href="#cb176-24" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In C++, the call to a member function can be qualified, as shown in the above example, and avoids the vulnerability.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.43.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>At a call site, consider whether virtual dispatch is desired: if not, construct the call using the qualified name.</p></li>
<li><p>Be suspicious of any call from a virtual member function of the derived class to any member function of any of its base classes.</p></li>
</ul>
<h2 id="BKK">6.44 Polymorphic variables [BKK]</h2>
<h3 id="applicability-to-language">6.44.1 Applicability to language</h3>
<p>This vulnerability as described in ISO/IEC TR 24772-1:2019 applies to C++. In addition to the upcast and downcast issues addressed in that document, this clause also addresses cross-casting, which is unique to C++. For further type system related issues see subclause <a href="#IHN">Type System[IHN]</a>.</p>
<p>C++ provides language mitigations to help avoid the problems as follows:</p>
<p>Since C++ supports multiple inheritance, up-casting, down-casting, and cross-casting operations can be used to switch to different (pointer/reference) types in the inheritance hierarchy of a specific object, i.e.,</p>
<ul>
<li><p><em>up-casting</em> is casting an object to an ancestor type in the object's type inheritance hierarchy.</p></li>
<li><p><em>down-casting</em> is casting an object to a descendent type in the object's type inheritance hierarchy, and,</p></li>
<li><p><em>cross-casting</em> is casting an object to a sibling/cousin (possibly removed) type in the object's type inheritance hierarchy with multiple inheritance.</p></li>
<li><p>Unsafe casts, which include C-style casts and <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>, can cast to unrelated arbitrarily structured types. This allows reading and modifying arbitrary memory areas. See subclause [[6.11 Pointer Casting and Pointer Type Changes] [HFC](#HFC) for more details.</p></li>
</ul>
<blockquote>
<p>Developers should be aware that virtual member functions can be overridden in derived classes, even if they are private.</p>
</blockquote>
<p>Given the following:</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Z { <span class="dt">int</span> z; <span class="kw">virtual</span> ~Z() { } };</span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Y { <span class="dt">int</span> y; <span class="kw">virtual</span> ~Y() { } };</span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A : Z { <span class="dt">int</span> a; };</span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> B : <span class="kw">virtual</span> A { <span class="dt">int</span> b; };</span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> C : <span class="kw">virtual</span> A, Y { <span class="dt">int</span> c; };</span>
<span id="cb177-6"><a href="#cb177-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> D : B, C { <span class="dt">int</span> d; };</span>
<span id="cb177-7"><a href="#cb177-7" aria-hidden="true" tabindex="-1"></a>D d_inst;</span></code></pre></div>
<p>then these examples demonstrate upcasts, downcasts, and crosscasts:</p>
<p><strong>Upcasts:</strong></p>
<div class="sourceCode" id="cb178"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a>B* b_ptr = &amp;d_inst; <span class="co">// implicit</span></span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a>C&amp; c_ref = d_inst; <span class="co">// implicit</span></span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a>Z* z_ptr = <span class="kw">static_cast</span>&lt;Z*&gt;(&amp;d_inst);</span>
<span id="cb178-4"><a href="#cb178-4" aria-hidden="true" tabindex="-1"></a>Y* y_ptr = <span class="kw">dynamic_cast</span>&lt;Y*&gt;(&amp;d_inst);</span></code></pre></div>
<p><strong>Downcasts:</strong></p>
<div class="sourceCode" id="cb179"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a>D&amp; d_ref = <span class="kw">dynamic_cast</span>&lt;D&amp;&gt;(*y_ptr);</span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a>D* d_ptr = <span class="kw">static_cast</span>&lt;D*&gt;(b_ptr);</span></code></pre></div>
<p><strong>Crosscasts:</strong></p>
<div class="sourceCode" id="cb180"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a>C* c_ptr = <span class="kw">dynamic_cast</span>&lt;C*&gt;(b_ptr);</span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a>Y* y_ptr2 = <span class="kw">dynamic_cast</span>&lt;Y*&gt;(b_ptr);</span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a>C* c_ptr = <span class="kw">static_cast</span>&lt;C*&gt; (<span class="kw">static_cast</span>&lt;D*&gt;(b_ptr));</span></code></pre></div>
<p>and notes the following about such:</p>
<p>Upcasts:</p>
<ul>
<li><p>are the only ones that can be performed implicitly</p></li>
<li><p>can cause object slicing when a copy of a base class object is created from a derived class object.</p></li>
<li><p>can also be done with <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> or <code class="sourceCode cpp"><span class="kw">static_cast</span></code></p></li>
</ul>
<p>Downcasts</p>
<ul>
<li><p>are explicit;</p></li>
<li><p>can be done safely with <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code></p></li>
<li><p><code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> requires appropriate portions of inheritance to be polymorphic (i.e. has <code class="sourceCode cpp"><span class="kw">virtual</span></code> members);</p></li>
<li><p>can be done using <code class="sourceCode cpp"><span class="kw">static_cast</span></code> which is unchecked and may be unsafe;</p></li>
</ul>
<p>Crosscasts:</p>
<ul>
<li><p>are explicit</p></li>
<li><p>can be done safely with a single call to <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> which requires appropriate portions of inheritance to be polymorphic (i.e. has <code class="sourceCode cpp"><span class="kw">virtual</span></code> members).</p></li>
<li><p>can often be done with a chain of <code class="sourceCode cpp">static_casts</code> traversing the inheritance hierarchy, which is almost always unsafe.</p></li>
</ul>
<p>Deleting derived objects via a base class pointer is undefined behavior <a href="#EWF">[EWF]</a>, unless the base class declares a virtual destructor.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.44.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.44.5.</p></li>
<li><p>In a base class declaring virtual member functions, define a virtual defaulted destructor (Core Guidelines C.35) and make the class non-copyable (Core Guidelines C.130).</p></li>
<li><p>Avoid designs relying on downcasts or crosscasts; rely on proper virtual member functions in the base classes instead.</p></li>
<li><p>Avoid explicit upcast, rely on implicit conversion.</p></li>
<li><p>If a downcast or a crosscast is needed, prefer using <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> since it is checked.</p></li>
<li><p>Ensure that all invariants of a derived class are preserved by all public operations on its public base classes. If this cannot be ensured, make the base class private, or avoid inheritance.</p></li>
<li><p>Avoid attempting to navigate class hierarchies using C-style casts or <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>.</p></li>
<li><p>Prohibit deletion of a polymorphic object without a virtual destructor; including using <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr&lt;base&gt;</code> from a unique pointer allocated with <code class="sourceCode cpp"><span class="bu">std::</span>make_unique&lt;derived&gt;()</code></p></li>
</ul>
<blockquote>
<p>See also C++ Core Guidelines ES.48, ES.49, C.146, C.147, C.148 and C.153. source: OOP52-CPP?</p>
</blockquote>
<h2 id="LRM">6.45 Extra Intrinsics [LRM]</h2>
<h3 id="applicability-to-the-language">6.45.1 Applicability to the language</h3>
<p>The vulnerability as described in ISO/IEC 24772-1 clause 6.45 applies to C++ as explained below.</p>
<p>C++ implementations are allowed to provide built-in functionality but are restricted to a specific naming schema reserved by the standard. For example, names containing a double underscore or that begin with an underscore and a capital letter are reserved for that purpose. See ISO/IEC 14882 clause [Lex.name]. The use of such names by the programmer is forbidden by the language. Language processors are not required to prohibit such usage, hence the vulnerability exists.</p>
<p>The standard restricts definitions in reserved namespaces, such as <code>std</code> (see ISO/IEC 14882 clause [namespace.constraints]). In addition, specializing a template from namespace <code>std</code> is restricted (see ISO/IEC 14882 clause [namespace.std]) unless explicitly allowed, for example, see ISO/IEC 14882 clause [unord.hash].</p>
<h3 id="avoidance-mechanisms-for-program-users">6.45.2 Avoidance mechanisms for program users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li>Prohibit identifiers containing a double underscore <code>__</code>.</li>
<li>Avoid identifiers starting with <code>_</code>, except when used for a literal suffix.</li>
<li>Ensure user-defined literal suffixes start with a single <code>_</code>.</li>
<li>Prohibit the declaration of names in reserved namespaces.</li>
<li>Prohibit the specialization of a restricted template.</li>
<li>Use compiler warnings and static analysis tools to detect and report violations of the above.</li>
</ul>
<h2 id="argument-passing-to-library-functions-trj">6.46 Argument Passing to Library Functions [TRJ]</h2>
<h3 id="applicability-to-language">6.46.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.46 is applicable to C++.</p>
<p>Libraries that supply objects or functions are in most cases not required to check the validity of parameters passed to them. In those cases where parameter validation is required there might not be adequate parameter validation.</p>
<p>When calling a library, either the calling function or the library may make assumptions about parameters. For example, it may be assumed by a library that a parameter is non-zero so division by that parameter is performed without checking the value. Sometimes some validation is performed by the calling function, but the library may use the parameters in ways that were unanticipated by the calling function resulting in a potential vulnerability. Even when libraries do validate parameters, their response to an invalid parameter is usually undefined and can cause unanticipated results.</p>
<p>This vulnerability applies in particular to C++ libraries which are designed for high efficiency; responsibility for satisfying the preconditions for most functions rests with the caller. When these preconditions are not met, the result will be undefined behaviour <a href="#EWF">[EWF]</a>. In addition, error conditions are specified by the language for specific functions, such as raising an exception, returning an error code or a known value, such as NaN.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.46.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.47.5.</p></li>
<li><p>Use translation modes provided by the implementation to perform addition analysis or checking, such as contracts checks, or instrumentation of executing code.</p></li>
<li><p>Pay attention to the distinction between precondition violation and error conditions in library documentation: the former results in undefined behaviour; the latter results in defined but possibly unwanted behaviour.</p></li>
</ul>
<h2 id="inter-language-calling-djs">6.47 Inter-language Calling [DJS]</h2>
<h3 id="applicability-to-language">6.47.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.47 is applicable to C++.</p>
<p>C++ is a multi-paradigm language with a number of features that do not interface simply with other language systems. It is left to the implementation team the task of converting the results of these paradigms to constructs that can cross an interface for further processing in other languages.</p>
<p>C++ compilers provide an application binary interface (ABI) that delineates areas of interoperability with other languages or other C++ compiler/runtime systems. An ABI includes calling conventions, data layout, error and exception handling and return conventions, name mangling, data model, initialization of memory, and linkage to operating systems and libraries.</p>
<p>C++ compilers implement a C++ language linkage and a C language linkage. It is implementation-defined what other languages the implementation supports. Alternatively, other language systems provide linkages to C systems[^3](Ada has developed a standard for interfacing with C. Fortran has included a Clause 15 that explains how to call C functions.), leaving the developer the task of channeling everything through this common language system.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.47.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.47.5</p></li>
<li><p>Use standard layout types for the interoperable interfaces.</p>
<ul>
<li><pre><code>  Use language linkage facilities that support the languages being</code></pre>
<p>used.</p></li>
<li><pre><code>  EXP56-CPP. Do not call a function with a mismatched language</code></pre>
<p>linkage (-&gt; 6.47)</p></li>
<li><pre><code>  EXP60-CPP. Do not pass a nonstandard-layout type object across</code></pre>
<p>(-&gt; 6.47 ?)<br />
execution boundaries</p></li>
</ul></li>
<li><p>Be aware that the static initialization phase and dynamic initialization for every language system are required before the system begins execution</p></li>
<li><p>Be aware that C++ exceptions are not usually compatible with exceptions in other languages.</p></li>
<li><p>Segregate outgoing cross-language interfacing code into functions that present a C++ interface to the C++ code and implements that interface by calling code compatible with the other language system. Similarly implement incoming cross-language interfaces by providing simplified functions that presents a simplified (C or other language) interface and is implemented by calling C++ code with the correct style.</p></li>
<li><p>Separate the interfacing code from the code containing the main functionality</p></li>
</ul>
<p>See also the C++ Core Guidelines CPL.3.</p>
<p><em>AI 63-6 – group – add the guidance from 6.47.2 Interoperability into the Core Guidelines.</em></p>
<h2 id="NYY">6.48 Dynamically-linked Code and Self-modifying Code [NYY]</h2>
<h3 id="applicability-to-language">6.48.1 Applicability to language</h3>
<p>The vulnerability described in ISO/IEC 24772-1:2024 applies to C++. As for the C programming language, the process of linking and loading is outside the scope of the C++ standard.</p>
<p>In C++, the conversion of a function pointer to another type (to misdirect a pointer, for example) requires the use of a C-style cast or <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>. Such casts can result in unspecified behaviour, undefined behaviour or implementation-defined behaviour.</p>
<!-- The reflection mechanism introduced in the C++26 revision of the standard does not allow self-modifying code, because it is compile-time only. -->
<h3 id="avoidance-mechanisms-for-language-users">6.48.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.48.5 and ISO/IEC 24772-3 clause 6.48.2.</li>
<li>Follow the avoidance mechanisms of 6.11.2 Pointer type conversions [HFC].</li>
<li>Document and carefully review all uses of <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> or C-style casts.</li>
</ul>
<h2 id="NSQ">6.49 Library Signature [NSQ]</h2>
<h3 id="applicability-to-language">6.49.1 Applicability to language</h3>
<p>The vulnerability as enumerated in ISO/IEC 24772-1 clause 6.49 applies to C++.</p>
<p>As a mitigation, the C++ <code class="sourceCode cpp"><span class="at">extern</span> <span class="st">&quot;C&quot;</span></code> linkage specifier usually provides simple interoperability with libraries using the C application binary interface (ABI).</p>
<h3 id="avoidance-mechanisms-for-language-users">6.49.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.49.5.</p></li>
<li><p>Follow the avoidance mechanisms of clause <a href="#DJS">6.47 Inter-language Calling [DJS]</a> as applicable.</p></li>
</ul>
<h2 id="unanticipated-exceptions-from-library-routines-hjw">6.50. Unanticipated Exceptions from Library Routines [HJW]</h2>
<h3 id="applicability-to-language">6.50.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 clause 6.50 exists for C++. In particular the issue of the failing dynamic initialization of namespace-scope objects exists in C++.</p>
<p>When dynamic initialization of a namespace-scope object fails with an exception, the exception cannot be caught and the program is terminated. Function-scope static objects, in contrast, are initialized the first time execution passes through the declaration. Using function-scope static objects in preference to dynamic initialization ensures that there is always an enclosing function that could catch the exception.</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="dt">exception_prone_type</span> troubling_object;</span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a><span class="co">// An exception from the constructor could cause termination.</span></span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a><span class="co">// The following function always returns a reference to the same object,</span></span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a><span class="co">// which is initialized the first time this function is called.</span></span>
<span id="cb184-5"><a href="#cb184-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-6"><a href="#cb184-6" aria-hidden="true" tabindex="-1"></a><span class="co">// If initialization fails, it will be retried on the next call.</span></span>
<span id="cb184-7"><a href="#cb184-7" aria-hidden="true" tabindex="-1"></a><span class="dt">exception_prone_type</span>&amp; safer_object()</span>
<span id="cb184-8"><a href="#cb184-8" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb184-9"><a href="#cb184-9" aria-hidden="true" tabindex="-1"></a>   <span class="at">static</span> <span class="dt">exception_prone_type</span> the_safer_object;</span>
<span id="cb184-10"><a href="#cb184-10" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> the_safer_object;</span>
<span id="cb184-11"><a href="#cb184-11" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<h3 id="avoidance-mechanisms-for-language-users">6.50.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Expect functions not marked <code class="sourceCode cpp"><span class="kw">noexcept</span></code> to throw exceptions of arbitrary type, excluding all destructors, which are are implicitly <code class="sourceCode cpp"><span class="kw">noexcept</span></code>.</p></li>
<li><p>Follow the avoidance mechanisms of clause 6.36.2 for catching and handling exceptions.</p></li>
<li><p>Prefer function-scope static objects to namespace-scope objects for objects needing dynamic initialization.</p></li>
</ul>
<h2 id="NMP">6.51 Pre-processor Directives [NMP]</h2>
<h3 id="applicability-to-language">6.51.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.51 applies to C++.</p>
<p>The C++ pre-processor allows the use of macros that are text-replaced before compilation.</p>
<p>Function-like macros look similar to functions but have different semantics. Because the arguments are text-replaced, expressions passed to a function-like macro may be evaluated multiple times. This can result in unintended and undefined behaviour <a href="#EWF">[EWF]</a> if the arguments have side effects or are pre-processor directives. Additionally, the arguments and body of function-like macros should be fully parenthesized to avoid unintended and undefined behaviour.</p>
<p>The following code example demonstrates undefined behaviour when a function-like macro is called with arguments that have side-effects (in this case, the increment operator) .</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CUBE</span>(X)<span class="pp"> </span>((X)<span class="pp"> </span><span class="er">\</span>*<span class="pp"> </span>(X)<span class="pp"> </span><span class="er">\</span>*<span class="pp"> </span>(X))</span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i = <span class="dv">2</span>;</span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a = <span class="dv">81</span> / CUBE(++i);</span></code></pre></div>
<p>The above example could expand to:</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a = <span class="dv">81</span> / ((++i) * (++i) * (++i));</span></code></pre></div>
<p>which has undefined behaviour so this macro expansion is difficult to predict.</p>
<p>Another mechanism of failure can occur when the arguments within the body of a function-like macro are not fully parenthesized. The following example shows the CUBE macro without parenthesized arguments.</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CUBE</span>(X)<span class="pp"> </span>(X<span class="pp"> </span><span class="er">\</span>*<span class="pp"> </span>X<span class="pp"> </span><span class="er">\</span>*<span class="pp"> </span>X)</span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a = CUBE(<span class="dv">2</span> + <span class="dv">1</span>);</span></code></pre></div>
<p>This example expands to:</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a = (<span class="dv">2</span> + <span class="dv">1</span> * <span class="dv">2</span> + <span class="dv">1</span> * <span class="dv">2</span> + <span class="dv">1</span>)</span></code></pre></div>
<p>which evaluates to 7 instead of the intended 27.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.51.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Replace function-like macros with <code class="sourceCode cpp"><span class="kw">constexpr</span></code> inline functions where possible.</p></li>
<li><p>Replace normal macros with <code class="sourceCode cpp"><span class="kw">constexpr</span></code> variables where possible.</p></li>
<li><p>Replace conditional compilation with the preprocessor with <code class="sourceCode cpp"><span class="cf">if</span> <span class="kw">constexpr</span></code> where possible, e.g., in function bodies, including cases where compile-time define of a macro (as empty) controls if a macro definition is used to expand to an empty statement or another statement.</p></li>
<li><p>Replace preprocessor include directives with module <code class="sourceCode cpp"><span class="kw">import</span></code> where possible.</p></li>
<li><p>Prefer <code class="sourceCode cpp"><span class="bu">std::</span>source_location</code> mechanisms over employing macros that use <code class="sourceCode cpp"><span class="ot">__LINE__</span></code>, <code class="sourceCode cpp"><span class="ot">__FILE__</span></code>, or <code class="sourceCode cpp"><span class="ot">__func__</span></code>.</p></li>
<li><p>If a function-like macro must be used, ensure that its parameters and body are parenthesized.</p></li>
<li><p>In a function-like macro, ensure that each argument is evaluated at most once.</p></li>
<li><p>Prohibit embedding the following in a function-like macro: pre-processor directives; or side-effects such as an assignment, increment/decrement, volatile access, or function call.</p></li>
<li><p>Only use macros for <em>include guards</em>, to control conditional compilation, or when the macro’s definition requires token pasting (<code>##</code>.{.cpp}) or stringification (<code class="sourceCode cpp"><span class="er">#</span></code>) of macro arguments.</p></li>
<li><p>Prohibit the use of macro paramters that are used as argument for <code class="sourceCode cpp"><span class="pp">#</span><span class="er">#</span></code> or <code class="sourceCode cpp"><span class="er">#</span></code> in the macro.</p></li>
</ul>
<h2 id="suppression-of-language-defined-run-time-checking-mxb">6.52 Suppression of Language-defined Run-time Checking [MXB]</h2>
<h3 id="applicability-to-language">6.52.1 Applicability to language</h3>
<p>With the exception of the macro <code>assert</code>, the vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.52 does not apply to C++, because there is no language-defined runtime checking. Macro assert is defined by the standard but is invoked by the programmer, hence is not a language-defined check.</p>
<p>C++ libraries, however, often provide run-time checks which meet the criteria of this vulnerability. Also, compilers and other tools commonly provide means to perform such runtime checks.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.51.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.52.5 with respect to library and compiler-provided checks, which will almost always require the explicit enabling the checks.</p>
<h2 id="provision-of-inherently-unsafe-operations-skl">6.53 Provision of Inherently Unsafe Operations [SKL]</h2>
<h3 id="applicability-to-language">6.53.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC 24772-1:2019 clause 6.53 applies to C++. In particular, anything described by ISO/IEC 14882:2023 as “undefined behaviour” <a href="#EWF">[EWF]</a> is unsafe.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.53.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1:2024 and ISO/IEC TR 24772-3:2020 clause 6.53.5.</p></li>
<li><p>Enable checks that warn about unsafe operations.</p></li>
<li><p>Use static analysis tools to detect unsafe constructs.</p></li>
</ul>
<h2 id="BRS">6.54 Obscure Language Features [BRS]</h2>
<h3 id="applicability-of-language">6.54.1 Applicability of language</h3>
<p>The vulnerability as described in ISO/IEC 24772-1 clause 6.54 applies to C++.</p>
<p>C++ is a rich language and provides facilities for a wide range of application areas with a long history of evolution. The latter means that evolution of the language also means an evolution of best and safe practices. This means that code can look obscure, because it either uses obsolete or very modern language idioms.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.54.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.54.5.</p></li>
<li><p>Use static analysis tools or multiple compilers to help identify occurrences of obscure language features.</p></li>
</ul>
<h2 id="unspecified-behaviour-bqf">6.55 Unspecified Behaviour [BQF]</h2>
<h3 id="applicability-of-language">6.55.1 Applicability of language</h3>
<p>The vulnerability as described in ISO/IEC 24772-1:2019 clause 6.55 applies to C++.</p>
<p>In the following example, the value of <code class="sourceCode cpp">size</code> can be different than the length of <code class="sourceCode cpp">data</code> because the extent of <code class="sourceCode cpp">data</code> must be calculated at compile time but the calculation of <code class="sourceCode cpp">size</code> can be determined at compile time or executed at runtime, which is one source of unspecified behaviour.</p>
<pre><code>char data[1 + int(1 + 0.2 - 0.1 - 0.1)] = { }; // compile-time evaluation
int size = 1 + int(1 + 0.2 - 0.1 - 0.1);       // compile-time or run-time evaluation
char f() { return data[size-1];} // Possible buffer overflow</code></pre>
<h3 id="avoidance-mechanisms-for-language-users">6.55.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.55.5.</p></li>
<li><p>Use static analysis tools and multiple compilers/tools to help identify occurrences of unspecified behaviour.</p></li>
</ul>
<h2 id="EWF">6.56 Undefined Behaviour [EWF]</h2>
<h3 id="applicability-to-language">6.56.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC 24772-1 clause 6.56 applies to C++. In ISO/IEC 14882:2023, the terms “undefined behaviour” and “ill-formed, no diagnostic required” expose situations to be avoided.</p>
<p>For the special case of constant expressions, compilers are required to detect and reject undefined behaviour during the evaluation of constant expressions in the core language. It is unspecified whether or not undefined behaviour in the standard library is detected during constant expression evaluation.</p>
<p>C++ compilers and static analysis tools can often detect code that can lead to undefined behaviour and provide diagnostic messages to that effect. Use of multiple compiler tool chains during development increases the likelyhood that such behaviours will be detected. Similarly, runtime tools such as address sanitizers and thread sanitizers can be used during development to detect and report concrete instances of undefined behaviour. In addition, recent C++ language revisions have provided safer alternatives some standard library calls that can lead to undefined behaviours. For example,the calls <code class="sourceCode cpp"><span class="bu">std::</span>stoi</code> or <code class="sourceCode cpp"><span class="bu">std::</span>from_chars</code> provide equivalent functionality to <code class="sourceCode cpp"><span class="bu">std::</span>atoi</code> but without the the risk of undefined behaviour.</p>
<p>Code with UB often appears to work correctly but masks situations that can result in serious consequences, for example:</p>
<ul>
<li>Compilers optimize based on the assemed lack of UB, that can result in the incorrect pruning of code paths</li>
<li>Compiler (or tool chain) changes or updates can result in previously undetected UB’s being manifested with serious consequences.</li>
<li>If the impact of a UB is the overwriting of some memory location, non-obvious changes to the source code can result in a previously benign action now having serious consequences.</li>
<li>The impact of the UB often depends on additional factors, for example the available capacity of a container decides if memory needs to be reallocated.</li>
</ul>
<p>Undefined behaviour often manifests in code distant from where the UB occured, resulting in extremely hard to find bug. Therfore, retrospective detection of undefined behaviour is exceedingly difficult and resource intensive. Many undefined behaviour situations can be avoided through the use of explicit tests or assertions for undefined behaviour situations, such as null-pointer tests before assessing via a pointer, array-bounds checks before access to array members, and floating-integeral conversions that cannot be represented in the target type. Modern compilers can eliminate such tests when they know that the check will succeed.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.56.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.56.5.</p></li>
<li><p>Exploit compile-time evaluation whenever possible to detect undefined behaviour.</p></li>
<li><p>Use static analysis tools to help identify occurrences and consequences of undefined behaviour.</p></li>
<li><p>Use runtime tools such as ASAN (address sanitizer) and related tools.</p></li>
<li><p>Use multiple compilers/tools and different optimization levels to increase the chance of identifying constructs that have undefined behaviours.</p></li>
<li><p>Where the C++ language or library provide both defined behaviour mechanisms and undefined behaviour mechanisms, mandate the use the mechanisms with defined behaviours.</p></li>
<li><p>Explicitly test or use assertions for situations that can cause undefined behaviour.</p></li>
</ul>
<h2 id="implementation-defined-behaviour-fab">6.57 Implementation-defined Behaviour [FAB]</h2>
<h3 id="applicability-to-language">6.57.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC 24772-1:2019 clause 6.57 applies to C++. In ISO/IEC 14882, the term “implementation-defined” is used to describe implementation-defined behaviour. In addition, the C++ standard provides a dedicated index titled, “Index of implementation-defined behavior”.</p>
<p>In deciding whether or not to use a feature with implementation-defined behaviours, it is important be cognizant that:</p>
<ul>
<li><p>A given implementation may change or remove an implementation-defined behaviour; and</p></li>
<li><p>Programs that are specifically intended for a particular implementation may in the future be ported to another environment or sections reused for future implementations.</p></li>
</ul>
<p>In either situation, the implementation-defined behaviour will become problematic.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.57.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Apply the avoidance mechanisms of ISO/IEC 24772-1 clause 6.57.5.</p></li>
<li><p>Eliminate to the extent possible any reliance on implementation-defined behaviour from programs in order to increase portability.</p></li>
<li><p>Use multiple compilers/tools to increase the likelyhood of identifying constructs that have implementation-defined behaviours.</p></li>
<li><p>Refer to “Index of implementation-defined behavior” for the definitive list of C++ implementation-defined behaviours and understand the relevant compiler documentation for each of these behaviours.</p></li>
</ul>
<h2 id="deprecated-language-features-mem">6.58 Deprecated Language Features [MEM]</h2>
<h3 id="applicability-to-language">6.58.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC 24772-1 clause 6.58 applies to C++. Appendix D “Compatibility features” of ISO/IEC 14882:2024 enumerates the deprecated features. The C++ attribute <code class="sourceCode cpp">[[<span class="at">deprecated</span>]]</code> allows library writers and users to mark deprecated declarations.</p>
<p>Although backward compatibility is sometimes offered as an option for compilers so one can avoid changes to code to be compliant with current language specifications, updating the legacy software to the current standard is a better option.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.58.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Apply the avoidance mechanisms of ISO/IEC 24772-1 clause 6.58.5.</p></li>
<li><p>Enable compiler options or use static analysis tools that identify the use of deprecated features.</p></li>
<li><p>Apply the <code class="sourceCode cpp">[[<span class="at">deprecated </span>(<span class="st">&quot;*reason*&quot;</span>)]]</code> attribute to obsolete declarations that exist only for backward compatibility.</p></li>
</ul>
<h2 id="CGA">6.59 Concurrency – Activation [CGA]</h2>
<h3 id="applicability-to-language">6.59.1 Applicability to language</h3>
<p>The vulnerabilities as specified in ISO/IEC 24772-1 clause 6.59 do not apply to C++, as long as the standard library facilities for creating threads are used. If the C standard library mechanisms or threading libraries from POSIX or other applications are used to create threads, then the vulnerabilities apply as described in ISO/IEC 24772-3 clause 6.59. This subclause will examine the C++ standard mechanisms.</p>
<p>Creating a thread using the <code class="sourceCode cpp"><span class="bu">std::</span>async</code> function or the <code class="sourceCode cpp"><span class="bu">std::</span>thread</code> or <code class="sourceCode cpp"><span class="bu">std::</span>jthread</code> results in the constructor synchronized with the thread creation site. Unless the thread is detached, <code class="sourceCode cpp">join()</code> must be called when using <code class="sourceCode cpp"><span class="bu">std::</span>thread</code> or <code class="sourceCode cpp"><span class="bu">std::</span>terminate</code> will be invoked upon destruction of the thread object. This can be avoided by using <code class="sourceCode cpp"><span class="bu">std::</span>jthread</code> instead.</p>
<p>Failure to create or start a thread due to lack of system resources will cause an exception to be thrown to the creating thread thus the thread object never exists. For the vulnerabilities with unhandled exceptions see clause <a href="#OYB">6.36 Ignored error status and unhandled exceptions [OYB]</a>.</p>
<p>C++ provides other ways to create parallel executing functions via - the <code class="sourceCode cpp"><span class="bu">std::</span>async()</code> call or the <code class="sourceCode cpp"><span class="bu">std::</span>packaged_task()</code> functions; - Coroutines (describe and reference clause 7.5 and 7.6).</p>
<p>If <code class="sourceCode cpp"><span class="bu">std::</span>async()</code> threads are created without a launch policy, then system determines whether or not the thread is run lazily (in the current thread) or in a new thread. The launch policy <code class="sourceCode cpp"><span class="bu">std::</span>launch<span class="bu">::</span>async</code> or <code class="sourceCode cpp"><span class="bu">std::</span>launch<span class="bu">::</span>deferred</code> controls whether each asynch thread creation creates new threads or executes the call on demand. When a launch policy is <code class="sourceCode cpp"><span class="bu">std::</span>launch<span class="bu">::</span>async</code> then each call to <code class="sourceCode cpp"><span class="bu">std::</span>async()</code> will always create a new thread which can lead to resource exhaustion. When a launch policy is <code class="sourceCode cpp"><span class="bu">std::</span>launch<span class="bu">::</span>deferred()</code> the function will execute on the thread that executes the respective <code class="sourceCode cpp">get()</code> function for that <code>async</code> function.</p>
<p>C++ provides a mechanism to construct and control the execution of a function on a user-controlled potentially asynchronous thread via the <code class="sourceCode cpp"><span class="bu">std::</span>packaged_task</code> mechanism that allows access to the result via a <code class="sourceCode cpp"><span class="bu">std::</span>future</code> object. Each <code class="sourceCode cpp">packaged_task</code> object can be executed at most once and can be executed on the current thread or on a different thread.</p>
<p>There are a number of vulnerabilities that are possible once the thread is created using <code class="sourceCode cpp"><span class="bu">std::</span>thread</code> or <code class="sourceCode cpp"><span class="bu">std::</span>jthread</code>. See <a href="#CGM">6.63 lock protocol errors [CGM]</a>. Each <code class="sourceCode cpp"><span class="bu">std::</span>thread</code> object must have its <code class="sourceCode cpp">.join()</code> member function called before the object is destroyed unless its <code class="sourceCode cpp">.detach()</code> member function was previously called. This is not required for threads created as <code class="sourceCode cpp"><span class="bu">std::</span>jthread</code>. If <code class="sourceCode cpp">.detach()</code> was called on thread object then any calls to <code class="sourceCode cpp">.join()</code> will result in an exception.</p>
<p>Any exception thrown within a thread’s function needs to be handled by that thread, otherwise such an exception will cause program termination. For handling such termination see clause <a href="#CGS">6.62 Concurrency - Premature termination [CGS]</a>. Employing a <code class="sourceCode cpp"><span class="bu">std::</span>packaged_task</code> object as the thread function allows to pass an exception to the holder of its <code class="sourceCode cpp"><span class="bu">std::</span>future</code> object.</p>
<p>A detached thread will execute until its thread function ends or until the program is terminated. The <code class="sourceCode cpp"><span class="bu">std::</span>jthread</code> type allows to employ cooperative thread termination through <code class="sourceCode cpp"><span class="bu">std::</span>stop_token</code> See <a href="#CGT">6.60 Concurrency – Directed termination [CGT]</a> or <a href="#CGS">6.62 Concurrency – Premature termination [CGS]</a>.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.59.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li>When using non-standard thread facilities, e.g., by making use of <code class="sourceCode cpp"><span class="bu">std::</span>thread<span class="bu">::</span>native_handle</code>, use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.59.5.</li>
<li>Prefer <code class="sourceCode cpp"><span class="bu">std::</span>jthread</code> over <code class="sourceCode cpp"><span class="bu">std::</span>thread</code> for explicit thread creation.</li>
<li>When handling the exception thrown due to failure to create a thread, ensure that potentially dependent other threads are informed.</li>
<li>Prefer the use of managed threading constructs such as <code class="sourceCode cpp"><span class="bu">std::</span>async</code> or C++ parallel algorithms instead of explicit thread creation and management.</li>
<li>Prefer being explicit about running a function in a deferred way with <code class="sourceCode cpp"><span class="bu">std::</span>packaged_task</code> instead of using <code class="sourceCode cpp"><span class="bu">std::</span>async()</code> without specifying a launch policy.</li>
<li>Consider using cooperative thread termination through <code>std::stop_token</code>, especially for detached threads.</li>
</ul>
<h2 id="concurrency-directed-termination-cgt">6.60 Concurrency – Directed termination [CGT]</h2>
<h3 id="applicability-to-language">6.60.1 Applicability to language</h3>
<p>This vulnerability as specified in ISO/IEC 24772-1 clause 6.60 is mitigated in C++, as long as the standard C++ library facilities for threads are used. For issues associated with threades created using the standard C library, see ISO/IEC 24772-3 clause 6.60.</p>
<p>C++ does not provide the means to terminate a C++ thread asynchronously, except in the case that std::terminate() is called. Instead C++ allows cooperative termination through the use of <code class="sourceCode cpp"><span class="bu">std::</span>stop_token</code>, however, a thread instructed by a stop request to cease execution can ignore such a request. For example, using <code class="sourceCode cpp"><span class="bu">std::</span>jthread<span class="bu">::</span>request_stop()</code> to send a stop request to the started thread, the created thread can have a thread function that never handles such a stop request.</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> some_function(<span class="dt">int</span> value);</span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> stoppable_function(<span class="bu">std::</span>stop_token tok, <span class="dt">int</span> value);</span>
<span id="cb190-3"><a href="#cb190-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-4"><a href="#cb190-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main()</span>
<span id="cb190-5"><a href="#cb190-5" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb190-6"><a href="#cb190-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb190-7"><a href="#cb190-7" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>jthread t(some_function,<span class="dv">10</span>);           <span class="co">// stop_token ignored since not provided</span></span>
<span id="cb190-8"><a href="#cb190-8" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>jthread t2(stoppable_function,<span class="dv">100</span>);    <span class="co">// stop_token passed</span></span>
<span id="cb190-9"><a href="#cb190-9" aria-hidden="true" tabindex="-1"></a>  t.request_stop();              <span class="co">// no-op as ignored in t</span></span>
<span id="cb190-10"><a href="#cb190-10" aria-hidden="true" tabindex="-1"></a>  t2.request_stop();             <span class="co">// stop_token `tok`{.cpp} signalled in `t2`{.cpp},</span></span>
<span id="cb190-11"><a href="#cb190-11" aria-hidden="true" tabindex="-1"></a>                                 <span class="co">// returns `true`{.cpp} showing `stop_token`{cpp} set</span></span>
<span id="cb190-12"><a href="#cb190-12" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb190-13"><a href="#cb190-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-14"><a href="#cb190-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> stoppable_function(<span class="bu">std::</span>stop_token tok, <span class="dt">int</span> value) {</span>
<span id="cb190-15"><a href="#cb190-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>literals;</span>
<span id="cb190-16"><a href="#cb190-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> (!tok.stop_requested()) <span class="co">//</span></span>
<span id="cb190-17"><a href="#cb190-17" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb190-18"><a href="#cb190-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>osyncstream(<span class="bu">std::</span>cout) &lt;&lt; value++ &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb190-19"><a href="#cb190-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="dv">200</span><span class="bu">ms</span>);</span>
<span id="cb190-20"><a href="#cb190-20" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb190-21"><a href="#cb190-21" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb190-22"><a href="#cb190-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-23"><a href="#cb190-23" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> some_function(<span class="dt">int</span> value) </span>
<span id="cb190-24"><a href="#cb190-24" aria-hidden="true" tabindex="-1"></a>{ </span>
<span id="cb190-25"><a href="#cb190-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>literals;</span>
<span id="cb190-26"><a href="#cb190-26" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (<span class="dt">int</span> i =<span class="dv">0</span>; i&lt;<span class="dv">10</span>; ++i)</span>
<span id="cb190-27"><a href="#cb190-27" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb190-28"><a href="#cb190-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>osyncstream(<span class="bu">std::</span>cout) &lt;&lt; value++ &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb190-29"><a href="#cb190-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="dv">200</span><span class="bu">ms</span>);</span>
<span id="cb190-30"><a href="#cb190-30" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb190-31"><a href="#cb190-31" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb190-32"><a href="#cb190-32" aria-hidden="true" tabindex="-1"></a><span class="er">```</span>{.cpp}</span>
<span id="cb190-33"><a href="#cb190-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> OK = t2.request_stop(); }</span>
<span id="cb190-34"><a href="#cb190-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-35"><a href="#cb190-35" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> stoppable_function(<span class="bu">std::</span>stop_token tok, <span class="dt">int</span> value) {</span>
<span id="cb190-36"><a href="#cb190-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (!stop_token.stop_requested()) <span class="co">//</span></span>
<span id="cb190-37"><a href="#cb190-37" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb190-38"><a href="#cb190-38" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout &lt;&lt; value++ &lt;&lt; <span class="ch">&#39; &#39;</span> &lt;&lt; <span class="bu">std::</span>flush;</span>
<span id="cb190-39"><a href="#cb190-39" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="dv">200</span><span class="bu">ms</span>);</span>
<span id="cb190-40"><a href="#cb190-40" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb190-41"><a href="#cb190-41" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> some_function(<span class="dt">int</span> value) {</span>
<span id="cb190-42"><a href="#cb190-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i&lt;<span class="dv">10</span>; i++) <span class="co">//</span></span>
<span id="cb190-43"><a href="#cb190-43" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb190-44"><a href="#cb190-44" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout &lt;&lt; value++ &lt;&lt; <span class="ch">&#39; &#39;</span> &lt;&lt; <span class="bu">std::</span>flush;</span>
<span id="cb190-45"><a href="#cb190-45" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="dv">200</span><span class="bu">ms</span>);</span>
<span id="cb190-46"><a href="#cb190-46" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb190-47"><a href="#cb190-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-48"><a href="#cb190-48" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb190-49"><a href="#cb190-49" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Note that in the while loop in ’stoppable_function()<code>{.cpp}, if stop_token.stop_requested had not been checked, it would continue to run until the program itself is terminated. In the above example, at the end of the main function the destructors of the thread objects</code>t<code>{.cpp} and</code>t2<code>{.cpp} will call</code>this-&gt;request_stop()<code>{.cpp} and</code>this-&gt;join()<code>{.cpp}. If one of the thread functions never returns, then the corresponding</code>join()`{.cpp} call will block.</p>
<p>Other programmed mechanisms can be constructed to cause another thread to complete, such as setting a shared variable to a known value that the target thread reads and then terminates itself.</p>
<p>A common programming mistake is to create threads with the intention that they will participate in a joint computation, but missing the <code class="sourceCode cpp">join()</code> operation in one or more threads. If <code class="sourceCode cpp">jthreads</code> are used for the threading, all threads are joined with the thread that created them.</p>
<p>Even if a thread is successfully terminated, the thread that initiated the termination should take action to clean up after the terminating thread,such as releasing memory</p>
<p>Discussion: Do we need to discuss termination of tasks?</p>
<h2 id="avoidance-mechanisms-for-language-users">6.60.2 Avoidance mechanisms for language users</h2>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>For threads created using the C library, follow the avoidance mechanisms of ISO/IEC TR 24772-3.</p></li>
<li><p>Follow the avoidance mechanisms of ISO/IEC 24772-1 clause 6.60.5.</p></li>
<li><p>Use code reviews and static analysis tools if available, to ensure that threads correctly terminate.</p></li>
</ul>
<h2 id="CGX">6.61 Concurrent Data Access [CGX]</h2>
<h3 id="applicability-to-language">6.61.1 Applicability to language</h3>
<p>C++ has threading and shared access to variables which have the vulnerabilities described in ISO/IEC 24772-1 clause 6.61.1. Accessing mutable data from multiple threads without synchronization is undefined behaviour <a href="#EWF">[EWF]</a>. C++ provides atomic types, mutual exclusion primitives and higher-level synchronization mechanisms in the standard library to prevent such data races. Sharing non-volatile constant data or not sharing data at all does not incur data races. For example, avoiding pointer-like types for thread function parameters guarantees that there is no sharing of the argument values.</p>
<p>The C++ memory model defines how memory accesses can be reordered. The default memory order guarantees sequential consistency. For increased parallel execution other memory orders can be used but require expert-level of care.</p>
<p>NOTE: The above sentence needs explanation or rewrite.</p>
<p>C++ programs that used multiple threads before the C++11 standard might employ volatile variables to guarantee race free data access. This practice is not sanctioned by current standards, you cannot use <code class="sourceCode cpp"><span class="at">volatile</span></code> for synchronization. The use of <code>volatile std::sig_atomic_t</code> only prevents a data race between a signal handler an the execution thread running the signal handler.</p>
<p>The algorithm library allows specifying non-sequential execution policy for most algorithms. Employing parallel (<code class="sourceCode cpp"><span class="bu">std::</span>par</code>) or vectorized (<code class="sourceCode cpp"><span class="bu">std::</span>unseq</code>, <code class="sourceCode cpp"><span class="bu">std::</span>par_unseq</code>) execution policies may have additional requirements on data layout of the underlying ranges, especially to avoid data races.</p>
<p>Primitives requiring explicit locking and unlocking the pairwise application of these operations is supported implicitly by <code class="sourceCode cpp"><span class="bu">std::</span>scoped_lock</code>, even when an exception might be thrown. In addition to scope-based locking, <code class="sourceCode cpp"><span class="bu">std::</span>scoped_lock</code> guarantees deadlock-free locking of multiple mutexes.</p>
<p>Variables with thread storage duration cannot create data races, as long as their address is not shared with other threads.</p>
<p>Discuss sharing of memory between tasks!! i.e. Don’t do it!?</p>
<h3 id="avoidance-mechanisms-for-language-users">6.61.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Place all mutable data in memory accessible to only one thread at a time;</p></li>
<li><p>Use the appropriate standard library features for synchronization of shared mutable data, in particular use <code class="sourceCode cpp"><span class="bu">std::</span>scoped_lock</code> or the other scoped-based locking library facilities;</p></li>
<li><p>Prohibit calling lock and unlock facilities directly.</p></li>
<li><p>Forbid the use of volatile for synchronization;</p></li>
<li><p>Avoid specifying memory orders on atomic operations other than sequential consistency;</p></li>
<li><p>Use atomic variables or fences for synchronization of data shared from a signal handler, employ <code class="sourceCode cpp"><span class="at">volatile</span> <span class="dt">sig_atomic_t</span></code> only in a single-threaded environment;</p></li>
<li><p>Pass all thread function arguments by non-pointer-like values.</p></li>
</ul>
<h2 id="concurrency-premature-termination-cgs">6.62 Concurrency – Premature Termination [CGS]</h2>
<h3 id="applicability-to-language">6.62.1 Applicability to language</h3>
<h3 id="section"></h3>
<p>The vulnerability as described in ISO IEC 24772-1 6.62 applies to C++.</p>
<p>For concurrent entities created using the C library, apply the avoidance mechanisms documented in ISO IEC TR 24772-3 clause 6.62.</p>
<p>C++ standard threads</p>
<p>Within C++ standard thread concurrency, the vulnerability as specified in ISO/IEC 24772-1 clause 6.62 can arise as follows: - as part of the termination of the complete program resulting from an explicit call to a program-terminating function in any thread in the program or an implicit call on std::terminate, for example, - as a result of an unhandled exception in any thread function when using <code class="sourceCode cpp">thread</code> or <code class="sourceCode cpp">jthread</code> - as a result of an unhandled exception in any thread function when using C++ parallel algorithms - as a result of faulty inter-thread asynchronous communications that results in unplanned termination of a communicating thread.</p>
<p>Errors relating to improper shutdown and cleanup are addressed in 6.36 Unhandled errors and exceptions(??) If non-standard C++ concurrency is used, the vulnerability and avoidance mechanisms are as specified in ISO/IEC 24772-1 and ISO/IEC 24772-3.</p>
<p>(see https://en.cppreference.com/w/cpp/error/terminate for more termination conditions)</p>
<p>Joining a thread causes the joining thread to await the joined thread’s termination before continuing. Useful for executing in parallel and then proceeding after the dispatched work is complete, but does not notify the joining task if the termination was premature.</p>
<p>C++ 2020 provides callbacks in the form of stop_callback to notify the setting thread when a thread of interest has been terminated. It also provides stop_token for a thread to query it is being instructed to terminate. (should go in 6.60 if not there already).</p>
<p>The terminating thread can pass back whatever is programmed back to the `join’ function, which can include notice of premature termination, for example by returning a pointer to the handled exception that identifies the error that caused premature termination.</p>
<p>The semantics of C++ is that all children of the main program will prematurely terminate if the main program terminates and final results from such threads will not be delivered . It is necessary to join the main program to all its children to ensure that children are not silently terminated prematurely.</p>
<p>Premature termination of C++ Tasks</p>
<p>Tasks can <code>abort</code> or <code>terminate</code> or <code>cancelled</code> (last one - by the scheduler) but these affect the whole program containing the thread. Therefore, the only way for a task to terminate is to receive a terminate request and transfer to the end of its code where the parent that initiated it will be waiting at the future.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.62.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Use the avoidance mechanisms of ISO/IEC 24772-1 clause 6.63.5.</p></li>
<li><p>Use low-level operating system primitives or other APIs where available to check that a required thread is still active.</p></li>
<li><p>Prohibit explicit or implicit calls to program-terminating functions whenever active threads are executing.</p></li>
<li><p>Check and obey the result of <code>stop_token.stop_requested()</code> periodically (see 6.60 Concurrency - Directed termination [CGT])</p></li>
<li><p>Return some indication of conditions resulting in premature termination</p></li>
<li><p>Ensure that the main program joins all created threads that need to complete normally, such as by using the std::jthread type.</p></li>
</ul>
<h2 id="uncontrolled-format-string-shl">6.64 Uncontrolled Format String [SHL]</h2>
<h3 id="applicability-to-language">6.64.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC 24772-1 is applicable to C++.</p>
<p>C++ inherits the C libraries which provide a large family of input and output functions that use a control string to interpret the data read or format the output. These strings include all the feature described in ISO/IEC TR 24772-1:2019 clause 6.64.1.</p>
<p>C++ provides type-safe alternatives for input/output, which do not use format strings and which should be used in preference, such as</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> aNumber{};</span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span>(<span class="bu">std::</span>cin){ <span class="co">// is input still available</span></span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Enter a whole number, please:&quot;</span>;</span>
<span id="cb191-4"><a href="#cb191-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="bu">std::</span>cin &gt;&gt; aNumber) { <span class="co">// no format string needed</span></span>
<span id="cb191-5"><a href="#cb191-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &gt;&gt; <span class="st">&quot;Thank you, the number can be represented as &quot;</span></span>
<span id="cb191-6"><a href="#cb191-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>format(<span class="st">&quot;0b</span><span class="sc">{0:b}</span><span class="st"> </span><span class="sc">{0:d}</span><span class="st"> 0</span><span class="sc">{0:o}</span><span class="st"> 0x</span><span class="sc">{0:x}</span><span class="st">&quot;</span>, aNumber);</span>
<span id="cb191-7"><a href="#cb191-7" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> { <span class="co">// input failed</span></span>
<span id="cb191-8"><a href="#cb191-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin.clear();  <span class="co">// re-enable input</span></span>
<span id="cb191-9"><a href="#cb191-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string line;</span>
<span id="cb191-10"><a href="#cb191-10" aria-hidden="true" tabindex="-1"></a>    getline(<span class="bu">std::</span>cin,line); <span class="co">// skip to eol</span></span>
<span id="cb191-11"><a href="#cb191-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb191-12"><a href="#cb191-12" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In addition, operator overloading of output operators allows to extend formatting abilities to user-defined types.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.64.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Forbid the use of the C library facilities provided by <strong><code>&lt;cstdio&gt;</code></strong>.</p></li>
<li><p>Apply the avoidance mechanisms provided by the standard library as described in ISO/IEC 14882 20.20 Formatting [format] or similar libraries, if <em>printf-style</em> formatting of output or strings is desired, or when the formatting facilities of <code>std::ostream</code> are inadequate.</p></li>
<li><p>Read untrusted input as plain characters and then check for validity, before any conversion to numbers or program entities occurs, using facilities that do not require format strings and that check and report error conditions.</p></li>
</ul>
<h1 id="UJO">6.65 Modifying constants [UJO]</h1>
<h3 id="applicability-to-language">6.65.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 clause 6.65 exists in C++.</p>
<p>An object can be declared as <code class="sourceCode cpp"><span class="at">const</span></code>, denoting that its value will not change in its lifetime without invoking mechanisms which have undefined behaviour <a href="#EWF">[EWF]</a>. For example, an access path to an object can be declared as <code class="sourceCode cpp"><span class="at">const</span></code>, denoting that the value of the object will not change via this access path without invoking mechanisms which have undefined behaviour, e.g.,</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> i = <span class="dv">0</span>;              <span class="co">// the simplest access path</span></span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span>&amp; j = <span class="kw">const_cast</span>&lt;<span class="dt">int</span>&amp;&gt;(i); <span class="co">// undefined behaviour</span></span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo(<span class="dt">int</span>* p) { *p += <span class="dv">43</span>; }</span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a><span class="co">//...</span></span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a>foo(<span class="kw">const_cast</span>&lt;<span class="dt">int</span>*&gt;(&amp;i));    <span class="co">// undefined behaviour</span></span>
<span id="cb192-6"><a href="#cb192-6" aria-hidden="true" tabindex="-1"></a>foo(&amp;i);                      <span class="co">// ill-formed, compiler error</span></span></code></pre></div>
<p>It is an illegal program or undefined behaviour to attempt to change a <code class="sourceCode cpp"><span class="at">const</span></code> object, such as <code class="sourceCode cpp">i</code>, above.</p>
<p>A object that is not <code class="sourceCode cpp"><span class="at">const</span></code>-qualified can be accessed through a path that is <code class="sourceCode cpp"><span class="at">const</span></code>-qualified.</p>
<p>The checking for the correctness of <code class="sourceCode cpp"><span class="at">const</span></code> is enforced based on the access-path and not the type of the target object. While it is possible to remove the const-qualification for an access path, attempting to modify a const object this way is undefined-behavior (see <span id="EWF">Undefined Behavior [EWF]</span>) : <code class="sourceCode cpp"><span class="kw">const_cast</span>&lt;<span class="dt">int</span>&amp;&gt; (i) = <span class="dv">0</span>; <span class="co">// undefined behavior</span></code></p>
<p>A constant can also be legitimately modified via a secondary access path. For example:</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> k = <span class="dv">0</span>;</span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> break_it() </span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb193-5"><a href="#cb193-5" aria-hidden="true" tabindex="-1"></a>  k = <span class="dv">42</span>; <span class="co">// legal</span></span>
<span id="cb193-6"><a href="#cb193-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb193-7"><a href="#cb193-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-8"><a href="#cb193-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> test(<span class="dt">int</span> <span class="at">const</span> <span class="at">volatile</span>&amp; j)   <span class="co">// Volatile used only to guarantee observability</span></span>
<span id="cb193-9"><a href="#cb193-9" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb193-10"><a href="#cb193-10" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span>(j == <span class="dv">0</span>); <span class="co">// will pass since k == 0</span></span>
<span id="cb193-11"><a href="#cb193-11" aria-hidden="true" tabindex="-1"></a>  break_it();</span>
<span id="cb193-12"><a href="#cb193-12" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span>(j == <span class="dv">0</span>); <span class="co">// will fail since k != 0</span></span>
<span id="cb193-13"><a href="#cb193-13" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb193-14"><a href="#cb193-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-15"><a href="#cb193-15" aria-hidden="true" tabindex="-1"></a>  test(k);</span></code></pre></div>
<p>When using pointers, confusion can occur between qualifications on the pointer’s type (pointer type) and qualifications on the type being referenced (pointee type).</p>
<p>A common misconception is that a member function qualified with <code class="sourceCode cpp"><span class="at">const</span></code> cannot modify any of its members.<br />
The following badly defined class introduces a non-<code class="sourceCode cpp"><span class="at">const</span></code> access path to a potentially const object:</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A</span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a>    A * pA;                </span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i{<span class="dv">0</span>};            </span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-6"><a href="#cb194-6" aria-hidden="true" tabindex="-1"></a>    A () : pA{<span class="kw">this</span>}{}     <span class="co">// pA provides non-const access path</span></span>
<span id="cb194-7"><a href="#cb194-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-8"><a href="#cb194-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f () <span class="at">const</span></span>
<span id="cb194-9"><a href="#cb194-9" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb194-10"><a href="#cb194-10" aria-hidden="true" tabindex="-1"></a>      <span class="co">// pA = nullptr;     // ill-formed</span></span>
<span id="cb194-11"><a href="#cb194-11" aria-hidden="true" tabindex="-1"></a>      <span class="co">// i = 0;            // ill-formed</span></span>
<span id="cb194-12"><a href="#cb194-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-13"><a href="#cb194-13" aria-hidden="true" tabindex="-1"></a>      pA-&gt;i = <span class="dv">42</span>;          <span class="co">// compiles, but undefined behavior</span></span>
<span id="cb194-14"><a href="#cb194-14" aria-hidden="true" tabindex="-1"></a>                           <span class="co">// if executed on a const object</span></span>
<span id="cb194-15"><a href="#cb194-15" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb194-16"><a href="#cb194-16" aria-hidden="true" tabindex="-1"></a>  };</span>
<span id="cb194-17"><a href="#cb194-17" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb194-18"><a href="#cb194-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main(){</span>
<span id="cb194-19"><a href="#cb194-19" aria-hidden="true" tabindex="-1"></a>    A a;           <span class="co">// mutable</span></span>
<span id="cb194-20"><a href="#cb194-20" aria-hidden="true" tabindex="-1"></a>    A <span class="at">const</span> b; </span>
<span id="cb194-21"><a href="#cb194-21" aria-hidden="true" tabindex="-1"></a>    a.f();         <span class="co">// OK</span></span>
<span id="cb194-22"><a href="#cb194-22" aria-hidden="true" tabindex="-1"></a>    b.f();         <span class="co">// undefined behaviour</span></span>
<span id="cb194-23"><a href="#cb194-23" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>However, for C++ classes with members of a pointer-like type, programmers can establish the transitivity of <code class="sourceCode cpp"><span class="at">const</span></code> with <code class="sourceCode cpp"><span class="at">const</span></code> member functions that do not change the referred-to objects.</p>
<p>Within a <code class="sourceCode cpp"><span class="at">const</span></code> member function a <code class="sourceCode cpp"><span class="at">mutable</span></code> data member can still be modified, even if the containing object is <code class="sourceCode cpp"><span class="at">const</span></code>.<br />
The use of <code class="sourceCode cpp"><span class="at">mutable</span></code> on a data member not contributing to the observable state of the object is preferable to removing the constness of the containing object (see <span id="FLC">Conversion Errors [FLC]</span>).<br />
Historically, classes with expensive computations in frequently-called const-member-functions, used <code class="sourceCode cpp"><span class="at">mutable</span></code> data members to cache results of those computations. In concurrent code this practice can lead to data races, unless access to those mutable data members is synchronised.</p>
<p>A safe use of <code class="sourceCode cpp"><span class="at">mutable</span></code> data members is for synchronisation primitives, allowing synchronisation in const member functions.</p>
<p>The following is a common example where a mutex member is declared <code class="sourceCode cpp"><span class="at">mutable</span></code> to allow locking in a <code class="sourceCode cpp"><span class="at">const</span></code> member function:</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;mutex&gt;</span></span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MyQueue {</span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">mutable</span> <span class="bu">std::</span>mutex <span class="va">m_mutex</span>;</span>
<span id="cb195-5"><a href="#cb195-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> * <span class="va">m_head</span> { <span class="kw">nullptr</span> };</span>
<span id="cb195-6"><a href="#cb195-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-7"><a href="#cb195-7" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb195-8"><a href="#cb195-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-9"><a href="#cb195-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> empty () <span class="at">const</span> {</span>
<span id="cb195-10"><a href="#cb195-10" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>lock_guard sg {<span class="va">m_mutex</span>}; <span class="co">// lock the mutex, which requires m_mutex to be writable</span></span>
<span id="cb195-11"><a href="#cb195-11" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="va">m_head</span> != <span class="kw">nullptr</span>;</span>
<span id="cb195-12"><a href="#cb195-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb195-13"><a href="#cb195-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-14"><a href="#cb195-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb195-15"><a href="#cb195-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-16"><a href="#cb195-16" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div>
<h3 id="avoidance-mechanisms-for-language-users">6.65.2 Avoidance mechanisms for language users</h3>
<p>To avoid the vulnerability or mitigate its ill effects, C++ software developers can:</p>
<ul>
<li><p>Apply the avoidance mechanisms of ISO/IEC 24772-1 clause 6.65.5.</p></li>
<li><p>Forbid casting away <code class="sourceCode cpp"><span class="at">const</span></code> by <code class="sourceCode cpp"><span class="kw">const_cast</span></code> or by any other means.</p></li>
<li><p>Be aware that, while <code class="sourceCode cpp"><span class="at">const</span></code> means “read only”, C++ permits values accessed by a <code class="sourceCode cpp"><span class="at">const</span></code> access path to be modified via a different access path.</p></li>
<li><p>Apply <code class="sourceCode cpp"><span class="at">const</span></code> on pointer-like parameters as a promise to callers and an obligation on the implementation to not modify the referred object.</p></li>
<li><p>Within <code class="sourceCode cpp"><span class="at">const</span></code> member functions, avoid indirectly modifying the object’s state.</p></li>
<li><p>Apply <code class="sourceCode cpp"><span class="at">mutable</span></code> only to member variables that do not influence the observable state of an object.</p></li>
<li><p>Ensure in concurrent code, that mutable data members are synchronisation primitives or are explicitly synchronized.</p></li>
<li><p>When designing C++ classes, provide <code class="sourceCode cpp"><span class="at">const</span></code> member functions to support <code class="sourceCode cpp"><span class="at">const</span></code> objects.</p></li>
<li><p>Ensure that C++ classes modelling pointer-like types provide transitivity of <code class="sourceCode cpp"><span class="at">const</span></code> within <code class="sourceCode cpp"><span class="at">const</span></code> member functions.</p></li>
</ul>
<h1 id="language-specific-vulnerabilities-for-c">7. Language specific vulnerabilities for C++</h1>
<p>TBD</p>
<!-- -->
<h1 id="implications-for-standardization">8. Implications for standardization</h1>
<p>Future standardization efforts should consider:</p>
<ul>
<li><pre><code>Moving in the direction over time to being a more strongly typed</code></pre>
<p>language. Much of the use of weak typing is simply convenience to the developer in not having to fully consider the types and uses of variables. Stronger typing forces good programming discipline and clarity about variables while at the same time removing many unexpected run time errors due to implicit conversions. This is not to say that C should be strictly a strongly typed language – some advantages of C are due to the flexibility that weaker typing provides. It is suggested that when enforcement of strong typing does not detract from the good flexibility that C offers (for example, adding an integer to a character to step through a sequence of characters) and is only a convenience for programmers (for example, adding an integer to a floating-point number), then the standard should specify the stronger typed solution.</p></li>
<li><pre><code>A common warning in Annex I should be added for floating-point</code></pre>
<p>expressions being used in a Boolean test for equality.</p></li>
<li><pre><code>Modifying or deprecating many of the C standard library functions</code></pre>
<p>that make assumptions about the occurrence of a string termination character.</p></li>
<li><pre><code>Define a string construct that does not rely on the null termination</code></pre>
<p>character.</p></li>
<li><pre><code>Defining an array type that does automatic bounds checking.</code></pre></li>
<li><pre><code>Deprecating less safe functions such as strcpy() and strcat() where</code></pre>
<p>a more secure alternative is available.<span data-custom-style="annotation reference"></span></p></li>
<li><pre><code>Defining safer and more secure replacement functions such as</code></pre>
<p>memncpy() and memncmp() to complement the memcpy() and memcmp() functions (see <em>6.11.6 Implications for standardization</em>)</p></li>
<li><pre><code>Defining an array type that does automatic bounds checking.</code></pre></li>
<li><pre><code>Defining functions that contain an extra parameter in memcpy() and</code></pre>
<p>memmove() for the maximum number of bytes to copy. In the past, some have suggested that the size of the destination buffer be used as an additional parameter. Some critics state that this solution is easy to circumvent by simply repeating the parameter that was used for the number of bytes to copy as the parameter for the size of the destination buffer. This analysis and criticism is correct. What is needed is a failsafe check as to the maximum number of bytes to copy. There are several reasons for creating new functions with an additional parameter. This would make it easier for static analysis to eliminate those cases where the memory copy could not be a problem (such as when the maximum number of bytes is demonstrably less than the capacity of the receiving buffer). Manual analysis or more involved static analysis could then be used for the remaining situations where the size of the destination buffer may not be sufficient for the maximum number of bytes to copy. This extra parameter may also help in determining which copies could take place among objects that overlap. Such copying is undefined according to the C standard. It is suggested that safer versions of functions that include a restriction max_n on the number of bytes n to copy (for example, void *memncpy(void * restrict s1,const void * restrict s2,size_t n), const size_t max_n) be added to the standard in addition to retaining the current corresponding functions (for example, memcpy(void * restrict s1,const void * restrict s2,size_t n))). The additional parameter would be consistent with the copying function pairs that have already been created such as strcpy()/strncpy() and strcat()/strncat(). This would allow a safer version of memory copying functions for those applications that want to use them in to facilitate both safer and more secure code and more efficient and accurate static code reviews<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p></li>
<li><pre><code>Restrictions on pointer arithmetic that could eliminate common</code></pre>
<p>pitfalls. Pointer arithmetic is error-prone and the flexibility that it offers is useful, but some of the flexibility is simply a shortcut that if restricted could lessen the chance of a pointer arithmetic based error.</p></li>
<li><pre><code>Defining a standard way of declaring an attribute to indicate that a</code></pre>
<p>variable is intentionally unused.</p></li>
<li><pre><code>A common warning in Annex I should be added for variables with the</code></pre>
<p>same name in nested scopes.</p></li>
<li><pre><code>Creating a few standardized precedence orders. Standardizing on a</code></pre>
<p>few precedence orders will help to eliminate the confusing intricacies that exist between languages. This would not affect current languages as altering precedence orders in existing languages is too onerous. However, this would set a basis for the future as new languages are created and adopted. Stating that a language uses “ISO precedence order A” would be useful rather than having to spell out the entire precedence order that differs in a conceptually minor way from some other languages, but in a major way when programmers attempt to switch between languages.</p></li>
<li><pre><code>Deprecating the goto statement. The use of the goto construct is</code></pre>
<p>often spotlighted as the antithesis of good structured programming. Though its deprecation will not instantly make all C code structured, deprecating the goto and leaving in place the restricted goto variations (for example, break and continue) and possibly adding other restricted goto’s could assist in encouraging safer and more secure C programming in general.</p></li>
<li><pre><code>Defining a &quot;fallthru&quot; construct that will explicitly bind multiple</code></pre>
<p>switch cases together and eliminate the need for the break statement. The default would be for a case to break instead of falling through to the next case. Granted this is a major shift in concept, but if it could be accomplished, less unintentional errors would occur.</p></li>
<li><pre><code>Defining an identifier type for loop control that cannot be modified</code></pre>
<p>by anything other than the loop control construct would be a relatively minor addition to C that could make C code safer and encourage better structured programming.</p></li>
<li><pre><code>Defining a standardized interface package for interfacing C with</code></pre>
<p>many of the top programming languages and a reciprocal package should be developed of the other top languages to interface with C.</p></li>
<li><pre><code>Joining with other languages in developing a standardized set of</code></pre>
<p>mechanisms for detecting and treating error conditions so that all languages to the extent possible could use them. Note that this does not mean that all languages should use the same mechanisms as there should be a variety ( label parameters, auxiliary status variables), but each of the mechanisms should be standardized.</p></li>
<li><pre><code>Since fault handling and exiting of a program is common to all</code></pre>
<p>languages, it is suggested that common terminology such as the meaning of fail safe, fail hard, fail soft, and so on along with a core API set such as exit, abort, and so on be standardized and coordinated with other languages.</p></li>
<li><pre><code>Deprecating unions. The primary reason for the use of unions to save</code></pre>
<p>memory has been diminished considerably as memory has become cheaper and more available. Unions are not statically type safe and are historically known to be a common source of errors, leading to many C programming guidelines specifically prohibiting the use of unions.</p></li>
<li><pre><code>Creating a recognizable naming standard for routines such that one</code></pre>
<p>version of a library does parameter checking to the extent possible and another version does no parameter checking. The first version would be considered safer and more secure and the second could be used in certain situations where performance is critical and the checking is assumed to be done in the calling routine. A naming standard could be made such that the library that does parameter checking could be named as usual, say “library_xyz” and an equivalent version that does not do checking could have a “_p” appended, such as “library_xyz_p”. Without a naming standard such as this, a considerable number of wasted cycles will be conducted doing a double check of parameters or even worse, no checking will be done in both the calling and receiving routines as each is assuming the other is doing the checking.</p></li>
<li><pre><code>Creating an Annex that lists deprecated features.</code></pre></li>
</ul>
<h1 id="bibliography">Bibliography</h1>
<div data-custom-style="Bibliography1">
<p>[1] ISO/IEC Directives, Part 2, <em>Rules for the structure and drafting of International Standards</em>, 2004</p>
</div>
<div data-custom-style="Bibliography1">
<p>[2] ISO/IEC TR 10000‑1, <em>Information technology — Framework and taxonomy of International Standardized Profiles — Part 1: General principles and documentation framework</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[3] ISO 10241 (all parts), <em>International terminology standards</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[4] ISO/IEC 9899:2011, <em>Information technology</em> — <em>Programming languages —</em> C</p>
</div>
<div data-custom-style="Bibliography1">
<p>[5] ISO/IEC 9899:2011/Cor.1:2012, <em>Technical Corrigendum 1</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[6] ISO/IEC 30170:2012, <em>Information technology</em> — <em>Programming languages —</em> Ruby</p>
</div>
<div data-custom-style="Bibliography1">
<p>[7] ISO/IEC/IEEE 60559:2011, <em>Information technology – Microprocessor Systems – Floating-Point arithmetic</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[8] ISO/IEC 1539-1:2010, <em>Information technology — Programming languages —</em> Fortran — Part 1: Base language</p>
</div>
<div data-custom-style="Bibliography1">
<p>[9] ISO/IEC 8652:1995, <em>Information technology — Programming languages —</em> Ada</p>
</div>
<div data-custom-style="Bibliography1">
<p>[10] ISO/IEC 14882:2011, <em>Information technology</em> — <em>Programming languages —</em> C++</p>
</div>
<div data-custom-style="Bibliography1">
<p>[11] R. Seacord, <em>The CERT C Secure Coding Standard</em>. Boston,MA: Addison-Westley, 2008.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[12] Motor Industry Software Reliability Association. <em>Guidelines for the Use of the C Language in Vehicle Based Software</em>, 2012 (third edition)16F<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[13] ISO/IEC TR24731–1, <em>Information technology — Programming languages, their environments and system software interfaces — Extensions to the C library — Part 1: Bounds-checking interfaces</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[14] ISO/IEC TR 15942:2000, <em>Information technology — Programming languages — Guide for the use of the Ada programming language in high integrity systems</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[15] Joint Strike Fighter Air Vehicle: C++ Coding Standards for the System Development and Demonstration Program. Lockheed Martin Corporation. December 2005.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[16] Motor Industry Software Reliability Association. <em>Guidelines for the Use of the C++ Language in critical systems</em>, June 2008</p>
</div>
<div data-custom-style="Bibliography1">
<p>[17] ISO/IEC TR 24718: 2005, <em>Information technology — Programming languages — Guide for the use of the Ada Ravenscar Profile in high integrity systems</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[18] L. Hatton, Safer C: developing software for high-integrity and safety-critical systems. McGraw-Hill 1995</p>
</div>
<div data-custom-style="Bibliography1">
<p>[19] ISO/IEC 15291:1999, <em>Information technology — Programming languages — Ada Semantic Interface Specification (ASIS)</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[20] Software Considerations in Airborne Systems and Equipment Certification. Issued in the USA by the Requirements and Technical Concepts for Aviation (document RTCA SC167/DO-178B) and in Europe by the European Organization for Civil Aviation Electronics (EUROCAE document ED-12B).December 1992.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[21] IEC 61508: Parts 1-7, Functional safety: safety-related systems. 1998. (Part 3 is concerned with software).</p>
</div>
<div data-custom-style="Bibliography1">
<p>[22] ISO/IEC 15408: 1999 Information technology. Security techniques. Evaluation criteria for IT security.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[23] J Barnes, High Integrity Software - the SPARK Approach to Safety and Security. Addison-Wesley. 2002.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[25] Steve Christy, <em>Vulnerability Type Distributions in CVE</em>, V1.0, 2006/10/04</p>
</div>
<div data-custom-style="Bibliography1">
<p>[26] <em>ARIANE 5: Flight 501 Failure</em>, Report by the Inquiry Board, July 19, 1996 <a href="http://esamultimedia.esa.int/docs/esa-x-1819eng.pdf"><span data-custom-style="Hyperlink">http://esamultimedia.esa.int/docs/esa-x-1819eng.pdf</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[27] Hogaboom, Richard, <em>A Generic API Bit Manipulation in C</em>, Embedded Systems Programming, Vol 12, No 7, July 1999 <a href="http://www.embedded.com/1999/9907/9907feat2.htm"><span data-custom-style="Hyperlink">http://www.embedded.com/1999/9907/9907feat2.htm</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[28] Carlo Ghezzi and Mehdi Jazayeri, Programming Language Concepts, 3<sup>rd</sup> edition, ISBN-0-471-10426-4, John Wiley &amp; Sons, 1998</p>
</div>
<div data-custom-style="Bibliography1">
<p>[29] Lions, J. L. <a href="http://en.wikisource.org/wiki/Ariane_501_Inquiry_Board_report"><span data-custom-style="Hyperlink">ARIANE 5 Flight 501 Failure Report</span></a>. Paris, France: European Space Agency (ESA) &amp; National Center for Space Study (CNES) Inquiry Board, July 1996.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[30] Seacord, R. <em>Secure Coding in C and C++</em>. Boston, MA: Addison-Wesley, 2005. See <a href="http://www.cert.org/books/secure-coding"><span data-custom-style="Hyperlink">http://www.cert.org/books/secure-coding</span></a> for news and errata.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[31] John David N. Dionisio. Type Checking. <a href="http://myweb.lmu.edu/dondi/share/pl/type-checking-v02.pdf"><span data-custom-style="Hyperlink">http://myweb.lmu.edu/dondi/share/pl/type-checking-v02.pdf</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[32] MISRA Limited. "<a href="http://www.misra.org.uk/"><span data-custom-style="Hyperlink">MISRA C</span></a>: 2012 Guidelines for the Use of the C Language in Critical Systems." Warwickshire, UK: MIRA Limited, March 2013 (ISBN 978-1-906400-10-1 and 978-1-906400-11-8).</p>
</div>
<div data-custom-style="Bibliography1">
<p>[33] The Common Weakness Enumeration (CWE) Initiative, MITRE Corporation, (<a href="http://cwe.mitre.org/"><span data-custom-style="Hyperlink">http://cwe.mitre.org/</span></a>)</p>
</div>
<div data-custom-style="Bibliography1">
<p>[34] Goldberg, David, <em>What Every Computer Scientist Should Know About Floating-Point Arithmetic</em>, ACM Computing Surveys, vol 23, issue 1 (March 1991), ISSN 0360-0300, pp 5-48.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[35] IEEE Standards Committee 754. IEEE Standard for Binary Floating-Point Arithmetic, ANSI/IEEE Standard 754-2008. Institute of Electrical and Electronics Engineers, New York, 2008.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[36] Robert W. Sebesta, Concepts of Programming Languages, 8<sup>th</sup> edition, ISBN-13: 978-0-321-49362-0, ISBN-10: 0-321-49362-1, Pearson Education, Boston, MA, 2008</p>
</div>
<div data-custom-style="Bibliography1">
<p>[37] Bo Einarsson, ed. Accuracy and Reliability in Scientific Computing, SIAM, July 2005 <a href="http://www.nsc.liu.se/wg25/book"><span data-custom-style="Hyperlink">http://www.nsc.liu.se/wg25/book</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[38] GAO Report, Patriot <em>Missile Defense: Software Problem Led to System Failure at Dhahran, Saudi Arabia</em>, B-247094, Feb. 4, 1992, <a href="http://archive.gao.gov/t2pbat6/145960.pdf"><span data-custom-style="Hyperlink">http://archive.gao.gov/t2pbat6/145960.pdf</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[39] Robert Skeel, <em>Roundoff Error Cripples Patriot Missile</em>, SIAM News, Volume 25, Number 4, July 1992, page 11, <a href="http://www.siam.org/siamnews/general/patriot.htm"><span data-custom-style="HTML Typewriter"><u>http://www.siam.org/siamnews/general/patriot.htm</u></span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[40] CERT. <em>CERT C++ Secure Coding Standard</em>.  <a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637%20"><span data-custom-style="Hyperlink">https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637</span></a> (2009).</p>
</div>
<div data-custom-style="Bibliography1">
<p>[41] Holzmann, Garard J., Computer, vol. 39, no. 6, pp 95-97, Jun., 2006, <em>The Power of 10: Rules for Developing Safety-Critical Code</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[42] P. V. Bhansali, A systematic approach to identifying a safe subset for safety-critical software, ACM SIGSOFT Software Engineering Notes, v.28 n.4, July 2003</p>
</div>
<div data-custom-style="Bibliography1">
<p>[43] Ada 95 Quality and Style Guide, SPC-91061-CMC, version 02.01.01. Herndon, Virginia: Software Productivity Consortium, 1992. Available from: <a href="http://www.adaic.org/docs/95style/95style.pdf"><span data-custom-style="Hyperlink">http://www.adaic.org/docs/95style/95style.pdf</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[44] Ghassan, A., &amp; Alkadi, I. (2003). Application of a Revised DIT Metric to Redesign an OO Design. <em>Journal of Object Technology</em> , 127-134.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[45] Subramanian, S., Tsai, W.-T., &amp; Rayadurgam, S. (1998). Design Constraint Violation Detection in Safety-Critical Systems. The 3rd IEEE International Symposium on High-Assurance Systems Engineering , 109 - 116.</p>
</div>
<p>[46] Lundqvist, K and Asplund, L., “<em>A Formal Model of a Run-Time Kernel for Ravenscar</em>”, The 6th International Conference on Real-Time Computing Systems and Applications – RTCSA 1999</p>
<p>[47] ISO/IEC TS 17961, <em>Information technology – Programming languages, their environments and system software interfaces – C secure coding rules</em></p>
<p>[48] GNU Project. GCC Bugs “Non-bugs” http://gcc.gnu.org/bugs.html#nonbugs_c (2009).</p>
<h1 id="index">Index</h1>
<div data-custom-style="Bibliography1">
<p>LHS (left-hand side), 22</p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>::: {custom-style=“footnote text”} <span data-custom-style="footnote reference"></span> This has been addressed by WG 14 in an optionally normative annex in the current working paper<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>::: {custom-style=“footnote text”} <span data-custom-style="footnote reference"></span> The first edition should not be used or quoted in this work.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
