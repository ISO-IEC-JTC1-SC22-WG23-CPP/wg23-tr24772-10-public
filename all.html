<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>tr24772-10-C++</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div data-custom-style="zzCover">
<p>ISO/IEC JTC 1/SC 22/WG23 N1012</p>
</div>
<div data-custom-style="zzCover">
<p>Date: 2020-11-23</p>
</div>
<div data-custom-style="zzCover">
<p>ISO/IEC TR 24772–10<br />
Notes on this document</p>
</div>
<p>Effective 23 November 2020, this document is being moved to “github”. Contact <span data-custom-style="Hyperlink">Stephen.michell@maurya.on.ca</span> to gain access.</p>
<p>This document is a draft of a Guidance to avoiding programming language vulnerabilities in C++.</p>
<p>At this point in time, the following clauses are essentially completed first pass.</p>
<ul>
<li><pre><code>6.2 type system</code></pre></li>
<li><pre><code>6.3 Bit representation</code></pre></li>
<li><pre><code>6.4 Floating Point</code></pre></li>
<li><pre><code>6.5 Enumerator issues \[CCB\],</code></pre></li>
<li><pre><code>6.6 Conversion errors</code></pre></li>
<li><pre><code>6.7 String termination</code></pre></li>
<li><pre><code>6.8 Buffer boundary violation</code></pre></li>
<li><pre><code>6.9 Unchecked array indexing</code></pre></li>
<li><pre><code>6.10 Unchecked array copying (needs to be revisited)</code></pre></li>
<li><pre><code>6.11 Pointer type conversions</code></pre></li>
<li><pre><code>6.12 Pointer arithmetic</code></pre></li>
<li><pre><code>6.13 Null pointer dereference \[XYH\],</code></pre></li>
<li><pre><code>6.14 Dangling reference to heap</code></pre></li>
<li><pre><code>6.15 Arithmetic wrap-around error</code></pre></li>
<li><pre><code>6.16 Using shift operations for multiplication and division</code></pre></li>
<li><pre><code>6.17 Choice of clear names \[NAI\]</code></pre></li>
<li><pre><code>6.18 Dead Store</code></pre></li>
<li><pre><code>6.19 Unused variables</code></pre></li>
<li><pre><code>6.20 Identifier name reuse</code></pre></li>
<li><pre><code>6.21 Namespace Issues</code></pre></li>
<li><pre><code>6.22 Initialization of variables \[LAV\]</code></pre></li>
<li><pre><code>6.23 Operator precedence and associativity</code></pre></li>
<li><pre><code>6.24 Side effects and order of evaluation</code></pre></li>
<li><pre><code>6.25 Likely incorrect expression</code></pre></li>
<li><pre><code>6.26 Dead store,</code></pre></li>
<li><pre><code>6.27 Switch statements and static analysis</code></pre></li>
<li><pre><code>6.28 Demarcation of control flow</code></pre></li>
<li><pre><code>6.29 Loop control variables</code></pre></li>
<li><pre><code>6.30 Off-by-one errors</code></pre></li>
<li><pre><code>6.31 Structured programming</code></pre></li>
<li><pre><code>6.32 Passing parameters and return values</code></pre></li>
<li><pre><code>6.33 Dangling references to stack frames</code></pre></li>
<li><pre><code>6.34 Subprogram signature mismatch</code></pre></li>
<li><pre><code>6.35 Recursion</code></pre></li>
<li><pre><code>6.36 Ignored error status and unhandled exceptions</code></pre></li>
<li><pre><code>6.37 Type breaking reinterpretation of data</code></pre></li>
<li><pre><code>6.38 Deep vs shallow copying \[YAN\]</code></pre></li>
<li><pre><code>6.39 Memory leak and heap fragmentation</code></pre></li>
<li><pre><code>6.41 Inheritance</code></pre></li>
<li><pre><code>6.42 Violations of the Liskov substitution principle</code></pre></li>
<li><pre><code>6.43 Redispatching</code></pre></li>
<li><pre><code>6.44 Polymorphic variables</code></pre></li>
<li><pre><code>6.45 Extra intrinsics</code></pre></li>
<li><pre><code>6.46 Argument passing to library functions</code></pre></li>
<li><pre><code>6.47 Inter-language calling</code></pre></li>
<li><pre><code>6.48 Dynamically-linked code and self-modifying code \[NYY\]</code></pre></li>
<li><pre><code>6.49 Library Signature</code></pre></li>
<li><pre><code>6.50 Unanticipated exceptions from library routines</code></pre></li>
<li><pre><code>6.51 Pre-processor directives</code></pre></li>
<li><pre><code>6.52 Suppression of language-defined run-time checking</code></pre></li>
<li><pre><code>6.53 Provision of inherently unsafe operations</code></pre></li>
<li><pre><code>6.54 Obscure language features</code></pre></li>
<li><pre><code>6.55 Unspecified behaviour</code></pre></li>
<li><pre><code>6.56 Undefined behaviour</code></pre></li>
<li><pre><code>6.57 Implementation-defined behaviour</code></pre></li>
<li><pre><code>6.58 Deprecated language features</code></pre></li>
<li><pre><code>6.59 Concurrency \-- Activation</code></pre></li>
<li><pre><code>6.60 Concurrency -- Directed termination</code></pre></li>
<li><pre><code>6.64 Uncontrolled format string</code></pre></li>
</ul>
<div data-custom-style="Normal (Web)">
<p>TBD</p>
</div>
<ul>
<li><pre><code>6.2 Type system -- issues being fed from 6.40 and elsewhere</code></pre></li>
<li><pre><code>6.61 Concurrent data access</code></pre></li>
<li><pre><code>6.62 Concurrency -- Premature termination</code></pre></li>
<li><pre><code>6.63 Protocol lock errors</code></pre></li>
</ul>
<div data-custom-style="Normal (Web)">
<p>Participants at meeting 23 November 2020</p>
</div>
<p>Stephen Michell</p>
<p>Paul Preney</p>
<p>Peter Sommerlad</p>
<p>Richard Corden</p>
<p>Erhard Ploedereder</p>
<p>Clive Pygott</p>
<p>Michael Wong</p>
<!-- Here we include stuff... with pandoc-include filter -->
<div data-custom-style="zzCover">
<p>Edition 1</p>
</div>
<div data-custom-style="zzCover">
<p>ISO/IEC JTC 1/SC 22/WG 23</p>
</div>
<div data-custom-style="zzCover">
<p>Secretariat: ANSI</p>
</div>
<div data-custom-style="Bibliography1">
<p>Information Technology — Programming languages — Guidance to avoiding vulnerabilities in programming languages – Part 10 – Vulnerability descriptions for the programming language C++</p>
</div>
<div data-custom-style="zzCover">
<p>Document type: International standard</p>
</div>
<div data-custom-style="zzCover">
<p>Document subtype: if applicable</p>
</div>
<div data-custom-style="zzCover">
<p>Document stage: (10) development stage</p>
</div>
<div data-custom-style="zzCover">
<p>Document language: E</p>
</div>
<p><em>Élément introductif — Élément principal — Partie n: Titre de la partie</em></p>
<div data-custom-style="zzCover">
<p>Warning</p>
</div>
<div data-custom-style="zzCover">
<p>This document is not an ISO International Standard. It is distributed for review and comment. It is subject to change without notice and may not be referred to as an International Standard.</p>
</div>
<div data-custom-style="zzCover">
<p>Recipients of this draft are invited to submit, with their comments, notification of any relevant patent rights of which they are aware and to provide supporting documentation.</p>
</div>
<div data-custom-style="zzCopyright">
<p><strong>Copyright notice</strong></p>
</div>
<div data-custom-style="zzCopyright">
<p>This ISO document is a working draft or committee draft and is copyright-protected by ISO. While the reproduction of working drafts or committee drafts in any form for use by participants in the ISO standards development process is permitted without prior permission from ISO, neither this document nor any extract from it may be reproduced, stored or transmitted in any form for any other purpose without prior written permission from ISO.</p>
</div>
<div data-custom-style="zzCopyright">
<p>Requests for permission to reproduce this document for the purpose of selling it should be addressed as shown below or to ISO’s member body in the country of the requester:</p>
</div>
<div data-custom-style="zzCopyright">
<p><em>ISO copyright office</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>Case postale 56, CH-1211 Geneva 20</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>Tel. + 41 22 749 01 11</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>Fax + 41 22 749 09 47</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>E-mail copyright@iso.org</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>Web www.iso.org</em></p>
</div>
<div data-custom-style="zzCopyright">
<p>Reproduction for sales purposes may be subject to royalty payments or a licensing agreement.</p>
</div>
<div data-custom-style="zzCopyright">
<p>Violators may be prosecuted.</p>
</div>
<div data-custom-style="zzContents">
<p>Contents Page</p>
</div>
<div data-custom-style="toc 1">
<p><a href="#foreword"><span data-custom-style="Hyperlink">Foreword</span> vii</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#introduction"><span data-custom-style="Hyperlink">Introduction</span> viii</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#scope"><span data-custom-style="Hyperlink">1. Scope</span> 1</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#normative-references"><span data-custom-style="Hyperlink">2. Normative references</span> 1</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#terms-and-definitions-symbols-and-conventions"><span data-custom-style="Hyperlink">3. Terms and definitions, symbols and conventions</span> 1</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#terms-and-definitions"><span data-custom-style="Hyperlink">3.1 Terms and definitions</span> 1</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#language-concepts"><span data-custom-style="Hyperlink">4. Language concepts</span> 4</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#section"><span data-custom-style="Hyperlink">5. Avoiding programming language vulnerabilities in C++</span> 4</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#specific-guidance-for-c-vulnerabilities"><span data-custom-style="Hyperlink">6. Specific Guidance for C++ Vulnerabilities</span> 6</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#general"><span data-custom-style="Hyperlink">6.1 General</span> 6</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#type-system-ihn"><span data-custom-style="Hyperlink">6.2 Type System [IHN]</span> 6</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#bit-representations-str"><span data-custom-style="Hyperlink">6.3 Bit Representations [STR]</span> 7</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#floating-point-arithmetic-plf"><span data-custom-style="Hyperlink">6.4 Floating-point Arithmetic [PLF]</span> 8</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#enumerator-issues-ccb"><span data-custom-style="Hyperlink">6.5 Enumerator Issues [CCB]</span> 8</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc1165233"><span data-custom-style="Hyperlink">6.6 Conversion Errors [FLC]</span> 9</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#string-termination-cjm"><span data-custom-style="Hyperlink">6.7 String Termination [CJM]</span> 10</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc1165235"><span data-custom-style="Hyperlink">•</span> <span data-custom-style="Hyperlink">Use std::string or similar, in preference to C-style arrays of chars</span> 11</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#buffer-boundary-violation-hcb"><span data-custom-style="Hyperlink">6.8 Buffer Boundary Violation [HCB]</span> 11</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unchecked-array-indexing-xyz"><span data-custom-style="Hyperlink">6.9 Unchecked Array Indexing [XYZ]</span> 12</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unchecked-array-copying-xyw"><span data-custom-style="Hyperlink">6.10 Unchecked Array Copying [XYW]</span> 13</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#pointer-type-conversions-hfc"><span data-custom-style="Hyperlink">6.11 Pointer Type Conversions [HFC]</span> 13</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#pointer-arithmetic-rvg"><span data-custom-style="Hyperlink">6.12 Pointer Arithmetic [RVG]</span> 15</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#null-pointer-dereference-xyh"><span data-custom-style="Hyperlink">6.13 NULL Pointer Dereference [XYH]</span> 16</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dangling-reference-to-heap-xyk"><span data-custom-style="Hyperlink">6.14 Dangling Reference to Heap [XYK]</span> 16</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#arithmetic-wrap-around-error-fif"><span data-custom-style="Hyperlink">6.15 Arithmetic Wrap-around Error [FIF]</span> 18</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#using-shift-operations-for-multiplication-and-division-pik"><span data-custom-style="Hyperlink">6.16 Using Shift Operations for Multiplication and Division [PIK]</span> 18</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#choice-of-clear-names-nai"><span data-custom-style="Hyperlink">6.17 Choice of Clear Names [NAI]</span> 19</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dead-store-wxq"><span data-custom-style="Hyperlink">6.18 Dead Store [WXQ]</span> 19</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unused-variable-yzs"><span data-custom-style="Hyperlink">6.19 Unused Variable [YZS]</span> 20</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#identifier-name-reuse-yow"><span data-custom-style="Hyperlink">6.20 Identifier Name Reuse [YOW]</span> 20</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc310518176"><span data-custom-style="Hyperlink">6.21 Namespace Issues [BJL]</span> 21</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#initialization-of-variables-lav"><span data-custom-style="Hyperlink">6.22 Initialization of Variables [LAV]</span> 21</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#operator-precedence-and-associativity-jcw"><span data-custom-style="Hyperlink">6.23 Operator Precedence and Associativity [JCW]</span> 21</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#side-effects-and-order-of-evaluation-of-operands-sam"><span data-custom-style="Hyperlink">6.24 Side-effects and Order of Evaluation of Operands [SAM]</span> 21</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#likely-incorrect-expression-koa"><span data-custom-style="Hyperlink">6.25 Likely Incorrect Expression [KOA]</span> 22</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dead-and-deactivated-code-xyq"><span data-custom-style="Hyperlink">6.26 Dead and Deactivated Code [XYQ]</span> 24</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#switch-statements-and-static-analysis-cll"><span data-custom-style="Hyperlink">6.27 Switch Statements and Static Analysis [CLL]</span> 24</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#demarcation-of-control-flow-eoj"><span data-custom-style="Hyperlink">6.28 Demarcation of Control Flow [EOJ]</span> 25</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#loop-control-variables-tex"><span data-custom-style="Hyperlink">6.29 Loop Control Variables [TEX]</span> 26</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#off-by-one-error-xzh"><span data-custom-style="Hyperlink">6.30 Off-by-one Error [XZH]</span> 27</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#structured-programming-ewd"><span data-custom-style="Hyperlink">6.31 Structured Programming [EWD]</span> 28</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#passing-parameters-and-return-values-csj"><span data-custom-style="Hyperlink">6.32 Passing Parameters and Return Values [CSJ]</span> 28</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dangling-references-to-stack-frames-dcm"><span data-custom-style="Hyperlink">6.33 Dangling References to Stack Frames [DCM]</span> 29</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#subprogram-signature-mismatch-otr"><span data-custom-style="Hyperlink">6.34 Subprogram Signature Mismatch [OTR]</span> 30</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#recursion-gdl"><span data-custom-style="Hyperlink">6.35 Recursion [GDL]</span> 31</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#ignored-error-status-and-unhandled-exceptions-oyb"><span data-custom-style="Hyperlink">6.36 Ignored Error Status and Unhandled Exceptions [OYB]</span> 31</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#type-breaking-reinterpretation-of-data-amv"><span data-custom-style="Hyperlink">6.37 Type-breaking Reinterpretation of Data [AMV]</span> 32</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#deep-vs.-shallow-copying-yan"><span data-custom-style="Hyperlink">6.38 Deep vs. Shallow Copying [YAN]</span> 33</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#memory-leak-and-heap-fragmentation-xyl"><span data-custom-style="Hyperlink">6.39 Memory Leak and Heap Fragmentation [XYL]</span> 33</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#templates-and-generics-sym"><span data-custom-style="Hyperlink">6.40 Templates and Generics [SYM]</span> 34</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#inheritance-rip"><span data-custom-style="Hyperlink">6.41 Inheritance [RIP]</span> 35</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#applicability-to-language-39"><span data-custom-style="Hyperlink">6.41.1 Applicability to language</span> 35</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-37"><span data-custom-style="Hyperlink">6.41.2 Guidance to language users</span> 37</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#violations-of-the-liskov-substitution-principle-or-the-contract-model-blp"><span data-custom-style="Hyperlink">6.42 Violations of the Liskov Substitution Principle or the Contract Model [BLP]</span> 37</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#applicability-to-language-40"><span data-custom-style="Hyperlink">6.42.1 Applicability to language</span> 37</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-38"><span data-custom-style="Hyperlink">6.42.2 Guidance to language users</span> 38</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#redispatching-pph"><span data-custom-style="Hyperlink">6.43 Redispatching [PPH]</span> 38</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#applicability-to-language-41"><span data-custom-style="Hyperlink">6.43.1 Applicability to language</span> 38</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-39"><span data-custom-style="Hyperlink">6.43.2 Guidance to language users</span> 39</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#polymorphic-variables-bkk"><span data-custom-style="Hyperlink">6.44 Polymorphic variables [BKK]</span> 39</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#applicability-to-language-42"><span data-custom-style="Hyperlink">6.44.1 Applicability to language</span> 40</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-40"><span data-custom-style="Hyperlink">6.44.2 Guidance to language users</span> 41</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#extra-intrinsics-lrm"><span data-custom-style="Hyperlink">6.45 Extra Intrinsics [LRM]</span> 42</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#argument-passing-to-library-functions-trj"><span data-custom-style="Hyperlink">6.46 Argument Passing to Library Functions [TRJ]</span> 42</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#inter-language-calling-djs"><span data-custom-style="Hyperlink">6.47 Inter-language Calling [DJS]</span> 42</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dynamically-linked-code-and-self-modifying-code-nyy"><span data-custom-style="Hyperlink">6.48 Dynamically-linked Code and Self-modifying Code [NYY]</span> 45</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#library-signature-nsq"><span data-custom-style="Hyperlink">6.49 Library Signature [NSQ]</span> 46</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unanticipated-exceptions-from-library-routines-hjw"><span data-custom-style="Hyperlink">6.50</span> <span data-custom-style="Hyperlink">Unanticipated Exceptions from Library Routines [HJW]</span> 47</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#pre-processor-directives-nmp"><span data-custom-style="Hyperlink">6.51 Pre-processor Directives [NMP]</span> 48</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#suppression-of-language-defined-run-time-checking-mxb"><span data-custom-style="Hyperlink">6.52 Suppression of Language-defined Run-time Checking [MXB]</span> 49</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#provision-of-inherently-unsafe-operations-skl"><span data-custom-style="Hyperlink">6.53 Provision of Inherently Unsafe Operations [SKL]</span> 49</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#obscure-language-features-brs"><span data-custom-style="Hyperlink">6.54 Obscure Language Features [BRS]</span> 49</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unspecified-behaviour-bqf"><span data-custom-style="Hyperlink">6.55 Unspecified Behaviour [BQF]</span> 50</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#undefined-behaviour-ewf"><span data-custom-style="Hyperlink">6.56 Undefined Behaviour [EWF]</span> 50</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#implementationdefined-behaviour-fab"><span data-custom-style="Hyperlink">6.57 Implementation–defined Behaviour [FAB]</span> 51</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#deprecated-language-features-mem"><span data-custom-style="Hyperlink">6.58 Deprecated Language Features [MEM]</span> 52</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#concurrency-activation-cga"><span data-custom-style="Hyperlink">6.59 Concurrency – Activation [CGA]</span> 52</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#concurrency-directed-termination-cgt"><span data-custom-style="Hyperlink">6.60 Concurrency – Directed termination [CGT]</span> 52</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc1165297"><span data-custom-style="Hyperlink">6.60.1 Applicability to language</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-55"><span data-custom-style="Hyperlink">6.60.2 Guidance to language users</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc1165299"><span data-custom-style="Hyperlink">6.61 Concurrent Data Access [CGX]</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#concurrency-premature-termination-cgs"><span data-custom-style="Hyperlink">6.62 Concurrency – Premature Termination [CGS]</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#protocol-lock-errors-cgm"><span data-custom-style="Hyperlink">6.63 Protocol Lock Errors [CGM]</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#uncontrolled-format-string-shl"><span data-custom-style="Hyperlink">6.64 Uncontrolled Format String [SHL]</span> 54</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#language-specific-vulnerabilities-for-c"><span data-custom-style="Hyperlink">7. Language specific vulnerabilities for C</span> 54</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#implications-for-standardization"><span data-custom-style="Hyperlink">8. Implications for standardization</span> 54</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#bibliography"><span data-custom-style="Hyperlink">Bibliography</span> 57</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#index"><span data-custom-style="Hyperlink">Index</span> 60</a></p>
</div>
<h1 id="foreword">Foreword</h1>
<p>ISO (the International Organization for Standardization) and IEC (the International Electrotechnical Commission) form the specialized system for worldwide standardization. National bodies that are members of ISO or IEC participate in the development of International Standards through technical committees established by the respective organization to deal with particular fields of technical activity. ISO and IEC technical committees collaborate in fields of mutual interest. Other international organizations, governmental and non-governmental, in liaison with ISO and IEC, also take part in the work. In the field of information technology, ISO and IEC have established a joint technical committee, ISO/IEC JTC 1.</p>
<p>International Standards are drafted in accordance with the rules given in the ISO/IEC Directives, Part 2.</p>
<p>The main task of the joint technical committee is to prepare International Standards. Draft International Standards adopted by the joint technical committee are circulated to national bodies for voting. Publication as an International Standard requires approval by at least 75 % of the national bodies casting a vote.</p>
<p>In exceptional circumstances, when the joint technical committee has collected data of a different kind from that which is normally published as an International Standard (“state of the art”, for example), it may decide to publish a Technical Report. A Technical Report is entirely informative in nature and shall be subject to review every five years in the same manner as an International Standard.</p>
<p>Attention is drawn to the possibility that some of the elements of this document may be the subject of patent rights. ISO and IEC shall not be held responsible for identifying any or all such patent rights.</p>
<p>ISO/IEC TR 24772-10, was prepared by Joint Technical Committee ISO/IEC JTC 1, <em>Information technology</em>, Subcommittee SC 22, <em>Programming languages, their environments and system software interfaces</em>.</p>
<h1 id="introduction">Introduction</h1>
<div data-custom-style="zzHelp">
<p>This Technical Report provides guidance for the programming language C++, so that application developers using or considering C++ will be better able to avoid the programming constructs that lead to vulnerabilities in software written in the C++ language and their attendant consequences. This guidance can also be used by developers to select source code evaluation tools that can discover and eliminate some constructs that could lead to vulnerabilities in their software. This report can also be used in comparison with companion Technical Reports and with the language-independent report, TR 24772–1, to select a programming language that provides the appropriate level of confidence that anticipated problems can be avoided.</p>
</div>
<div data-custom-style="zzHelp">
<p>This technical report part is intended to be used with TR 24772–1, which discusses programming language vulnerabilities in a language independent fashion. It is also intended to be used with TR 24772-3, which discusses how the vulnerabilities introduced in TR 24772-1 are manifested in C, which is a subset of C++.</p>
</div>
<p>It should be noted that this Technical Report is inherently incomplete. It is not possible to provide a complete list of programming language vulnerabilities because new weaknesses are discovered continually. Any such report can only describe those that have been found, characterized, and determined to have sufficient probability and consequence.</p>
<div data-custom-style="Bibliography1">
<p><strong>Information Technology — Programming Languages — Guidance to avoiding vulnerabilities in programming languages — Vulnerability descriptions for the programming language C++</strong></p>
</div>
<h1 id="scope">1. Scope</h1>
<p>This Technical Report specifies software programming language vulnerabilities to be avoided in the development of systems where assured behaviour is required for security, safety, mission-critical and business-critical software. In general, this guidance is applicable to the software developed, reviewed, or maintained for any application.</p>
<p>Vulnerabilities described in this Technical Report document the way that the vulnerability described in the language-independent TR 24772–1 are manifested in C++.</p>
<h1 id="normative-references">2. Normative references</h1>
<p>The following referenced documents are indispensable for the application of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.</p>
<p>ISO/IEC 14882:2014 — <em>Programming Languages—C</em> ++</p>
<p>ISO/IEC TR24772–3 -- Information Technology — Programming Languages — Guidance to avoiding vulnerabilities in programming languages — Vulnerability descriptions for the programming language C</p>
<h1 id="terms-and-definitions-symbols-and-conventions">3. Terms and definitions, symbols and conventions</h1>
<h2 id="terms-and-definitions">3.1 Terms and definitions</h2>
<!-- TODO: needs formatting adjustment as of ISO word template document -->
<p>For the purposes of this document, the terms and definitions given in ISO/IEC 2382, in TR 24772–1, in 14882:2014 and the following apply. Other terms are defined where they appear in <em>italic</em> type.</p>
<p>The following terms are in alphabetical order, with general topics referencing the relevant specific terms.</p>
<p><u>3.1.1</u></p>
<p><u>TBD</u></p>
<p><u>3.1.2</u></p>
<p><u>access</u>:</p>
<p>An execution-time action, to read or modify the value of an object.</p>
<blockquote>
<p>Note 1: Where only one of two actions is meant, read or modify. Modify includes the case where the new value being stored is the same as the previous value. Expressions that are not evaluated do not access objects</p>
</blockquote>
<p><strong><u>3.1.3</u></strong></p>
<p>access protection</p>
<p><strong><u>alignment</u></strong><br />
requirement that objects of a particular type be located on storage boundaries with addresses that are particular multiples of a byte address.</p>
<p><strong><u>3.1.3</u></strong></p>
<p><strong><u>argument</u></strong><br />
the expression in the comma-separated list bounded by the parentheses in a function call expression, or a sequence of preprocessing tokens in the comma-separated list bounded by the parentheses in a function-like macro invocation</p>
<blockquote>
<p>Note 1: Also called actual argument</p>
<p>Note 2: An argument replaces a <em>formal parameter</em> as the call is realized.</p>
</blockquote>
<p><strong><u>3.1.4</u></strong></p>
<p><strong><u>behaviour</u></strong><br />
an external appearance or action</p>
<blockquote>
<p>Note 3: See: implementation-defined behavior, locale-specific behavior, undefined behavior, unspecified behaviour</p>
</blockquote>
<p><strong><u>3.1.5</u></strong></p>
<p><strong><u>bit</u></strong><br />
the unit of data storage in the execution environment large enough to hold an object that may have one of two values</p>
<p>Note: It need not be possible to express the address of each individual bit of an object.</p>
<p><strong><u>3.1.6</u></strong></p>
<p><strong><u>byte</u></strong><br />
the addressable unit of data storage large enough to hold any member of the basic character set of the execution environment</p>
<blockquote>
<p>Note: It is possible to express the address of each individual byte of an object uniquely. A byte is composed of a contiguous sequence of bits, the number of which is implementation-defined. The least significant bit is called the low-order bit; the most significant bit is called the high-order bit.</p>
</blockquote>
<p><strong><u>3.1.7</u></strong></p>
<p><strong><u>character</u></strong><br />
abstract member of a set of elements used for the organization, control, or representation of data</p>
<blockquote>
<p>Note: See: single-byte character, multibyte character, wide character</p>
</blockquote>
<p><strong><u>correctly rounded result</u></strong><br />
representation in the result format that is nearest in value, subject to the current rounding mode, to what the result would be given unlimited range and precision.</p>
<p>3.1.8</p>
<p><strong><u>class</u></strong><br />
<u>TBD</u></p>
<p><strong><u>3.1.9</u></strong></p>
<p><strong><u>concrete</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.10</u></strong></p>
<p><strong><u>diagnostic message</u></strong><br />
</p>
<p>message belonging to an implementation-defined subset of the implementation’s message output</p>
<p>Note: The C Standard requires diagnostic messages for all constraint violations.</p>
<p><strong>[3.1.11]</strong>{.ul}**<br />
</p>
<p><strong><u>dynamic dispatch</u></strong><br />
</p>
<p><u>TBD</u></p>
<p>3.1.12</p>
<p><strong><u>encapsulation</u></strong><br />
</p>
<p><u>TBD</u></p>
<p><strong><u>3.1.13</u></strong><br />
</p>
<p><strong><u>formal parameter</u></strong><br />
</p>
<p>object declared as part of a function declaration or definition that acquires a value on entry to the function, or an identifier from the comma-separated list bounded by the parentheses immediately following the macro name in a function-like macro definition.</p>
<p><strong>[3.1.14] hidden friends</strong><br />
</p>
<p>an available function or object that can only be accessed … (needs completion)</p>
<p>Note: explain the difference between C++ “hidden friends” “[hidden.friends] in the C++ standard” and the usage in this document.</p>
<p><strong><u>3.1.14</u></strong><br />
</p>
<p><strong><u>Implementation</u></strong><br />
</p>
<p>particular set of software, running in a particular translation environment under particular control options, that performs translation of programs for, and supports execution of functions in, a particular execution environment.</p>
<p><strong><u>3.1.15</u></strong><br />
</p>
<p><strong><u>implementation-defined behaviour</u></strong><br />
</p>
<p>unspecified behaviour where each implementation documents how the choice is made</p>
<p>Note: An example of implementation-defined behaviour is the propagation of the high-order bit when a signed integer is shifted right.</p>
<p><strong><u>3.1.16</u></strong><br />
</p>
<p><strong><u>implementation-defined value</u></strong><br />
</p>
<p>unspecified value where each implementation documents how the choice for the value is selected.</p>
<p><strong><u>3.1.17</u></strong><br />
</p>
<p><strong><u>implementation limit</u></strong><br />
</p>
<p>restriction imposed upon programs by the implementation.</p>
<p><strong><u>3.1.18</u></strong><br />
</p>
<p><strong><u>indeterminate value</u></strong><br />
</p>
<p>unspecified value or a trap representation.</p>
<p><strong><u>3.1.19</u></strong><br />
</p>
<p><strong><u>Inheritance</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.20</u></strong><br />
</p>
<p><strong><u>language type</u></strong><br />
</p>
<p>see block-structured language, comb-structured language (Non-responsive)</p>
<p><strong><u>3.1.21</u></strong><br />
</p>
<p><strong><u>locale-specific behaviour</u></strong><br />
</p>
<p>behaviour that depends on local conventions of nationality, culture, and language that each implementation documents</p>
<p>Note: An example, locale-specific behaviour is whether the islower() function returns true for characters other than the 26 lower case Latin letters.</p>
<p><strong><u>3.1.22</u></strong><br />
</p>
<p><strong><u>memory location</u></strong><br />
</p>
<p>an object of scalar[^1] type, or a maximal sequence of adjacent bit-fields all having nonzero width (Non-responsive)</p>
<blockquote>
<p>Note: A bit-field and an adjacent non-bit-field member are in separate memory locations. The same applies to two bit-fields, if one is declared inside a nested structure declaration and the other is not, or if the two are separated by a zero-length bit-field declaration, or if they are separated by a non-bit-field member declaration. It is not safe to concurrently update two bit-fields in the same structure if all members declared between them are also bit-fields, no matter what the sizes of those intervening bit-fields happen to be. For example a structure declared as</p>
</blockquote>
<p>struct {</p>
<p>char a;</p>
<p>int b:5, c:11, :0, d:8;</p>
<p>struct { int ee:8; } e;</p>
<p>}</p>
<p>contains four separate memory locations: The member a, and bit-fields d and e.ee are separate memory locations, and can be modified concurrently without interfering with each other. The bit-fields b and c together constitute the fourth memory location. The bit-fields b and c can’t be concurrently modified, but b and a, can be concurrently modified.</p>
<p><strong><u>3.23</u></strong><br />
</p>
<p><strong><u>multibyte character</u></strong><br />
</p>
<p>sequence of one or more bytes representing a member of the extended character set of either the source or the execution environment.</p>
<p>Note: The extended character set is a superset of the basic character set.</p>
<p><strong><u>3.1.24</u></strong><br />
</p>
<p><strong><u>namespace</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.25</u></strong><br />
</p>
<p><strong><u>object</u></strong><br />
</p>
<p>region of data storage in the execution environment, the contents of which can represent values</p>
<p>Note: When referenced, an object may be interpreted as having a particular type.</p>
<p><strong><u>3.1.26</u></strong><br />
</p>
<p><strong><u>overload</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.27</u></strong><br />
</p>
<p><strong><u>override</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.28</u></strong><br />
</p>
<p><strong><u>parameter</u></strong><br />
</p>
<p>(rewrite) See actual argument, argument, formal parameter (Non-responsive, needs definition)</p>
<p><strong><u>3.1.29</u></strong><br />
</p>
<p><strong>{Protected]{.ul}</strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.30</u></strong><br />
</p>
<p><strong><u>private</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.31</u></strong><br />
</p>
<p><strong><u>Public</u></strong><br />
</p>
<p>TBD</p>
<p>3.1.32</p>
<p>Pure</p>
<p><u>TBD</u></p>
<p><strong><u>3.1.33</u></strong><br />
</p>
<p><strong><u>recommended practice</u></strong><br />
</p>
<p>specification that is strongly recommended as being in keeping with the intent of the language standard, but that may be impractical for some implementations</p>
<p>**<u>3.1.34</u>((<br />
</p>
<p><strong><u>runtime-constraint</u></strong><br />
</p>
<p>requirement on a program when calling a library function</p>
<p><strong><u>3.1.35</u></strong><br />
</p>
<p><strong><u>single-byte character</u></strong><br />
</p>
<p>bit representation that fits in a byte (binary representation?)</p>
<p><strong><u>3.1.36</u></strong><br />
</p>
<p><strong><u>static</u></strong><br />
</p>
<p><u>TBD</u></p>
<p>**<u>3.1.37</u></p>
<p><strong><u>STL</u></strong><br />
</p>
<p><u>TBD</u></p>
<p><strong><u>3.1.38</u></strong><br />
</p>
<p><strong><u>standard library</u></strong><br />
</p>
<p>[TBD]</p>
<p><strong><u>3.1.39</u></strong><br />
</p>
<p><strong><u>template</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.40</u></strong><br />
</p>
<p><strong><u>trap representation</u></strong><br />
</p>
<p>object representation that need not represent a value of the object type</p>
<p><strong><u>3.1.41</u></strong><br />
</p>
<p><strong><u>undefined behaviour</u></strong><br />
</p>
<p>use of a non-portable or erroneous program construct or of erroneous data, for which the language standard imposes no requirements</p>
<blockquote>
<p>Note: Undefined behaviour ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message). An example of, undefined behaviour is the behaviour on integer overflow.</p>
</blockquote>
<p><strong><u>3.1.42</u></strong><br />
</p>
<p><strong><u>unspecified behaviour</u></strong><br />
</p>
<p>use of an unspecified value, or other behaviour where the language standard provides two or more possibilities and imposes no further requirements on which is chosen in any instance</p>
<blockquote>
<p>Note: For example, unspecified behaviour is the order in which the arguments to a function are evaluated.</p>
</blockquote>
<p><strong><u>3.1.43</u></strong><br />
</p>
<p><strong><u>unspecified value</u></strong><br />
</p>
<p>valid value of the relevant type where the language standard imposes no requirements on which value is chosen in any instance</p>
<blockquote>
<p>Note: An unspecified value cannot be a trap representation.</p>
</blockquote>
<p><strong><u>3.1.44</u></strong><br />
</p>
<p><strong><u>value</u></strong><br />
</p>
<p>precise meaning of the contents of an object when interpreted as having a specific type (specific type or specified type?)</p>
<blockquote>
<p>Note: See implementation-defined value, indeterminate value, unspecified value, trap representation</p>
</blockquote>
<p><strong><u>3.1.45</u></strong><br />
</p>
<p><strong><u>virtual</u></strong><br />
</p>
<p><u>TBD</u></p>
<p><strong><u>3.1.45</u></strong><br />
</p>
<p><strong><u>wide character</u></strong><br />
</p>
<p>bit representation capable of representing any character in the current locale</p>
<p><span data-custom-style="annotation reference"></span></p>
<h1 id="language-concepts">4. Language concepts</h1>
<p><u><em>This clause requires a rewrite. See C++ Core Guidelines CPL for a good explanation of the differences</em>.</u></p>
<p>C++ has a rich type system with many nuances. In addition to the C base types (int, long, float, double, char, and arrays with their C-style vulnerabilities), C++ provides the following:</p>
<ul>
<li><pre><code>Distinct types for char, signed char, unsigned char</code></pre></li>
<li><pre><code>bool with a true Boolean context</code></pre></li>
<li><pre><code>enum with fixed underlying type</code></pre></li>
<li><pre><code>Classes as the primary user-defined types</code></pre></li>
<li><pre><code>Arrays</code></pre></li>
<li><pre><code>References in addition to pointers</code></pre></li>
<li><pre><code>Parameterized types</code></pre></li>
</ul>
<p>Many vulnerabilities can be mitigated more easily by using library facilities rather than the base language types. (e.g. std::string rather than char*)</p>
<ul>
<li><pre><code>Use of the `explicit`{.cpp} keyword for constructors and conversion
operators</code></pre></li>
<li><pre><code>`operator bool()`{.cpp} discussion</code></pre></li>
<li><pre><code>many built-in implicit conversions, refer to TR 24772-3 clause 6.2
and other clauses (C)</code></pre></li>
<li><pre><code>conversion to bool and null pointer conversions</code></pre></li>
<li><pre><code>legacy code operator void\* - change to explicit operator bool</code></pre></li>
<li><pre><code>C-style casts break type safety.</code></pre></li>
<li><pre><code>static_cast</code></pre></li>
<li><pre><code>explicit casts highlight mismatches between the design and
implementation.</code></pre></li>
<li><pre><code>const and volatile</code></pre></li>
<li><pre><code>constexpr -- needs a writeup -- (in C++:11 , encouraged heavy stack
use and possible exhaustion).</code></pre></li>
</ul>
<p>Narrowly tailored number-like class types, such as time_point and duration, improve safety by providing only safe and appropriate operations. User-defined types tailored to a particular use case can provide additional safety.</p>
<p>C++ was initially defined as a syntactic superset of the C programming language: adding object oriented features such as classes, encapsulation, dynamic dispatch, namespaces and templates. It was a “syntactic superset” because whilst there is a core of C++ that is syntactically identical to C, it has always been the case that there are subtle semantic differences between the two, for example:</p>
<ul>
<li><p>Historically, C permitted the use of a function before its declaration (though this is now deprecated in C) . This is illegal in C++</p></li>
<li><p>Where a struct is defined within another struct, in C the inner declaration is in effect made at file scope, so the definition is available for use later in the program. In C++, the inner declaration name is qualified by that of the parent, so without qualification, the inner struct cannot be used later in the program, as in the following example</p></li>
</ul>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S1 {</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">struct</span> S2 {...} m1;</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>   ...</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S2 v1; /\* legal in C <span class="kw">not</span> C++ \*/</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>S1::S2 v2 <span class="co">// legal in C++ not C</span></span></code></pre></div>
<p>Subsequently, the two languages have diverged, both adding features not present in the other. Not withstanding that, there is still a significant syntactic and semantic overlap between C and C++, so the starting point for this report has been the equivalent for C. However, in many cases, the additional features of C++ provide mechanisms for avoiding the vulnerabilities inherited from C, and these are reflected in the following sections.</p>
<p><em>Include discussions of Object orientation, <strong>static</strong>, and <strong>const,</strong> scoped enumerations</em></p>
<p>C++ includes concurrency within the language, expressed by <em>threads</em> and <em>tasks.</em> Threads are sequences of execution that can be executed concurrently with the entity (thread) that created them, and with each other. There are good reasons to use threads in a C++ program:</p>
<ol type="a">
<li><p>The running program, or a running thread, block for real-world events, such as awaiting input, awaiting completion of a system-level event, or communications with non-local systems.</p></li>
<li><p>Threading permit other parts of the program to continue execution even while one or more parts are blocked, or lets a program to await and respond to sets of events in the order that they are received.</p></li>
<li><p>Threading lets the program make effective use of multiple cores, proving significantly more computing power to a program.</p></li>
</ol>
<p>Threads are initiated by calling std::threads constructor. The thread is then initialized and begins execution on its sequence of instructions. A thread can be <em>joined</em>, i.e. the joining thread awaits the completion of the joined thread, or a thread can be <em>detached</em>.</p>
<p>Threads share data and events via <em>atomic</em> variables, <em>condition_variables</em>, <em>futures</em>, and <em>mutexes</em>.</p>
<p>Threads terminate when they complete the execution of the function that was named at thread initiation.</p>
<p>C++ also has the notion of light weight concurrency in the form of <em>tasks</em>. These tasks are created by calling the std:packaged_task with a <em>function</em>, <em>lambda expression</em>, <em>bind expression</em> or another <em>function object</em>. It is expected that the results of a task execution is collected at the end of that execution by calling <em>get_future</em> (t) and waiting for that/those completion(s).</p>
<p>In addition, C++ programs can interact with other programs executing in a system using operating system-level calls to initiate, schedule, communicate and destroy/terminate itself or others.</p>
<p>There are a number of significant vulnerabilities associated with concurrency, which are described in clause 6.59 through 6.63 of this document.</p>
<h1 id="avoiding-programming-language-vulnerabilities-in-c">5. Avoiding programming language vulnerabilities in C++</h1>
<blockquote>
<p>In addition to the generic programming rules from ISO/IECTR 24772-1 clause 5.4, additional rules from this section apply specifically to the C++ programming language. The recommendations of this section are restatements of recommendations from clause 6, but represent ones stated frequently, or that are considered as particularly noteworthy by the authors. Clause 6 of this document contains the full set of recommendations, as well as explanations of the problems that led to the recommendations made.</p>
</blockquote>
<blockquote>
<p>Every guidance provided in this section, and in the corresponding Part section, is supported by material in Clause 6 of this document, as well as other important recommendations.</p>
</blockquote>
<blockquote>
<p><strong><em>TBD</em></strong></p>
</blockquote>
<table style="width:94%;">
<colgroup>
<col style="width: 44%" />
<col style="width: 5%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th>Index</th>
<th></th>
<th>Reference[]{custom- style=“annotation reference”}</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>2</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>3</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>4</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>5</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>6</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Need to consider C++-11, 14 and 17.</p>
<h1 id="specific-guidance-for-c-vulnerabilities">6. Specific Guidance for C++ Vulnerabilities</h1>
<h2 id="general">6.1 General</h2>
<p>This clause contains specific advice for C++ about the possible presence of vulnerabilities as described in TR 24772-1, and provides specific guidance on how to avoid them in C++ code. This section mirrors TR 24772-1 clause 6 in that the vulnerability “Type System [IHN]” is found in 6.2 of TR 24772–1, and C++ specific guidance is found in clause 6.2 and subclauses in this TR.</p>
<p>As part of its design (and with few exceptions), C++ has a common subset with the complete C language. For code portions written in the common subset, the vulnerabilities described and the advice given in ISO/IEC TR 24772-3:2020, <em>Part 3 – Vulnerability descriptions for the programming language C</em>, apply, except when this document provides refined advice. The following subclauses usually do not further acknowledge the issues from the subset since those have been adequately addressed in the referenced document. However, C++ provides mechanisms to mitigate many of the problems that arise. Please refer to the respective clauses of this document for these mitigations and related guidelines.</p>
<h2 id="type-system-ihn">6.2 Type System [IHN]</h2>
<h3 id="applicability-to-language">6.2.1 Applicability to language</h3>
<p>C++ is a strongly- and statically-typed language: all variables and expressions must have a type. C++ also permits implicit and explicit conversions between types.</p>
<p>C++’s implicit conversions between types include C’s implicit conversions, for example, fundamental types smaller than an <code class="sourceCode cpp"><span class="dt">int</span></code> can be promoted to an <code class="sourceCode cpp"><span class="dt">int</span></code> when participating in an expression. The keyword <code class="sourceCode cpp"><span class="kw">explicit</span></code> applied to a constructor or a cast operator prevents implicit conversions. Implicit conversions involving user-defined types are enabled via constructors that can be called with a single-argument and/or cast operators of those types.</p>
<p>ADVICE: Prefer to define <code class="sourceCode cpp"><span class="kw">explicit</span></code> constructors and cast operators except in cases where it would be safe and meaningful to permit implicit conversions.</p>
<p>C++’s <code class="sourceCode cpp"><span class="kw">dynamic_cast</span>&lt;T&gt;(expr)</code> operator attempts to cast the expression, <code class="sourceCode cpp">expr</code>, to <code class="sourceCode cpp">type T</code> at run-time using internal type state information the compiler stored with expr’s type. All other casts (implicit or explicit) are computed using only compile-time –not run-time-- information.</p>
<p>It is possible to use a single type to define two distinct sets of values, e.g., a double could be used to store the distance in kilometers or miles.:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> miles = <span class="fl">5.67</span>;</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> km    = <span class="fl">13.88</span>;</span></code></pre></div>
<p>If the same underlying type is used then one risks manipulating such without properly converting the units first, e.g.,</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> distance_travelled = miles + km; <span class="co">// =19.55 (what?)</span></span></code></pre></div>
<p>which will produce an incorrect result. Instead one must define user-defined types with constructors and/or cast operator definitions that will use the type system to correctly convert units. For this example we will use temperatures in Celsius and Fahrenheit.</p>
<pre><code>&lt;!-- the following code is not C++ (confused, Peter) --&gt;</code></pre>
<pre><code>t1 : Celsius := -40.0;
t2 : Fahrenheit := 32.0;</code></pre>
<pre><code>&lt;!--
ASIDE: This code works but needs discussion and brevity.
--&gt;</code></pre>
<div class="sourceCode" id="cb87"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> miles { <span class="dt">double</span> m; };</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> kilometer { <span class="dt">double</span> km; };</span></code></pre></div>
<!-- code example to be reworked by Paul: -->
<div class="sourceCode" id="cb88"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> celsius;</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> fahrenheit;</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> celsius</span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> val;</span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a>  celsius() : val{} { }</span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a>  celsius(celsius <span class="at">const</span>&amp;) = <span class="cf">default</span>;            </span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>  celsius&amp; <span class="kw">operator</span> =(celsius <span class="at">const</span>&amp;) = <span class="cf">default</span>;</span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">explicit</span> celsius(<span class="dt">double</span> <span class="at">const</span>&amp; v) : val{v} { }</span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> <span class="at">const</span>&amp; value() <span class="at">const</span> { <span class="cf">return</span> val; }</span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-18"><a href="#cb88-18" aria-hidden="true" tabindex="-1"></a>  celsius(fahrenheit <span class="at">const</span>&amp; f);     <span class="co">// permits implicit casts</span></span>
<span id="cb88-19"><a href="#cb88-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">operator</span> fahrenheit() <span class="at">const</span>;      <span class="co">// permits implicit casts</span></span>
<span id="cb88-20"><a href="#cb88-20" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb88-21"><a href="#cb88-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-22"><a href="#cb88-22" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> fahrenheit</span>
<span id="cb88-23"><a href="#cb88-23" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb88-24"><a href="#cb88-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">// The code for fahrenheit is repeated from celsius with “fahrenheit” </span></span>
<span id="cb88-25"><a href="#cb88-25" aria-hidden="true" tabindex="-1"></a>  <span class="co">// replacing “celsius”</span></span>
<span id="cb88-26"><a href="#cb88-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">// and missing the last two declarations. </span></span>
<span id="cb88-27"><a href="#cb88-27" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb88-28"><a href="#cb88-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-29"><a href="#cb88-29" aria-hidden="true" tabindex="-1"></a>celsius::celsius(fahrenheit <span class="at">const</span>&amp; f) :</span>
<span id="cb88-30"><a href="#cb88-30" aria-hidden="true" tabindex="-1"></a>  val{ (f.value() - <span class="fl">32.0</span>) * <span class="fl">5.0</span> / <span class="fl">9.0</span> }         <span class="co">// constructor to celsuis</span></span>
<span id="cb88-31"><a href="#cb88-31" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb88-32"><a href="#cb88-32" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb88-33"><a href="#cb88-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-34"><a href="#cb88-34" aria-hidden="true" tabindex="-1"></a>celsius::<span class="kw">operator</span> fahrenheit() <span class="at">const</span>    <span class="co">// cast operator to Fahrenheit!!</span></span>
<span id="cb88-35"><a href="#cb88-35" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb88-36"><a href="#cb88-36" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> fahrenheit{ (<span class="kw">this</span>-&gt;val * <span class="fl">9.0</span>) / <span class="fl">5.0</span> + <span class="fl">32.0</span> };</span>
<span id="cb88-37"><a href="#cb88-37" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb88-38"><a href="#cb88-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-39"><a href="#cb88-39" aria-hidden="true" tabindex="-1"></a>celsius <span class="kw">operator</span> <span class="st">&quot;&quot;</span> _C(<span class="dt">long</span> <span class="dt">double</span> temp)</span>
<span id="cb88-40"><a href="#cb88-40" aria-hidden="true" tabindex="-1"></a>  { <span class="cf">return</span> celsius(temp); }        <span class="co">// explicit construction w/double</span></span>
<span id="cb88-41"><a href="#cb88-41" aria-hidden="true" tabindex="-1"></a>fahrenheit <span class="kw">operator</span> <span class="st">&quot;&quot;</span> _F(<span class="dt">long</span> <span class="dt">double</span> temp)</span>
<span id="cb88-42"><a href="#cb88-42" aria-hidden="true" tabindex="-1"></a>  { <span class="cf">return</span> fahrenheit(temp); }      <span class="co">// explicit construction w/double</span></span>
<span id="cb88-43"><a href="#cb88-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-44"><a href="#cb88-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-45"><a href="#cb88-45" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main()</span>
<span id="cb88-46"><a href="#cb88-46" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb88-47"><a href="#cb88-47" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb88-48"><a href="#cb88-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-49"><a href="#cb88-49" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> fp = <span class="fl">0.0</span><span class="dv">_C</span>; <span class="co">// Celsius</span></span>
<span id="cb88-50"><a href="#cb88-50" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> bp = <span class="fl">212.0</span><span class="dv">_F</span>; <span class="co">// Fahrenheit</span></span>
<span id="cb88-51"><a href="#cb88-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-52"><a href="#cb88-52" aria-hidden="true" tabindex="-1"></a>  fahrenheit fp_F = fp; <span class="co">// implicit conversion</span></span>
<span id="cb88-53"><a href="#cb88-53" aria-hidden="true" tabindex="-1"></a>  celsius bp_C = bp;    <span class="co">// implicit conversion</span></span>
<span id="cb88-54"><a href="#cb88-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-55"><a href="#cb88-55" aria-hidden="true" tabindex="-1"></a>  bp = fp;  <span class="co">// prohibited  ??  See [over.match.best] in C++ standard</span></span>
<span id="cb88-56"><a href="#cb88-56" aria-hidden="true" tabindex="-1"></a>  fp = bp;  <span class="co">// prohibited </span></span>
<span id="cb88-57"><a href="#cb88-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-58"><a href="#cb88-58" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (fp == bp)…  <span class="co">// is this equality defined??</span></span>
<span id="cb88-59"><a href="#cb88-59" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb88-60"><a href="#cb88-60" aria-hidden="true" tabindex="-1"></a>cout &lt;&lt; <span class="st">&quot;Freezing pt: &quot;</span> &lt;&lt; fp &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; fahrenheit{fp} &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; fp_F &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb88-61"><a href="#cb88-61" aria-hidden="true" tabindex="-1"></a>  cout &lt;&lt; <span class="st">&quot;Boiling pt: &quot;</span> &lt;&lt; celsius{bp} &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; bp_C &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; bp &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb88-62"><a href="#cb88-62" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>C++ enumeration and class types distinguishes different types with identical structure. In contrast to C, where structural equivalence allows to cast a value from one type as another type with a compatible structure, C++ does have a few cases, (union types, reinterpret_cast) where structurally equivalent types play a role, but those situations come with their own set of vulnerabilities (note: needs section) and should be avoided. Other cases, where C-style casts can be used to reinterpret values as another type, are managed by the use of appropriate C++-style casts (static, const, dynamic, reinterpret), These named casts eliminate many of the issues associated with C-style casts. See clauses 6.6 and 6.37 for a discussion of C++ conversion capabilities and errors.</p>
<p>Note that C++ aliasing mechanisms for types and templates (using, typedef) do not provide new types or templates and thus a type alias is considered identical to its original type.</p>
<p>In addition to user-defined class types (<code class="sourceCode cpp"><span class="kw">struct</span></code>, <code class="sourceCode cpp"><span class="kw">union</span></code>, <code class="sourceCode cpp"><span class="kw">class</span></code>), C++ allows the definition of enumeration types and the construction of reference types, pointer types, array types and function types from other types.</p>
<p>Templates and the use of the keyword <code class="sourceCode cpp"><span class="kw">auto</span></code> permits type-agnostic code that determines free type parameters to be deduced or, additionally in the case of templates, to be specified. C++20 concepts further allow easier formulation of syntactic restrictions on the parameters (see 6.39 Templates and generics).</p>
<p>Forming class hierarchies with virtual member functions in the base class and corresponding overrides in derived classes introduce dynamic typing that can be employed and checked at run-time, when the corresponding object is passed by reference or pointer to one of its base classes (see section <em>(inheritance, polymorphism)</em>). Note, that in constructors and destructors the object pointed to <code class="sourceCode cpp"><span class="kw">this</span></code> is always statically typed.</p>
<p>Since C++ inherits some of the type system of C (arithmetic types and pointers), it suffers similar vulnerabilities, such as those caused by integral promotion, implicit numeric conversion, pointer arithmetic and pointer casts. User-defined class types are vulnerable to unexpected conversions due to implicitly applied converting constructors and conversion operators (see “type conversions”).</p>
<p>On the other hand, C++ provides mechanisms to define strong domain types (without runtime overhead) that allow appropriate operators through overloading, value range control through constructors and encapsulation of data, without implicit or surprising conversions.</p>
<p>There exist a few holes in the type system, often for backward compatibility. See clause …</p>
<pre><code>&lt;!--
AI -- Peter, help by Paul -- Write up the introduction to this clause
following Erhard&#39;s outline.
--&gt;</code></pre>
<p>C++-style casts eliminate many of the issues associated with C-style casts. See clauses 6.6 and 6.37 for a discussion of C++ conversion capabilities and errors.</p>
<pre><code>&lt;!--
Material from Richard)
--&gt;</code></pre>
<p>Holes in the type system</p>
<p>Shadow type system (explain) – Thoughts. – exception specification don’t participate in a functions types, until they are invoked. (Michael to provide some text in an email). This is only an issue before C++ 17. Fixed by using noexecpt and avoiding throw.</p>
<p>Don't write exception specifications on your functions unless you're forced to (because other code you can't change has already introduced them and/or you are in pre C++17 when dynamic exception was banned or C++20 when empty throw specification was banned to be replaced by noexcept)</p>
<p>A specific issue exists with exceptions in that exception specifications aren't part of a function's type, except when they are. They form a shadow type system whereby writing an exception specification can be:</p>
<ul>
<li><p>Illegal: In a typedef for a pointer to function.</p></li>
<li><p>Allowed: In the identical code without the typedef.</p></li>
<li><p>Required: In the declaration of a virtual function that overrides a base class virtual function that has an exception specification.</p></li>
<li><p>Implicit and automatic: In the declaration of the constructors, assignment operators, and destructors when they are implicitly generated by the compiler.</p></li>
</ul>
<p>A common but incorrect belief is that exception specifications statically guarantee that functions will throw only listed exceptions (possibly none), and will enable compiler optimizations based on that knowledge. Instead, exceptions cause the compiler to inject additional run-time overhead in the form of implicit try/catch blocks around the function body to enforce via run-time checking that the function does in fact emit only listed exceptions (possibly none), unless the compiler can statically prove that the exception specification can never be violated in which case it is free to optimize the checking away. In addition, exception specifications can both enable and prevent further compiler optimizations (besides the inherent overhead already described); for example, some compilers refuse to inline functions that have exception specifications.</p>
<p>When these rules are violated, by default they immediately terminate your program.<span data-custom-style="apple-converted-space"></span></p>
<p>You generally can't write useful exception specifications for function templates anyway, because you generally can't tell what exceptions the types they operate on might throw.</p>
<p>Exceptions : - see 6.36</p>
<p>Incomplete types and operations on incomplete types – usually checked by the compiler but some holes exist, for example when a virtual function is invoked from within a class constructor or destructor.</p>
<p>Mitigation, don’t overload unary <code>&amp;</code> or <code>,</code>, don’t delete an object of an incomplete class type,</p>
<pre><code>&lt;!--
&gt; AI -- Paul -- explain.
--&gt;</code></pre>
<p>don’t invoke virtual functions in constructors and destructors</p>
<pre><code>&lt;!--
High level issues

Note: discuss the problems with unions.

*NOTE: Ensure that the above explicit text is put into the relevant
sections and generalize or forward reference in this section.*
--&gt;</code></pre>
<p>C++ overloading of operators can cause significant issues. See clause 6.23.</p>
<p>C++ does not enforce consistent <code class="sourceCode cpp"><span class="at">const</span></code> along all access paths to an object. See clause 6.65.</p>
<pre><code>&lt;!--
13 Feb 2020 - Issue moved here*
from 6.41(?) 
--&gt;</code></pre>
<p>Templates and Generics- Templates take a hit because it is possible to invoke a template with a type that does not have all of the operations necessary to correctly execute the operations. For example, if an instantiation of a template type parameter does not implement “&lt;” (or is it “less”?) and the underlying code executes a “sort”, the sort will call whatever “&lt;” it can use. If a “&lt;” had been defined for a related type, then that “&lt;” will be called. The experts at meeting 67 say that this is not exclusive to templates, so the problem should be assigned here and referenced from templates.*</p>
<pre><code>&lt;!--
13 Feb 2020 -- Another issue appears*
to be that some primitive types
have operations that are inappropriate for the type. For example, the
basic type for characters include operators &quot;+&quot;, &quot;-&quot;, &quot;\&lt;&quot;, &quot;\*&quot; which
operate on the underlying integer representation. Passing such types
into templates or into a class can result in the fundamental integer
operation being called instead of a higher-level operation to perform,
for example, comparison on a ISO 8859 character set. The only
work-around appears to be to define classes with the fundamental type
and legal operations as the only operators.*
---&gt;</code></pre>
<pre><code>&lt;!--
*Question -- how does the &quot;.&quot; Operator interact with such types?(Maybe
this comma operator?)*
--&gt;</code></pre>
<pre><code>&lt;!--
A recommendation for future revisions of the language could be to
provide a way to remove basic operations from types such as enumeration
types or characters.*
--&gt;</code></pre>
<p>References</p>
<ul>
<li><p>CERT section OOP (AI – Aaron to provide others), (note that some of these will likely migrate to other vulnerabilities)x</p>
<ul>
<li><pre><code>  DCL52-CPP. Never qualify a reference type with const or</code></pre>
<p>volatile<br />
(this one is odd because the language makes this an error, but some<br />
compilers like MSVC only warn on it, but will still translate the<br />
source somehow)</p></li>
<li><pre><code>  EXP55-CPP. Do not access a cv-qualified object through a</code></pre>
<p>cv-unqualified type</p></li>
<li><pre><code>  EXP47-C. Do not call va_arg with an argument of the incorrect</code></pre>
<p>type</p></li>
<li><pre><code>  OOP51-CPP. Do not slice derived objects</code></pre></li>
</ul></li>
<li><p>AI – Lisa – look at C++ Core Guidelines for “casts” (-&gt; 6.6)</p>
<ul>
<li></li>
</ul></li>
<li><p>AUTOSAR (AI Peter to work with AUTOSAR to provide references)</p></li>
</ul>
<h3 id="guidance-to-language-users">6.2.2 Guidance to language users</h3>
<p>For specific types discussed in this document, such as floating point types, see the respective clauses.</p>
<ul>
<li><p>Be aware of the rules for typing and conversions with fundamental types (i.e., built-in language types) and operators to avoid vulnerabilities.</p>
<ul>
<li><pre><code>  To help aid correctness of code, couple all scalar values (e.g.,</code></pre>
<p><code>double</code>, <code>int</code>, etc.) that have units (e.g., metres, grams, litres, etc.) with suitable types representing those units. This will allow the compiler to generate errors with scalar-with-unit-type-values when they are used with operations that are incompatible.</p></li>
<li><pre><code>  User-defined literals</code></pre>
<p>(This lets you define 15_C and 15_F)</p>
<ul>
<li><pre><code>      *(AI -- Paul -- Write up)*</code></pre></li>
</ul></li>
</ul></li>
<li><p>Make converting constructors and conversion functions <code class="sourceCode cpp"><span class="kw">explicit</span></code> to avoid them being used implicitly or in unexpected ways. (<em>Move to 6.6)</em></p></li>
<li><p>Do not use union without an associated indicator as to which member it holds, alternatively wrap a union in a class with a type field or use C++:17 std::variant (see clause 23.7 of ISO/IEC 14882:2017)</p></li>
<li><p>Use unsigned integer types when manipulating integral values' bits.</p></li>
<li><p>Use one of (not both!) unsigned or signed integral types within expressions to help avoid programming mistakes, consistently</p></li>
<li><p>Treat explicit casts as candidates for code refactoring, i.e., ideally explicit casts should not be required in the code.</p></li>
<li><p>Avoid casting away <code class="sourceCode cpp"><span class="at">const</span></code>:. Doing so can result in undefined behaviour that may not be detectable by the compiler or other tools. Refactor code so that it handles <code class="sourceCode cpp"><span class="at">const</span></code> and non-<code class="sourceCode cpp"><span class="at">const</span></code> types properly. See clause 6.65.</p></li>
<li><p>don’t overload unary ‘<code>&amp;</code>’ or “<code>,</code>”,</p></li>
<li><p>don’t delete an incomplete class type,</p></li>
<li><p>don’t invoke virtual functions in constructors and destructors. See clause 6.43.</p></li>
</ul>
<blockquote>
<p>[+ the guidance already in the document as WG23 decides (or moves to another section or otherwise edits) --there are a lot of items listed]</p>
</blockquote>
<div data-custom-style="Normal (Web)">
<p>From Part 1. The Part 1 guidelines were accepted but are left here for review.</p>
</div>
<ul>
<li><p>Take advantage of any facility offered by the programming language to declare distinct types and use any mechanism provided by the language processor and related tools to check for or enforce type compatibility.</p></li>
<li><p>Use available language and tools facilities to preclude or detect the occurrence of implicit type conversions, such as those in mixed type arithmetic. If it is not possible, use human review to assist in searching for implicit conversions.</p></li>
<li><p>Avoid explicit type conversion of data values except when there is no alternative. Document such occurrences so that the justification is made available to maintainers.</p></li>
<li><p>Use the most restricted data type that suffices to accomplish the job. For example, use an enumeration type to select from a limited set of choices (such as, a switch statement or the discriminant of a union type) rather than a more general type, such as integer. This will make it possible for tooling to check if all possible choices have been covered.</p></li>
<li><p>Always respect the implied unit systems, when converting explicitly from one numeric type to another.</p></li>
</ul>
<p>(Explicit C++ guidance for unit-based types.</p>
<ul>
<li><p>Follow the guidance of TR 24772-1 clause 6.2.5.</p></li>
<li><p>Use distinct C++ types for unit systems if available or define explicit unit-based types.)</p></li>
</ul>
<!-- -->
<ul>
<li><p>Treat every compiler, tool, or run-time diagnostic concerning type compatibility as a serious issue. Do not resolve the problem by modifying the code to include an explicit conversion, without further analysis; instead examine the underlying design to determine if the type error is a symptom of a deeper problem.</p></li>
<li><p><em>Never ignore instances of implicit type conversion; if the conversion is necessary, change it to an explicit conversion and document the rationale for use by maintainers.</em> <em>– narrowing conversions and loss of precision</em></p></li>
<li><p>Analyze the problem to be solved to learn the magnitudes and/or the precisions of the quantities needed as auxiliary variables, partial results and final results.</p></li>
<li><p>Create types that more accurately model the problem domain, with corresponding safe operations and conversions in lieu of using primitive types.</p></li>
<li><p>Minimize use of predefined numeric types whose ranges and precisions are implementation defined. Instead, use types whose ranges and precision are guaranteed.</p></li>
<li><p><em>C++ Issue – Use syntax that forces the compiler to Issue diagnostics on narrowing – need example.</em></p></li>
<li><p>Treat every explicit cast as a candidate for refactoring.</p></li>
<li><p>Use C++ casts rather than C-style casts, as they provide more compile-time checking and are more restrictive in what they can change, - rationale – syntactic distinction – in C++ obvious.</p></li>
<li><p><em>Make class member functions that can be static, ‘<code class="sourceCode cpp"><span class="at">static</span></code>’. Make class member functions that cannot be ‘<code class="sourceCode cpp"><span class="at">static</span></code>’, but can be ‘<code class="sourceCode cpp"><span class="at">const</span></code>’, ‘<code class="sourceCode cpp"><span class="at">const</span></code>’</em></p></li>
<li><p><em>The ‘<code class="sourceCode cpp"><span class="at">mutable</span></code>’ keyword for class member variables should be used sparingly</em></p></li>
<li><p>Don't mix signed and unsigned types in arithmetic</p></li>
<li><p>Follow the advice provided in TR 24772-3 clause 6.2.2. when using C-style numeric types, and implicit conversions. *<br />
</p>
<ul>
<li></li>
</ul></li>
</ul>
<h2 id="bit-representations-str">6.3 Bit Representations [STR]</h2>
<h3 id="applicability-to-language">6.3.1 Applicability to language</h3>
<p>This vulnerabilities described in TR24772-1 clause 6.3 is applicable to C++.</p>
<pre><code>&lt;!--
Document the C++ behaviours- handling bit-fields, - hitting enclosing
word, concurrent access, hardware implications,
--&gt;</code></pre>
<p>Able to use non-integer types (such as enumerations) in accessing bit fields.</p>
<p>A C++ memory location is either an object is or a contiguous collection of bit-fields.</p>
<p>C++ bit fields are not separated from adjacent bit-fields for purposes of thread synchronization or volatility. Bit-fields are very difficult to use correctly in these contexts.</p>
<pre><code>&lt;!--
TO-DO -- Bit_Cast - Applies a bit representation to an object of a new
type, for example copy a 64 bit IEEE 654 number to a 64 bit integer to
perform bit operations and then cast back.
--&gt;</code></pre>
<pre><code>&lt;!--
Needs documentation.
--&gt;</code></pre>
<pre><code>&lt;!--
Issue was raised about padding bits between object/struct/union members
can leak information. Where to put this? Mitigation -- use member copy
instead of byte-wise copy.
--&gt;</code></pre>
<p>When a struct, union or class is embedded within an array, implementations will typically add padding to provide efficient alignment and access. Therefore, the compiler will add padding bytes in case it is used in arrays. The padding bytes can be used as a <em>secret channel</em> to hide information and extract it later.</p>
<h3 id="guidance-to-language-users">6.3.2 Guidance to language users</h3>
<p>In addition to the advice of ISO/IEC TR 24772-3:2020 clause 6.3.2:</p>
<p>See C++ Core Guidelines ES101 use unsigned types for bit manipulation.</p>
<p>CERT INT34-C</p>
<ul>
<li><p>Do not use <code class="sourceCode cpp"><span class="bu">std::</span>vector&lt;<span class="dt">bool</span>&gt;</code></p></li>
<li><p>Use bit-fields with care or avoid them entirely. Instead, use a class type containing one or more unsigned integer data members and member functions appropriate to the particular situation.</p></li>
<li><p>Do not create a bit-field of a signed type and size one.</p></li>
</ul>
<p>See AUTOSAR A9-6-1</p>
<ul>
<li><p>Avoid using <code>bit_cast</code> or heavily analyse and document its use.</p></li>
<li><p>Prefer performing member-by-member copies and moves instead of using <code>std::memcpy</code> or <code>std::memmove</code></p></li>
<li><p>Cover known padding with named members to eliminate padding. This can be checked with a <code>static_assert(std::has_unique_object_representations_v&lt;T&gt;)</code>. If this assertion is true then there are no padding bits.</p></li>
</ul>
<p>CERT EXP62-CPP</p>
<h2 id="floating-point-arithmetic-plf">6.4 Floating-point Arithmetic [PLF]</h2>
<h3 id="applicability-to-language">6.4.1 Applicability to language</h3>
<p>C++ has the vulnerability as described in ISO/IEC TR 24772-1 clause 6.4. The C++ standard assumes IEC 60559 if <code class="sourceCode cpp"><span class="bu">std::</span>numeric_limits<span class="bu">\</span>&lt;T&gt;::is_iec559</code> is true for the types in use. In the absence of this, C++ makes few guarantees about the behaviour of floating point numbers.</p>
<p>Sorting floating point numbers with the built-in operators violates the preconditions of sorting predicates in the presence of NaN values and may raise floating point errors. The default sorting predicate <code>std::less</code> is suspect to this precondition violation.</p>
<h3 id="guidance-to-language-users">6.4.2 Guidance to language users</h3>
<ul>
<li><p>Follow the general advice of ISO/IEC TR 24772-1:2019 clause 6.4.5</p></li>
<li><p>Verify compliance to ISO/IEC/IEEE 60559:2011 at compile time through <code class="sourceCode cpp"><span class="bu">std::</span>numeric_limits&lt;T&gt;::is_iec559</code>. Other numeric characteristics such as <code>min()</code>, <code>max()</code>, existence of NaNs, <code>has_denorm</code>, and infinities can be determined in this class template.</p></li>
<li><p>Be aware that the default comparison functions in the standard library may produce wrong results when used on floating point members. In particular <code>std::less</code> is not a total order; <code>std::equal</code> is not equivalent to substitutability (NaNs compare unequal to themselves, but neither less nor greater, and negative zero compares equal to positive zero).</p></li>
</ul>
<h2 id="enumerator-issues-ccb">6.5 Enumerator Issues [CCB]</h2>
<h3 id="applicability-to-language">6.5.1 Applicability to language</h3>
<h4 id="references">6.5.1.1 References</h4>
<p>AUTOSAR A7-2-2 Enumeration base type shall be explicitly defined</p>
<h4 id="applicability">6.5.1.2 Applicability</h4>
<p>C++ offers enums for defining distinct types composed of sets of related named constants. The type of each enum is different from all other types. Each enum has an underlying integral type, which the user can specify. Since enums are distinct types, the user can only assign values to an object of enumerated type that are values of that enumerated type. C++ does not support implicit conversion of an int to an enum, therefore preventing <code>A = B + C</code> where <code>A</code>, <code>B</code> and <code>C</code> are variables of the same enum, unless an overloaded operator “<code>+</code>” is provided.</p>
<p>C++ enums can be scoped (<code>enum class</code>) or unscoped (<code>enum</code>). C++ supports implicit conversion of an unscoped enum to an integer by integral promotion</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Color : <span class="dt">short</span> {red, green, blue};</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a><span class="dt">short</span> i = red; <span class="co">// implicit conversion</span></span></code></pre></div>
<p>C++ does not support implicit conversion of a scoped enum to an int. Hence, operations such as <code>++</code>, <code>+</code>, <code>&lt;</code> and enums used as array indices require explicit definitions.</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> Color : <span class="dt">short</span> {red, green, blue};</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a><span class="dt">short</span> i = red; <span class="co">// error -- no implicit conversion</span></span></code></pre></div>
<p>Where unscoped enums are used as array indexes and do not have a user-specified mapping to an underlying representation, there will be “holes” as documented in TR24772-1 clause 6.6.</p>
<p>Note that unscoped enumeration types implicitly promote their underlying type and can be used as the index of an array without a cast, with all of the issues described in TR 24772-1 clause 6.5.</p>
<p>From C++ 2017 forward, casting a value to an enumeration type is undefined behavior unless the source value is within the range of values of an enumeration type. See CERT INT50-CPP.</p>
<h3 id="guidance-to-language-users">6.5.2 Guidance to language users</h3>
<ul>
<li><p>Use <em>scoped enumerations</em> in preference to the C-style <em>unscoped enumerations</em> for related values, especially at namespace-level.</p>
<ul>
<li><pre><code>  See CPP Core Guidelines Enum.3 &quot;Prefer class enums over &#39;plain&#39;</code></pre>
<p>enums".</p></li>
<li><pre><code>  See AUTOSAR A7-2-3 &quot;Enumerations shall be declared as scoped</code></pre>
<p>enum classes"</p></li>
<li><pre><code>  See MISRA C++ 28.5.5</code></pre></li>
</ul></li>
<li><p>Use <code class="sourceCode cpp"><span class="kw">constexpr</span></code> to declare a set of unrelated values, such as <code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">size_t</span> bufferLen = <span class="dv">128</span>;</code> <code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">char</span> special_char = <span class="ch">&#39;a&#39;</span>;</code></p></li>
<li><p>Provide operators and functions that perform the arithmetic operations and conversions appropriate to the enumerated type. Outside those functions, avoid directly performing arithmetic or conversions on objects of the enumerated type.</p>
<ul>
<li><pre><code>  See CPP Core Guidelines Enum.4 &quot;Define operations on</code></pre>
enumerations for safe and simple use"</li>
</ul></li>
<li><p>If <em>unscoped enumerations</em> are used, follow the general advice of TR 24772-3 clause 6.5.2 as well as the following:</p>
<ul>
<li><pre><code>  Avoid casting arbitrary integer values to enumeration type. If it is</code></pre>
<p>unavoidable, use braced initialization instead of C-style or static casts<br />
<code>e_type{7};</code></p>
<pre><code>  &gt; See CERT INT50-CPP &quot;Do no Cast to an out-of-range-value&quot;</code></pre></li>
</ul></li>
<li><pre><code>Obtain the underlying enumeration value, by casting the enumeration</code></pre>
<p>to its underlying type, e.g.,</p>
<blockquote>
<p><code class="sourceCode cpp"><span class="kw">enum</span> <span class="dt">e_type</span>{A, B, C};</code></p>
</blockquote>
<blockquote>
<p><code class="sourceCode cpp"><span class="kw">auto</span> value = <span class="kw">static_cast</span>\&lt;<span class="bu">std::</span>underlying_type_t<span class="bu">\</span>&lt;<span class="dt">e_type</span>\&gt;\&gt;(B);</code></p>
</blockquote></li>
</ul>
<h2 id="conversion-errors-flc">6.6 Conversion Errors [FLC]</h2>
<h3 id="applicability-to-language">6.6.1 Applicability to language</h3>
<pre><code>&lt;!--
From Michael about &quot;constraint Error*

This was referring to the following case from  Clive:
--&gt;</code></pre>
<pre><code>&lt;!--
*The example I intended was int \*i = malloc(10);*

*The context was we wanted to say \&#39;C++ doesn\&#39;t allow implicit cast
from void\* to any other pointer type\&#39; (which actually may be the best
way to express this).*

*We were going with something along the lines of \&#39;Attempting to
implicitly cast void\* to any other pointer type is a constraint error\&#39;
- at which point I wondered if \&#39;constraint error\&#39; was the appropriate
C++ term*

I don\&#39;t think I ever heard of constraint error before. Range error yes
but this is not a range error. In this case, there isn\&#39;t a name as
such.  In section 4.10.2. It says a T\* can be converted to a void\*. It
leaves out the reverse, implying you must use a cast. We say it is not
well-formed. 
--&gt;</code></pre>
<p>C++ includes some of the conversion mechanisms of C, as documented in TR 24772-3 clause 6.6.1.</p>
<p>C++ type conversion mechanisms differ from the mechanisms of C, as documented in ISO IEC 14882 Annex C. This subclause highlights those differences where C++ eliminates potential vulnerabilities found in C.</p>
<p>Implicit, i.e., automatic, conversions to a type <code>T</code> can be performed, for example, in the following situations:</p>
<ol type="a">
<li><p>If the declaration, <code>T t=e;</code>, is defined for some expression, <code>e</code>, and some invented variable, <code>t</code> [C++17, Clause 7 [conv], para 3];</p></li>
<li><p>In expressions involving operands of operators (e.g., <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, etc.) subject to the requirements of each operators' operands [C++17, Clause 7 [conv], para 2.1];</p></li>
<li><p>For example, the expression, <code>5 + 6.5</code>, has operands of type <code class="sourceCode cpp"><span class="dt">int</span></code> and <code class="sourceCode cpp"><span class="dt">double</span></code>. Per language rules, the int will be implicitly converted to <code class="sourceCode cpp"><span class="dt">double</span></code>, i.e., the expression becomes <code class="sourceCode cpp"><span class="dt">double</span>(<span class="dv">5</span>) + <span class="fl">6.5</span></code>, i.e., <code>5.0 + 6.5</code>.</p></li>
<li><p>In the condition of an <code class="sourceCode cpp"><span class="cf">if</span></code>, <code class="sourceCode cpp"><span class="cf">for</span></code>, <code class="sourceCode cpp"><span class="cf">do</span>..<span class="cf">while</span></code>, or <code class="sourceCode cpp"><span class="cf">while</span></code> statement: the implicit conversion will be to the type bool [C++17, Clause 7 [conv], para 2.2];</p></li>
<li><p>In the expression of a switch statement: the implicit conversion will be to an integral type [C++17, Clause 7 [conv], para 2.3];</p></li>
<li><p>In an expression that initializes an object (e.g., an argument to a function call, the expression in a return statement) [C++17, Clause 7 [conv], para 2.4];</p></li>
<li><p>When a non-<code class="sourceCode cpp"><span class="kw">explicit</span></code> class/struct/union constructor can be invoked on an object resulting in some desired type, <code>T</code>, from initial objects passed to the constructor; and</p></li>
<li><p>When a conversion operator has not been declared <code class="sourceCode cpp"><span class="kw">explicit</span></code>, it can be implicitly invoked on an object resulting in some desired type, <code>T</code>, from an initial type.</p></li>
</ol>
<p>Explicit conversions are conversions that occur:</p>
<p>From the C++ reference manual clause 8.5.3 paragraph 2:</p>
<blockquote>
<p>“An explicit type conversion can be expressed using functional notation (8.5.1.3), a type conversion operator (dynamic_cast, static_cast, reinterpret_cast, const_cast), or the cast notation.”<br />
<br />
Note: The final 'cast notation' refers to C-style cast.</p>
</blockquote>
<p>Implicit conversions from <code class="sourceCode cpp"><span class="dt">void</span>*</code> to any other object type is invalid.</p>
<p>C++ adds a number of new features relevant to type conversion:</p>
<ul>
<li><p>C-style casts (using the desired type in brackets in front of an expression), whilst still available in C++, are augmented by four C++ specific cast and function style casts. These provide a number of (mostly) compile-time checks, so prevent casting between obviously inappropriate types</p></li>
<li><p>The programmer can add code to the definition of a class to allow values of any other type to be implicitly cast to that class type, or for a class object to be implicitly cast to any other type (including basic numeric types). As implicit conversions can make code maintenance more difficult, in general they should be avoided</p></li>
</ul>
<p>Non-explicit unary constructors, non-explicit conversion operators, <em>(and conditionally-explicit unary constructors(??))</em> can provide implicit conversions that are unexpected by the programmer. Such constructors and conversion operators should be declared with the keyword <code class="sourceCode cpp"><span class="kw">explicit</span></code>.</p>
<p>Implicit casting to a class type occurs when a class has a constructor that can take a single parameter, as in the following example:</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>      {<span class="kw">public</span>:</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>        C(<span class="dt">int</span> x=<span class="dv">10</span>, <span class="dt">float</span> y=<span class="dv">0</span>){...}}</span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>      };</span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo(C param){...}</span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a>...  foo(<span class="dv">21</span>); ...</span></code></pre></div>
<p>The call to <code class="sourceCode cpp">foo</code> requires a parameter of type C, but is provided with an int. However, as C has a constructor that can take an <code class="sourceCode cpp"><span class="dt">int</span></code> parameter (the float parameter is ignored because it has a default value), a temporary object of type <code class="sourceCode cpp">C</code> is constructed using <code class="sourceCode cpp"><span class="dv">21</span></code> as the <code class="sourceCode cpp">x</code> parameter. This is passed to foo. The temporary object is destroyed when foo returns.</p>
<p>Note that this implicit conversion to a class object is the default behavior of constructors that can be called with a single parameter. To prevent this happening, the keyword ‘explicit’ is used before the constructor, as in:</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">explicit</span> C(<span class="dt">int</span> x=<span class="dv">10</span>, <span class="dt">float</span> y=<span class="dv">0</span>){...}</span></code></pre></div>
<p>The call <code class="sourceCode cpp">foo(<span class="dv">21</span>)</code> would now not be legal.</p>
<p>C++ provides:</p>
<ul>
<li><p><code class="sourceCode cpp"><span class="kw">static_cast</span></code> (explain)</p></li>
<li><p><code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> (explain)</p></li>
<li><p><code class="sourceCode cpp"><span class="kw">const_cast</span>(</code>explain)</p></li>
<li><p><code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> (as in <code class="sourceCode cpp">&lt;<span class="dt">target_type</span>&gt;(expression)</code> ) that casts an arbitrary piece of data to the desired type.</p></li>
</ul>
<p>Unlike C++'s other cast notations, <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> relies on run-time type information generated by the compiler to ensure the requested conversion is valid. If it is not valid, then the null pointer value of the required result type is returned for pointer types, otherwise an exception is thrown. [C++17, Clause 8.2.7 [expr.dynamic.cast]] Thus, <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> is safer to use when converting down a hierarchy.</p>
<p>All other conversions are not necessarily "safe" as they can sometimes yield unexpected results. This is an issue with implicit conversions since they are automatic: the programmer does not explicitly write code to do the conversion. For example, a common problem is mixing signed and unsigned integral types in arithmetic expressions. This can become a problem since the ranges of signed and unsigned integer types differ; unsigned integers are permitted to overflow and wrap (modulo arithmetic) whereas signed integers should never overflow.</p>
<p>When these types are mixed in the same expressions, there is a possibility that erroneous values will result. <em><strong>(example? AI - Paul)</strong></em></p>
<h3 id="guidance-to-language-users">6.6.2 Guidance to language users</h3>
<p>In addition to the general advice of TR 24772-1 clause 6.6.5:</p>
<ul>
<li><p>Guidance for numeric conversions: Use the brace form of function style casts</p></li>
<li><p>Use C++ casts rather than C-style casts, as they provide more checking</p></li>
<li><p>If a class has a converting constructor and implicit conversions are not required, make that constructor ‘explicit’</p></li>
<li><p>Avoid casts (see Core guidelines ES48)</p></li>
<li><p>If using a cast, use a named cast (see C++ Core Guidelines ES49)</p></li>
<li><p>Don’t cast away const. See 6.65 Non-constant constants.<br />
(see C++ Core Guidelines ES50)</p></li>
<li><p>Prefer <code class="sourceCode cpp">{}</code> over <code class="sourceCode cpp">()</code> when constructing values. (See C++ Core Guidelines ES23 and ES64)</p></li>
<li><p>Avoid narrowing conversions. (See C++ Core Guidelines ES46)</p></li>
<li><p>Don’t mix signed and unsigned arithmetic (See C++ Core Guidelines ES100)</p></li>
</ul>
<h2 id="string-termination-cjm">6.7 String Termination [CJM]</h2>
<h3 id="applicability-to-language">6.7.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IECTR 24772-1:2019 exists in C++ when C-style strings are used. C++ provides the library class templates <code class="sourceCode cpp"><span class="bu">std::</span>basic_stringview</code> and <code class="sourceCode cpp"><span class="bu">std::</span>span</code> that implment reference semantics to non-owned buffers. These classes do not include a string termination character and their use can result in this vulnerability. C++ provides alternative string processing capabilities that do not exhibit those vulnerabilities.</p>
<p>C++ provides a class template for string processing, <code class="sourceCode cpp"><span class="bu">std::</span>basic_string</code> that manages the space for the string and the string length and always includes a termination character. On concatenation, the string object will increase in size to contain the resulting string. The class <code class="sourceCode cpp"><span class="bu">std::</span>filesystem<span class="bu">::</span>path</code> also provides string processing capabilities among other facilities by wrapping <code class="sourceCode cpp"><span class="bu">std::</span>basic_string</code>.</p>
<p>Unlike C-style strings, the class templates <code class="sourceCode cpp"><span class="bu">std::</span>basic_string</code>, <code class="sourceCode cpp"><span class="bu">std::</span>basic_string_view</code>, and <code class="sourceCode cpp"><span class="bu">std::</span>span</code> permit embedded null characters to be used safely.</p>
<h3 id="guidance-to-language-users">6.7.2 Guidance to language users</h3>
<ul>
<li><p>Avoid C-style strings. Use <code class="sourceCode cpp"><span class="bu">std::</span>string</code> or corresponding instantiations of <code class="sourceCode cpp"><span class="bu">std::</span>basic_string</code> for the character type used.</p></li>
<li><p>If <code class="sourceCode cpp"><span class="bu">std::</span>basic_string</code> is not appropriate, provide your own encapsulation and perform the appropriate verifications.</p></li>
<li><p>If C-style strings are used, follow the guidance of ISO/IEC TR 24772-3 clause 6.7.2.</p></li>
<li><p>When calling interfaces that expect C-style strings as arguments, pass the result of a <code class="sourceCode cpp"><span class="bu">std::</span>string<span class="bu">::</span>c_str()</code> as an argument. Do not employ types that cannot guarantee the string termination.</p></li>
<li><p>When obtaining C-style strings via character pointers from interfaces, manage the string via a <code class="sourceCode cpp"><span class="bu">std::</span>string_view</code> only if lifetime and content of the underlying buffer is persistent, or store it in a <code class="sourceCode cpp"><span class="bu">std::</span>string</code> object otherwise.</p></li>
</ul>
<h2 id="buffer-boundary-violation-hcb">6.8 Buffer Boundary Violation [HCB]</h2>
<h3 id="applicability-to-language">6.8.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1 clause 6.8 exists in C++ when arrays are managed using raw pointers and indexing. To avoid the vulnerability, C++ provides facilities to encapsulate code that may suffer from this vulnerability. The standard library provides classes that mitigate or circumvent this vulnerability. For example, <code class="sourceCode cpp"><span class="bu">std::</span>string,</code> <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> and <code class="sourceCode cpp">iostreams</code> manage buffers internally using “range-for” such as for (auto I: <em>some container</em>) and the algorithm library to access elements of the container without the possibility of a buffer boundary violation.</p>
<p><del>A buffer boundary violation condition occurs when an array is indexed outside its bounds, or pointer arithmetic results in an access to storage that occurs outside the bounds of the object accessed. This behaviour may occur when copying, initializing, writing or reading.</del></p>
<p><del>In C++, the built-in subscript operator <code class="sourceCode cpp">\[\]</code> is defined such that <code class="sourceCode cpp">E1\[E2\]</code> is identical to <code class="sourceCode cpp">(\*((E1)+(E2))</code>), so that in either representation, the value in location (E1+E2) is returned. C++ does not perform bounds checking on arrays: arrays may be accessed outside of their bounds which is undefined behaviour. For example, in C++ the following code is syntactically valid, though, if offset has the value <code class="sourceCode cpp"><span class="dv">10</span></code>, the behaviour is undefined:</del></p>
<blockquote>
<p><del>int foo(const int offset) {</del></p>
<p><del>int t;</del></p>
<p><del>int x[] = {0,0,0,0,0};</del></p>
<p><del>t = x[offset];</del></p>
<p><del>return t;</del></p>
<p><del>}</del></p>
</blockquote>
<p><del>or, when written using iterators, the same issues can occur</del></p>
<blockquote>
<p><del>int foo(const int offset) {</del></p>
</blockquote>
<blockquote>
<p>~~ std::array&lt;int, 5&gt; a;~~</p>
</blockquote>
<blockquote>
<p>~~ return *(a.begin() + offset);~~</p>
</blockquote>
<p>Another way that overflows can occur is through the use of C-style strings, which can be treated as arrays of characters, but the nul termination can make overflows possible. See clause 6.7 String Termination.</p>
<p>For further explanation and examples, see</p>
<p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR50-CPP.+Guarantee+that+container+indices+and+iterators+are+within+the+valid+range"><span data-custom-style="Hyperlink">https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR50-CPP.+Guarantee+that+container+indices+and+iterators+are+within+the+valid+range</span></a></p>
<p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR53-CPP.+Use+valid+iterator+ranges"><span data-custom-style="Hyperlink">https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR53-CPP.+Use+valid+iterator+ranges</span></a></p>
<p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR55-CPP.+Do+not+use+an+additive+operator+on+an+iterator+if+the+result+would+overflow"><span data-custom-style="Hyperlink">https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR55-CPP.+Do+not+use+an+additive+operator+on+an+iterator+if+the+result+would+overflow</span></a></p>
<pre><code>&lt;!--
Note: Consider C++ Core guidelines if completed.
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.8.2 Guidance to language users</h3>
<ul>
<li><p>Avoid C-style arrays. Guidance for the use of C-style arrays is provided in TR 24772-3 clause 6.8.2.</p></li>
<li><p>Use a library class such as <code>std::array</code> to encapsulate an array, or write a class with similar behavior.</p></li>
<li><p>Use library classes such as <code>std::span</code> or <code>std::string_view</code> to represent ranges of elements within an array or container. (AI – Paul, double check)</p></li>
<li><p>Use containers of the standard library, such as <code>std::vector</code> or <code>std::deque</code>, to model arrays with dynamically changing size.</p></li>
<li><p>Use iterator-based algorithms, such as those of the standard library.</p></li>
<li><p>Use the range-based for loop construct such as <code>for (auto e:</code> <em>some container</em><code>)</code> to iterate within the defined bounds of the object.</p></li>
<li><p>Use iterators over the range of elements to be accessed instead of using an array and bounds as parameters.</p></li>
<li><p>When using C-style arrays, statically show that an access outside of the array cannot occur, or alternatively perform range checking before indexing into the array.</p></li>
<li><p>When performing random access by indexing, follow the guidance of clause 6.9.2. When performing other forms of random access, follow the guidance of clause 6.12.2. <em>)</em></p></li>
<li><p>Use static analysis tools to detect buffer boundary violations.</p></li>
</ul>
<h2 id="unchecked-array-indexing-xyz">6.9 Unchecked Array Indexing [XYZ]</h2>
<h3 id="applicability-to-language">6.9.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 exists in C++ when C-style arrays are used, when access to some containers is performed using <code class="sourceCode cpp"><span class="kw">operator</span>[]</code>, or when accessing elements in containers by pointer arithmetic.</p>
<p>Like a C-style array, some STL containers, such as <code>std::vector</code>, can be indexed using [], and as in C such an access is unchecked. However, these containers also provide an access function <code>at()</code> that behaves like [], but performs a check that the access is within the bounds of the container.</p>
<p>Placing C-types (such as arrays) in containers let the implementer create access operators that check bounds.</p>
<p>The following example compares C and C++ performing equivalent array operations:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>C</strong></th>
<th style="text-align: left;"><strong>C++</strong></th>
<th style="text-align: left;"><strong>Comment</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;array&gt;</span></code></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode cpp"><span class="dt">int</span> arr [<span class="dv">10</span>];</code></td>
<td style="text-align: left;"><code class="sourceCode cpp"><span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">10</span>&gt;arr;</code></td>
<td style="text-align: left;">Both arrays are of 10 elements</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode cpp">arr[<span class="dv">10</span>] = <span class="dv">0</span>;</code></td>
<td style="text-align: left;"><code class="sourceCode cpp">arr[<span class="dv">10</span>] = <span class="dv">0</span>;</code></td>
<td style="text-align: left;">Both accesses silently violate array’s bounds</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode cpp">arr[<span class="dv">10</span>] = <span class="dv">0</span>;</code></td>
<td style="text-align: left;"><code class="sourceCode cpp">arr.at(<span class="dv">10</span>) = <span class="dv">0</span>;</code></td>
<td style="text-align: left;">The C++ access fails with an error exception</td>
</tr>
</tbody>
</table>
<h3 id="guidance-to-language-users">6.9.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance from clause 6.8.2.</p></li>
<li><p>Use static analysis or explicit checks to establish that bounds violations do not occur. Otherwise use the <code class="sourceCode cpp">at()</code> member function of the standard library containers and handle the bounds violation exceptions. For issues associated with exception handling and error handling, see clause 6.36 Ignored error status and unhandled exceptions.</p></li>
</ul>
<h2 id="unchecked-array-copying-xyw">6.10 Unchecked Array Copying [XYW]</h2>
<h3 id="applicability-to-language">6.10.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 exists in C++, but can be mitigated using features provided by the language.</p>
<p>A buffer overflow occurs when some number of bytes (or other units of storage) is copied from one buffer to another and the amount being copied is greater than is allocated for the destination buffer. This is a special case of Buffer Boundary Violation [HCB].</p>
<p>As with clause 6.8 [HCB], in most cases the vulnerability can be avoided by using library classes, such as <code class="sourceCode cpp"><span class="bu">std::</span>vector</code>, which provides a copy assignment operator that adjusts the size of the target to fit the object being copied.</p>
<p>If for some reason this is not acceptable, C++ has access to the C library functions <code class="sourceCode cpp">memcpy()</code> and <code class="sourceCode cpp">memmove()</code>. Both simply copy memory and no checks are made as to whether the destination area is large enough to accommodate the amount of data being copied. It is assumed that the calling routine or programmer has ensured that adequate space has been provided in the destination. Problems can arise when the destination buffer is too small to receive the amount of data being copied.</p>
<p>In general, placing C-types (such as arrays) in containers lets the implementer create whole array operations that can eliminate the errors discussed in Part 1, clause 6.10.</p>
<h3 id="guidance-to-language-users">6.10.2 Guidance to language users</h3>
<ul>
<li><p>Use standard library containers, such as <code class="sourceCode cpp"><span class="bu">std::</span>vector</code>, that provide copying mechanisms that ensure the target array is large enough for the indicated source.</p></li>
<li><p>When copying C-style arrays, statically shown that an access outside of the array cannot occur, or alternatively perform range checking before copying the array.</p></li>
</ul>
<pre><code>&lt;!--
Deleted text
-   ~~For copies of fixed-sized arrays, perform range checking to
    prevent out-of-bounds access on the target and the source arrays. In
    the interest of speed and efficiency, range checking only needs to
    be done when it cannot be statically shown that an access outside of
    the arrays cannot occur.~~
--&gt;</code></pre>
<ul>
<li><p>Use <code class="sourceCode cpp"><span class="bu">std::</span>string_view</code> to represent immutable string literals<span data-custom-style="annotation reference"></span>.</p></li>
<li><p>Use <code class="sourceCode cpp">std:string</code> to represent mutable strings<span data-custom-style="annotation reference"></span>.</p></li>
<li><p>Place arrays in containers with whole-array and bounds-checking operations. <span data-custom-style="annotation reference"></span></p></li>
</ul>
<h2 id="pointer-type-conversions-hfc">6.11 Pointer Type Conversions [HFC]</h2>
<h3 id="applicability-to-language">6.11.1 Applicability to language</h3>
<pre><code>&lt;!--
In this clause, all C++ references, in addition to pointers. The
`shared_ptr`{.cpp} casts
--&gt;</code></pre>
<p>The vulnerabilites as described in ISO/IEC TR 24772-1:2019 clause 6.11.1 applies to C++.</p>
<p>In general casting pointers breaks the type system and should be avoided.</p>
<p>In C++, a C-style cast is defined in terms of the C++ cast operators <code class="sourceCode cpp"><span class="kw">const_cast</span></code>, <code class="sourceCode cpp"><span class="kw">static_cast</span></code>, and <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>. In some cases, it is unspecified which cast is used, for example when a cast operation involves an incomplete type, a <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> may be used for the conversion which can produce an incorrect result.</p>
<p>Especially, <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> has the problem that it simply treats the unmodified pattern of bits in the pointer as being of the target type rather than the original type, but the C++ standard recognizes that the language or compiler may impose constraints or additional data requirements on a pointer. <code class="sourceCode cpp"><span class="kw">static_cast</span></code> and <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> take this difference into account, but other cast operators do not take this into consideration and hence can give incorrect results. For example, in the use of multiple inheritance, the address of an object may be different than one of its base class sub-objects, causing the potential for the exploitable access of adjacent memory.</p>
<p>C++ permits the change of constant or volatile properties as part of a conversion. Such conversions, unless done in extremely limited ways, puts the program at risk of creating undefined behavior.</p>
<p>A typical use of pointer conversion in C++ occurs where there is a hierarchy of classes declared, as in:</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Base {<span class="kw">virtual</span> ~Base() = <span class="cf">default</span>; };</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Derived: Base { };</span></code></pre></div>
<p>Where a <code>Base</code> pointer needs to be converted to <code>Derived</code> pointer, <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> will check at runtime that the pointer is to an object of the correct type. If it’s not, either <code class="sourceCode cpp"><span class="kw">nullptr</span></code> will be returned, or an is exception thrown in case references are used as source and target type.<span data-custom-style="annotation reference"></span></p>
<pre><code>&lt;!--
C++ Dynamic cast and the use of it during construction and destruction needs further exposition. The this pointer type can have surprising effects.*
--&gt;</code></pre>
<pre><code>&lt;!--
*AI* *--* *Paul, Richard to review* *-- Writeup about incomplete objects before or after their lifetime and related to translation units.[]{custom-style=&quot;annotation reference&quot;}*[]{custom-style=&quot;annotation reference&quot;}
--&gt;</code></pre>
<p>Pointer casts to a more strictly aligned pointer type is undefined behaviour.</p>
<p><code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> for pointer-interconvertible on objects (see clause 6.9.2 of IS 14882)</p>
<p>C++ permits <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> to be used to convert a pointer to an object, a, to a pointer to another object, b, only in specific restricted circumstances, i.e., when</p>
<ul>
<li><p>a and b are the same object,</p></li>
<li><p>either a or b is a standard-layout union object and the other is a non-static data member of that object,</p>
<ul>
<li>Examples: <code>{.cpp}     union A { int i; double d; } a;\     int\* iptr = reinterpret_cast\&lt;int\*\&gt;(&amp;a);\     double\* dptr = reinterpret_cast\&lt;double\*\&gt;(&amp;a);\     A\* uptr1 = reinterpret_cast\&lt;A\*\&gt;(iptr);\     A\* uptr2 = reinterpret_cast\&lt;A\*\&gt;(dptr);</code></li>
</ul></li>
<li><p>either a or b is a standard-layout class object and the other is the first non-static data member of that object,</p>
<ul>
<li>Examples: <code>{.cpp}     struct B { int i; double d; } b;\     int\* iptr = reinterpret_cast\&lt;int\*\&gt;(&amp;b);\     B\* bptr = reinterpret_cast\&lt;B\*\&gt;(iptr);</code></li>
</ul></li>
<li><p>either a or b is a standard-layout class object with no non-static data members and the other is the first base class subobject of that object, or,</p>
<ul>
<li>Examples: <code>{.cpp}     struct A { double d; };\     struct B : A { static int i; } b;\     double\* dptr = reinterpret_cast\&lt;double\*\&gt;(&amp;b.d);\     B\* cptr = reinterpret_cast\&lt;B\*\&gt;(dptr);</code></li>
</ul></li>
<li><p>there exists an object c where a and c are <em>pointer-interconvertible</em> and c and b are pointer-interconvertible.<span data-custom-style="annotation reference"></span></p></li>
</ul>
<p>In essence, such pointer-interconvertibility implies objects a and b have the same address, however, having the same address does not imply a and b are pointer-interconvertible! For example, an array and its first element have the same address but they are not pointer-interconvertible. This means that one cannot use reinterpret_cast to cast an array object to the type of its first element or vice versa. [Reference: ISO 14882 Section 6.9.2 [basic.compound], Paragraph 4].</p>
<h3 id="guidance-to-language-users">6.11.2 Guidance to language users</h3>
<ul>
<li><p>Follow the advice provided in ISO/IEC TR 24772-1:2019 clause 6.11.5.</p></li>
<li><p>Prefer C++ <code class="sourceCode cpp">T&amp;</code> references to <code class="sourceCode cpp">T*</code> pointers</p></li>
<li><p>Avoid the C-style cast, <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>, and casts to and from <code>void*</code>.</p></li>
<li><p>For conversions that remove the <code class="sourceCode cpp"><span class="at">const</span></code> qualification, see the guidance in clause 6.65.</p></li>
<li><p>When downcasting, prefer <code>dynamic_cast</code> and explicitly handle the possible failure cases. <em>What about</em> <em>references???</em></p>
<ul>
<li><pre><code>  *C++ Core guidelines C.146, 1.47 and 1.48*</code></pre></li>
</ul></li>
<li><p>Only be made using <code>dynamic_cast</code> for casts between two bases in a multiple inheritance hierarchy shall o. <em>What about references???</em></p>
<ul>
<li><pre><code>  *C++ Core guidelines C.146*</code></pre></li>
</ul></li>
<li><p>Heed compiler warnings that are issued for pointer conversion instances. The decision may be made to avoid all conversions so any warnings must be addressed. Note that casting into and out of <code>void *</code> pointers will most likely not generate a compiler warning as this is valid in C++</p></li>
<li><p>Use <code>new</code> and <code>delete</code> to allocate/deallocate memory, rather than <code>malloc()</code>/<code>free()</code>.</p>
<ul>
<li><pre><code>  EXP51-CPP. Do not delete an array through a pointer of the</code></pre>
<p>incorrect type (implied by 6.11)</p></li>
<li><pre><code>  EXP57-CPP. Do not cast or delete pointers to incomplete classes</code></pre>
<p>(-&gt; 6.11)</p></li>
<li><pre><code>  EXP36-C. Do not cast pointers into more strictly aligned pointer</code></pre>
<p>types (-&gt; 6.11)</p></li>
<li></li>
<li><pre><code>  MISRA C++ 10-1-1 - Classes should not be derived from virtual</code></pre>
<p>bases.</p></li>
</ul></li>
</ul>
<h2 id="pointer-arithmetic-rvg">6.12 Pointer Arithmetic [RVG]</h2>
<h3 id="applicability-to-language">6.12.1 Applicability to language</h3>
<p>The vulnerabilites described in ISO/IEC TR 24772-1:2019 clause 6.12.1 also apply to C++ pointers. Analogous vulnerabilities can also apply to C++ iterators.</p>
<p>Although based on the same implementation principles, iterators provide a layer of abstraction over pointer arithmetic. Their use typically restricts the arithmetic to the safe access to elements of the container. This restriction is enforced by the typical usage, not necessarily by the capability of iterators.</p>
<h3 id="guidance-to-language-users">6.12.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance of clause 6.8.2.</p></li>
<li><p>Prefer standard algorithms to hand-written loops</p>
<ul>
<li>See Core Guideline.ES.1 (TBD)</li>
</ul></li>
<li><p>Prefer ranges over iterators; and iterators over pointer arithmetic.</p></li>
<li><p>When using iterators, use an iterator that checks against the bounds of the container before performing the intended operation on the container.</p></li>
<li><p>Consider an outright ban on pointer arithmetic due to the error-prone nature of pointer arithmetic.</p></li>
<li><p>Verify that all pointers are assigned a valid memory address for use.</p></li>
</ul>
<h2 id="null-pointer-dereference-xyh">6.13 NULL Pointer Dereference [XYH]</h2>
<h3 id="applicability-to-language">6.13.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.13 exists in C++. C++ does, however, provide a number of mechanisms that allow the programmer to create, manipulate and destroy objects without the explicit use of raw pointers.</p>
<ul>
<li><p>Containers manage memory and separate memory management from the use of objects.</p></li>
<li><p>The container interface throws an exception if a container cannot be allocated.</p></li>
<li><p>Smart pointer creation functions allocate heap memory and handle memory management.</p></li>
<li><p>References provide similar functionality as pointers but cannot be null.</p></li>
</ul>
<p>The C++ mechanism new, by default, throws an exception if the allocated object cannot be created (i.e. if a null pointer would be returned). C++ does provide other allocation mechanism, including C malloc and a non-throwing new, that are not recommended for general use<span data-custom-style="annotation reference"></span>.<span data-custom-style="annotation reference"></span></p>
<p>See C++ Core Guidelines R: Resource Management, and CERT EXP34-C “Do not dereference null pointers”</p>
<pre><code>&lt;!--
Capture notion that std::make_shared does not guarantee* *atomaticity
of the referenced object.
[]{custom-style=&quot;annotation reference&quot;}
--.</code></pre>
<pre><code>&lt;!--
std::span, std.vector and std.array::provide ...

std::span is more lightweight and permit resizing .
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.13.2 Guidance to language users</h3>
<ul>
<li><p>When dereferencing objects of pointer-like types that may contain a null value, follow the guidance from TR 24772-3 clause 6.13.2.</p></li>
<li><p>Avoid the use of direct memory allocation. Instead use containers such as <code>std::array</code>, <code>std::vector</code>, and <code>std::span</code>.</p></li>
<li><p>Consider the use of library facilities of <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr</code> and <code>std::shared_ptr</code> to manage the lifetime of the object being referenced.</p></li>
<li><p>Use references to reduce the number of places where pointers are dereferenced. <span data-custom-style="annotation reference"></span></p></li>
<li><p>Do not suppress exceptions on memory allocation and handle any exceptions that arise. If exceptions are suppressed, follow the guidance of TR 24772-3:2020 clause 6.13.2.</p></li>
</ul>
<h2 id="dangling-reference-to-heap-xyk">6.14 Dangling Reference to Heap [XYK]</h2>
<h3 id="applicability-to-language">6.14.1 Applicability to language</h3>
<p>The vulnerability as expressed in ISO/IEC TR 24772-1:2019 and ISO/IEC TR 24772-3:2020 C exists in C++. C++, however, provides mechanisms to mitigate the vulnerability.</p>
<p>C++ provides a rich set of types whose objects may dangle, e.g.</p>
<ul>
<li><p>References</p></li>
<li><p>Pointers</p></li>
<li><p>Iterators</p></li>
<li><p><code class="sourceCode cpp"><span class="bu">std::</span>string_view</code></p></li>
<li><p><code class="sourceCode cpp"><span class="bu">std::</span>span</code></p></li>
<li><p><code class="sourceCode cpp"><span class="bu">std::</span>reference_wrapper</code></p></li>
</ul>
<p>We call these <em>potentially dangling types</em>.</p>
<p>If the lifetime of a <em>potentially dangling</em> <em>object</em> ends before its referent’s lifetime ends, then the vulnerability does not apply to that potentially dangling object. This is the primary C++ strategy for avoiding vulnerabilities due to potentially dangling objects. For example, using a <em>potentially dangling type</em> as a function parameter and passing an argument that refers to an object (referent) in the scope of the function call, and the function does not take ownership of the referent (for example, by deleting the referent), then the language guarantees that the lifetime of the referent is longer than the lifetime of the parameter, even if the referent is a temporary object created within the function call expression. This lifetime guarantee does not apply to further copies made to potentially dangling objects that outlive the function call, or if the function is a coroutine.</p>
<p>The language guarantees that a const-lvalue-reference or an rvalue-reference that are bound to a temporary object extend the lifetime of the temporary until the reference goes out of scope. Otherwise, the temporary object is destroyed at the end of the surrounding full expression. This lifetime extension is not transitive.</p>
<p>A simple example is where the temporary object referring heap allocation is passed as a constructor argument:</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string_view bad(<span class="st">&quot;a temporary string&quot;</span><span class="bu">s</span>); <span class="co">// \&quot;bad\&quot; holds a dangling pointer</span></span></code></pre></div>
<p>Note: technically in this example the vulnerability exists in the conversion operator <code class="sourceCode cpp"><span class="bu">std::</span>string<span class="bu">::</span>operator string_view()</code>, that returns a potentially dangling type from a member function callable on a temporary object.</p>
<p>Functions returning <em>potentially dangling types</em> are vulnerable, when the caller is not copying the resulting referent, but just stores the <em>potentially dangling object</em>. For example, the <em>range-for statement</em> uses the above mentioned lifetime extension for the range object to be iterated upon. If that range object itself is given as a reference already, the loop will access the elements through dangling iterators.</p>
<pre class="{cpp}"><code>extern std::vector&lt;std::string&gt; make(); // creates a vector

for(char c: make().front()) { // attempt to iterate over first string in vector
   // vector and thus contained string is already destroyed
}</code></pre>
<p>For objects directly allocated on the heap C++ provides smart pointers and corresponding factory functions that allow transferring ownership or shared ownership.</p>
<h3 id="guidance-to-language-users">6.14.2 Guidance to language users</h3>
<p>In addition to the guidance provided in TR 24772-1 clause 6.14.5:</p>
<ul>
<li><p>Do not rely on lifetime extension of temporaries by binding them to named references. Use (local) variables instead.</p></li>
<li><p>Prefer value types that manage heap memory, for example <code class="sourceCode cpp"><span class="bu">std::</span>string</code> instead of <code class="sourceCode cpp"><span class="at">const</span> <span class="dt">char</span> *</code> or <code class="sourceCode cpp"><span class="bu">std::</span>vector</code>, and pass by value/return by value over the use of <em>potentially dangling types</em>.</p></li>
<li><p>If value types are not feasible, adopt a style that makes explicit the ownership and lifetime of heap resources, by using <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr</code> or <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr</code> or similar RAII/SBRM types and allocate heap memory exclusively with their corresponding factory functions <code class="sourceCode cpp"><span class="bu">std::</span>make_unique/<span class="bu">std::</span>make_shared</code>.</p></li>
<li><p>Adopt a style that ensures all copies of any potentially dangling objects are guaranteed to be cleaned up before the referent’s lifetime ends or never accessed afterwards. For example, do not store the raw pointers managed by smart pointers, e.g., by calling their <code class="sourceCode cpp">get()</code> member function.</p></li>
<li><p>Consider making member functions ref-qualified, that return potentially dangling types to members or heap allocated objects managed by the class,<br />
to avoid being called on temporary objects. Note: An rvalue-ref-qualified overload should either return a copy by value, or be defined as <code class="sourceCode cpp">=<span class="kw">delete</span></code> to prevent calling it on a temporary that would lead to returning an immediately dangling object.</p></li>
<li><p>Show that the <em>range-for</em> dangling vulnerability does not apply or take steps to avoid it, for example, use a variable representing the range and not an expression that might yield a reference to a temporary.</p></li>
</ul>
<p>$incldue 6.15.ArithmeticWrap-aroundError-FIF.md</p>
<h2 id="using-shift-operations-for-multiplication-and-division-pik">6.16 Using Shift Operations for Multiplication and Division [PIK]</h2>
<h3 id="applicability-to-language">6.16.1 Applicability to language</h3>
<pre><code>&lt;!--
REWORD: The issues for C++ are well defined in TR 24772-1 clause 6.16
*Using Shift Operations for Multiplication and Division \[PIK\].* Also
see clause *6.15 Arithmetic Wrap-around Error \[FIF\]*.

In C++, shifts with too large an argument is defined as Undefined
Behaviour. See 6.56 Undefined Behaviour and ISO/IEC 14882:2017 C++
reference manual

&gt; From the C++ standard 14882:2017 clause 8.8 \[expr.shift\],\
&gt;  The shift operators \&lt;\&lt; and `\&gt;\&gt;`{.cpp} group
&gt; left-to-right.\
&gt; shift-expression:\
&gt; `additive-expression\
&gt; shift-expression \&lt;\&lt; additive-expression\
&gt; shift-expression \&gt;\&gt; additive-expression`{.cpp}\
&gt; The operands shall be of integral or unscoped enumeration type and
&gt; integral promotions are performed. The type of the result is that of
&gt; the promoted left operand. The behavior is undefined if the right
&gt; operand is negative, or greater than or equal to the length in bits of
&gt; the promoted left operand.\
&gt; \
&gt; The value of `E1 \&lt;\&lt; E2`{.cpp} is
&gt; `E1`{.cpp} left-shifted `E2`{.cpp} bit
&gt; positions; vacated bits are zero-filled. If `E1`{.cpp}
&gt; has an unsigned type, the value of the result is `E1 ×
&gt; 2E2`{.cpp}, reduced modulo one more than the maximum
&gt; value representable in the result type. Otherwise, if
&gt; `E1`{.cpp} has a signed type and non-negative value,
&gt; and `E1 × 2E2`{.cpp} is representable in the
&gt; corresponding unsigned type of the result type, then that value,
&gt; converted to the result type, is the resulting value; otherwise, the
&gt; behavior is undefined.\
&gt; \
&gt;  The value of `E1 \&gt;\&gt; E2`{.cpp} is
&gt; `E1`{.cpp} right-shifted `E2`{.cpp} bit
&gt; positions. If `E1`{.cpp} has an unsigned type or if
&gt; `E1`{.cpp} has a signed type and a non-negative value,
&gt; the value of the result is the integral part of the quotient of
&gt; `E1/2E2`{.cpp}. If `E1`{.cpp} has a
&gt; signed type and a negative value, the resulting value is
&gt; implementation-defined.
&gt;
&gt; The expression `E1`{.cpp} is sequenced before the
&gt; expression `E2`{.cpp}.
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.16.2 Guidance to language users</h3>
<pre><code>&lt;!--
SGM June 28 2021 - Since the applicability to language is incomplete, this section is currently also incomplete
--&gt;</code></pre>
<p>Follow the guidance of ISO/IEC TR 24772-1:2019 clause 6.16 <em>Using Shift Operations for Multiplication and Division [PIK].</em> Also see, <em>6.15 Arithmetic Wrap-around Error [FIF].</em></p>
<p>References:</p>
<h2 id="choice-of-clear-names-nai">6.17 Choice of Clear Names [NAI]</h2>
<h3 id="applicability-to-language">6.17.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.17 is applicable to C++.</p>
<p>’’’ <!--
This subclause requires a complete rewrite to have it reflect C++
issues.. TBD!!!

Think about discussing reserved names. Maybe also in Part 1.
--></p>
<pre><code>
C is somewhat susceptible to errors resulting from the use of similarly
appearing names. C does require the declaration of variables before they
are used. However, C allows scoping so that a variable that is not
declared locally may be resolved to some outer block and a human
reviewer may not notice that resolution. Variable name length is
implementation specific and so one implementation may resolve names to
one length whereas another implementation may resolve names to another
length resulting in unintended behaviour.

As with the general case, calls to the wrong subprogram or references to
the wrong data element (when missed by human review) can result in
unintended behaviour.ISO/IEC 14882:2017 C++ clause 20.5.4
\[constraints\] -- reserved names, from C++, also from C, deprecated
names

`Numeric_limits`{.cpp} are in std namespace,

To Do *(Paul)*

-   One can add names to a templates as part of specialization.

-   Example extending a hash function from std::

-   Also inline namespaces.

-   Also the use of underscores in symbol names.

-   Also Unicode in identfiers.

### 6.17.2 Guidance to language users

-   Follow the guidance of ISO/IEC 148822017 clause 20.5.4 regarding
    names to refrain from usage.

-   Use names that are clear and non-confusing.

-   Use consistency in choosing names.

-   Keep the scope of names as small as reasonable.

-   Keep names short and concise in order to make the code easier to
    understand.

-   Use longer names for longer-lived objects.

-   Choose names that are appropriately rich in meaning for the context.

-   When choosing names, keep in mind that code will be reused and
    combined in ways that the original developers never imagined.

-   Do not differentiate names through only a mixture of case or the
    presence/absence of an underscore character. (this is in Part 1?)

-   Do not choose names that conflict with (unreserved) keywords or
    language-defined library names for the language being used, as
    follows:

    -       Names that begin with two or more underscore;
    
    -       Names that begin with a single underscore followed by an
        uppercase letter;
    
    -   Contextual keywords such as module, final and override;

    -   In the global namespace, identifiers commencing with std
        followed by any string of digits;

&gt; Follow common conventions for naming macros:

-   Avoid names for macros that are not all uppercase;

-   Avoid names that are all uppercase not used for macros;

```{=html}
&lt;!-- --&gt;</code></pre>
<ul>
<li><p>Avoid differentiating through characters that are commonly confused visually such as ‘O’ and ‘0’, ‘l’ (lower case ‘L’), ‘I’ (capital ‘I’) and ‘1’, ‘S’ and ‘5’, ‘Z’ and ‘2’, and ‘n’ and ‘h’.</p></li>
<li><p>Adopt or develop coding guidelines to define a common coding style and to avoid the above dangerous practices.</p></li>
</ul>
<h2 id="dead-store-wxq">6.18 Dead Store [WXQ]</h2>
<h3 id="applicability-to-language">6.18.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 clause 6.18 exists in C++.</p>
<pre><code>&lt;!--
For Volatile, what do you do to ensure that a write reaches memory?

Initializing part of an array zeros the rest in C++

For the definition of &quot;dead store&quot; in C++, non-trivial destructors
constitute &quot;use of an object&quot; .
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.18.2 Guidance to language users</h3>
<ul>
<li><p>Use compilers and static analysis tools to identify dead stores in the program.</p></li>
<li><p>Declare variables to be accessed by other execution threads that represent values of type <code>T</code> as <code class="sourceCode cpp"><span class="bu">std::</span>atomic&lt;T&gt;</code>.</p></li>
<li><p>If variables are intended to be accessed by external devices, declare them as <code class="sourceCode cpp"><span class="at">volatile</span></code>.</p></li>
<li><p>If variables are intended to be used to communicate with signal handlers, declare them as <code class="sourceCode cpp"><span class="at">volatile</span> <span class="dt">sig_atomic_t</span></code>.</p></li>
<li><p>Declare variables as <code class="sourceCode cpp"><span class="at">volatile</span></code> when they are intentional targets of a store whose value does not appear to be used.</p></li>
</ul>
<h2 id="unused-variable-yzs">6.19 Unused Variable [YZS]</h2>
<h3 id="applicability-to-language">6.19.1 Applicability to language</h3>
<p>The vulnerability as documented in TR 24772-1 clause 6.19 exists in C++.</p>
<h3 id="guidance-to-language-users">6.19.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance of ISO/IEC TR 24772-1:2019 clause 6.19.5.</p></li>
<li><p>Resolve all compiler warnings for unused variables.</p></li>
</ul>
<h2 id="identifier-name-reuse-yow">6.20 Identifier Name Reuse [YOW]</h2>
<h3 id="applicability-to-language">6.20.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.20 exists in C++, except for the second issue of limited identifier length. In C++ all characters in an identifier are significant.</p>
<p>C++ provides the scope resolution operator <code class="sourceCode cpp">::</code> to access identifier from non-local scopes.</p>
<p>Overloading and specialization of functions is a cornerstone of C++ generic programming. In this context, the reuse of function names is essential. See clause 6.41 for inheritance issues associated with name reuse.</p>
<p>Overloaded function names and operators considered in an expression are not restricted to a simple scope hierarchy, because of argument-dependent lookup (ADL). In generic code the unqualified function or operator selected can come from a scope based on the type of the arguments and not from the current scope hierarchy. The rules for which namespaces are eligible for lookup unqualified functions and operators are intricate, but required to make overloaded operators work.</p>
<p>In addition, if implicit conversions can happen on arguments, the overload selected by ADL can be different from programmer expectation even in non-generic code, especially when an argument is of a type that can be implicitly converted to another type where a corresponding overload is defined. Visibility on a namespace-level of such an operator overload may make it eligible, even if neither argument matches the parameter types directly. In the best case this leads to a compile error due to ambiguities, but it can also result in perfectly compiling code executing an unexcepted overload.</p>
<p>The following example demonstrates part of the problem:</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;typeinfo&gt;</span></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> Y {</span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print(T i){</span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">typeid</span>(T).name()&lt;&lt; <span class="st">&quot;:&quot;</span> &lt;&lt; i ;</span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb141-10"><a href="#cb141-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> println(T x){</span>
<span id="cb141-11"><a href="#cb141-11" aria-hidden="true" tabindex="-1"></a>    print(x); <span class="co">// expects to call Y::print</span></span>
<span id="cb141-12"><a href="#cb141-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout&lt;&lt;<span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb141-13"><a href="#cb141-13" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb141-14"><a href="#cb141-14" aria-hidden="true" tabindex="-1"></a>} </span>
<span id="cb141-15"><a href="#cb141-15" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> X {</span>
<span id="cb141-16"><a href="#cb141-16" aria-hidden="true" tabindex="-1"></a>   <span class="kw">struct</span> A{</span>
<span id="cb141-17"><a href="#cb141-17" aria-hidden="true" tabindex="-1"></a>        A(<span class="dt">double</span>){}</span>
<span id="cb141-18"><a href="#cb141-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="co">// make this a hidden friend</span></span>
<span id="cb141-19"><a href="#cb141-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ostream &amp; <span class="kw">operator</span> &lt;&lt; (<span class="bu">std::</span>ostream &amp; out, A <span class="at">const</span> &amp;a){</span>
<span id="cb141-20"><a href="#cb141-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> out &lt;&lt; <span class="st">&quot;An A as expected</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb141-21"><a href="#cb141-21" aria-hidden="true" tabindex="-1"></a>        } </span>
<span id="cb141-22"><a href="#cb141-22" aria-hidden="true" tabindex="-1"></a>    };</span>
<span id="cb141-23"><a href="#cb141-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> print(A a){ <span class="co">// not expected to be called by println</span></span>
<span id="cb141-24"><a href="#cb141-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Surprise happens!&quot;</span>;</span>
<span id="cb141-25"><a href="#cb141-25" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb141-26"><a href="#cb141-26" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb141-27"><a href="#cb141-27" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main(){</span>
<span id="cb141-28"><a href="#cb141-28" aria-hidden="true" tabindex="-1"></a>    X::A a{<span class="fl">3.14</span>};</span>
<span id="cb141-29"><a href="#cb141-29" aria-hidden="true" tabindex="-1"></a>    Y::println(<span class="dv">42</span>); <span class="co">// i:42 - calls Y::print</span></span>
<span id="cb141-30"><a href="#cb141-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; a; <span class="co">// An A as expected - calls X::operator&lt;&lt;</span></span>
<span id="cb141-31"><a href="#cb141-31" aria-hidden="true" tabindex="-1"></a>    Y::println(a);  <span class="co">// Surprise happens! - calls X::print</span></span>
<span id="cb141-32"><a href="#cb141-32" aria-hidden="true" tabindex="-1"></a>    Y::println(<span class="dv">42</span><span class="bu">u</span>);<span class="co">// u:42 - calls Y::print</span></span>
<span id="cb141-33"><a href="#cb141-33" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The above code calls the overload <code>print(A)</code> from println since it is pulled in by ADL. On the other hand, ADL is required to work to allow the output operator for type <code>X::A</code> to work.</p>
<p>The consideration of implicit conversions together with ADL can be suppressed by defining operator overloads as class members or as <em>hidden friends</em>. The latter is achieved by declaring all corresponding overloads as <code class="sourceCode cpp"><span class="kw">friend</span></code> functions in the class that take the class’ objects as arguments. Generic base classes can provide mix-in facilities for <em>hidden friends</em> by taking the argument type that is the derived class as template parameter.</p>
<h3 id="guidance-to-language-users">6.20.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance of ISO/IEC TR 24772-1:2019 clause 6.20, with the exclusion of guidance related to truncated identifiers.</p></li>
<li><p>Qualify names to disambiguate potential conflicts between names introduced from different scopes.</p></li>
<li><p>Document argument-dependent lookup usage where name qualification is not desirable.</p></li>
<li><p>Limit the visibility of overloaded operators or functions for class types by defining them as member functions or <em>hidden friends</em>.</p></li>
<li><p>Place overloaded operators that are not class members and cannot be provided as <em>hidden friends</em> together with their argument type in a namespace that is not the global namespace, so that they are picked up by ADL.</p></li>
<li><p>Use modern integrated development environments that inform about the declaration of any identifier occurrence.</p></li>
<li><p>Enable compiler diagnostics that inform about the hiding of declarations.</p>
<ul>
<li><pre><code>  DCL60-CPP. Obey the one-definition</code></pre>
<p>rule (6.21)</p></li>
<li><pre><code>  DCL40-C. Do not create incompatible declarations of the same</code></pre>
<p>function or object (6.21)</p></li>
</ul></li>
</ul>
<h2 id="namespace-issues-bjl">6.21 Namespace Issues [BJL]</h2>
<h3 id="applicability-to-language">6.21.1 Applicability to language</h3>
<p>The vulnerability described in ISO/IEC TR 24772-1:2019 clause 6.21 is restricted to the following cases:</p>
<ul>
<li><p>Overloading, where clause 6.20 applies;</p></li>
<li><p>Overriding, where clause 6.41 applies.</p></li>
</ul>
<p>In all other cases, C++ compilers are required to diagnose an ambiguity.</p>
<pre><code>&lt;!--
Note: there might be corner cases with extern &quot;C&quot; functions declared in different namespaces (Peter)_
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.21.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance of clauses 6.20.2 and 6.41.2 as applicable.</p>
<ul>
<li><pre><code>  DCL60-CPP. Obey the one-definition rule (6.21)</code></pre></li>
<li><pre><code>  DCL40-C. Do not create incompatible declarations of the same</code></pre>
function or object (6.21)</li>
</ul></li>
</ul>
<h2 id="initialization-of-variables-lav">6.22 Initialization of Variables [LAV]</h2>
<h3 id="applicability-to-language">6.22.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 exists in C++.</p>
<p>C++ provides language capabilities to mitigate the effects of uninitialized variables as follows:</p>
<p>See C++ Core Guidelines ES.20 and CERT C++ Coding Guidelines EXP53-CPP</p>
<pre><code>&lt;!--
Need a list of references TBD -- (AI -- J. Daniel Garcia)
--&gt;</code></pre>
<p>Readers should note that ES.20 and EXP53 are complementary. Both point out that you should always initialize before reading, but ES.20 uses the narrow sense of initialize while EXP53 includes assignment.</p>
<h3 id="guidance-to-language-users">6.22.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance provided in</p>
<ul>
<li><pre><code>  C++ Core Guidelines, section Class hierarchies, and Expressions</code></pre>
<p>and Statements and</p></li>
<li><pre><code>  SEI CERT C++ Coding Standard section EXP53-CPP (and possibly</code></pre>
<p>more).</p></li>
</ul></li>
</ul>
<h2 id="operator-precedence-and-associativity-jcw">6.23 Operator Precedence and Associativity [JCW]</h2>
<h3 id="applicability-to-language">Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.23 is applicable to C++.</p>
<p>Operator precedence and associativity in C++ are determined by the C++ grammar. There are four operators that cannot be overloaded (user-defined)</p>
<ul>
<li><p><code class="sourceCode cpp">::</code> ;</p></li>
<li><p><code class="sourceCode cpp">.</code> ;</p></li>
<li><p><code class="sourceCode cpp">.\*</code> ; and</p></li>
<li><p><code class="sourceCode cpp">?:</code> .</p></li>
</ul>
<p>Due to the large number of operators, one is recommended to consult an operator precedence table when needed, e.g., <a href="https://en.cppreference.com/w/cpp/language/operator_precedence"><span data-custom-style="Hyperlink">https://en.cppreference.com/w/cpp/language/operator_precedence</span></a>. For example, in C++, the bitwise logical and shift operators are sometimes incorrectly treated as having the same precedence as arithmetic operations even though the bitwise operators have lower precedence. For example, the following (correct) expression subtracts one from <code class="sourceCode cpp">x</code> and then checks if the result is zero:</p>
<p><code class="sourceCode cpp">x - <span class="dv">1</span> == <span class="dv">0</span></code></p>
<p>which is equivalent to <code class="sourceCode cpp">(x - <span class="dv">1</span>) == <span class="dv">0</span></code>,i.e., <code class="sourceCode cpp">x - <span class="dv">1</span></code> is done first, then that result is compared to <code class="sourceCode cpp"><span class="dv">0</span></code>. Programmers mistakenly thinking the bitwise operations have the same precedence as arithmetic ones might write:</p>
<p><code class="sourceCode cpp">x &amp; <span class="dv">1</span> == <span class="dv">0</span></code></p>
<p>intending to perform <code class="sourceCode cpp">(x &amp; <span class="dv">1</span>) == <span class="dv">0</span></code>, but precedence rules result in this evaluating <code class="sourceCode cpp">x &amp; (<span class="dv">1</span> == <span class="dv">0</span>)</code> instead. This would have been easily fixed by using parenthesis to ensure the proper evaluation of an expression.</p>
<p>In addition to the aforementioned, C++ also permits operators to be overloaded when used with user-defined types. While it is not possible to change the precedence, associativity, and number of operands of overloaded operators [C++17, Clause 16.5 [over.oper], para. 6], overloaded operators can be executed differently than built-in operators. For example, overloaded operators lose any built-in operator short-circuiting properties and sequence order guarantees. Similarly overloaded operators and their arguments' evaluations behave as normal function calls, differing from built-in operator evaluation.</p>
<p>Note: overloaded assignment falls into this category.</p>
<p>C++ overloading of operators can cause significant issues. One hazard up-to the C++20 standard is that the overloaded comparison operators do not automatically connect the inverse operator, such as:</p>
<ul>
<li><p><code class="sourceCode cpp">==</code> and <code class="sourceCode cpp">!=</code>;</p></li>
<li><p><code class="sourceCode cpp">\&lt;</code> and <code class="sourceCode cpp">\&gt;=</code>;</p></li>
<li><p><code class="sourceCode cpp">\&gt;</code> and <code class="sourceCode cpp">\&lt;=;</code></p></li>
<li><p>etc.</p></li>
</ul>
<p>Unless the declarer declares all relevant operators, unexpected results occur. In addition, overloaded operators <code class="sourceCode cpp">&amp;&amp;</code> and <code class="sourceCode cpp">\|\|</code> do not have shortcut semantics and thus behave differently. This is problematic since the safety of evaluating a right-hand operand of a short circuit operator often depends on the result of the left-hand operand, e.g. an existence test before the value is read.</p>
<pre><code>&lt;!--
This needs to be adjusted to C++20 changes for comparison, should include combined assignment in examples instead. Peter
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.23.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance provided in ISO/IEC TR 24772-1:2019 Clause 6.23.5 [JCW].</p></li>
<li><p>Enable all C++ compiler/tool warnings and static analysis tool diagnostics concerning possible issues with precedence and associativity to help avoid and detect mistakes.</p></li>
<li><p>Even if technically unnecessary, use parentheses around operator (sub)expressions that are known to be or felt likely to be sources of error.</p></li>
<li><p>Avoid overloading the following operators:</p>
<ul>
<li><pre><code>  `&amp;&amp;` ;</code></pre></li>
<li><pre><code>  `||` ;</code></pre></li>
<li><pre><code>  `,` ;</code></pre></li>
</ul></li>
<li><p>Break up complex expressions and use temporary variables to make complex expressions easier to understand and maintain.</p></li>
</ul>
<h2 id="side-effects-and-order-of-evaluation-of-operands-sam">6.24 Side-effects and Order of Evaluation of Operands [SAM]</h2>
<h3 id="applicability-to-language">6.24.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.24 exists in C++.</p>
<p>The evaluation of an expression includes: (i) its value computation; and (ii) its side-effects. The value computation is the value returned by the expression, e.g., the valuation of <code>3 * 2 + 1</code> is <code>7</code>. The side-effect of an expression are</p>
<ul>
<li><p>Write accesses to objects in that expression,</p></li>
<li><p>Reading a volatile object,</p></li>
<li><p>Calling a library I/O function, and</p></li>
<li><p>Calling a function that does any of the above.</p></li>
</ul>
<p>For example consider:</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i = <span class="dv">2</span>;</span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> j = i++;</span></code></pre></div>
<p>the evaluation of i++ is 2 and the side-effects are the writing of 3 to i and the initialization of j.</p>
<p>Within an expression, one must ensure an object is stored only once to avoid undefined behaviour, e.g.,</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a>i = i++ + <span class="dv">5</span>; <span class="co">// undefined behaviour (before C++17)</span></span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a>k = i++ + i\--; <span class="co">// undefined behaviour in all versions of C++</span></span></code></pre></div>
<p>and expressions modifying objects can only read the object to determine the value to be stored (e.g., ++i requires reading the value), i.e., other accesses are undefined behaviour, e.g.,</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a>my_array\[i\] = i++; <span class="co">// undefined behaviour (before C++17)</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a>Starting with C++<span class="dv">17</span>, the evaluation order of an expression involving</span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a>overloaded operators preserves the sequenced before behaviour of the</span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true" tabindex="-1"></a>built-in <span class="kw">operator</span>:</span>
<span id="cb157-6"><a href="#cb157-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-7"><a href="#cb157-7" aria-hidden="true" tabindex="-1"></a><span class="er">```</span>{.cpp}</span>
<span id="cb157-8"><a href="#cb157-8" aria-hidden="true" tabindex="-1"></a>my_array[i] = i++;</span>
<span id="cb157-9"><a href="#cb157-9" aria-hidden="true" tabindex="-1"></a>my_array[i++] = i++;</span></code></pre></div>
<p>say <code class="sourceCode cpp">i = <span class="dv">10</span></code> before the expression</p>
<p>evaluate RHS <code>i++</code> – <code>i</code> is <code>11</code></p>
<p>evaluate <code>my_array[i++]</code> //evaluates <code>my_array\[11\]</code>, then assigns <code>i</code> to <code>12</code></p>
<p><code>my_array[11]</code> is assigned <code>10</code></p>
<p>This occurs because assignment is sequenced after the value computation of the right and left operands and before the value computation of the assignment expression and, the right operand is sequenced before the left operand. [C++17, Clause 8.18 [expr.ass], para. 1] Since this is the built-in operator, this statement can be thought of as:</p>
<blockquote>
<p>Compute value of right-hand-side: <code>i++</code> (e.g., integer value).</p>
<p>Compute value of left-hand-side: <code>my_array[i]</code> (e.g., memory address).</p>
<p>Apply side-effects of <code>i++</code>.</p>
<p>Apply side-effects of the assignment.</p>
</blockquote>
<p>In general, one should follow commonly-stated C/C++ advice of never reading from and writing to the same object within an expression to avoid potential vulnerabilities. Often breaking the expression into separate statements achieves clear and clean semantics, e.g.,</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a>++i;</span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a>my_array[i] = i;</span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a>my_array[i] = i;</span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a>++i;</span></code></pre></div>
<p>makes it unambiguous what the value of i is during the array assignment and eliminates the possibility of vulnerabilities.</p>
<p>In addition, it is important to note that overloading an operator disables short-circuiting behaviours (e.g., built-in boolean operators): those operators' operands are all evaluated before the operator itself.</p>
<p>The C++ built-in (two-argument) Boolean operators (e.g., <code class="sourceCode cpp">&amp;&amp;</code> and <code class="sourceCode cpp">\|\|</code>)as well as <code>&lt;type_traits&gt;</code>’s <code class="sourceCode cpp"><span class="bu">std::</span>conjunction</code> and <code class="sourceCode cpp"><span class="bu">std::</span>disjunction</code> operations are all short-circuiting, i.e., if the value of an earlier (from left-to-right) operand of an operation determines the result of the operation, then all remaining arguments are not evaluated.</p>
<pre><code>&lt;!--
Conjunction and disjunction operate at compile time and the short-circuiting is about template instantiations that might lead to compile errors otherwiese. This is not a runtime safety issue. I suggest dropping that (Peter)_
--&gt;</code></pre>
<p>Typically this allows one to write code like this, e.g.,</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> *p;</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (p != <span class="kw">nullptr</span> &amp;&amp; *p != <span class="dv">0</span>) {</span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* do something */</span></span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>i.e., if <code class="sourceCode cpp">p</code> is <code class="sourceCode cpp"><span class="kw">nullptr</span></code>, then <code class="sourceCode cpp">*p != <span class="dv">0</span></code> is never executed, thus, avoiding undefined behaviour. Only when <code>p</code> is not <code class="sourceCode cpp"><span class="kw">nullptr</span></code> is *p != 0 is evaluated. It must be stressed that this only applies to the built-in <code class="sourceCode cpp">&amp;&amp;</code> and <code>||</code> operators: user-defined operator overloads as functions always evaluate all operands first.</p>
<p>Consequently should one want to always evaluate all operands of a boolean expression, one should not write code like this:</p>
<p><code class="sourceCode cpp"><span class="dt">bool</span> x = foo() &amp;&amp; bar();</code></p>
<p>where <code>foo()</code> and <code>bar()</code> are functions that return something convertible to <code>bool</code>. In this expression, if <code>foo()</code> returns <code class="sourceCode cpp"><span class="kw">false</span></code>, then <code>bar()</code> will never be executed; –only when <code>foo()</code> returns <code class="sourceCode cpp"><span class="kw">true</span></code> will <code>bar()</code> be executed. Similarly for <code>||</code>:</p>
<p><code class="sourceCode cpp"><span class="dt">bool</span> y = foo() || bar();</code></p>
<p>i.e., only when <code class="sourceCode cpp">foo()</code> returns <code class="sourceCode cpp"><span class="kw">false</span></code> will <code class="sourceCode cpp">bar()</code> be executed if <code class="sourceCode cpp">foo()</code> returns <code class="sourceCode cpp"><span class="kw">true</span></code> then <code class="sourceCode cpp">bar()</code> will never be executed. Thus, if both <code class="sourceCode cpp">foo()</code> and <code class="sourceCode cpp">bar()</code> are both required to be executed, then execute them in separate statements first, e.g.,</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> foo_result = foo();</span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> bar_result = bar();</span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> x = foo_result &amp;&amp; bar_result;</span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> y = foo_result \|\| bar_result;</span></code></pre></div>
<pre><code>&lt;!--
Stephen: My write-up here is lengthy but should help get more terse
wording\... but I note this: C++ operator information is in C++17 Clause
8 and Clause 16.5, \... Also per 16.5.1 para 2. unary and binary forms
of the same operator are considered to have the same name so one can
hide another from an enclosing scope. Thus, this is also another
possible vulnerability.\]
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.24.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance provided in ISO/IEC TR 24772-1:2019 Clause 6.24.5.</p></li>
<li><p>Write expressions so that the same effects will occur under any order of evaluation that C++ permits since side effects can be dependent on an implementation specific order of evaluation.</p></li>
<li><p>Avoid overloading logical operators (&amp;&amp; and ||), as these overloaded versions will not short-circuit.</p></li>
<li><p><em>Ensure that</em> ++, --, @= <em>are used as solitary items in a statement.</em></p></li>
<li><p>Be aware to which C++ standard a compiler is compiling code against. This determines the semantics of all operator (overloaded and built-in) expressions.</p></li>
<li><p>Avoid placing multiple operations with side effects in a single expression.</p></li>
<li><p>Write simple code expressions and statements so that within any expression or statement an object is one of:</p>
<ul>
<li><pre><code>  Read from;</code></pre></li>
<li><pre><code>  Only modified once; or</code></pre></li>
<li><pre><code>  Only read and modified by: a single increment; a single</code></pre>
decrement; a single simple assignment; or a single compound assignment.</li>
</ul></li>
<li><p>Be aware that different versions of C++ have different evaluation order specifications and program accordingly.</p></li>
</ul>
<h2 id="likely-incorrect-expression-koa">6.25 Likely Incorrect Expression [KOA]</h2>
<h3 id="applicability-to-language">6.25.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6,25 exists in C++.</p>
<p>C++ has several instances of operators which are similar in structure, but different in meaning. The most common quoted example for C-based languages is the replacement of “<code>==</code>” with “<code>=</code>” in an expression, or confusion between:</p>
<ul>
<li><p><code>&amp;</code> and <code>&amp;&amp;</code>;</p></li>
<li><p><code>|</code> and <code>||</code>;</p></li>
<li><p><code>&lt;</code>, <code>&lt;&lt;</code>, and <code>&lt;&lt;=</code>; and</p></li>
<li><p><code>&gt;</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;=</code>.</p></li>
</ul>
<!-- fixed, there is not triple angle bracket operator in C!! Peter. -->
<p>As a general rule, the use of <code>=</code>, <code>+=</code>, <code>-=</code> in an expression when the operator is not the final assignment to a variable is unsafe since the assignment operator creates side-effects within the expression which are difficult to analyze by a human reader and can be have different results depending upon the order of evaluation of terms within the expression.</p>
<p>C++ provides significant freedom in constructing statements. This freedom, if misused, can result in unexpected results and potential vulnerabilities.</p>
<p>The flexibility of C++ can obscure the intent of a programmer. Consider:</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x,y;</span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a><span class="co">/* … */</span></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (x = y){</span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* … */</span></span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>A fair amount of analysis may need to be done to determine whether the programmer intended to do an assignment as part of the if statement (valid in C++) or whether the programmer made the common mistake of using an <code class="sourceCode cpp">=</code> (assignment) instead of a <code class="sourceCode cpp">==</code> (equality). The major issue with assignment inside of a term of an expression is that it creates side effects that can cause the expression to evaluate in different orders and create different results on different compilers, or even in different executions with the same implementation.</p>
<p>In order to prevent this confusion, move assignments in contexts that are easily misunderstood outside of Boolean expression. This would change the example code to:</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x,y;</span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a><span class="co">/* … */</span></span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a>x = y;</span>
<span id="cb168-4"><a href="#cb168-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (x == <span class="dv">0</span>) {</span>
<span id="cb168-5"><a href="#cb168-5" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* ... */</span></span>
<span id="cb168-6"><a href="#cb168-6" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>This would clearly state what the programmer meant and that the assignment of y to x was intended.</p>
<p>Programmers can easily get in the habit of inserting the “<code>;</code>” statement terminator at the end of statements. However, inadvertently doing this can drastically alter the meaning of code, even though the code is valid as in the following example:</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a,b;</span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* … */</span></span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (a == b);  <span class="co">// the semi-colon will make this a null statement</span></span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb169-5"><a href="#cb169-5" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* ... */</span></span>
<span id="cb169-6"><a href="#cb169-6" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>Because of the misplaced semi-colon, the code block following the if will always be executed. In this case, it is extremely likely that the programmer did not intend to put the semi-colon there.</p>
<p>Unary ‘<code>+</code>’ on a variable is (almost) a no-op, and is possibly a mistype of ‘<code>++</code>’. A unary ‘<code>-</code>’ on a variable will switch its sign, unless applied to a variable of an unsigned type, in which case the result is the value subtracted from 2<sup>n</sup> where n is the number of bits in the unsinged type.</p>
<pre><code>&lt;--
Document with comments any use of `+`{.cpp} or
`-`{.cpp} applied as a unary since (as opposed to the
binary `+`{.cpp} or `-`{.cpp}.

-   Unary minus on unsigned type (MISRA 5-3-2)

-   Size of a pointer
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.25.2 Guidance to language users</h3>
<ul>
<li><blockquote>
<p>Simplify statements with interspersed comments to aid in accurately programming functionality and help future maintainers understand the intent and nuances of the code. The flexibility of C++ permits a programmer to create extremely complex expressions.</p>
</blockquote></li>
<li><blockquote>
<p>From Core guidelines:</p>
</blockquote>
<ul>
<li><pre><code>  ES 85 Make empty statements visible</code></pre></li>
<li><pre><code>  ES 40 Avoid complicated expressions</code></pre></li>
<li><pre><code>  ES 41 If in doubt about operator precedence, parenthesize</code></pre></li>
<li><pre><code>  ES 44 Do not depend on order of evaluation</code></pre></li>
</ul></li>
<li><blockquote>
<p>Avoid assignments embedded within other statements, as these can be problematic. Each of the following would be clearer and have less potential for problems if the embedded assignments were conducted outside of the expressions:</p>
</blockquote>
<div class="sourceCode" id="cb175"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a,b,c,d;</span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* ... */</span></span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ((a == b) || (c = (d-<span class="dv">1</span>)))    <span class="co">/* the assignment to c may not</span></span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a><span class="co">                                       occur if a is equal to b */</span></span></code></pre></div>
<p>or:</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a,b,c;</span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* ... */</span></span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a>  foo (a=b, c);</span></code></pre></div></li>
</ul>
<p>Each may have unintended results.</p>
<ul>
<li><p>Give null statements a source line of their own. This, combined with enforcement by static analysis, would make clearer the intention that the statement was meant to be a null statement.</p></li>
<li><p>Consider the adoption of a coding standard that limits the use of the assignment statement within an expression.</p></li>
</ul>
<h2 id="dead-and-deactivated-code-xyq">6.26 Dead and Deactivated Code [XYQ]</h2>
<h3 id="applicability-to-language">6.26.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 clause 6.26 exists in C++.</p>
<h3 id="guidance-to-language-users">6.26.2 Guidance to language users</h3>
<ul>
<li>Follow the guidance of ISO/IEC TR 24772-1:2019 clause 6.26.5.</li>
</ul>
<h2 id="switch-statements-and-static-analysis-cll">6.27 Switch Statements and Static Analysis [CLL]</h2>
<h3 id="applicability-to-language">6.27.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.27 exists in C++.</p>
<p>Because of the way in which the switch-case statement in C++ is structured, it can be relatively easy to unintentionally omit the break statement between cases causing unintended execution of statements for some cases.</p>
<p>The switch statement has the form:</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> abc = someExpression();</span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* … */</span></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> (abc) {</span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a>       <span class="cf">case</span> <span class="dv">1</span>:</span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a>          sval = “a”;</span>
<span id="cb177-6"><a href="#cb177-6" aria-hidden="true" tabindex="-1"></a>           <span class="cf">break</span>;</span>
<span id="cb177-7"><a href="#cb177-7" aria-hidden="true" tabindex="-1"></a>       <span class="cf">case</span> <span class="dv">2</span>:</span>
<span id="cb177-8"><a href="#cb177-8" aria-hidden="true" tabindex="-1"></a>           sval = “b”;</span>
<span id="cb177-9"><a href="#cb177-9" aria-hidden="true" tabindex="-1"></a>           <span class="cf">break</span>;</span>
<span id="cb177-10"><a href="#cb177-10" aria-hidden="true" tabindex="-1"></a>       <span class="cf">case</span> <span class="dv">3</span>:</span>
<span id="cb177-11"><a href="#cb177-11" aria-hidden="true" tabindex="-1"></a>           sval = “c”;</span>
<span id="cb177-12"><a href="#cb177-12" aria-hidden="true" tabindex="-1"></a>           <span class="cf">break</span>;</span>
<span id="cb177-13"><a href="#cb177-13" aria-hidden="true" tabindex="-1"></a>       <span class="cf">default</span>:</span>
<span id="cb177-14"><a href="#cb177-14" aria-hidden="true" tabindex="-1"></a>           <span class="cf">throw</span> SomeException();</span>
<span id="cb177-15"><a href="#cb177-15" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>If there isn’t a default case and the switched expression doesn’t match any of the cases, then control simply shifts to the next statement after the switch statement block. Unintentionally omitting a break statement between two cases will cause subsequent cases to be executed until a break or the end of the switch block is reached. This could cause unexpected results.</p>
<p>The attribute <code class="sourceCode cpp">[[<span class="at">fallthrough</span>]]</code> expresses the programmer’s intent that the code where it is placed is intended to fall through. If this attribute is not used, compilers typically diagnose the absence of a break statement.</p>
<h3 id="guidance-to-language-users">6.27.2 Guidance to language users</h3>
<ul>
<li><p>Apply the guidance provided in ISO/IEC TR 24772-1:2019 clause 6.27.5</p></li>
<li><p>Use <code class="sourceCode cpp">[[<span class="at">fallthrough</span>]]</code> wherever fall-through is intended.</p></li>
<li><p>Terminate every case with either a flow control transfer or <code class="sourceCode cpp">[[<span class="at">fallthrough</span>]]</code> as illustrated in the following example:</p>
<pre><code>```{.cpp}
int i;
. . .
switch (i) {
       case 1: 
                     [[fallthrough]]; // documents the intended fallthrough.
       case 2:
            i++;    
            break;
        case 3: 
            j++; 
          [[fallthrough]]; // documents the intended fallthrough.
       case 4: //other code
            return 42;
       default: throw CaseNotFound();   
      }
```</code></pre></li>
<li><p>Adopt a style that permits your language processor and analysis tools to verify that all cases are covered. Where this is not possible, use a default clause that diagnoses the error.</p></li>
</ul>
<blockquote>
<p>See also the C++ Core Guidelines ES.78</p>
</blockquote>
<h2 id="demarcation-of-control-flow-eoj">6.28 Demarcation of Control Flow [EOJ]</h2>
<h3 id="applicability-to-language">6.28.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.28 exists in C++.</p>
<p>C++ lacks a keyword to be used as an explicit terminator. Therefore, it may not be readily apparent which statements are part of a loop construct or an if statement.</p>
<p>Consider the following sections of code:</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foo(<span class="dt">int</span> a, <span class="at">const</span> <span class="dt">int</span> *b) {</span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i=<span class="dv">0</span>;</span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// . . .</span></span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a>        a = <span class="dv">0</span>;</span>
<span id="cb179-5"><a href="#cb179-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">10</span>; i++);</span>
<span id="cb179-6"><a href="#cb179-6" aria-hidden="true" tabindex="-1"></a>        {</span>
<span id="cb179-7"><a href="#cb179-7" aria-hidden="true" tabindex="-1"></a>            a = a + b[i];</span>
<span id="cb179-8"><a href="#cb179-8" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb179-9"><a href="#cb179-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> c = <span class="dv">0</span>;</span>
<span id="cb179-10"><a href="#cb179-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x = <span class="dv">0</span>;</span>
<span id="cb179-11"><a href="#cb179-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;<span class="dv">10</span>; i++)</span>
<span id="cb179-12"><a href="#cb179-12" aria-hidden="true" tabindex="-1"></a>            c = c + b[i];</span>
<span id="cb179-13"><a href="#cb179-13" aria-hidden="true" tabindex="-1"></a>            x+= c; </span>
<span id="cb179-14"><a href="#cb179-14" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>At first it may appear that, after the first loop, <code class="sourceCode cpp">a</code> will be a sum of the numbers <span data-custom-style="Code">b[0]</span> to <span data-custom-style="Code">b[9]</span>. However, even though the code is laid out so that the <span data-custom-style="Code">a = a + b[i]</span> code appears to be within the for loop, the “<code class="sourceCode cpp">;</code>” at the end of the for statement causes the loop to be on a null statement (the “<code class="sourceCode cpp">;</code>”) and the</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a>a = a + b[i];</span></code></pre></div>
<p>statement to only be executed once. Similarly, the indentation leads us to believe that that assignment to x is part of the second loop, but it is not. These mistakes may be readily apparent during development or testing. More subtle cases may not be as readily apparent leading to unexpected results.</p>
<blockquote>
<p><code class="sourceCode cpp"><span class="cf">if</span></code> statements in C++ are also susceptible to control flow problems since there isn’t a requirement in C++ for there to be an else statement for every if statement. An <code class="sourceCode cpp"><span class="cf">else</span></code> statement in C++ always belong to the most recent <code class="sourceCode cpp"><span class="cf">if</span></code> statement without an <code class="sourceCode cpp"><span class="cf">else</span></code>. However, the situation could occur where it is not readily apparent to which <code class="sourceCode cpp"><span class="cf">if</span></code> statement an <code class="sourceCode cpp"><span class="cf">else</span></code> belongs due to the way the code is indented or aligned.</p>
<p>Similar issues arise for <code class="sourceCode cpp"><span class="cf">if</span></code>-statements, particularly during maintenance, for example:</p>
</blockquote>
<pre><code>```{.cpp}
int a,b,i;
// . . . 
if (i == 10){
       a = 5;       
       b = 10; // added later, but correct since within the {…}
      }
      else 
          a = 10;   
          b = 5;    // added later, intended to be part of the else clause
```</code></pre>
<blockquote>
<p>If the assignments to b were added later and were expected to be part of each <code class="sourceCode cpp"><span class="cf">if</span></code> and <code class="sourceCode cpp"><span class="cf">else</span></code> clause (they are indented as such), the above code is incorrect: the assignment to <code class="sourceCode cpp">b</code> that was intended to be in the <code class="sourceCode cpp"><span class="cf">else</span></code> clause is unconditionally executed.</p>
</blockquote>
<h3 id="guidance-to-language-users">6.28.2 Guidance to language users</h3>
<ul>
<li>Follow the rules provided in ISO/IEC TR 24772-1:2019 clause 6.28.5.</li>
</ul>
<blockquote>
<p>Enclose the bodies of <code class="sourceCode cpp"><span class="cf">if</span></code>, <code class="sourceCode cpp"><span class="cf">else</span></code>, <code class="sourceCode cpp"><span class="cf">while</span></code>, <code class="sourceCode cpp"><span class="cf">for</span></code>, and similar in braces. This will reduce confusion and potential problems when modifying the software.</p>
</blockquote>
<ul>
<li><p>Declare loop variables in the initializer of the loop statement</p></li>
<li><p>Prefer the standard library algorithms over hand-crafted loops.</p></li>
</ul>
<blockquote>
<p>See also the C++ Core Guidelines ES.85, ES.71, ES.74, ES.1 and ES.2</p>
</blockquote>
<h2 id="loop-control-variables-tex">6.29 Loop Control Variables [TEX]</h2>
<h3 id="applicability-to-language">6.29.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.29 exists in C++.</p>
<p>C++ allows the modification of loop control variables within a loop. Though this is usually not considered good programming practice as it can cause unexpected problems, the flexibility of C++ expects the programmer to use this capability responsibly.</p>
<p>Since the modification of a loop control variable within a loop is infrequently encountered, reviewers of C++ code may not expect it and hence miss noticing the modification. Modifying the loop control variable can cause unexpected results if not carefully done. In C++, the following is valid:</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a;</span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">1</span>; i\&lt;<span class="dv">10</span>; i++){</span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (a \&gt; <span class="dv">7</span>)</span>
<span id="cb182-5"><a href="#cb182-5" aria-hidden="true" tabindex="-1"></a>        i = <span class="dv">10</span>;</span>
<span id="cb182-6"><a href="#cb182-6" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb182-7"><a href="#cb182-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>which would cause the for loop to exit once a is greater than 7 regardless of the number of iterations that have occurred.</p>
<p>C++ also permits the use of multiple variable of the same type in the loop header</p>
<pre><code>&lt;!--
Mitigation -- range for statement -- document with an example (see
ES.71) -- Gabriel
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.29.2 Guidance to language users</h3>
<ul>
<li><p>Apply the guidance of ISO/IEC TR 24772-1:2019 clause 6.29.5.</p></li>
<li><p>Do not modify a loop control variable within a loop. Even though the capability exists in C, it is still considered to be a poor programming practice.</p></li>
<li><p>Use a range for loop in preference to general loops</p></li>
<li><p>Alternatively, use std library functions like <code>copy</code>, <code>accumulate</code>, <code>transform</code>, <code>for_each</code>, etc. in preference to general loops.</p></li>
<li><p>Something about multiple loop control variables in the same loop?</p></li>
</ul>
<blockquote>
<p>See also the C++ Core Guidelines ES.71, ES.86,</p>
</blockquote>
<h2 id="off-by-one-error-xzh">6.30 Off-by-one Error [XZH]</h2>
<h3 id="applicability-to-language">6.30.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.30 exists in C++.</p>
<p>Arrays are a common place for off by one errors to manifest. In C++, arrays are indexed starting at 0, causing the common mistake of looping from 0 to the size of the array as in:</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> foo() {</span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a[<span class="dv">10</span>];</span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i;</span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i=<span class="dv">0</span>, i&lt;=<span class="dv">10</span>, i++)</span>
<span id="cb184-5"><a href="#cb184-5" aria-hidden="true" tabindex="-1"></a>      ...</span>
<span id="cb184-6"><a href="#cb184-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="dv">0</span>);</span>
<span id="cb184-7"><a href="#cb184-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>C++ mitigates the issue of sentinel values in strings document in TR 24772-1 by providing the <code class="sourceCode cpp">string</code> class and the <code class="sourceCode cpp">string_view</code> class.</p>
<p>C++ does not flag accesses outside of array bounds, so an off by one error may not be as detectable in C++ as in some other languages. Several good and freely available tools can be used to help detect accesses beyond the bounds of arrays that are caused by an off by one error. However, such tools will not help in the case where only a portion of the array is used, and the access is still within the bounds of the array.</p>
<p>C++ mitigates these issues by providing</p>
<ul>
<li><p>Range-based for loops</p></li>
<li><p><code class="sourceCode cpp">std</code> algorithms</p></li>
<li><p>Iterator style loops terminated by <code class="sourceCode cpp">!=</code></p></li>
<li><p>Container classes</p></li>
<li><p><code class="sourceCode cpp">gsl::span</code> (soon to be <code class="sourceCode cpp"><span class="bu">std::</span>span</code>)</p></li>
</ul>
<h3 id="guidance-to-language-users">6.30.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance of ISO/IEC TR 24772-1:2019 clause 6.30.5.</p></li>
<li><p>Use careful programming, testing of border conditions, and static analysis tools to detect off-by-one errors in C++.</p></li>
<li><p>Use range-based for loops, std algorithms, iterator style loops terminated by !=, or container classes in preference to C-style arrays and structures.</p></li>
</ul>
<blockquote>
<p>See also the C++ Core guidelines ES.1, ES.42, ES.71, SL.con.3 (more to come)</p>
</blockquote>
<h2 id="structured-programming-ewd">6.31 Structured Programming [EWD]</h2>
<h3 id="applicability-to-language">6.31.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.31 exists in C++.</p>
<p>It is as easy to write structured programs in C++ as it is not to. C++ contains the goto statement, which can create unstructured code. Also, C has <code class="sourceCode cpp"><span class="cf">continue</span></code>, <code class="sourceCode cpp"><span class="cf">break</span></code>, and <code class="sourceCode cpp"><span class="cf">return</span></code> that can create a complicated control flow, when used in an undisciplined manner. Spaghetti code can be more difficult for static analyzers to analyze and is sometimes used on purpose to intentionally obfuscate the functionality of software. Code that has been modified multiple times by an assortment of programmers to add or remove functionality or to fix problems can be prone to become unstructured.</p>
<p>Because unstructured code in can cause problems for analyzers, both automated and human, of code, problems with the code may not be detected as readily or at all as would be the case if the software was written in a structured manner.</p>
<pre><code>&lt;1--
IMHO, a static analyzer worth its money would do any CFA DFA based on basic blocks and should not be bothered by gotos etc. Peter.
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.31.2 Guidance to language users</h3>
<ul>
<li><p>Write clear and concise structured code to make code as understandable as possible.</p></li>
<li><p>Avoid the use of <code>longjmp</code></p></li>
</ul>
<pre><code>&lt;!--
The guidance &quot;avoid the useof longjmp&quot; comes out of nowhere. It needs documentation in 6.31.1
--&gt;</code></pre>
<ul>
<li>Avoid the use of <code class="sourceCode cpp"><span class="cf">goto</span></code> except in the case of exiting a nested loop.</li>
</ul>
<p>See also the C++ Core guidelines ES.76, ES.77, SL.C.1</p>
<h2 id="passing-parameters-and-return-values-csj">6.32 Passing Parameters and Return Values [CSJ]</h2>
<h3 id="applicability-to-language">6.32.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.32 exists in C++.</p>
<p>C++ provides both <em>call by value</em> and <em>call by reference</em> parameter passing. The argument is evaluated to initialize the formal parameter (in the first case) or bound to the formal parameter (in the second case) of the function that is being called. A formal parameter behaves like a local variable.</p>
<p>An object can be modified in a function by passing the address to the object to the function, for example</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a>      <span class="dt">void</span> swap(<span class="dt">int</span> *x, <span class="dt">int</span> *y) { <span class="co">// C-style</span></span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a>         <span class="dt">int</span> t = *x;</span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a>         *x = *y;</span>
<span id="cb187-4"><a href="#cb187-4" aria-hidden="true" tabindex="-1"></a>         *y = t;</span>
<span id="cb187-5"><a href="#cb187-5" aria-hidden="true" tabindex="-1"></a>      }</span></code></pre></div>
<p>A call to this function is <code class="sourceCode cpp">swap( &amp;a, &amp;b);</code></p>
<p>In a preferred style (below), an object may be passed to a function by reference, which eliminates many of the problems enumerated in TR 24772-1 clause 6.32.1 and 6.32.3.</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap(<span class="dt">int</span> &amp; x, <span class="dt">int</span> &amp; y) { <span class="co">// C++-style which is like std::swap</span></span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> t = x;</span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a>        x = y;</span>
<span id="cb188-4"><a href="#cb188-4" aria-hidden="true" tabindex="-1"></a>        y = t;</span>
<span id="cb188-5"><a href="#cb188-5" aria-hidden="true" tabindex="-1"></a>     }</span></code></pre></div>
<p>This function is called by <code class="sourceCode cpp">swap(a,b);</code></p>
<p>Where x and y are integer pointer formal parameters, and *x and *y in the swap()function body dereference the pointers to access the integers.</p>
<p>C macros use a <em>call by name</em> parameter passing; a call to the macro replaces the macro by the body of the macro. This is called <em>macro expansion</em>. Macro expansion is applied to the program source text and amounts to the substitution of the formal parameters with the actual parameter expressions. Formal parameters are often parenthesized to avoid syntax issues after the expansion. Call by name parameter passing reevaluates the actual parameter expression each time the formal parameter is read.<span data-custom-style="annotation reference"></span></p>
<p><em>Paragraph about the violation of the keyword “restrict” in Part 3. – C++ does not have this keyword. Think about the issue.</em></p>
<h3 id="guidance-to-language-users">6.32.2 Guidance to language users</h3>
<ul>
<li><p>Follow the advice of ISO/IEC TR 24772-1:2019 clause 6.32.5.</p></li>
<li><p>Use caution for reevaluation of function calls in parameters with macros.</p></li>
<li><p>Use caution when passing the address of an object. The object passed could be an alias[^2]. Aliases can be avoided by following the respective guidelines of TR 24772-1 Clause 6.32.5.</p></li>
</ul>
<blockquote>
<p>See also the C++ Core Guidelines F.7 through F.48.</p>
</blockquote>
<h2 id="dangling-references-to-stack-frames-dcm">6.33 Dangling References to Stack Frames [DCM]</h2>
<h3 id="applicability-to-language">6.33.1 Applicability to language</h3>
<p>C++ allows one variable to refer to another variable. For example, a pointer variable can contain the address of another variable; a reference can be bound to a variable; and an iterator can point to a portion of a variable (in this case a container). Should the referencing variable outlive the referenced variable, the subsequent operations through the referencing variable will have undefined behavior.</p>
<p>For example</p>
<div class="sourceCode" id="cb189"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> *bad_pointer() {</span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a = <span class="dv">0</span>;</span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> &amp;a;</span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true" tabindex="-1"></a> }</span>
<span id="cb189-5"><a href="#cb189-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-6"><a href="#cb189-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span>&amp; bad_reference() {</span>
<span id="cb189-7"><a href="#cb189-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a = <span class="dv">0</span>;</span>
<span id="cb189-8"><a href="#cb189-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> a;</span>
<span id="cb189-9"><a href="#cb189-9" aria-hidden="true" tabindex="-1"></a> }</span>
<span id="cb189-10"><a href="#cb189-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-11"><a href="#cb189-11" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">3</span>&gt;::iterator bad_iterator()</span>
<span id="cb189-12"><a href="#cb189-12" aria-hidden="true" tabindex="-1"></a> {</span>
<span id="cb189-13"><a href="#cb189-13" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">3</span>&gt; a = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };</span>
<span id="cb189-14"><a href="#cb189-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> a.begin();</span>
<span id="cb189-15"><a href="#cb189-15" aria-hidden="true" tabindex="-1"></a> }</span>
<span id="cb189-16"><a href="#cb189-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-17"><a href="#cb189-17" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> bad_lambda() {</span>
<span id="cb189-18"><a href="#cb189-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x = <span class="dv">0</span>;</span>
<span id="cb189-19"><a href="#cb189-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [&amp;] { x = <span class="dv">1</span>; };</span>
<span id="cb189-20"><a href="#cb189-20" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb189-21"><a href="#cb189-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-22"><a href="#cb189-22" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> erroneous_use() {</span>
<span id="cb189-23"><a href="#cb189-23" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; *bad_pointer();</span>
<span id="cb189-24"><a href="#cb189-24" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; bad_reference();</span>
<span id="cb189-25"><a href="#cb189-25" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; *bad_iterator();</span>
<span id="cb189-26"><a href="#cb189-26" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; bad_lambda()();</span>
<span id="cb189-27"><a href="#cb189-27" aria-hidden="true" tabindex="-1"></a> }</span></code></pre></div>
<p><em>need to say something about lifetime extension, returning references, range for vulnerability with dangling references from temporaries. Peter</em></p>
<h3 id="guidance-to-language-users">6.33.2 Guidance to language users</h3>
<ul>
<li><p>Do not assign the address of an object, or reference to any entity where the referencing entity persists after the object has ceased to exist. This is done in order to avoid the possibility of a dangling reference.</p></li>
<li><p>Do not return the address of a local variable as the result of a function call.</p></li>
<li><p>Do not return a local variable as the result of a function returning a reference type</p></li>
<li><p>Avoid capturing by reference in lambdas that will be used non-locally, including return, or passing it to another thread, or stored in dynamic memory</p></li>
</ul>
<p>See also C++ Core Guidelines F.53, …</p>
<h2 id="subprogram-signature-mismatch-otr">6.34 Subprogram Signature Mismatch [OTR]</h2>
<h3 id="applicability-to-language">6.34.1 Applicability to language</h3>
<p>In general, there must be a match between the number of parameters in a function call and the number of arguments in the function definition. For issues related to macro signatures, see 6.51 Pre-processor directives.</p>
<p>The number of arguments can be different to the number of parameters in a function where: - a function template includes a <em>function parameter pack</em>, or - a function parameter includes a default argument, or - a function parameter-declaration-clause ends with an ellipsis, <code>f(\...)</code>.</p>
<p>Calling a function template with a <em>function parameter pack</em> results in a specialization of the function with the parameter types matching the corresponding argument types.</p>
<p>The compiler will ensure for variadic templates that the type and number of arguments is correct:</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> ...T&gt;</span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">int</span>, T ... t);</span>
<span id="cb190-3"><a href="#cb190-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-4"><a href="#cb190-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f2 ()</span>
<span id="cb190-5"><a href="#cb190-5" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb190-6"><a href="#cb190-6" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">0</span>, <span class="fl">0.1</span>, <span class="ch">&#39;a&#39;</span>); <span class="co">// OK - calls f&lt;double, char&gt; (int, double, char);</span></span>
<span id="cb190-7"><a href="#cb190-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>A call to a function with default arguments can provide fewer arguments than parameters as long as the parameters for which no explicit argument is provided include a default argument:</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">int</span>, <span class="dt">int</span> = <span class="dv">0</span>);</span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f2 ()</span>
<span id="cb191-4"><a href="#cb191-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb191-5"><a href="#cb191-5" aria-hidden="true" tabindex="-1"></a>  f1 ();        <span class="co">// error, not enough arguments </span></span>
<span id="cb191-6"><a href="#cb191-6" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>);       <span class="co">// OK, f1(1, 0)</span></span>
<span id="cb191-7"><a href="#cb191-7" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>, <span class="dv">2</span>);    <span class="co">// OK, f1(1, 2)</span></span>
<span id="cb191-8"><a href="#cb191-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Note: during overload resolution the compiler only considers conversions for the explicitly specified arguments.</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">short</span>, <span class="dt">int</span> = <span class="dv">0</span>);</span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">int</span>, <span class="dt">short</span> = <span class="dv">0</span><span class="bu">L</span>);</span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f2 ()</span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb192-6"><a href="#cb192-6" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>);       <span class="co">// OK, calls &#39;f1(1, 0)&#39; as &#39;1 -&gt; int&#39; is better match than &#39;1 -&gt; short&#39;</span></span>
<span id="cb192-7"><a href="#cb192-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Where a function parameter-declaration-clause ends with an ellipsis, additional arguments can be accessed through the mechanisms provided by <code>&lt;cstdarg&gt;</code>. No information about the number or types of the parameters is supplied by the compiler. The use of this feature outside of special situations can be the basis for vulnerabilities.</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstdarg&gt;</span></span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">int</span> cnt, ...)</span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb193-5"><a href="#cb193-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">va_list</span> ap;</span>
<span id="cb193-6"><a href="#cb193-6" aria-hidden="true" tabindex="-1"></a>  va_start (ap, cnt);</span>
<span id="cb193-7"><a href="#cb193-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-8"><a href="#cb193-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i = va_arg (ap, <span class="dt">int</span>);  <span class="co">// corresponds to parameter &#39;2&#39;, with value &#39;3&#39;</span></span>
<span id="cb193-9"><a href="#cb193-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-10"><a href="#cb193-10" aria-hidden="true" tabindex="-1"></a>  va_end(ap);</span>
<span id="cb193-11"><a href="#cb193-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb193-12"><a href="#cb193-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-13"><a href="#cb193-13" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f2 ()</span>
<span id="cb193-14"><a href="#cb193-14" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb193-15"><a href="#cb193-15" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>, <span class="dv">3</span>);</span>
<span id="cb193-16"><a href="#cb193-16" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Unlike the other mechanisms for argument passing, undefined behavior can arise, for example:</p>
<ul>
<li>Arguments with integral or enumeration type that are passed to an ellipsis parameter will undergo integral promotions, and so the type of the parameter is <code>int</code> and not <code>short</code>. The use of <code>short</code> with <code>va_arg</code> is therefore invalid.</li>
</ul>
<div class="sourceCode" id="cb194"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;cstdarg&gt;</span></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">int</span> cnt, ...)</span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">va_list</span> ap;</span>
<span id="cb194-6"><a href="#cb194-6" aria-hidden="true" tabindex="-1"></a>  va_start (ap, cnt);</span>
<span id="cb194-7"><a href="#cb194-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-8"><a href="#cb194-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">short</span> i = va_arg (ap, <span class="dt">short</span>);  <span class="co">// Invalid type</span></span>
<span id="cb194-9"><a href="#cb194-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-10"><a href="#cb194-10" aria-hidden="true" tabindex="-1"></a>  va_end(ap);</span>
<span id="cb194-11"><a href="#cb194-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<ul>
<li>In the following case, <code>f1</code> assumes that there will be two parameters after the named parameter.</li>
</ul>
<div class="sourceCode" id="cb195"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstdarg&gt;</span></span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">int</span> cnt, ...)</span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb195-5"><a href="#cb195-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">va_list</span> ap;</span>
<span id="cb195-6"><a href="#cb195-6" aria-hidden="true" tabindex="-1"></a>  va_start (ap, cnt);</span>
<span id="cb195-7"><a href="#cb195-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-8"><a href="#cb195-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i = va_arg (ap, <span class="dt">int</span>);</span>
<span id="cb195-9"><a href="#cb195-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> j = va_arg (ap, <span class="dt">int</span>);</span>
<span id="cb195-10"><a href="#cb195-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-11"><a href="#cb195-11" aria-hidden="true" tabindex="-1"></a>  va_end(ap);</span>
<span id="cb195-12"><a href="#cb195-12" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb195-13"><a href="#cb195-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-14"><a href="#cb195-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f2 ()</span>
<span id="cb195-15"><a href="#cb195-15" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb195-16"><a href="#cb195-16" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>);  <span class="co">// OK</span></span>
<span id="cb195-17"><a href="#cb195-17" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>, <span class="dv">2</span>);     <span class="co">// results in undefined behaviour</span></span>
<span id="cb195-18"><a href="#cb195-18" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>These issues cannot occur where default arguments or variadic function templates are used.</p>
<h3 id="guidance-to-language-users">6.34.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1:2019 clause 6.34.5.</p></li>
<li><p>Do not overload and use default arguments for the same set of functions</p></li>
<li><p>Do not use functionality from <code>&lt;cstdarg&gt;</code></p></li>
</ul>
<p>Note: See also C++ Core Guidelines F.55.</p>
<h2 id="recursion-gdl">6.35 Recursion [GDL]</h2>
<h3 id="applicability-to-language">6.35.1 Applicability to language</h3>
<p>C++ permits recursion, hence is subject to the problems described in ISO/IEC TR 24772-1:2019 clause 6.35.</p>
<h3 id="guidance-to-language-users">6.35.2 Guidance to language users</h3>
<ul>
<li>Apply the guidance described in TR 24772-1 clause 6.35.5.</li>
</ul>
<h2 id="ignored-error-status-and-unhandled-exceptions-oyb">6.36 Ignored Error Status and Unhandled Exceptions [OYB]</h2>
<h3 id="applicability-to-language">6.36.1 Applicability to language</h3>
<p>The vulnerabilities described in ISO/IEC TR 24772-1:2019 clause 6.36 exist in C++.</p>
<p>By default, C++ has the C weakness of permitting the call to a function that returns an error code without capturing the return value in a variable. For example</p>
<div class="sourceCode" id="cb196"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a>errnum foo( <span class="dt">int</span> a, <span class="dt">int</span> b);</span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true" tabindex="-1"></a>. . .</span>
<span id="cb196-3"><a href="#cb196-3" aria-hidden="true" tabindex="-1"></a>foo(x, y); <span class="co">// failure to capture the return error code.</span></span></code></pre></div>
<p>C++ offers as a mitigating mechanism the [[nodiscard]] attribute. This attribute indicates that the function result must not be discarded.</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a>[[<span class="at">nodiscard</span>]] errnum foo( <span class="dt">int</span> a, <span class="dt">int</span> b);</span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a>. . .</span>
<span id="cb197-3"><a href="#cb197-3" aria-hidden="true" tabindex="-1"></a>foo(x, y);  <span class="co">// compile error.</span></span>
<span id="cb197-4"><a href="#cb197-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-5"><a href="#cb197-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>( <span class="kw">auto</span> e = foo(a,b); e == <span class="dv">0</span>) { <span class="co">// no compile error</span></span>
<span id="cb197-6"><a href="#cb197-6" aria-hidden="true" tabindex="-1"></a><span class="co">// success</span></span>
<span id="cb197-7"><a href="#cb197-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb197-8"><a href="#cb197-8" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> {</span>
<span id="cb197-9"><a href="#cb197-9" aria-hidden="true" tabindex="-1"></a><span class="co">// handle errors</span></span>
<span id="cb197-10"><a href="#cb197-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>&lt;!--
Should we include a discussion about C++ error_code??? AI -- Michael Wong
--&gt;</code></pre>
<p>The header <code>&lt;system_error&gt;</code> defines types and functions used to report error conditions originating from the operating system, streams I/O, <a href="https://en.cppreference.com/w/cpp/thread/future"><code>std::future</code></a>, or other low-level APIs.</p>
<p>Defined in header <code>&lt;system_error&gt;</code> since C++11.</p>
<p>std::error_category serves as the base class for specific error category types, such as <a href="https://en.cppreference.com/w/cpp/error/system_category"><code class="sourceCode cpp"><span class="bu">std::</span>system_category</code></a>, <a href="http://en.cppreference.com/w/cpp/io/iostream_category"><code class="sourceCode cpp"><span class="bu">std::</span>iostream_category</code></a>, etc. Each specific category class defines the <code>error_code</code> - error_condition mapping and holds the explanatory strings for all error_conditions. The objects of error category classes are treated as singletons, passed by reference.</p>
<p><code>std::error_code</code> is a platform-dependent error code. Each <code>std::error_code</code> object holds an error code originating from the operating system or some low-level interface and a pointer to an object of type <a href="https://en.cppreference.com/w/cpp/error/error_category"><code class="sourceCode cpp"><span class="bu">std::</span>error_category</code></a>, which corresponds to the said interface. The error code values may be not unique across different error categories.</p>
<pre><code>&lt;!--
Discuss global error states, such as errno (which is thread-local) but still static.
---&gt;</code></pre>
<p>Global state for error codes is hard to manage and it is easy to forget to check it (C++ Core Guidelines E.28).</p>
<p>C++ offers a set of library-defined exceptions for error conditions that may be detected by checks that are performed by the standard library. In addition, the programmer may define exceptions that are appropriate for their application. These exceptions are handled using an exception handler. Exceptions may be handled in the environment where the exception occurs or may be propagated out to an enclosing scope.</p>
<h3 id="guidance-to-language-users">6.36.2 Guidance to language users</h3>
<ul>
<li><p>Follow the mitigation mechanisms of subclause 6.36.5 of ISO/IEC TR 24772-1:2019.</p></li>
<li><p>Check the returned error status upon return from a function. The C standard library functions provide an error status as the return value and sometimes in an additional global error value.</p></li>
<li><p>Use static analysis tools to detect and report missing or ineffective error detection or handling.</p></li>
<li><p>Avoid error handling based on global state.</p></li>
<li><p>Use <code class="sourceCode cpp">[[<span class="at">nodiscard</span>]]</code> to prevent callers from ignoring error values.</p></li>
<li><p>Prefer throwing exceptions to returning error values.</p></li>
<li><p>Use destructors to manage the finalization of the current context upon exit, whether erroneous or not.</p></li>
<li><p>Return error values from each enclosing function until an alternative strategy is available. Consider throwing an exception in lieu of returning an error value.</p></li>
<li><p>Handle exceptions at each function where an alternative strategy is available. In functions where no alternative strategy is available, do not catch the exception.</p></li>
<li><p>Consider termination as a last resort strategy for main or for noexcept functions.</p></li>
<li><p>Notify higher level constructs before a thread is allowed to terminate.</p></li>
<li><p>Consider the use of an <code>exception_ptr</code> object to transport an exception from the terminating thread to another thread for further processing.</p></li>
</ul>
<p>See also C++ Core Guidelines E.1, E.2, E.5, E.6, E.13, E.17, E.19, E.25, and E.28.</p>
<h2 id="type-breaking-reinterpretation-of-data-amv">6.37 Type-breaking Reinterpretation of Data [AMV]</h2>
<h3 id="applicability-to-language">6.37.1 Applicability to language</h3>
<p><em>This subclause requires a complete rewrite to have it reflect C++ issues.</em></p>
<p>The primary way in C that a reinterpretation of data is accomplished is through a union which may be used to interpret the same piece of memory in multiple ways. If the use of the union members is not managed carefully, then unexpected and erroneous results may occur.</p>
<p>C allows the use of pointers to memory so that an integer pointer could be used to manipulate character data. This could lead to a mistake in the logic that is used to interpret the data leading to unexpected and erroneous results.</p>
<p>C Part says</p>
<p><em>Wait for Gabriel</em> <em>to help analyze this.</em></p>
<h3 id="guidance-to-language-users">6.37.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1:2019 clause 6.38.5.</p></li>
<li><p>When using unions, implement an explicit discriminant and check its value before accessing the data in the union.</p></li>
<li><p>Ensure through static analysis that arbitrary pointer casts return a type compatible with the source.<span data-custom-style="annotation reference"></span></p></li>
<li><p>Avoid the use of C-style casts and reinterpret_cast</p></li>
</ul>
<h2 id="deep-vs.-shallow-copying-yan">6.38 Deep vs. Shallow Copying [YAN]</h2>
<h3 id="applicability-to-language">6.38.1 Applicability to Language</h3>
<p>The vulnerability described in ISO/IEC TR 24772-1:2019 clause 6.38 exists in C++.</p>
<p>The vulnerability only arises in C++ when there is a mismatch between the object’s copy semantics and the programmer’s intent. (references to Core Guidelines C.22)</p>
<p>C++ objects, by default, are copied member-wise. Each class type may define its own copy, move and assignment operations, allowing a class author to choose an appropriate depth for these operations. Class member types should be chosen to have copy and move semantics that support the semantics of the enclosing class.</p>
<pre><code>&lt;!--
This may belong elsewhere -- TBD\&gt; C++ provides the &quot;string view&quot;
mechanism as safer pointers to strings. Updates through string view are
prohibited, but the initial non &quot;view&quot; value can be updated and this
change will be seen by all viewers, even if they are dependent on fixed
value.
--&gt;</code></pre>
<p>Note: in C++, this is more commonly known as member-wise copying vs semantic copying, or owning vs observing rights.</p>
<pre><code>&lt;!--
Note: Why CERT does not address this issue -- involves programmer intent
and not readily tool-checkable.
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.38.2 Guidance to language users</h3>
<ul>
<li><p>Prefer the composition of most types from types that have either value semantics or semantics that support the intended copy and move semantics of the enclosing type.</p></li>
<li><p>When the above is not achievable, ensure that the copy assignment operator, copy constructor, move assignment operator, move constructor and destructor provide the desired semantics.</p></li>
<li><p>Avoid the use of raw pointers with the copy operation and (finish or delete)</p></li>
<li><p>Follow the guidance of C++ core guidelines C.20, C.22, C.32, C.67</p></li>
<li><p><em>&lt;This may belong elsewhere – TBD&gt;</em> Avoid updating the value of a string while there are valid string views in existence.</p></li>
</ul>
<h2 id="memory-leak-and-heap-fragmentation-xyl">6.39 Memory Leak and Heap Fragmentation [XYL]</h2>
<h3 id="applicability-to-language">6.39.1 Applicability to language</h3>
<p>The memory leak vulnerability documented in ISO/IEC TR24772-1:2019 clause 6.39 exists in C++, unless the programmer takes steps to avoid it.</p>
<p>C++ uses destructors, and a pattern called Resource Acquisition Is Initialization (RAII) which performs recovery of resources. Destructors (and therefore memory and resource releases) are deterministically ordered with respect to other events on their thread. Object destructors will not be called</p>
<ul>
<li><p>When an unhandled exception escapes its thread of execution</p></li>
<li><p>Under conditions of abnormal termination</p></li>
</ul>
<p>See CERT ERR50-CPP for list of cases.</p>
<p>The steps mentioned above will mitigate most memory leak issues.</p>
<p>The mechanisms <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr</code> and <code class="sourceCode cpp"><span class="bu">std::</span>shared_future</code> and similarly constructed reference-counting user code do not detect cycles which will cause leaks because the shared pointers (and hence what they point to) will not be destroyed.</p>
<p><em>need to clarify to rely on memory managing types, containers, and unique ptr, shared ptr is often bad , Peter</em></p>
<h3 id="guidance-to-language-users">6.39.2 Guidance to language users</h3>
<ul>
<li><p>Use containers and smart pointers in preference to direct (manual) memory management.</p></li>
<li><p>Follow C++ Core guidelines section R and CERT MEM51.</p></li>
<li><p>For heap fragmentation issues, follow the guidance of ISO/IEC TR 24772-1:2019 clause 6.39.5. In particular, create pools of fixed size with user-defined operators new and operators delete.</p></li>
<li><p>Use dynamic analysis tools to detect cycles.</p></li>
<li><p>Break cycles, for example by using <code class="sourceCode cpp"><span class="bu">std::</span>weak_ptr</code> or appropriate weak pointers.</p></li>
<li><p>Use <code class="sourceCode cpp"><span class="bu">std::</span>abort()</code> or <code class="sourceCode cpp"><span class="bu">std::</span>terminate()</code> and related functions only in extreme situations. See CERT ERR50-CPP for list of cases.</p></li>
<li><p>Use debugging tools such as leak detectors to help identify unreachable memory.</p></li>
</ul>
<h2 id="templates-and-generics-sym">6.40 Templates and Generics [SYM]</h2>
<h3 id="applicability-to-language">6.40.1 Applicability to language<span data-custom-style="annotation reference"></span></h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1 clause 6.40 exists in C++. C++ provides the facility <em>Templates</em> to support the generic programming methodology. C++ Templates can be variadic templates. C++ Templates can accept as arguments types, templates, and values, including addresses of global variables. <em>Concepts</em> improve template argument checking at compile time.</p>
<p>Programming language compilers help programmers avoid run-time errors by performing static analysis on the code and generating diagnostics that prevent run-time errors. Therefore, the goal of the C++ language is to help transition code towards compile-time analysis instead of relying on runtime executions that result in run-time failures. Templates are one of the favourable mechanisms to achieve this goal of maximizing compile-time analysis to reduce or eliminate run-time analysis.</p>
<p>When used appropriately, they are suitable for embedded and safety critical systems;</p>
<ul>
<li><p>They provide type safe generic in contrast to legacy void*-based or macro-based genericity;</p></li>
<li><p>They have no runtime overhead for inline operations; and</p></li>
<li><p>They have no memory used or code generated for unused operations which are both critical in limited resource systems.</p></li>
</ul>
<p>Excessive use of templates can lead to cognitive overload in terms of learning, understanding and the maintainability of the code. This clause provides explanation and guidance to mitigate problems that can arise.</p>
<p>From ISO/IEC TR 24772-1:2019 clause 6.40.1 (or .3) "Confusion, and hence potential vulnerability, can arise where the instantiated code is apparently invalid, but does not result in a compiler error. For example, a generic class defines a set of members, a subset of which rely on a particular property of the instantiation type (such as a generic container class with a sort member function, only the sort function relies on the instantiating type having a defined relational operator). In some languages, such as C++, if the generic is instantiated with a type that does not meet all the requirements but the program never subsequently makes use of the subset of members that rely on the property of the instantiating type, the code will compile and execute (for example, the generic container is instantiated with a user defined class that does not define a relational operator, but the program never calls the sort member of this instantiation). When the code is reviewed the generic class will appear to reference a member of the instantiating type that does not exist."</p>
<p>The above paragraph does not correctly characterise the issue. In an implicit instantiation of a class template, only those functions that are ODR (one definition rule)-used are instantiated. Therefore, a template argument need not provide all of the operations used by all possible member functions of the class template. This case is exhibited in the standard library. std::vector&lt;T&gt;::emplace requires an accessible constructor of T. The Factory pattern makes constructors of a class C inaccessible to anyone but the factory functions. Still it is desirable to use std::vector with objects of type C. In this case, emplace cannot be used, which is clearly the intended behaviour of the class because objects of type C should only be constructed by the factory functions.</p>
<p>It is the nature of templates that every method that is not called is not compiled. If the program is changed such that a function is later ODR-used and the program recompiled, Three possible outcomes are:</p>
<ul>
<li><p>The program compiles and executes safely;</p></li>
<li><p>The program fails to compile; or</p></li>
<li><p>The program executes erroneously.</p></li>
</ul>
<p>Vulnerabilities that arise from the third case are covered elsewhere in the document(list), however, in the case of templates, the fact that code is written and may not be instantiated for a long time since code that invokes it has not been written, errors may not appear until later.</p>
<p>Features such as concepts and <code class="sourceCode cpp"><span class="kw">static_assert</span></code> can be used to mitigate the issue.</p>
<p><em>Mitigation</em> <em>– ensure complete coverage of Template code with unit tests</em></p>
<p>The third case is not specific to templates, except that the problem may be hidden is addressed in 6.2.</p>
<p>In the above paragraph, cases can arise where the programmer has not provided a type with all of the operations needed to function correctly in the template. For example,</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt; <span class="kw">typename</span> ForwardIterator , <span class="kw">typename</span> Value &gt;</span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a>   ForwardIterator find (ForwardIterator first, ForwardIterator last, <span class="at">const</span> Value &amp; val)</span>
<span id="cb202-3"><a href="#cb202-3" aria-hidden="true" tabindex="-1"></a>   {</span>
<span id="cb202-4"><a href="#cb202-4" aria-hidden="true" tabindex="-1"></a>       <span class="cf">while</span> ( first != last &amp;&amp; * first == val )</span>
<span id="cb202-5"><a href="#cb202-5" aria-hidden="true" tabindex="-1"></a>       ++ first ;</span>
<span id="cb202-6"><a href="#cb202-6" aria-hidden="true" tabindex="-1"></a>       <span class="cf">return</span> first</span>
<span id="cb202-7"><a href="#cb202-7" aria-hidden="true" tabindex="-1"></a>   }</span></code></pre></div>
<p>The standard says that</p>
<ul>
<li><p>the first template argument must be a forward iterator.</p></li>
<li><p>the second template argument type must be comparable to the value type of that iterator using <code class="sourceCode cpp">==</code>.</p></li>
</ul>
<p>These requirements are implicit and all the compiler has to go by is their use in the function</p>
<p>body. The result is great flexibility, splendid generated code for correct calls, and spectacularly bad</p>
<p>error messages for incorrect calls. The obvious solution is to specify the first two requirements as</p>
<p>part of the template’s interface:</p>
<div class="sourceCode" id="cb203"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt; forward_iterator Iter , <span class="kw">typename</span> Value &gt;</span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a>          <span class="kw">requires</span> equality_comparable &lt;Value, Iter :: <span class="dt">value_type</span> &gt;</span>
<span id="cb203-3"><a href="#cb203-3" aria-hidden="true" tabindex="-1"></a>forward_iterator find ( Iter first, Iter last, <span class="at">const</span> Value &amp; val );</span></code></pre></div>
<p>This is roughly what C++20 offers. Note the equality_comparable concept. It captures the</p>
<p>required relationship between the two template arguments.</p>
<p>The general C++11 <code class="sourceCode cpp"><span class="kw">static_assert</span></code> can also be used:</p>
<div class="sourceCode" id="cb204"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span> ( Equality_comparable &lt;<span class="dt">int</span> &gt;);       <span class="co">// succeeds</span></span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span> &lt; Eeqality_comparable &lt;<span class="dt">int</span> ,<span class="dt">long</span> &gt;); <span class="co">// succeeds</span></span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> S { <span class="dt">int</span> a; };</span>
<span id="cb204-4"><a href="#cb204-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span> ( Equality_comparable &lt;S&gt;);         <span class="co">// fails because structs don&#39;t</span></span>
<span id="cb204-5"><a href="#cb204-5" aria-hidden="true" tabindex="-1"></a>                                                       <span class="co">// automatically get == &amp; !=</span></span></code></pre></div>
<p><code class="sourceCode cpp"><span class="kw">static_assert</span> ( Equality_comparable \&lt;<span class="dt">int</span> \&gt;);</code></p>
<p><strong><u>Discussion of “ranges”</u></strong></p>
<p>Using the example above, the first two function arguments must denote a sequence. To express this requirement (that [first:last) is a sequence), requires a library extension. C++20 offers that in the Ranges standard-library component (§9.3.5). Hence in the example below we replace iterators with ranges:</p>
<div class="sourceCode" id="cb205"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt; range R, <span class="kw">typename</span> Value &gt;</span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true" tabindex="-1"></a><span class="kw">requires</span> equality_comparable &lt;Value , Range :: <span class="dt">value_type</span> &gt;</span>
<span id="cb205-3"><a href="#cb205-3" aria-hidden="true" tabindex="-1"></a>forward_iterator find (R r, <span class="at">const</span> Value &amp; val )</span>
<span id="cb205-4"><a href="#cb205-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb205-5"><a href="#cb205-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> first = begin (r);</span>
<span id="cb205-6"><a href="#cb205-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">auto</span> last = end (r);</span>
<span id="cb205-7"><a href="#cb205-7" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> ( first != last &amp;&amp; * first == val )</span>
<span id="cb205-8"><a href="#cb205-8" aria-hidden="true" tabindex="-1"></a>   ++ first ;</span>
<span id="cb205-9"><a href="#cb205-9" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> first</span>
<span id="cb205-10"><a href="#cb205-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p><span data-custom-style="annotation reference"></span></p>
<p><strong>Other issues</strong></p>
<p>Overload resolution of templates differs from the overload resolution of non-template code. This can result in methods or operators being chosen that are unexpected by the developer.</p>
<p>A template constructor is never a copy or move constructor and hence does not prevent the implicit definition of a copy or move constructor even if the constructor looks similar.</p>
<p>There are cases, however, where the instantiation of a template with a parameter that matches syntactic but not semantic requirements, such as ++ for a pointer, will compile and execute but will be wrong and can result in undefined behaviour. Other examples relate to incomplete class types, see clause 6.2 <em>Type system.</em></p>
<p>Another issue – likely to be placed elsewhere and referenced here</p>
<p>Standard vector construction issue where braces are replaced with curly braces. (Paul)</p>
<p>Guidance – use braces initially and only use other format if the compiler fails ???</p>
<p><em>(Examples needed</em>)</p>
<p>Core guidelines (fill in references)</p>
<p>I.9 T.10, T.11, 12, 13, T.20, T.21, T.22, T.23, T.24, T.25, T.26, T.30, T.31 – forward to Clive.</p>
<p>(<em>We may wish to summarize)</em></p>
<h3 id="guidance-to-language-users">6.40.2 Guidance to language users</h3>
<ul>
<li><p>Use static analysis tools to diagnose the use of inappropriate types in a template interface</p></li>
<li><p><em>Cyclic dependencies and ODR (one definition rule) use …</em></p></li>
<li><p>Consider using <em>concepts</em> for each template type parameter</p>
<ul>
<li><pre><code>  Create and use concepts that specify &quot;meaningful&quot; semantics</code></pre></li>
</ul></li>
<li><p>Write templates that check if a specific template argument fulfills the minimal syntactic requirements for the template, for example by using static_assert with type_traits.</p></li>
<li><p>Be aware that a constructor template or assignment operator function template will not replace compiler-provided special member functions</p></li>
<li><p>For generic operator functions, consider providing them as hidden friends through<span data-custom-style="annotation reference"></span> mix-in class templates.</p></li>
</ul>
<blockquote>
<p>As an example, the following class template defines equality operators for single-element structs (Template parameter U):</p>
</blockquote>
<div class="sourceCode" id="cb207"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> U&gt;</span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Eq{</span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span></span>
<span id="cb207-4"><a href="#cb207-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">operator</span>==(U <span class="at">const</span> &amp;l, U <span class="at">const</span>&amp; r) <span class="kw">noexcept</span> {</span>
<span id="cb207-5"><a href="#cb207-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> &amp;[vl]=l;</span>
<span id="cb207-6"><a href="#cb207-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> &amp;[vr]=r;</span>
<span id="cb207-7"><a href="#cb207-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> vl == vr;</span>
<span id="cb207-8"><a href="#cb207-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb207-9"><a href="#cb207-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span></span>
<span id="cb207-10"><a href="#cb207-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">operator</span>!=(U <span class="at">const</span> &amp;l, U <span class="at">const</span>&amp; r) <span class="kw">noexcept</span> {</span>
<span id="cb207-11"><a href="#cb207-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> !(l==r);</span>
<span id="cb207-12"><a href="#cb207-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb207-13"><a href="#cb207-13" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb207-14"><a href="#cb207-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-15"><a href="#cb207-15" aria-hidden="true" tabindex="-1"></a><span class="co">// usage of the above, check that type X obtains operator== and operator!=</span></span>
<span id="cb207-16"><a href="#cb207-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-17"><a href="#cb207-17" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> X: Eq&lt;X&gt;{</span>
<span id="cb207-18"><a href="#cb207-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> val;</span>
<span id="cb207-19"><a href="#cb207-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="kw">explicit</span></span>
<span id="cb207-20"><a href="#cb207-20" aria-hidden="true" tabindex="-1"></a>    X(<span class="dt">int</span> v):val{v}{}</span>
<span id="cb207-21"><a href="#cb207-21" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb207-22"><a href="#cb207-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-23"><a href="#cb207-23" aria-hidden="true" tabindex="-1"></a>   <span class="kw">static_assert</span>(X{<span class="dv">42</span>} != X{<span class="dv">43</span>} &amp;&amp; X{<span class="dv">42</span>} == X{<span class="dv">42</span>} );</span></code></pre></div>
<p>The advantage in using the above mechanism is that these overloads are only visible comparing objects of type X, and not for other types. Implementing them as free functions increases likelihood that implicit conversions will result in the wrong function being called.</p>
<ul>
<li>Use qualified-id or this-&gt; to refer to names that may be found in a dependent base</li>
</ul>
<blockquote>
<p><em>Needs an example and explanation in 6.40.1 (AI Paul)</em></p>
</blockquote>
<ul>
<li><p>For template specialization, declared the specialization:</p>
<ol type="1">
<li><p>In the same file as the primary template; or</p></li>
<li><p>In the same file as the user-defined type for which the specialization is declared.</p></li>
</ol></li>
<li><p>Do not specialize function templates, except when specialization is on a non-deduceable template parameter</p></li>
</ul>
<h2 id="inheritance-rip">6.41 Inheritance [RIP]</h2>
<h2 id="applicability-to-language">6.41.1 Applicability to language</h2>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.41 is applicable to C++.</p>
<p>Inheritance, the ability to create enhanced and/or restricted object classes based on existing object classes, can introduce a number of vulnerabilities, both inadvertent and malicious. Because inheritance allows the overriding of methods of the parent class and because object-oriented systems are designed to separate and encapsulate code and data, it can be difficult to determine where in the hierarchy an invoked method is actually defined.</p>
<p>Also, since an overriding method does not need to call the method in the parent class that has been overridden, essential manipulation of class data may be bypassed.</p>
<p>This can be especially dangerous in copy assignment operator and move assignment operators and in particular when private data components (that is, data components not visible to methods of subclasses) of the parent class are left unchanged. Serious violations of type invariants can arise as a consequence.</p>
<p>Multiple inheritance adds additional complexities to the resolution of method invocations.</p>
<p>The use of inheritance can lead to an exploitable application vulnerability or negatively impact system safety in several ways:</p>
<ul>
<li><p>Execution of malicious redefinitions, which can occur through the insertion of a class into the class hierarchy that overrides commonly called methods in the parent classes.</p>
<ul>
<li><pre><code>  mitigation -- make member functions</code></pre>
<p><code class="sourceCode cpp"><span class="kw">final</span></code>,</p></li>
<li><pre><code>  reduce the use of inheritance</code></pre></li>
</ul></li>
<li><p>Accidental override, where a member function is defined that inadvertently overrides a member function that has already been defined in a parent class.</p>
<ul>
<li><pre><code>  Mitigation -- use `override`{.cpp} and</code></pre>
<code class="sourceCode cpp"><span class="kw">final</span></code> keywords on member functions to generate compiler diagnostics when overriding is accidental</li>
</ul></li>
<li><p>Accidental failure to override, when a method is incorrectly named or the parameters are not defined properly, and thus does not override a member function in a parent class.</p>
<ul>
<li><pre><code>  Mitigation -- use `override`{.cpp} and</code></pre>
<code class="sourceCode cpp"><span class="kw">final</span></code> keywords on member functions to generate compiler diagnostics when overriding is accidental</li>
</ul></li>
<li><p>Breaking of class invariants, which can be caused by redefining methods that assign, move, or validate class data without including the assigning, moving or validating in the overriding member function. This applies particularly to class invariants involving data of the parent class not visible in methods of the subclass. Inherited methods of the parent that have access to these “private” components will likely fail, if the components are set inappropriately.</p>
<ul>
<li><pre><code>  Mitigation -- if any class invariant depends upon a value of a</code></pre>
data member, then make that member private</li>
</ul></li>
<li><p>Direct reading and writing of visible class members when matching getting and setting member functions include additional functionality.</p>
<ul>
<li><pre><code>  Guidance: make data members private and provide a public</code></pre>
interface to access them that preserves class invariants.</li>
</ul></li>
</ul>
<p>These vulnerabilities can increase dramatically as the complexity of the hierarchy increases, especially in the use of multiple inheritance.</p>
<p>As member functions are inherited from multiple chains of ancestors, the determination of which member function implementations exist and are being called, becomes increasingly more difficult for the programmer. Understanding which member functions and data members apply to a given (sub)class becomes exceedingly difficult if these methods or components are inherited homographs (i.e., data components with identical names or member functions with identical signatures). Misunderstandings lead to inadvertent coding errors. The complexity increases even more when multiple inheritance is used to model “has-a” relationships (see subclause <a href="#_6.42_Violations_of_1"><span data-custom-style="Hyperlink">6.42 Violations of the Liskov substitution principle [BLP])</span></a>: member functions never intended to be applicable to instances of a subclass are inherited nevertheless. For example, an instance of class aircraftCarrier may be “turn”ed merely because it obtained its propulsion screw by a “has-a”-inheritance with “turn” being an obviously meaningful method for the class of propulsionScrew. Meanwhile the user has a quite different expectation of what it means to turn an aircraft carrier. The complications increase if the carrier inherits twice from the class propulsionScrew because it has two propulsion screws.</p>
<p>Changes in the execution of methods can be introduced by adding an unrelated but homographic member function (with signatures involving implicitly convertible types) anywhere is the hierarchies of ancestor classes during maintenance of the code. Malicious implementations can thus be added with each release of an object-oriented library and affect the behaviour of previously verified code. (see subclause <a href="#_6.42_Violations_of_1"><span data-custom-style="Hyperlink">6.42 Violations of the Liskov substitution principle [BLP])</span></a></p>
<ul>
<li><p>Guidance: Keep inheritance hierarchies short</p></li>
<li><p>Guidance: Qualify the program to invoke member functions in explicit parent classes.</p></li>
<li><p>Mitigation: use the ‘= delete’ construct to prevent a member function from being called due to an inheritance.</p></li>
</ul>
<h2 id="guidance-to-language-users">6.41.2 Guidance to language users</h2>
<ul>
<li><p>Follow the guidance of ISO/IEC TR 24772-1:2019 clause 41.5.</p></li>
<li><p>Avoid the use of multiple inheritance whenever possible.</p></li>
<li><p>Avoid access to data components when getting and setting functions are available for them.</p></li>
<li><p>Keep inheritance hierarchies short and narrow</p></li>
<li><p>Prefer non-virtual functions to virtual functions</p></li>
<li><p>Use <code class="sourceCode cpp"><span class="kw">override</span></code> and <code class="sourceCode cpp"><span class="kw">final</span></code> keywords on member functions to generate compiler diagnostics when overriding is accidental</p></li>
<li><p>Use the ‘= delete’ construct to prevent a member function from being called due to an inheritance.</p></li>
<li><p>If any class invariant depends upon a value of a data member, then make that member private</p></li>
<li><p>Make data members private and provide a public interface to access them that preserves class invariants</p></li>
<li><p>Provide complete documentation of all encapsulated data, and how each method affects that data for each object in the hierarchy.</p></li>
<li><p>Inherit only from trusted sources, and, whenever possible, check the version of the parent classes during compilation and/or initialization.</p></li>
<li><p>Provide a member function that provides versioning information for each class.</p></li>
<li><p>Prohibit the use of public inheritance for “has-a” relationships. Use composition instead for “has-a”-relationships.</p></li>
<li><p>Delegate assigning and moving of the parent’s data components by calling the corresponding operation of the parent type. You must delegate in particular when the parent has data components not visible to methods of the subclass. Alternatively, prohibit assignment and motion for classes intended to be base types. <em>(clarify – this has 2 possible meanings)</em></p></li>
<li><p>Avoid the creation of base classes that are both virtual and non-virtual in the same hierarchy.</p></li>
</ul>
<h2 id="violations-of-the-liskov-substitution-principle-or-the-contract-model-blp">6.42 Violations of the Liskov Substitution Principle or the Contract Model [BLP]</h2>
<h3 id="applicability-to-language">6.42.1 Applicability to language</h3>
<p>This vulnerability applies to C++ . It can be mitigated by a style of programming that uses wrapper functions to check preconditions, calls a virtual function to perform the required functionality and subsequently checks the postconditions before returning. An example is provided below.</p>
<div class="sourceCode" id="cb214"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Base  {</span>
<span id="cb214-2"><a href="#cb214-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">private</span>:</span>
<span id="cb214-3"><a href="#cb214-3" aria-hidden="true" tabindex="-1"></a>     <span class="kw">virtual</span> <span class="dt">int</span> function_to_override( <span class="dt">int</span> x ) = <span class="dv">0</span>;</span>
<span id="cb214-4"><a href="#cb214-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">// ...</span></span>
<span id="cb214-5"><a href="#cb214-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-6"><a href="#cb214-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span>:</span>
<span id="cb214-7"><a href="#cb214-7" aria-hidden="true" tabindex="-1"></a>     <span class="dt">int</span> interface_to_overridden_function( <span class="dt">int</span> x ) {</span>
<span id="cb214-8"><a href="#cb214-8" aria-hidden="true" tabindex="-1"></a>           check_preconditions( x );</span>
<span id="cb214-9"><a href="#cb214-9" aria-hidden="true" tabindex="-1"></a>           <span class="at">const</span> <span class="kw">auto</span> saved = data_saved_for_postcondition( x );</span>
<span id="cb214-10"><a href="#cb214-10" aria-hidden="true" tabindex="-1"></a>           <span class="kw">auto</span> result = function_to_override( x );</span>
<span id="cb214-11"><a href="#cb214-11" aria-hidden="true" tabindex="-1"></a>           check_postconditions( x, saved, result );</span>
<span id="cb214-12"><a href="#cb214-12" aria-hidden="true" tabindex="-1"></a>           <span class="cf">return</span> result;</span>
<span id="cb214-13"><a href="#cb214-13" aria-hidden="true" tabindex="-1"></a>         }</span>
<span id="cb214-14"><a href="#cb214-14" aria-hidden="true" tabindex="-1"></a>     <span class="co">// ...      </span></span>
<span id="cb214-15"><a href="#cb214-15" aria-hidden="true" tabindex="-1"></a> };</span></code></pre></div>
<h3 id="guidance-to-language-users">6.42.2 Guidance to language users</h3>
<ul>
<li><p>Obey all preconditions and postconditions of each member function, whether they are specified in the language or not.</p></li>
<li><p>Prohibit the strengthening of preconditions (specified or not) by overriding member functions.</p></li>
<li><p>Prohibit the weakening of postconditions (specified or not) by overriding member functions.</p></li>
<li><p>Prohibit the use of public inheritance for “has-a” relationships. Use composition for “has-a”-relationships instead.</p></li>
<li><p>Use static analysis tools that identify misuse of inheritance in the contract model.</p></li>
<li><p>Ensure that all invariants of a derived class are preserved by all public operations on its public base classes. If this cannot be ensured, make the base class private, or avoid inheritance.</p></li>
</ul>
<blockquote>
<p>See also C++ Core Guidelines C.120, C.121, C.122, C.126, C.127, and C.129 through C.133.</p>
</blockquote>
<h2 id="redispatching-pph">6.43 Redispatching [PPH]</h2>
<h3 id="applicability-to-language">6.43.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.43 exists in C++ for virtual functions, except for constructors and destructors which are not dispatching. An example of the infinite recursion is:</p>
<div class="sourceCode" id="cb215"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb215-3"><a href="#cb215-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A {</span>
<span id="cb215-4"><a href="#cb215-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb215-5"><a href="#cb215-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A::f()</span><span class="sc">\n</span><span class="st">&quot;</span>; }</span>
<span id="cb215-6"><a href="#cb215-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> g() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A::g()</span><span class="sc">\n</span><span class="st">&quot;</span>; A::f(); }  <span class="co">//call to f() will not dispatch.</span></span>
<span id="cb215-7"><a href="#cb215-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> h() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A::h()</span><span class="sc">\n</span><span class="st">&quot;</span>; }</span>
<span id="cb215-8"><a href="#cb215-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> i() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A::i()</span><span class="sc">\n</span><span class="st">&quot;</span>; h(); } <span class="co">//call to h() will dispatch</span></span>
<span id="cb215-9"><a href="#cb215-9" aria-hidden="true" tabindex="-1"></a>                                                      <span class="co">//showing the vulnerability</span></span>
<span id="cb215-10"><a href="#cb215-10" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb215-11"><a href="#cb215-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb215-12"><a href="#cb215-12" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B : <span class="kw">public</span> A {</span>
<span id="cb215-13"><a href="#cb215-13" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb215-14"><a href="#cb215-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f() <span class="kw">override</span> { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;B::f()</span><span class="sc">\n</span><span class="st">&quot;</span>; g(); }</span>
<span id="cb215-15"><a href="#cb215-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> h() <span class="kw">override</span> { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;B::h()</span><span class="sc">\n</span><span class="st">&quot;</span>; i(); }</span>
<span id="cb215-16"><a href="#cb215-16" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb215-17"><a href="#cb215-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb215-18"><a href="#cb215-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main() {</span>
<span id="cb215-19"><a href="#cb215-19" aria-hidden="true" tabindex="-1"></a>    B b;</span>
<span id="cb215-20"><a href="#cb215-20" aria-hidden="true" tabindex="-1"></a>    A * pA = &amp;b;</span>
<span id="cb215-21"><a href="#cb215-21" aria-hidden="true" tabindex="-1"></a>    pA-&gt;f(); <span class="co">// no problem</span></span>
<span id="cb215-22"><a href="#cb215-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;---</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb215-23"><a href="#cb215-23" aria-hidden="true" tabindex="-1"></a>    pA-&gt;h(); <span class="co">// infinite recursion</span></span>
<span id="cb215-24"><a href="#cb215-24" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p><em>Overriding -</em> <em>Private virtual functions can be overridden - AI – Paul – write up. May be a namespace issues or a Beaujolais issue.</em></p>
<p>In C++, the call to a member function can be qualified, as shown in the above example, and avoids the vulnerability.</p>
<h3 id="guidance-to-language-users">6.43.2 Guidance to language users</h3>
<ul>
<li><p>At a call site, consider whether virtual dispatch is desired. If not, construct the call using the qualified name.</p></li>
<li><p>Be suspicious of any call from a virtual member function of the derived class to any member function of any of its base classes.</p></li>
</ul>
<h2 id="polymorphic-variables-bkk">6.44 Polymorphic variables [BKK]</h2>
<h3 id="applicability-to-language">6.44.1 Applicability to language</h3>
<p>This vulnerability as described in ISO/IEC TR 24772-1:2019 applies to C++. In addition to the upcast and downcast issues addressed in that document, this clause also addresses cross-casting, which is unique to C++.</p>
<p>C++ provides language mitigations to help avoid the problems as follows:</p>
<p>Since C++ supports multiple inheritance, up-casting, down-casting, and cross-casting operations can be used to switch to different (pointer/reference) types in the inheritance hierarchy of a specific object, i.e.,</p>
<ul>
<li><p>up-casting is casting an object to an ancestor type in the object's type inheritance hierarchy.</p></li>
<li><p>down-casting is casting an object to a descendent type in the object's type inheritance hierarchy, and,</p></li>
<li><p>cross-casting is casting an object to a sibling/cousin (possibly removed) type in the object's type inheritance hierarchy.</p></li>
<li><p>Unsafe casts, which include C-style casts and <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>, can cast to unrelated arbitrarily structured types. This allows reading and modifying arbitrary memory areas. See subclause <a href="#_6.11_Pointer_type_1"><span data-custom-style="Hyperlink">6.11 Pointer Casting and Pointer Type Changes</span></a> [HFC] for more details.</p></li>
</ul>
<blockquote>
<p>Developers should be aware that virtual member functions can be overridden in derived classes, even if they are private.</p>
</blockquote>
<p>Given the following:</p>
<div class="sourceCode" id="cb216"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Z { <span class="dt">int</span> z; <span class="kw">virtual</span> ~Z() { } };</span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Y { <span class="dt">int</span> y; <span class="kw">virtual</span> ~Y() { } };</span>
<span id="cb216-3"><a href="#cb216-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A : Z { <span class="dt">int</span> a; };</span>
<span id="cb216-4"><a href="#cb216-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> B : <span class="kw">virtual</span> A { <span class="dt">int</span> b; };</span>
<span id="cb216-5"><a href="#cb216-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> C : <span class="kw">virtual</span> A, Y { <span class="dt">int</span> c; };</span>
<span id="cb216-6"><a href="#cb216-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> D : B, C { <span class="dt">int</span> d; };</span>
<span id="cb216-7"><a href="#cb216-7" aria-hidden="true" tabindex="-1"></a>D d_inst;</span></code></pre></div>
<p>then these examples demonstrate upcasts, downcasts, and crosscasts:</p>
<p><strong>Upcasts:</strong></p>
<div class="sourceCode" id="cb217"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a>B* b_ptr = &amp;d_inst; <span class="co">// implicit</span></span>
<span id="cb217-2"><a href="#cb217-2" aria-hidden="true" tabindex="-1"></a>C&amp; c_ref = d_inst; <span class="co">// implicit</span></span>
<span id="cb217-3"><a href="#cb217-3" aria-hidden="true" tabindex="-1"></a>Z* z_ptr = <span class="kw">static_cast</span>&lt;Z*&gt;(&amp;d_inst);</span>
<span id="cb217-4"><a href="#cb217-4" aria-hidden="true" tabindex="-1"></a>Y* y_ptr = <span class="kw">dynamic_cast</span>&lt;Y*&gt;(&amp;d_inst);</span></code></pre></div>
<p><strong>Downcasts:</strong></p>
<div class="sourceCode" id="cb218"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a>D&amp; d_ref = <span class="kw">dynamic_cast</span>&lt;D&amp;&gt;(*y_ptr);</span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true" tabindex="-1"></a>D* d_ptr = <span class="kw">static_cast</span>&lt;D*&gt;(b_ptr);</span></code></pre></div>
<p><strong>Crosscasts:</strong></p>
<div class="sourceCode" id="cb219"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a>C* c_ptr = <span class="kw">dynamic_cast</span>&lt;C*&gt;(b_ptr);</span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a>Y* y_ptr2 = <span class="kw">dynamic_cast</span>&lt;Y*&gt;(b_ptr);</span>
<span id="cb219-3"><a href="#cb219-3" aria-hidden="true" tabindex="-1"></a>C* c_ptr = <span class="kw">static_cast</span>&lt;C*&gt; (<span class="kw">static_cast</span>&lt;D*&gt;(b_ptr));</span></code></pre></div>
<p>and notes the following about such:</p>
<p>Upcasts:</p>
<ul>
<li><p>are the only ones that can be performed implicitly</p></li>
<li><p>can also be done with <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> or <code class="sourceCode cpp"><span class="kw">static_cast</span></code></p></li>
</ul>
<p>Downcasts</p>
<ul>
<li><p>are explicit;</p></li>
<li><p>can be done safely with <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code></p></li>
<li><p><code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> requires appropriate portions of inheritance to be polymorphic (i.e. has <code class="sourceCode cpp"><span class="kw">virtual</span></code> members);</p></li>
<li><p>can be done using <code class="sourceCode cpp"><span class="kw">static_cast</span></code> which is unchecked and may be unsafe;</p></li>
</ul>
<p>Crosscasts:</p>
<ul>
<li><p>are explicit</p></li>
<li><p>can be done safely with a single call to <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> which requires appropriate portions of inheritance to be polymorphic (i.e. has <code class="sourceCode cpp"><span class="kw">virtual</span></code> members).</p></li>
<li><p>can often be done with a chain of <code class="sourceCode cpp">static_casts</code> traversing the inheritance hierarchy, which is almost always unsafe.</p></li>
</ul>
<h3 id="guidance-to-language-users">6.44.2 Guidance to language users</h3>
<ul>
<li><p>Follow the advice provided in ISO/IEC TR 24772-1 :2019clause 6.44.5.</p></li>
<li><p>If an upcast is needed, prefer using implicit conversion, since an explicit upcast adds unnecessary complexity for the reader.</p></li>
<li><p>If a downcast or a crosscast is needed, prefer using <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> since it is checked.</p></li>
<li><p>Ensure that all invariants of a derived class are preserved by all public operations on its public base classes. If this cannot be ensured, make the base class private, or avoid inheritance.</p></li>
<li><p>Do not attempt to navigate class hierarchies using C-style casts or <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>.</p></li>
<li><p>For any class that implements a virtual member function, consider marking that member function final in the definition of that class.</p></li>
</ul>
<blockquote>
<p>NOTE: This forbids any derived class from redefining the implementation and thereby precludes ambiguity, regardless of whether a call is qualified or not.</p>
</blockquote>
<blockquote>
<p>NOTE: Making instead the class final contradicts C++ Core Guideline C.139, so is not recommended here.</p>
</blockquote>
<ul>
<li>Consider declaring virtual methods with protected or private visibility to preclude code from outside of the class hierarchy calling any specific implementation directly.</li>
</ul>
<blockquote>
<p>NOTE: This assumes that within the class hierarchy any qualified call is intentional and is the pattern of a non-public virtual interface.</p>
</blockquote>
<ul>
<li>OOP52-CPP. Do not delete a polymorphic object without a virtual destructor (-&gt;6.44)</li>
</ul>
<blockquote>
<p>See also C++ Core Guidelines ES.48, ES.49, C.146, C.147, C.148 and C.153.</p>
</blockquote>
<h2 id="extra-intrinsics-lrm">6.45 Extra Intrinsics [LRM]</h2>
<p>This vulnerability does not apply to C++ for the following reasons:</p>
<ul>
<li>When adding intrinsics, implementors are required to follow a specific name pattern that users are not allowed to use in definitions. See C++ standard clause 5.10 [Lex.name].</li>
</ul>
<p>Operations for swap, sin, cos, conversions float &lt;-&gt; double, saturation,</p>
<h2 id="argument-passing-to-library-functions-trj">6.46 Argument Passing to Library Functions [TRJ]</h2>
<h3 id="applicability-to-language">6.46.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.46 is applicable to C++.</p>
<p>Libraries that supply objects or functions are in most cases not required to check the validity of parameters passed to them. In those cases where parameter validation is required there might not be adequate parameter validation.</p>
<p>When calling a library, either the calling function or the library may make assumptions about parameters. For example, it may be assumed by a library that a parameter is non-zero so division by that parameter is performed without checking the value. Sometimes some validation is performed by the calling function, but the library may use the parameters in ways that were unanticipated by the calling function resulting in a potential vulnerability. Even when libraries do validate parameters, their response to an invalid parameter is usually undefined and can cause unanticipated results.</p>
<p>This vulnerability applies in particular to C++ libraries which are designed for high efficiency; responsibility for satisfying the preconditions for most functions rests with the caller. When these preconditions are not met, the result will be undefined behaviour. In addition, error conditions are specified by the language for specific functions, such as raising an exception, returning an error code or a known value, such as NaN.</p>
<h3 id="guidance-to-language-users">6.46.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1 clause 6.47.5.</p></li>
<li><p>Use translation modes provided the implementation to perform addition analysis or checking, such as contracts checks, or instrumentation of executing code.</p></li>
<li><p>Pay attention to the distinction between precondition violation and error conditions in library documentation. The former results in undefined behaviour; the latter results in defined but possibly unwanted behaviour.</p></li>
</ul>
<h2 id="inter-language-calling-djs">6.47 Inter-language Calling [DJS]</h2>
<h3 id="applicability-to-language">6.47.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.47 is applicable to C++.</p>
<p>C++ is a multi-paradigm language with a number of features that do not interface simply with other language systems. It is left to the implementation team the task of converting the results of these paradigms to constructs that can cross an interface for further processing in other languages.</p>
<p>C++ compilers provide an application binary interface (ABI) that delineates areas of interoperability with other languages or other C++ compiler/runtime systems. An ABI includes calling conventions, data layout, error and exception handling and return conventions, name mangling, data model, initialization of memory, and linkage to operating systems and libraries.</p>
<p>C++ compilers implement a C++ language linkage and a C language linkage. It is implementation-defined what other languages the implementation supports. Alternatively, other language systems provide linkages to C systems[^3](Ada has developed a standard for interfacing with C. Fortran has included a Clause 15 that explains how to call C functions.), leaving the developer the task of channeling everything through this common language system.</p>
<h3 id="guidance-to-language-users">6.47.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance contained in ISO/IEC TR 24772-1:2019 clause 6.47.5</p></li>
<li><p>Use standard layout types for the interoperable interfaces.</p>
<ul>
<li><pre><code>  Use language linkage facilities that support the languages being</code></pre>
<p>used.</p></li>
<li><pre><code>  EXP56-CPP. Do not call a function with a mismatched language</code></pre>
<p>linkage (-&gt; 6.47)</p></li>
<li><pre><code>  EXP60-CPP. Do not pass a nonstandard-layout type object across</code></pre>
<p>(-&gt; 6.47 ?)<br />
execution boundaries</p></li>
</ul></li>
<li><p>Be aware that the static initialization phase and dynamic initialization for every language system are required before the system begins execution</p></li>
<li><p>Be aware that C++ exceptions are not usually compatible with exceptions in other languages.</p></li>
<li><p>Segregate outgoing cross-language interfacing code into functions that present a C++ interface to the C++ code and implements that interface by calling code compatible with the other language system. Similarly implement incoming cross-language interfaces by providing simplified functions that presents a simplified (C or other language) interface and is implemented by calling C++ code with the correct style.</p></li>
<li><p>Separate the interfacing code from the code containing the main functionality</p></li>
</ul>
<p>See also the C++ Core Guidelines CPL.3.</p>
<p><em>AI 63-6 – group – add the guidance from 6.47.2 Interoperability into the Core Guidelines.</em></p>
<h2 id="dynamically-linked-code-and-self-modifying-code-nyy">6.48 Dynamically-linked Code and Self-modifying Code [NYY]</h2>
<h3 id="applicability-to-language">6.48.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.48 is applicable to C++.</p>
<h3 id="guidance-to-language-users">6.48.2 Guidance to language users</h3>
<p>Follow the guidance of ISO/IEC TR 24772-1:2019 clause 6.48.5.</p>
<h2 id="library-signature-nsq">6.49 Library Signature [NSQ]</h2>
<h3 id="applicability-to-language">6.49.1 Applicability to language</h3>
<p>The vulnerability as enumerated in ISO/IEC TR 24772-1:2019 clause 6.49 applies to C++.</p>
<p>As a mitigation, the C++ ‘<code class="sourceCode cpp"><span class="at">extern</span> <span class="st">&quot;C&quot;</span></code>’ linkage specifier usually provides simple interoperability with libraries using the C application binary interface (ABI).</p>
<h3 id="guidance-to-language-users">6.49.2 Guidance to language users</h3>
<p>From Part 1, 6.49.5</p>
<ul>
<li><p>Follow the guidance of ISO/IEC TR 24772-1:2019 clause 6.49.5.</p></li>
<li><p>Follow the advice of clause 6.47.2 as applicable.</p></li>
</ul>
<h2 id="unanticipated-exceptions-from-library-routines-hjw">6.50. Unanticipated Exceptions from Library Routines [HJW]</h2>
<h3 id="applicability-to-language">6.50.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 clause 6.50 exists for C++. In particular the issue of the failing dynamic initialization of namespace-scope objects exists in C++.</p>
<p>When dynamic initialization of a namespace-scope object fails with an exception, the exception cannot be caught and the program is terminated. Function-scope static objects, in contrast, are initialized the first time execution passes through the declaration. Using function-scope static objects in preference to dynamic initialization ensures that there is always an enclosing function that could catch the exception.</p>
<div class="sourceCode" id="cb223"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true" tabindex="-1"></a><span class="dt">exception_prone_type</span> troubling_object;</span>
<span id="cb223-2"><a href="#cb223-2" aria-hidden="true" tabindex="-1"></a><span class="co">// An exception from the constructor could cause termination.</span></span>
<span id="cb223-3"><a href="#cb223-3" aria-hidden="true" tabindex="-1"></a><span class="co">// The following function always returns a reference to the same object,</span></span>
<span id="cb223-4"><a href="#cb223-4" aria-hidden="true" tabindex="-1"></a><span class="co">// which is initialized the first time this function is called.</span></span>
<span id="cb223-5"><a href="#cb223-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-6"><a href="#cb223-6" aria-hidden="true" tabindex="-1"></a><span class="co">// If initialization fails, it will be retried on the next call.</span></span>
<span id="cb223-7"><a href="#cb223-7" aria-hidden="true" tabindex="-1"></a><span class="dt">exception_prone_type</span>&amp; safer_object()</span>
<span id="cb223-8"><a href="#cb223-8" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb223-9"><a href="#cb223-9" aria-hidden="true" tabindex="-1"></a>   <span class="at">static</span> <span class="dt">exception_prone_type</span> the_safer_object;</span>
<span id="cb223-10"><a href="#cb223-10" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> the_safer_object;</span>
<span id="cb223-11"><a href="#cb223-11" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<h3 id="guidance-to-language-users">6.50.2 Guidance to language users</h3>
<ul>
<li><p>Expect functions not marked <code class="sourceCode cpp"><span class="kw">noexcept</span></code> to throw exceptions of arbitrary type. Note that all destructors are implicitly <code class="sourceCode cpp"><span class="kw">noexcept</span></code>.</p></li>
<li><p>Follow the advice of clause 6.36.2 for catching and handling exceptions.</p></li>
<li><p>Prefer function-scope static objects to namespace-scope objects for objects needing dynamic initialization.</p></li>
</ul>
<h2 id="pre-processor-directives-nmp">6.51 Pre-processor Directives [NMP]</h2>
<h3 id="applicability-to-language">6.51.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.51 applies to C++.</p>
<p>The C++ pre-processor allows the use of macros that are text-replaced before compilation.</p>
<p>Function-like macros look similar to functions but have different semantics. Because the arguments are text-replaced, expressions passed to a function-like macro may be evaluated multiple times. This can result in unintended and undefined behaviour if the arguments have side effects or are pre-processor directives. Additionally, the arguments and body of function-like macros should be fully parenthesized to avoid unintended and undefined behaviour.</p>
<p>The following code example demonstrates undefined behaviour when a function-like macro is called with arguments that have side-effects (in this case, the increment operator) .</p>
<div class="sourceCode" id="cb224"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CUBE</span>(X)<span class="pp"> </span>((X)<span class="pp"> </span><span class="er">\</span>*<span class="pp"> </span>(X)<span class="pp"> </span><span class="er">\</span>*<span class="pp"> </span>(X))</span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb224-3"><a href="#cb224-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i = <span class="dv">2</span>;</span>
<span id="cb224-4"><a href="#cb224-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a = <span class="dv">81</span> / CUBE(++i);</span></code></pre></div>
<p>The above example could expand to:</p>
<div class="sourceCode" id="cb225"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a = <span class="dv">81</span> / ((++i) * (++i) * (++i));</span></code></pre></div>
<p>which has undefined behaviour so this macro expansion is difficult to predict.</p>
<p>Another mechanism of failure can occur when the arguments within the body of a function-like macro are not fully parenthesized. The following example shows the CUBE macro without parenthesized arguments.</p>
<div class="sourceCode" id="cb226"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CUBE</span>(X)<span class="pp"> </span>(X<span class="pp"> </span><span class="er">\</span>*<span class="pp"> </span>X<span class="pp"> </span><span class="er">\</span>*<span class="pp"> </span>X)</span>
<span id="cb226-2"><a href="#cb226-2" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb226-3"><a href="#cb226-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a = CUBE(<span class="dv">2</span> + <span class="dv">1</span>);</span></code></pre></div>
<p>This example expands to:</p>
<div class="sourceCode" id="cb227"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a = (<span class="dv">2</span> + <span class="dv">1</span> * <span class="dv">2</span> + <span class="dv">1</span> * <span class="dv">2</span> + <span class="dv">1</span>)</span></code></pre></div>
<p>which evaluates to 7 instead of the intended 27.</p>
<h3 id="guidance-to-language-users">6.51.2 Guidance to language users</h3>
<ul>
<li><p>Replace function-like macros with <code class="sourceCode cpp"><span class="kw">constexpr</span></code> inline functions where possible.</p></li>
<li><p>Replace normal macros with <code class="sourceCode cpp"><span class="kw">constexpr</span></code> variables where possible.</p></li>
<li><p>Replace conditional compilation with the preprocessor with <code class="sourceCode cpp"><span class="cf">if</span> <span class="kw">constexpr</span></code> where possible, e.g., in function bodies. This includes cases, where compile-time define of a macro (as empty) controls if a macro definition is used to expand to an empty statement or another statement.</p></li>
<li><p>Replace preprocessor include directives with module <code class="sourceCode cpp"><span class="kw">import</span></code> where possible.</p></li>
<li><p>Prefer <code class="sourceCode cpp"><span class="bu">std::</span>source_location</code> mechanisms over employing macros that use <code class="sourceCode cpp"><span class="ot">__LINE__</span></code>, <code class="sourceCode cpp"><span class="ot">__FILE__</span></code>, or <code class="sourceCode cpp"><span class="ot">__func__</span></code>.</p></li>
<li><p>If a function-like macro must be used, ensure that its parameters and body are parenthesized.</p></li>
<li><p>In a function-like macro, ensure that each argument is evaluated at most once.</p></li>
<li><p>Do not embed pre-processor directives or side-effects such as an assignment, increment/decrement, volatile access, or function call in a function-like macro.</p></li>
<li><p>Macros should only be used for <em>include guards</em>, to control conditional compilation, or when the macro’s definition requires token pasting (<code>##</code>.{.cpp}) or stringification (<code class="sourceCode cpp"><span class="er">#</span></code>) of macro arguments.</p></li>
<li><p>Macro paramters that are used as argument for <code class="sourceCode cpp"><span class="pp">#</span><span class="er">#</span></code> or <code class="sourceCode cpp"><span class="er">#</span></code> should not be used otherwise in the macro.</p></li>
</ul>
<h2 id="suppression-of-language-defined-run-time-checking-mxb">6.52 Suppression of Language-defined Run-time Checking [MXB]</h2>
<h3 id="applicability-to-language">6.52.1 Applicability to language</h3>
<p>With the exception of the macro <code>assert</code>, the vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.52 does not apply to C++, because there is no language-defined runtime checking. Macro assert is defined by the standard but is invoked by the programmer, hence is not a language-defined check.</p>
<p>C++ libraries, however, often provide run-time checks which meet the criteria of this vulnerability. Also, compilers and other tools commonly provide means to perform such runtime checks.</p>
<h3 id="guidance-to-language-users">6.51.2 Guidance to language users</h3>
<p>Follow the advice provided in ISO/IEC TR 24772-1:2019 clause 6.52.5 with respect to library and compiler-provided checks. Note that this will almost always require explicitly enabling the checks.</p>
<h2 id="provision-of-inherently-unsafe-operations-skl">6.53 Provision of Inherently Unsafe Operations [SKL]</h2>
<h3 id="applicability-to-language">6.53.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.53 applies to C++. In particular, anything described by ISO/IEC 14882:2017 as “undefined behaviour” is unsafe.</p>
<h3 id="guidance-to-language-users">6.53.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1:2019 clause 6.53.5.</p></li>
<li><p>Enable checks that warn about unsafe operations.</p></li>
<li><p>Use static analysis tools to detect unsafe constructs.</p></li>
</ul>
<h2 id="obscure-language-features-brs">6.54 Obscure Language Features [BRS]</h2>
<h3 id="applicability-of-language">6.54.1 Applicability of language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.54 applies to C++.</p>
<p>C++ is a rich language and provides facilities for a wide range of application areas. Because some areas are specialized, it is possible that a programmer not versed in a special area can misuse features for that area.</p>
<h3 id="guidance-to-language-users">6.54.2 Guidance to language users</h3>
<ul>
<li>Follow the guidelines of ISO/IEC TR 24772-1:2019 clause 6.54.5.</li>
</ul>
<p>$incldue 6.55.UnspecifiedBehaviour-BQF.md</p>
<h2 id="undefined-behaviour-ewf">6.56 Undefined Behaviour [EWF]</h2>
<h3 id="applicability-to-language">6.56.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.56 applies to C++. In ISO/IEC 14882:2017, the terms “undefined behaviour” and “ill-formed, no diagnostic required” expose situations to be avoided.</p>
<h3 id="guidance-to-language-users">6.56.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1:2019 clause 6.56.5.</p></li>
<li><p>Augment static analysis tool usage with runtime tools such as ASAN (address sanitizer) and related tools.</p></li>
<li><p>Use static analysis tools to help identify occurrences of undefined behaviour.</p></li>
<li><p>Use multiple compilers/tools and different optimization levels to increase your chance of identifying constructs that have undefined behaviours.</p></li>
<li><p>Where the language provides defined behaviour mechanisms and undefined behaviour mechanisms, ensure that you use the ones with defined behaviours. Note: This document is dedicated to explaining these issues.</p></li>
<li></li>
</ul>
<h2 id="implementationdefined-behaviour-fab">6.57 Implementation–defined Behaviour [FAB]</h2>
<h3 id="applicability-to-language">6.57.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.57 applies to C++. In ISO/IEC 14882, the term “implementation-defined” is used to describe implementation-defined behaviour. In addition, the C++ standard provides a dedicated index titled, “Index of implementation-defined behavior”.</p>
<h3 id="guidance-to-language-users">6.57.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1:2019 clause 6.57.5.</p></li>
<li><p>Eliminate to the extent possible any reliance on implementation-defined behaviour from programs in order to increase portability. Even programs that are specifically intended for a particular implementation may in the future be ported to another environment or sections reused for future implementations.</p></li>
<li><p>Use multiple compilers/tools to increase your chance of identifying constructs that have implementation-defined behaviours.</p></li>
<li><p>Refer to “Index of implementation-defined behavior” for the definitive list of C++ implementation-defined behaviours and understand the relevant compiler documentation for each of these behaviours.</p></li>
</ul>
<h2 id="deprecated-language-features-mem">6.58 Deprecated Language Features [MEM]</h2>
<h3 id="applicability-to-language">6.58.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1 clause 6.58 applies to C++. Appendix D “Compatibility features” of ISO/IEC 14882:2020(???) enumerates the deprecated features. The C++ attribute <code class="sourceCode cpp">[[<span class="at">deprecated</span>]]</code> allows library writers and users to mark deprecated declarations.</p>
<p>Although backward compatibility is sometimes offered as an option for compilers so one can avoid changes to code to be compliant with current language specifications, updating the legacy software to the current standard is a better option.</p>
<h3 id="guidance-to-language-users">6.58.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1 clause 6.58.5.</p></li>
<li><p>Enable compiler options or static analysis tools that identify the use of deprecated features.</p></li>
<li><p>Apply the <code class="sourceCode cpp">[[<span class="at">deprecated </span>(<span class="st">&quot;*reason*&quot;</span>)]]</code> attribute to obsolete declarations that exist only for backward compatibility.</p></li>
</ul>
<h2 id="concurrency-activation-cga">6.59 Concurrency – Activation [CGA]</h2>
<h3 id="applicability-to-language">6.59.1 Applicability to language</h3>
<p>This vulnerability does not apply to C++, as long as the standard library facilities for creating threads are used.</p>
<p>Creating a thread using <code class="sourceCode cpp"><span class="bu">std::</span>thread</code> or <code class="sourceCode cpp"><span class="bu">std::</span>jthread</code> is synchronized with the thread creation site.</p>
<p>Other vulnerabilities can be created when creating a thread object:</p>
<ul>
<li>6.61 Concurrent Data Access,</li>
<li>6.14 and 6.33 dangling of data reference, if data is passed to the thread function as reference or pointer, instead of passing a copy.</li>
<li>6.36 undhandle exception leading to premature termination of the program, if the thread object is destroyed and the spawned thread is neither joined nor detached. Creating a new thread through <code class="sourceCode cpp"><span class="bu">std::</span>async</code> will implicitly join.</li>
</ul>
<h3 id="guidance-to-language-users">6.59.2 Guidance to language users</h3>
<ul>
<li><p>If you are using a non-standard thread facilities, e.g., by making use of <code>std::thread::native_handle</code> follow the guidelines of TR 24772-1 clause 6.60.5.</p></li>
<li><p>Use <code class="sourceCode cpp"><span class="bu">std::</span>jthread</code> for thread creation, or always <code>.join()</code> or <code>.detach()</code> a created <code>std::thread</code>.</p></li>
<li><p>Pass all thread function arguments by value, or ensure their lifetime outlasts the running thread. In the latter case proper synchronization is required.</p></li>
</ul>
<h2 id="concurrency-directed-termination-cgt">6.60 Concurrency – Directed termination [CGT]</h2>
<h3 id="applicability-to-language">6.60.1 Applicability to language</h3>
<p>What about tasks? Explain std::function A functor is a class that can be called like a throw-away parallel object. Can also use in lambda expressions. The creating thread can only retrieve results by using a shared variable or using explicit thread calls to</p>
<p>A thread in C++ runs until completion, either a normal completion or as the result of an unhandled exception. There is no mechanism in the language to terminate another thread. If the threading model is POSIX or some other underlying paradigm, the underlying threading service calls can be used to terminate a thread.</p>
<p>C++ threads use a fork-join model. This means that the initiating thread will wait for the completion of the initiated thread at the join place at the end of the scope that created the initiated thread if a call to join the terminating thread has been made; otherwise the initiating task will have no indication of when the created thread completes.</p>
<p>Programmed mechanisms can be constructed to cause another thread to complete or to raise an exception, such as setting a shared variable to a known state that the target thread reads and then terminates itself.</p>
<p>Are there any language-defined ways to check on the progress of a thread or know if it is executable? Can always use underlying mechanism where available. Future mechanism provides for communication with the spawned thread to know if it terminated returning a value or returning an exception.</p>
<h2 id="guidance-to-language-users">6.60.2 Guidance to language users</h2>
<p>Follow the guidance of 24772-1 Clause 6.59.5</p>
<h2 id="concurrent-data-access-cgx">6.61 Concurrent Data Access [CGX]</h2>
<h3 id="applicability-to-language">6.61.1 Applicability to language</h3>
<p>C++ has threading and shared access to variables which have the vulnerabilities described in ISO/IEC TR 24772-1:2019 clause 6.61.1. C++ provides features such as atomic (type template) that guarantee the internal consistency of the data and to prevent corruption of data due to potentially interleaved updates to data elements.</p>
<p>What about concurrent data access between tasks?</p>
<p>Programmers should be aware that conversions or manipulations of data items are not always atomic, such as the conversion of an object as part of a computation</p>
<p><em>Need the C++ definition of atomic (indivisible access and memory ordering)</em></p>
<p><em>and volatile.</em></p>
<p>The C++ <span data-custom-style="typ">atomic</span> capability can be applied to any basic data type equivalent to <span data-custom-style="typ">char</span>, <span data-custom-style="typ">short</span>, <span data-custom-style="typ">int</span>, <span data-custom-style="typ">long</span>, and <span data-custom-style="typ">long</span> <span data-custom-style="typ">long</span>. When the C++ <span data-custom-style="typ">std::atomic</span> facilities are used, the language guarantees that simultaneous updates and reads to an atomic element will be well-behaved. Atomic does not guarantee the order in which competing reads and/or updates will occur. In order to manage order of access, synchronized locks are required. In order to use the atomic capabilities, each variable must be declared to be of one of the <span data-custom-style="typ">std::atomic</span> types, and the member functions used to compare, load, store or exchange values in an atomic variable.</p>
<p>We also need to move the notion of creating SHARED POINTERS FROM 6.13 TO HERE.</p>
<p>A volatile qualifier on a variable is used to indicate that updates to the variable may happen at any time and outside of program control, hence two subsequent reads on such a variable may return different results.</p>
<p>Programmers should be aware that even simple data accesses on modern architectures can involve instruction reordering, cache issues, and data alignment issues, hence the acquisition time and order are highly nondeterministic, especially when being accessed by concurrent threads. Any data structure that can be shared between threads should be shown to be accessed by at most one thread at a time or should be protected by synchronization mechanisms such as locks (see 6.63) or atomicity.</p>
<p>Most concurrent programming algorithms require some level of synchronization between threads or tasks when exchanging information, synchronization that “<span data-custom-style="typ">atomic</span>” does not provide. Mechanisms such as monitors, mailboxes, or mutexes (lock with a queue), futures, condition variables, and locks control scheduling of threads or tasks to control order-of-access and to enforce higher levels of cooperation between schedulable entities<span data-custom-style="annotation reference"></span>.</p>
<p>Atomic tied to memory orders.</p>
<p>Mutexes provide mutual exclusion and guaranteed visibility (consistency) of the shared data.</p>
<p>Mutex is a lock-and-release that is usually hidden.</p>
<p>Encapsulate mutexes and data</p>
<p>Thread-level storage (official term thread_local) has lifetime of the thread. Can exist at local scope or global scope.</p>
<p>For massively parallel concurrency – concurrent access mechanisms not applicable.</p>
<p>No resource management</p>
<p>Exception and exception handling (has some impact on threading)</p>
<p>Memory management issues more complex under concurrency</p>
<p>Volatile should be used for signal handlers to prevent the optimization of replicated accesses to volatile memory. (other) and does not guarantee that the object value will be available to other threads.</p>
<p>Controlling access to shared data (protected or including</p>
<p>Use of volatile (keyword type qualifier) for signal handlers (communicating with hardware?). Prefer volatile for communicating with hardware?</p>
<h3 id="guidance-to-language-users">6.61.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance of ISO/IEC TR 24772-1 clause 6.62.5.</p></li>
<li><p>Use mutexes, condition variables (convar) in preference to atomic variables to protect data from simultaneous access.</p></li>
<li><p>Use volatile only for synchronizing abstract machine state from memory.</p></li>
<li><p>Avoid the use of volatile for synchronizing access to shared memory between threads (which needs mutex, condvar, or atomics)</p>
<ul>
<li><pre><code>  See C++ Core guidelines CP.8, CP.200,</code></pre>
CP.111,<span data-custom-style="annotation reference"></span></li>
</ul></li>
<li><p>Avoid relaxed atomic operations whenever possible. Prefer the sequentially consistent std::memory_order_seq_cst instead .</p></li>
<li><p>Use mutexes appropriately to protect accesses to non-atomic shared objects.</p></li>
</ul>
<h2 id="concurrency-premature-termination-cgs">6.62 Concurrency – Premature Termination [CGS]</h2>
<h3 id="applicability-to-language">6.62.1 Applicability to language</h3>
<h3 id="section"></h3>
<p>A thread will terminate when it completes its assigned method, or when it raises an exception, or when it has been explicitly terminated (how is this done)</p>
<p>Joining a thread causes the joining thread to await the joined thread’s termination before continue. Useful for executing in parallel and then proceeding after the dispatched work is complete, but does not notify the joining task if the termination was premature.</p>
<p>In C++ 2020, methods are provided to instruct one or more threads to terminate. This is not premature termination since the requested thread terminates itself.</p>
<p>C++ 2020 provides callbacks in the form of stop_callback to notify the setting thread when a thread of interest has been terminated. It also provides stop_token for a thread to query it is being instructed to terminate.</p>
<p>Any thread can re-throw an exception to be caught by the creator of the terminating thread, (but the parent may have terminated first).</p>
<p>The semantics of C++ is that all children of the main program will terminate if the main program terminates. It is necessary to join the main program to all its children to ensure that children are not silently terminated prematurely.</p>
<h3 id="guidance-to-language-users">6.62.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of TR 24772-1 clause 6.63.5.</p></li>
<li><p>Use low-level operating system primitives or other APIs where available to check that a required thread is still active.</p></li>
<li><p>Make the main program join all created threads that need to complete normally.</p></li>
</ul>
<h2 id="protocol-lock-errors-cgm">6.63 Protocol Lock Errors [CGM]</h2>
<h3 id="applicability-to-language">6.63.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1 clause 6.63 is applicable to C++.</p>
<p>This subclause requires a complete rewrite to have it reflect C++ issues.</p>
<p>Difference between threads and tasks. Can threads and tasks coexist?</p>
<p>Deadlock with single mutex,</p>
<p>The C standard does not provide hidden protocols. Although the vulnerability does not apply to the C language, there could exist an application vulnerability if a program uses synchronization mechanisms incorrectly. For example:</p>
<p>atomic int a;</p>
<p>int b;</p>
<p>/* . . . */</p>
<p>a += b; // This operation is an atomic read-modify-write of the variable ‘a’.</p>
<p>a = a + b; // This statement contains two accesses to ‘a’ and is not atomic.</p>
<h3 id="guidance-to-language-users">6.63.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of TR 24772-1 clause 6.63.5.</p></li>
<li><p>Be aware of the operation of each synchronization mechanism, such as the cases where accesses to atomic variables may occur more than once in a statement.</p></li>
<li><p>Use higher level building blocks (such as TBB) in preference to …</p></li>
<li><p>Use the C++ Task mechanism in preference to threads …</p></li>
<li><p>Always put the acquisition and release of mutexes and the data access in a wrapper function. (i.e. <em>Do not call member functions of std::mutex, std::timed_mutex, std::recursive_mutex, std::recursive_timed_mutex, std::shared_mutex and std::shared_timed_mutex objects directly.)</em></p></li>
<li><p><em>Use std::lock(), std::try_lock() or std::scoped_lock to acquire multiple mutexes in same scope. (std::lock() permits multiple mutexes at the same time).</em></p></li>
<li><p>Use std::lock() only where multiple locks must be locked together and use std::lock_guard with the std::adopt_lock argument for all mutexes (needs example) see std::lock() example on cppreference.com.</p></li>
<li><p><em>Wrap mutex locks std::lock or std::try_lock with std<strong>::</strong>lock_guard, std::unique_lock or std::shared_lock with adopt_lock tag within the same scope</em></p></li>
<li><p>If explicit locking are used, ensure that the lock is released on every exit path, including exceptions. Use lock_guard, scope_lock and unique_lock in preference to lock(), unlock(), and try_lock(),</p></li>
<li><p><strong><em>Do not use platform specific multi-threading facilities</em></strong></p></li>
<li><p><strong><em>A thread shall not access objects whose lifetime has expired</em></strong></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.kj1vcao94oy1"><u>0.4.4 [12] Do not destroy objects of the following types std::mutex, std::timed_mutex, std::recursive_mutex, std::recursive_timed_mutex, std::shared_mutex, std::shared_timed_mutex if object is in locked or shared locked state Do not destroy a mutex while it is locked</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.1kfv9jdgd8ib"><u>0.4.5 [13] Mutexes locked with std::lock or std::try_lock shall be wrapped with std::lock_guard, std::unique_lock or std::shared_lock with adopt_lock tag within the same scope Ensure actively held locks are released on exceptional conditions</u> <u>12</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.729gvquxakq8"><u>0.4.6 [14] Do not call virtual functions and callable objects passed by argument of the function within the scope of locked mutex Never call unknown code while holding a lock (e.g., a callback)</u> <u>12</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.920crsa3sscx"><u>0.4.7 [15] Avoid deadlock by locking in a predefined order</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.xufkh9tsiuk8"><u>0.4.8 [16] Objects of std::lock_guards, std::unique_locks, std::shared_lock and std::scoped_lock classes shall always be named Remember to name your lock_guards and unique_locks</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.d6qklu5mi3fn"><u>0.4.9 [17] Define a mutex together with the data it guards. Use synchronized_value&lt;T&gt; where possible</u> <u>13</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.isn3bwogdp97"><u>0.4.10 [18] Do not speculatively lock a non-recursive mutex that is already owned by the calling thread</u> <u>14</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.einwxosnxvhf"><u>0.4.11 [19] There shall be no code path which results in locking of the non-recursive mutex within the scope when this mutex is already locked Within the scope of a lock, ensure that no static path results in a lock of the same mutex</u> <u>14</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.vq776pxv4nn5"><u>0.4.12 [20] The order of nested locks unlock shall form a DAG Ensure that order of nesting of locks in a project forms a DAG</u> <u>15</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.7pf8azwmy8l4"><u>0.4.13 [21] std::recursive_mutex and std::recursive_timed_mutex should not be used Do not use std::recursive_mutex</u> <u>17</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.z9k66jbl65u6"><u>0.4.14 [22] There should be a code path, where at least one member functions is called for std::unique_lock objects Only use std::unique_lock when std::lock_guard cannot be used</u> <u>18</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.3icrgfn0r3ae"><u>0.5 Conditional variable</u> <strong><u>19</u></strong></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.g0cdm0bk7l9l"><u>0.5.1 [23] std::condition_variable::wait, std::condition_variable::wait_for, std::condition_variable::wait_until shall always be called with a condition predicate</u> <u>19</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.ul4y0p7eoih1"><u>0.5.2 [24] Wrap functions that can spuriously wake up in a loop</u> <u>20</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.13kr181fh926"><u>0.5.3 [25] std::conditional_variable::notify_one() can be used if all threads must perform the same set of operations after waking up Preserve thread safety and liveness when using condition variables</u> <u>21</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.yt0hxah53p9e"><u>0.5.4 [26] Do not use std::condition_variable_any on a std::mutex</u></a></p></li>
<li><p>[<span data-custom-style="Hyperlink">0.10.1 [35] Source CCG Rule CP.100: Don't use lock-free programming unless you absolutely have to</span></p>
<p><span data-custom-style="Hyperlink">27</span>](https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.3hq5f8vdw7d)</p></li>
<li><p>0.10.2 [36] Source CCG Rule CP.101: Distrust your hardware/compiler combination</p></li>
<li><p>0.10.3 [37] Source CCG Rule CP.102: Carefully study the literature</p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.ca8el9ehijae"><span data-custom-style="Hyperlink">0.10.4 [38] Source CCG Rule CP.110: Do not write your own double-checked locking for initialization</span></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.9syx86lze887"><span data-custom-style="Hyperlink">0.10.5 [39] Source HIC Rule 18.2.4 Use std::call_once to ensure a function is called exactly once (rather than the Double-Checked Locking pattern)</span></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.gg4jn12ygzi5"><span data-custom-style="Hyperlink">0.10.6 [40] Source CCG Rule CP.111: Use a conventional pattern if you really need double-checked locking</span></a></p></li>
<li></li>
</ul>
<h2 id="uncontrolled-format-string-shl">6.64 Uncontrolled Format String [SHL]</h2>
<h3 id="applicability-to-language">6.64.1 Applicability to language</h3>
<p>C++ inherits the C libraries which provide a large family of input and output functions that use a control string to interpret the data read or format the output. These strings include all the feature described in ISO/IEC TR 24772-1:2019 clause 6.64.1.</p>
<p>C++ provides type-safe alternatives for input/output, which do not use format strings and which should be used in preference, such as</p>
<div class="sourceCode" id="cb229"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> aNumber{};</span>
<span id="cb229-2"><a href="#cb229-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span>(<span class="bu">std::</span>cin){ <span class="co">// is input still available</span></span>
<span id="cb229-3"><a href="#cb229-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Enter a whole number, please:&quot;</span>;</span>
<span id="cb229-4"><a href="#cb229-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="bu">std::</span>cin &gt;&gt; aNumber) { <span class="co">// no format string needed</span></span>
<span id="cb229-5"><a href="#cb229-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &gt;&gt; <span class="st">&quot;Thank you, the number can be represented as &quot;</span></span>
<span id="cb229-6"><a href="#cb229-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>format(<span class="st">&quot;0b</span><span class="sc">{0:b}</span><span class="st"> </span><span class="sc">{0:d}</span><span class="st"> 0</span><span class="sc">{0:o}</span><span class="st"> 0x</span><span class="sc">{0:x}</span><span class="st">&quot;</span>, aNumber);</span>
<span id="cb229-7"><a href="#cb229-7" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> { <span class="co">// input failed</span></span>
<span id="cb229-8"><a href="#cb229-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin.clear();  <span class="co">// re-enable input</span></span>
<span id="cb229-9"><a href="#cb229-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string line;</span>
<span id="cb229-10"><a href="#cb229-10" aria-hidden="true" tabindex="-1"></a>    getline(<span class="bu">std::</span>cin,line); <span class="co">// skip to eol</span></span>
<span id="cb229-11"><a href="#cb229-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb229-12"><a href="#cb229-12" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In addition, operator overloading of output operators allows to extend formatting abilities to user-defined types.</p>
<h3 id="guidance-to-language-users">6.64.2 Guidance to language users</h3>
<p>Avoid the C library facilities provided by <strong><code>&lt;cstdio&gt;</code></strong>.</p>
<p>Use the mechanisms provided by the standard library as described in ISO/IEC 14882 20.20 Formatting [format] or similar libraries, if <em>printf-style</em> formatting of output or strings is desired, or when the formatting facilities of <code>std::ostream</code> are inadequate.</p>
<p>Read untrusted input as plain characters and then check for validity, before any conversion to numbers or program entities occurs, using facilities that do not require format strings and that check and report error conditions.</p>
<h1 id="modifying-constants-ujo">6.65 Modifying constants [UJO]</h1>
<h3 id="applicability-to-language">6.65.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 clause 8.2 exists in C++. The model of <code class="sourceCode cpp"><span class="at">const</span></code> in C++ is known as "bit-wise const" or "physical const".</p>
<p>C++ can also model logical-const <em>&lt;need more&gt;</em></p>
<p><em>Also include discussion of keyword</em> <code class="sourceCode cpp"><span class="at">mutable</span></code></p>
<p>An object can be declared as <code class="sourceCode cpp"><span class="at">const</span></code>, denoting that its value will not change in its lifetime:</p>
<p><code class="sourceCode cpp"><span class="dt">int</span> <span class="at">const</span> i = <span class="dv">0</span>;</code></p>
<p>A object that is not <code class="sourceCode cpp"><span class="at">const</span></code>-qualified can be accessed through a path that is <code class="sourceCode cpp"><span class="at">const</span></code>-qualified:</p>
<div class="sourceCode" id="cb230"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true" tabindex="-1"></a>  T k = <span class="dv">0</span>;</span>
<span id="cb230-2"><a href="#cb230-2" aria-hidden="true" tabindex="-1"></a>  T <span class="at">const</span> &amp; j = k;                <span class="co">// &#39;j&#39; is a const reference to &#39;k&#39;</span></span>
<span id="cb230-3"><a href="#cb230-3" aria-hidden="true" tabindex="-1"></a>  T <span class="at">const</span> * p = &amp;k;               <span class="co">// &#39;p&#39; is a pointer to const &#39;k&#39;</span></span>
<span id="cb230-4"><a href="#cb230-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const_cast</span>&lt;T <span class="at">const</span> &amp;&gt;(k);       <span class="co">// The type of the expression is const</span></span></code></pre></div>
<p>The checking for the correctness of <code class="sourceCode cpp"><span class="at">const</span></code> is enforced based on the access-path and not the type of the target object. For example, the following are ill-formed as the access path of the left-hand expression is <code class="sourceCode cpp"><span class="at">const</span></code>-qualified:</p>
<div class="sourceCode" id="cb231"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true" tabindex="-1"></a>  i = <span class="dv">0</span>; <span class="co">// T const i;</span></span>
<span id="cb231-2"><a href="#cb231-2" aria-hidden="true" tabindex="-1"></a>  j = <span class="dv">0</span>; <span class="co">// T const &amp;j</span></span>
<span id="cb231-3"><a href="#cb231-3" aria-hidden="true" tabindex="-1"></a>  *p = <span class="dv">0</span>; <span class="co">// T const *p</span></span>
<span id="cb231-4"><a href="#cb231-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const_cast</span>&lt;T <span class="at">const</span> &amp;&gt;(k) = <span class="dv">0</span>; <span class="co">// T k i.e. not const</span></span></code></pre></div>
<p>Note that the object <code class="sourceCode cpp">k</code> referred to by <code class="sourceCode cpp">j</code>, <code class="sourceCode cpp">\*p</code> and the <code class="sourceCode cpp"><span class="kw">const_cast</span>,</code> is not constant. In each case the access path could be changed to remove <code class="sourceCode cpp"><span class="at">const</span></code> making the program well-formed:<br />
<code class="sourceCode cpp"><span class="kw">const_cast</span>\&lt;T&amp;\&gt; (j) = <span class="dv">0</span>; <span class="co">// well-formed</span></code><br />
<br />
While it is possible to remove the const-qualification for an access path, attempting to modify a const object this way is undefined-behavior:<br />
<code class="sourceCode cpp"><span class="kw">const_cast</span>\&lt;T&amp;\&gt; (i) = <span class="dv">0</span>; <span class="co">// undefined behavior</span></code><br />
<br />
We distinguish between qualifications on the pointer’s type (pointer type) and qualifications on the type being referenced (pointer type).</p>
<p>A pointer type can be qualified as <code class="sourceCode cpp"><span class="at">const</span></code>, however the qualification only applies to the pointer type and not the pointee's type. Qualifying a reference type as <code class="sourceCode cpp"><span class="at">const</span></code> is either ill-formed or ignored.</p>
<div class="sourceCode" id="cb232"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> T = <span class="dt">int</span>;</span>
<span id="cb232-2"><a href="#cb232-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> T1 = T &amp;;</span>
<span id="cb232-3"><a href="#cb232-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> T2 = T *;</span>
<span id="cb232-4"><a href="#cb232-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> S1 = T1 <span class="at">const</span>;  <span class="co">// The const is ignored, S1 has type &#39;T &amp;&#39;</span></span>
<span id="cb232-5"><a href="#cb232-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> S2 = T2 <span class="at">const</span>;  <span class="co">// The const applies to the pointer type,</span></span>
<span id="cb232-6"><a href="#cb232-6" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// S2 has type &#39;T * const&#39;</span></span>
<span id="cb232-7"><a href="#cb232-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-8"><a href="#cb232-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> foo (S1 s1, S2 s2)</span>
<span id="cb232-9"><a href="#cb232-9" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb232-10"><a href="#cb232-10" aria-hidden="true" tabindex="-1"></a>    s1 = <span class="dv">0</span>;            <span class="co">// well-formed</span></span>
<span id="cb232-11"><a href="#cb232-11" aria-hidden="true" tabindex="-1"></a>    *s2 = <span class="dv">0</span>;           <span class="co">// well-formed</span></span>
<span id="cb232-12"><a href="#cb232-12" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>This can result in the misconception that a member function qualified with <code class="sourceCode cpp"><span class="at">const</span></code> cannot modify any of its members:</p>
<div class="sourceCode" id="cb233"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> A</span>
<span id="cb233-2"><a href="#cb233-2" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb233-3"><a href="#cb233-3" aria-hidden="true" tabindex="-1"></a>    A * pA;                <span class="co">// Pointer to non-const A</span></span>
<span id="cb233-4"><a href="#cb233-4" aria-hidden="true" tabindex="-1"></a>    T array[<span class="dv">2</span>];            <span class="co">// Array of type T</span></span>
<span id="cb233-5"><a href="#cb233-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb233-6"><a href="#cb233-6" aria-hidden="true" tabindex="-1"></a>    A () : pA{<span class="kw">this</span>}{}</span>
<span id="cb233-7"><a href="#cb233-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb233-8"><a href="#cb233-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f () <span class="at">const</span></span>
<span id="cb233-9"><a href="#cb233-9" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb233-10"><a href="#cb233-10" aria-hidden="true" tabindex="-1"></a>      pA = <span class="kw">nullptr</span>;        <span class="co">// ill-formed, hence compilation fails</span></span>
<span id="cb233-11"><a href="#cb233-11" aria-hidden="true" tabindex="-1"></a>      array[<span class="dv">0</span>] = <span class="dv">0</span>;        <span class="co">// ill-formed hence compilation fails</span></span>
<span id="cb233-12"><a href="#cb233-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb233-13"><a href="#cb233-13" aria-hidden="true" tabindex="-1"></a>      pA-&gt;array[<span class="dv">0</span>] = <span class="dv">0</span>;    <span class="co">// compiles, but undefined on const</span></span>
<span id="cb233-14"><a href="#cb233-14" aria-hidden="true" tabindex="-1"></a>object</span>
<span id="cb233-15"><a href="#cb233-15" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb233-16"><a href="#cb233-16" aria-hidden="true" tabindex="-1"></a>  };</span></code></pre></div>
<p>In the const member function f, naming array directly results in a const-qualified access path and so an attempt to modify it is ill-formed. However, the type of pA is A * const, that is a const pointer to a non-const <code class="sourceCode cpp">A</code>. An attempt to modify pA is ill-formed, however, modification of the value pointed to by pA is not a const-qualified access path and so is not ill-formed.<br />
<br />
It is undefined behavior to attempt to modify a const object. The programmer can incorrectly assume that a call to a const member function will not modify the object. However, as has been shown above there is no guarantee that this is the case. The following example, therefore, will compile but has undefined behavior as a result of the modification of the const object:</p>
<div class="sourceCode" id="cb234"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> foo ()</span>
<span id="cb234-2"><a href="#cb234-2" aria-hidden="true" tabindex="-1"></a>  { </span>
<span id="cb234-3"><a href="#cb234-3" aria-hidden="true" tabindex="-1"></a>     A a1 {} ;</span>
<span id="cb234-4"><a href="#cb234-4" aria-hidden="true" tabindex="-1"></a>     A <span class="at">const</span> a2 {} ;</span>
<span id="cb234-5"><a href="#cb234-5" aria-hidden="true" tabindex="-1"></a>     a1.f();           <span class="co">// OK - &#39;a1&#39; is not const</span></span>
<span id="cb234-6"><a href="#cb234-6" aria-hidden="true" tabindex="-1"></a>     a2.f();           <span class="co">// compiles but has undefined behaviour</span></span>
<span id="cb234-7"><a href="#cb234-7" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Where logical <code class="sourceCode cpp"><span class="at">const</span></code> is desired, C++ classes can be used to provide access to data through member functions:</p>
<div class="sourceCode" id="cb235"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; <span class="kw">struct</span> MyRef {   </span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true" tabindex="-1"></a>    MyRef &amp; <span class="kw">operator</span>=(T &amp; t) {  <span class="va">m_t</span> = t; <span class="cf">return</span> *<span class="kw">this</span>;}</span>
<span id="cb235-3"><a href="#cb235-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">private</span>:</span>
<span id="cb235-4"><a href="#cb235-4" aria-hidden="true" tabindex="-1"></a>   T &amp; <span class="va">m_t</span>;</span>
<span id="cb235-5"><a href="#cb235-5" aria-hidden="true" tabindex="-1"></a> };</span>
<span id="cb235-6"><a href="#cb235-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">struct</span> A {</span>
<span id="cb235-7"><a href="#cb235-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f1()       {  <span class="va">m_i</span> = <span class="dv">0</span>; }</span>
<span id="cb235-8"><a href="#cb235-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f2() <span class="at">const</span> {  <span class="va">m_i</span> = <span class="dv">0</span>; } <span class="co">// ill-formed, hence compilation fails</span></span>
<span id="cb235-9"><a href="#cb235-9" aria-hidden="true" tabindex="-1"></a>    MyRef&lt;<span class="dt">int</span>&gt; <span class="va">m_i</span>;</span>
<span id="cb235-10"><a href="#cb235-10" aria-hidden="true" tabindex="-1"></a> };</span></code></pre></div>
<p>In the above, <code class="sourceCode cpp">MyRef</code> type hides the reference member behind member functions that an API that does not provide an assignment operator that is callable for a <code class="sourceCode cpp"><span class="at">const</span></code> type. Therefore the above code fails to compile because <code class="sourceCode cpp">f2()</code> is a <code class="sourceCode cpp"><span class="at">const</span></code> member function which causes all data members to be treated as <code class="sourceCode cpp"><span class="at">const</span></code>. Since <code class="sourceCode cpp"><span class="va">m_i</span></code> is not a reference or a pointer, its type is effectively <code class="sourceCode cpp"><span class="at">const</span> MyRef&lt;<span class="dt">int</span>&gt;</code> inside o <code class="sourceCode cpp">f2()</code>. Therefore <code class="sourceCode cpp"><span class="va">m_i</span> = <span class="dv">0</span>;</code> is invalid.</p>
<p>C++ container iterator types, <code class="sourceCode cpp">iterator</code> and <code class="sourceCode cpp">const_iterator</code>, are examples of use of this pattern.</p>
<h3 id="guidance-to-language-users">6.65.2 Guidance to language users</h3>
<ul>
<li><p>Do not cast-away <code class="sourceCode cpp"><span class="at">const</span></code>.</p></li>
<li><p>Leverage the C++ type system to restrict the operations on a type in a way that emulates <em>logical const</em> and document where used</p></li>
<li><p>Be aware that, while <code class="sourceCode cpp"><span class="at">const</span></code> means “read only”, C++ permits <code class="sourceCode cpp"><span class="at">const</span></code> values to be modified as shown in clause 6.65.1and</p></li>
<li><p>If a</p></li>
</ul>
<!-- -->
<h1 id="language-specific-vulnerabilities-for-c">7. Language specific vulnerabilities for C</h1>
<p>7.2 Copy/move semantics from Classes. (Peter Sommerlad’s paper at http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1412r0.pdf</p>
<h1 id="implications-for-standardization">8. Implications for standardization</h1>
<p>Future standardization efforts should consider:</p>
<ul>
<li><pre><code>Moving in the direction over time to being a more strongly typed</code></pre>
<p>language. Much of the use of weak typing is simply convenience to the developer in not having to fully consider the types and uses of variables. Stronger typing forces good programming discipline and clarity about variables while at the same time removing many unexpected run time errors due to implicit conversions. This is not to say that C should be strictly a strongly typed language – some advantages of C are due to the flexibility that weaker typing provides. It is suggested that when enforcement of strong typing does not detract from the good flexibility that C offers (for example, adding an integer to a character to step through a sequence of characters) and is only a convenience for programmers (for example, adding an integer to a floating-point number), then the standard should specify the stronger typed solution.</p></li>
<li><pre><code>A common warning in Annex I should be added for floating-point</code></pre>
<p>expressions being used in a Boolean test for equality.</p></li>
<li><pre><code>Modifying or deprecating many of the C standard library functions</code></pre>
<p>that make assumptions about the occurrence of a string termination character.</p></li>
<li><pre><code>Define a string construct that does not rely on the null termination</code></pre>
<p>character.</p></li>
<li><pre><code>Defining an array type that does automatic bounds checking.</code></pre></li>
<li><pre><code>Deprecating less safe functions such as strcpy() and strcat() where</code></pre>
<p>a more secure alternative is available.<span data-custom-style="annotation reference"></span></p></li>
<li><pre><code>Defining safer and more secure replacement functions such as</code></pre>
<p>memncpy() and memncmp() to complement the memcpy() and memcmp() functions (see <em>6.11.6 Implications for standardization</em>)</p></li>
<li><pre><code>Defining an array type that does automatic bounds checking.</code></pre></li>
<li><pre><code>Defining functions that contain an extra parameter in memcpy() and</code></pre>
<p>memmove() for the maximum number of bytes to copy. In the past, some have suggested that the size of the destination buffer be used as an additional parameter. Some critics state that this solution is easy to circumvent by simply repeating the parameter that was used for the number of bytes to copy as the parameter for the size of the destination buffer. This analysis and criticism is correct. What is needed is a failsafe check as to the maximum number of bytes to copy. There are several reasons for creating new functions with an additional parameter. This would make it easier for static analysis to eliminate those cases where the memory copy could not be a problem (such as when the maximum number of bytes is demonstrably less than the capacity of the receiving buffer). Manual analysis or more involved static analysis could then be used for the remaining situations where the size of the destination buffer may not be sufficient for the maximum number of bytes to copy. This extra parameter may also help in determining which copies could take place among objects that overlap. Such copying is undefined according to the C standard. It is suggested that safer versions of functions that include a restriction max_n on the number of bytes n to copy (for example, void *memncpy(void * restrict s1,const void * restrict s2,size_t n), const size_t max_n) be added to the standard in addition to retaining the current corresponding functions (for example, memcpy(void * restrict s1,const void * restrict s2,size_t n))). The additional parameter would be consistent with the copying function pairs that have already been created such as strcpy()/strncpy() and strcat()/strncat(). This would allow a safer version of memory copying functions for those applications that want to use them in to facilitate both safer and more secure code and more efficient and accurate static code reviews<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p></li>
<li><pre><code>Restrictions on pointer arithmetic that could eliminate common</code></pre>
<p>pitfalls. Pointer arithmetic is error-prone and the flexibility that it offers is useful, but some of the flexibility is simply a shortcut that if restricted could lessen the chance of a pointer arithmetic based error.</p></li>
<li><pre><code>Defining a standard way of declaring an attribute to indicate that a</code></pre>
<p>variable is intentionally unused.</p></li>
<li><pre><code>A common warning in Annex I should be added for variables with the</code></pre>
<p>same name in nested scopes.</p></li>
<li><pre><code>Creating a few standardized precedence orders. Standardizing on a</code></pre>
<p>few precedence orders will help to eliminate the confusing intricacies that exist between languages. This would not affect current languages as altering precedence orders in existing languages is too onerous. However, this would set a basis for the future as new languages are created and adopted. Stating that a language uses “ISO precedence order A” would be useful rather than having to spell out the entire precedence order that differs in a conceptually minor way from some other languages, but in a major way when programmers attempt to switch between languages.</p></li>
<li><pre><code>Deprecating the goto statement. The use of the goto construct is</code></pre>
<p>often spotlighted as the antithesis of good structured programming. Though its deprecation will not instantly make all C code structured, deprecating the goto and leaving in place the restricted goto variations (for example, break and continue) and possibly adding other restricted goto’s could assist in encouraging safer and more secure C programming in general.</p></li>
<li><pre><code>Defining a &quot;fallthru&quot; construct that will explicitly bind multiple</code></pre>
<p>switch cases together and eliminate the need for the break statement. The default would be for a case to break instead of falling through to the next case. Granted this is a major shift in concept, but if it could be accomplished, less unintentional errors would occur.</p></li>
<li><pre><code>Defining an identifier type for loop control that cannot be modified</code></pre>
<p>by anything other than the loop control construct would be a relatively minor addition to C that could make C code safer and encourage better structured programming.</p></li>
<li><pre><code>Defining a standardized interface package for interfacing C with</code></pre>
<p>many of the top programming languages and a reciprocal package should be developed of the other top languages to interface with C.</p></li>
<li><pre><code>Joining with other languages in developing a standardized set of</code></pre>
<p>mechanisms for detecting and treating error conditions so that all languages to the extent possible could use them. Note that this does not mean that all languages should use the same mechanisms as there should be a variety ( label parameters, auxiliary status variables), but each of the mechanisms should be standardized.</p></li>
<li><pre><code>Since fault handling and exiting of a program is common to all</code></pre>
<p>languages, it is suggested that common terminology such as the meaning of fail safe, fail hard, fail soft, and so on along with a core API set such as exit, abort, and so on be standardized and coordinated with other languages.</p></li>
<li><pre><code>Deprecating unions. The primary reason for the use of unions to save</code></pre>
<p>memory has been diminished considerably as memory has become cheaper and more available. Unions are not statically type safe and are historically known to be a common source of errors, leading to many C programming guidelines specifically prohibiting the use of unions.</p></li>
<li><pre><code>Creating a recognizable naming standard for routines such that one</code></pre>
<p>version of a library does parameter checking to the extent possible and another version does no parameter checking. The first version would be considered safer and more secure and the second could be used in certain situations where performance is critical and the checking is assumed to be done in the calling routine. A naming standard could be made such that the library that does parameter checking could be named as usual, say “library_xyz” and an equivalent version that does not do checking could have a “_p” appended, such as “library_xyz_p”. Without a naming standard such as this, a considerable number of wasted cycles will be conducted doing a double check of parameters or even worse, no checking will be done in both the calling and receiving routines as each is assuming the other is doing the checking.</p></li>
<li><pre><code>Creating an Annex that lists deprecated features.</code></pre></li>
</ul>
<h1 id="bibliography">Bibliography</h1>
<div data-custom-style="Bibliography1">
<p>[1] ISO/IEC Directives, Part 2, <em>Rules for the structure and drafting of International Standards</em>, 2004</p>
</div>
<div data-custom-style="Bibliography1">
<p>[2] ISO/IEC TR 10000‑1, <em>Information technology — Framework and taxonomy of International Standardized Profiles — Part 1: General principles and documentation framework</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[3] ISO 10241 (all parts), <em>International terminology standards</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[4] ISO/IEC 9899:2011, <em>Information technology</em> — <em>Programming languages —</em> C</p>
</div>
<div data-custom-style="Bibliography1">
<p>[5] ISO/IEC 9899:2011/Cor.1:2012, <em>Technical Corrigendum 1</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[6] ISO/IEC 30170:2012, <em>Information technology</em> — <em>Programming languages —</em> Ruby</p>
</div>
<div data-custom-style="Bibliography1">
<p>[7] ISO/IEC/IEEE 60559:2011, <em>Information technology – Microprocessor Systems – Floating-Point arithmetic</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[8] ISO/IEC 1539-1:2010, <em>Information technology — Programming languages —</em> Fortran — Part 1: Base language</p>
</div>
<div data-custom-style="Bibliography1">
<p>[9] ISO/IEC 8652:1995, <em>Information technology — Programming languages —</em> Ada</p>
</div>
<div data-custom-style="Bibliography1">
<p>[10] ISO/IEC 14882:2011, <em>Information technology</em> — <em>Programming languages —</em> C++</p>
</div>
<div data-custom-style="Bibliography1">
<p>[11] R. Seacord, <em>The CERT C Secure Coding Standard</em>. Boston,MA: Addison-Westley, 2008.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[12] Motor Industry Software Reliability Association. <em>Guidelines for the Use of the C Language in Vehicle Based Software</em>, 2012 (third edition)16F<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[13] ISO/IEC TR24731–1, <em>Information technology — Programming languages, their environments and system software interfaces — Extensions to the C library — Part 1: Bounds-checking interfaces</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[14] ISO/IEC TR 15942:2000, <em>Information technology — Programming languages — Guide for the use of the Ada programming language in high integrity systems</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[15] Joint Strike Fighter Air Vehicle: C++ Coding Standards for the System Development and Demonstration Program. Lockheed Martin Corporation. December 2005.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[16] Motor Industry Software Reliability Association. <em>Guidelines for the Use of the C++ Language in critical systems</em>, June 2008</p>
</div>
<div data-custom-style="Bibliography1">
<p>[17] ISO/IEC TR 24718: 2005, <em>Information technology — Programming languages — Guide for the use of the Ada Ravenscar Profile in high integrity systems</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[18] L. Hatton, Safer C: developing software for high-integrity and safety-critical systems. McGraw-Hill 1995</p>
</div>
<div data-custom-style="Bibliography1">
<p>[19] ISO/IEC 15291:1999, <em>Information technology — Programming languages — Ada Semantic Interface Specification (ASIS)</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[20] Software Considerations in Airborne Systems and Equipment Certification. Issued in the USA by the Requirements and Technical Concepts for Aviation (document RTCA SC167/DO-178B) and in Europe by the European Organization for Civil Aviation Electronics (EUROCAE document ED-12B).December 1992.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[21] IEC 61508: Parts 1-7, Functional safety: safety-related systems. 1998. (Part 3 is concerned with software).</p>
</div>
<div data-custom-style="Bibliography1">
<p>[22] ISO/IEC 15408: 1999 Information technology. Security techniques. Evaluation criteria for IT security.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[23] J Barnes, High Integrity Software - the SPARK Approach to Safety and Security. Addison-Wesley. 2002.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[25] Steve Christy, <em>Vulnerability Type Distributions in CVE</em>, V1.0, 2006/10/04</p>
</div>
<div data-custom-style="Bibliography1">
<p>[26] <em>ARIANE 5: Flight 501 Failure</em>, Report by the Inquiry Board, July 19, 1996 <a href="http://esamultimedia.esa.int/docs/esa-x-1819eng.pdf"><span data-custom-style="Hyperlink">http://esamultimedia.esa.int/docs/esa-x-1819eng.pdf</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[27] Hogaboom, Richard, <em>A Generic API Bit Manipulation in C</em>, Embedded Systems Programming, Vol 12, No 7, July 1999 <a href="http://www.embedded.com/1999/9907/9907feat2.htm"><span data-custom-style="Hyperlink">http://www.embedded.com/1999/9907/9907feat2.htm</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[28] Carlo Ghezzi and Mehdi Jazayeri, Programming Language Concepts, 3<sup>rd</sup> edition, ISBN-0-471-10426-4, John Wiley &amp; Sons, 1998</p>
</div>
<div data-custom-style="Bibliography1">
<p>[29] Lions, J. L. <a href="http://en.wikisource.org/wiki/Ariane_501_Inquiry_Board_report"><span data-custom-style="Hyperlink">ARIANE 5 Flight 501 Failure Report</span></a>. Paris, France: European Space Agency (ESA) &amp; National Center for Space Study (CNES) Inquiry Board, July 1996.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[30] Seacord, R. <em>Secure Coding in C and C++</em>. Boston, MA: Addison-Wesley, 2005. See <a href="http://www.cert.org/books/secure-coding"><span data-custom-style="Hyperlink">http://www.cert.org/books/secure-coding</span></a> for news and errata.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[31] John David N. Dionisio. Type Checking. <a href="http://myweb.lmu.edu/dondi/share/pl/type-checking-v02.pdf"><span data-custom-style="Hyperlink">http://myweb.lmu.edu/dondi/share/pl/type-checking-v02.pdf</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[32] MISRA Limited. "<a href="http://www.misra.org.uk/"><span data-custom-style="Hyperlink">MISRA C</span></a>: 2012 Guidelines for the Use of the C Language in Critical Systems." Warwickshire, UK: MIRA Limited, March 2013 (ISBN 978-1-906400-10-1 and 978-1-906400-11-8).</p>
</div>
<div data-custom-style="Bibliography1">
<p>[33] The Common Weakness Enumeration (CWE) Initiative, MITRE Corporation, (<a href="http://cwe.mitre.org/"><span data-custom-style="Hyperlink">http://cwe.mitre.org/</span></a>)</p>
</div>
<div data-custom-style="Bibliography1">
<p>[34] Goldberg, David, <em>What Every Computer Scientist Should Know About Floating-Point Arithmetic</em>, ACM Computing Surveys, vol 23, issue 1 (March 1991), ISSN 0360-0300, pp 5-48.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[35] IEEE Standards Committee 754. IEEE Standard for Binary Floating-Point Arithmetic, ANSI/IEEE Standard 754-2008. Institute of Electrical and Electronics Engineers, New York, 2008.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[36] Robert W. Sebesta, Concepts of Programming Languages, 8<sup>th</sup> edition, ISBN-13: 978-0-321-49362-0, ISBN-10: 0-321-49362-1, Pearson Education, Boston, MA, 2008</p>
</div>
<div data-custom-style="Bibliography1">
<p>[37] Bo Einarsson, ed. Accuracy and Reliability in Scientific Computing, SIAM, July 2005 <a href="http://www.nsc.liu.se/wg25/book"><span data-custom-style="Hyperlink">http://www.nsc.liu.se/wg25/book</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[38] GAO Report, Patriot <em>Missile Defense: Software Problem Led to System Failure at Dhahran, Saudi Arabia</em>, B-247094, Feb. 4, 1992, <a href="http://archive.gao.gov/t2pbat6/145960.pdf"><span data-custom-style="Hyperlink">http://archive.gao.gov/t2pbat6/145960.pdf</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[39] Robert Skeel, <em>Roundoff Error Cripples Patriot Missile</em>, SIAM News, Volume 25, Number 4, July 1992, page 11, <a href="http://www.siam.org/siamnews/general/patriot.htm"><span data-custom-style="HTML Typewriter"><u>http://www.siam.org/siamnews/general/patriot.htm</u></span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[40] CERT. <em>CERT C++ Secure Coding Standard</em>.  <a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637%20"><span data-custom-style="Hyperlink">https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637</span></a> (2009).</p>
</div>
<div data-custom-style="Bibliography1">
<p>[41] Holzmann, Garard J., Computer, vol. 39, no. 6, pp 95-97, Jun., 2006, <em>The Power of 10: Rules for Developing Safety-Critical Code</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[42] P. V. Bhansali, A systematic approach to identifying a safe subset for safety-critical software, ACM SIGSOFT Software Engineering Notes, v.28 n.4, July 2003</p>
</div>
<div data-custom-style="Bibliography1">
<p>[43] Ada 95 Quality and Style Guide, SPC-91061-CMC, version 02.01.01. Herndon, Virginia: Software Productivity Consortium, 1992. Available from: <a href="http://www.adaic.org/docs/95style/95style.pdf"><span data-custom-style="Hyperlink">http://www.adaic.org/docs/95style/95style.pdf</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[44] Ghassan, A., &amp; Alkadi, I. (2003). Application of a Revised DIT Metric to Redesign an OO Design. <em>Journal of Object Technology</em> , 127-134.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[45] Subramanian, S., Tsai, W.-T., &amp; Rayadurgam, S. (1998). Design Constraint Violation Detection in Safety-Critical Systems. The 3rd IEEE International Symposium on High-Assurance Systems Engineering , 109 - 116.</p>
</div>
<p>[46] Lundqvist, K and Asplund, L., “<em>A Formal Model of a Run-Time Kernel for Ravenscar</em>”, The 6th International Conference on Real-Time Computing Systems and Applications – RTCSA 1999</p>
<p>[47] ISO/IEC TS 17961, <em>Information technology – Programming languages, their environments and system software interfaces – C secure coding rules</em></p>
<p>[48] GNU Project. GCC Bugs “Non-bugs” http://gcc.gnu.org/bugs.html#nonbugs_c (2009).</p>
<h1 id="index">Index</h1>
<div data-custom-style="Bibliography1">
<p>LHS (left-hand side), 22</p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>::: {custom-style=“footnote text”} <span data-custom-style="footnote reference"></span> This has been addressed by WG 14 in an optionally normative annex in the current working paper<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>::: {custom-style=“footnote text”} <span data-custom-style="footnote reference"></span> The first edition should not be used or quoted in this work.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
