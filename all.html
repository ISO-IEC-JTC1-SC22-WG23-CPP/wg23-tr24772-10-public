<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>tr24772-10-C++</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div data-custom-style="zzCover">
<p>ISO/IEC JTC 1/SC 22/WG23 N1012</p>
</div>
<div data-custom-style="zzCover">
<p>Date: 2020-11-23</p>
</div>
<div data-custom-style="zzCover">
<p>ISO/IEC TR 24772–10<br />
Notes on this document</p>
</div>
<p>Effective 23 November 2020, this document is being moved to “github”. Contact <span data-custom-style="Hyperlink">Stephen.michell@maurya.on.ca</span> to gain access.</p>
<p>This document is a draft of a Guidance to avoiding programming language vulnerabilities in C++.</p>
<p>At this point in time, the following clauses are essentially completed first pass.</p>
<ul>
<li><pre><code>6.2 type system</code></pre></li>
<li><pre><code>6.3 Bit representation</code></pre></li>
<li><pre><code>6.4 Floating Point</code></pre></li>
<li><pre><code>6.5 Enumerator issues \[CCB\],</code></pre></li>
<li><pre><code>6.6 Conversion errors</code></pre></li>
<li><pre><code>6.7 String termination</code></pre></li>
<li><pre><code>6.8 Buffer boundary violation</code></pre></li>
<li><pre><code>6.9 Unchecked array indexing</code></pre></li>
<li><pre><code>6.10 Unchecked array copying (needs to be revisited)</code></pre></li>
<li><pre><code>6.11 Pointer type conversions</code></pre></li>
<li><pre><code>6.12 Pointer arithmetic</code></pre></li>
<li><pre><code>6.13 Null pointer dereference \[XYH\],</code></pre></li>
<li><pre><code>6.14 Dangling reference to heap</code></pre></li>
<li><pre><code>6.15 Arithmetic wrap-around error</code></pre></li>
<li><pre><code>6.16 Using shift operations for multiplication and division</code></pre></li>
<li><pre><code>6.17 Choice of clear names \[NAI\]</code></pre></li>
<li><pre><code>6.18 Dead Store</code></pre></li>
<li><pre><code>6.19 Unused variables</code></pre></li>
<li><pre><code>6.20 Identifier name reuse</code></pre></li>
<li><pre><code>6.21 Namespace Issues</code></pre></li>
<li><pre><code>6.22 Initialization of variables \[LAV\]</code></pre></li>
<li><pre><code>6.23 Operator precedence and associativity</code></pre></li>
<li><pre><code>6.24 Side effects and order of evaluation</code></pre></li>
<li><pre><code>6.25 Likely incorrect expression</code></pre></li>
<li><pre><code>6.26 Dead store,</code></pre></li>
<li><pre><code>6.27 Switch statements and static analysis</code></pre></li>
<li><pre><code>6.28 Demarcation of control flow</code></pre></li>
<li><pre><code>6.29 Loop control variables</code></pre></li>
<li><pre><code>6.30 Off-by-one errors</code></pre></li>
<li><pre><code>6.31 Structured programming</code></pre></li>
<li><pre><code>6.32 Passing parameters and return values</code></pre></li>
<li><pre><code>6.33 Dangling references to stack frames</code></pre></li>
<li><pre><code>6.34 Subprogram signature mismatch</code></pre></li>
<li><pre><code>6.35 Recursion</code></pre></li>
<li><pre><code>6.36 Ignored error status and unhandled exceptions</code></pre></li>
<li><pre><code>6.37 Type breaking reinterpretation of data</code></pre></li>
<li><pre><code>6.38 Deep vs shallow copying \[YAN\]</code></pre></li>
<li><pre><code>6.39 Memory leak and heap fragmentation</code></pre></li>
<li><pre><code>6.41 Inheritance</code></pre></li>
<li><pre><code>6.42 Violations of the Liskov substitution principle</code></pre></li>
<li><pre><code>6.43 Redispatching</code></pre></li>
<li><pre><code>6.44 Polymorphic variables</code></pre></li>
<li><pre><code>6.45 Extra intrinsics</code></pre></li>
<li><pre><code>6.46 Argument passing to library functions</code></pre></li>
<li><pre><code>6.47 Inter-language calling</code></pre></li>
<li><pre><code>6.48 Dynamically-linked code and self-modifying code \[NYY\]</code></pre></li>
<li><pre><code>6.49 Library Signature</code></pre></li>
<li><pre><code>6.50 Unanticipated exceptions from library routines</code></pre></li>
<li><pre><code>6.51 Pre-processor directives</code></pre></li>
<li><pre><code>6.52 Suppression of language-defined run-time checking</code></pre></li>
<li><pre><code>6.53 Provision of inherently unsafe operations</code></pre></li>
<li><pre><code>6.54 Obscure language features</code></pre></li>
<li><pre><code>6.55 Unspecified behaviour</code></pre></li>
<li><pre><code>6.56 Undefined behaviour</code></pre></li>
<li><pre><code>6.57 Implementation-defined behaviour</code></pre></li>
<li><pre><code>6.58 Deprecated language features</code></pre></li>
<li><pre><code>6.59 Concurrency \-- Activation</code></pre></li>
<li><pre><code>6.60 Concurrency -- Directed termination</code></pre></li>
<li><pre><code>6.64 Uncontrolled format string</code></pre></li>
</ul>
<div data-custom-style="Normal (Web)">
<p>TBD</p>
</div>
<ul>
<li><pre><code>6.2 Type system -- issues being fed from 6.40 and elsewhere</code></pre></li>
<li><pre><code>6.61 Concurrent data access</code></pre></li>
<li><pre><code>6.62 Concurrency -- Premature termination</code></pre></li>
<li><pre><code>6.63 Protocol lock errors</code></pre></li>
</ul>
<div data-custom-style="Normal (Web)">
<p>Participants at meeting 23 November 2020</p>
</div>
<p>Stephen Michell</p>
<p>Paul Preney</p>
<p>Peter Sommerlad</p>
<p>Richard Corden</p>
<p>Erhard Ploedereder</p>
<p>Clive Pygott</p>
<p>Michael Wong</p>
<!-- Here we include stuff... with pandoc-include filter -->
<div data-custom-style="zzCover">
<p>Edition 1</p>
</div>
<div data-custom-style="zzCover">
<p>ISO/IEC JTC 1/SC 22/WG 23</p>
</div>
<div data-custom-style="zzCover">
<p>Secretariat: ANSI</p>
</div>
<div data-custom-style="Bibliography1">
<p>Information Technology — Programming languages — Guidance to avoiding vulnerabilities in programming languages – Part 10 – Vulnerability descriptions for the programming language C++</p>
</div>
<div data-custom-style="zzCover">
<p>Document type: International standard</p>
</div>
<div data-custom-style="zzCover">
<p>Document subtype: if applicable</p>
</div>
<div data-custom-style="zzCover">
<p>Document stage: (10) development stage</p>
</div>
<div data-custom-style="zzCover">
<p>Document language: E</p>
</div>
<p><em>Élément introductif — Élément principal — Partie n: Titre de la partie</em></p>
<div data-custom-style="zzCover">
<p>Warning</p>
</div>
<div data-custom-style="zzCover">
<p>This document is not an ISO International Standard. It is distributed for review and comment. It is subject to change without notice and may not be referred to as an International Standard.</p>
</div>
<div data-custom-style="zzCover">
<p>Recipients of this draft are invited to submit, with their comments, notification of any relevant patent rights of which they are aware and to provide supporting documentation.</p>
</div>
<div data-custom-style="zzCopyright">
<p><strong>Copyright notice</strong></p>
</div>
<div data-custom-style="zzCopyright">
<p>This ISO document is a working draft or committee draft and is copyright-protected by ISO. While the reproduction of working drafts or committee drafts in any form for use by participants in the ISO standards development process is permitted without prior permission from ISO, neither this document nor any extract from it may be reproduced, stored or transmitted in any form for any other purpose without prior written permission from ISO.</p>
</div>
<div data-custom-style="zzCopyright">
<p>Requests for permission to reproduce this document for the purpose of selling it should be addressed as shown below or to ISO’s member body in the country of the requester:</p>
</div>
<div data-custom-style="zzCopyright">
<p><em>ISO copyright office</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>Case postale 56, CH-1211 Geneva 20</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>Tel. + 41 22 749 01 11</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>Fax + 41 22 749 09 47</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>E-mail copyright@iso.org</em></p>
</div>
<div data-custom-style="zzCopyright">
<p><em>Web www.iso.org</em></p>
</div>
<div data-custom-style="zzCopyright">
<p>Reproduction for sales purposes may be subject to royalty payments or a licensing agreement.</p>
</div>
<div data-custom-style="zzCopyright">
<p>Violators may be prosecuted.</p>
</div>
<div data-custom-style="zzContents">
<p>Contents Page</p>
</div>
<div data-custom-style="toc 1">
<p><a href="#foreword"><span data-custom-style="Hyperlink">Foreword</span> vii</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#introduction"><span data-custom-style="Hyperlink">Introduction</span> viii</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#scope"><span data-custom-style="Hyperlink">1. Scope</span> 1</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#normative-references"><span data-custom-style="Hyperlink">2. Normative references</span> 1</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#terms-and-definitions-symbols-and-conventions"><span data-custom-style="Hyperlink">3. Terms and definitions, symbols and conventions</span> 1</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#terms-and-definitions"><span data-custom-style="Hyperlink">3.1 Terms and definitions</span> 1</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#language-concepts"><span data-custom-style="Hyperlink">4. Language concepts</span> 4</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#section"><span data-custom-style="Hyperlink">5. Avoiding programming language vulnerabilities in C++</span> 4</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#specific-guidance-for-c-vulnerabilities"><span data-custom-style="Hyperlink">6. Specific Guidance for C++ Vulnerabilities</span> 6</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#general"><span data-custom-style="Hyperlink">6.1 General</span> 6</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#type-system-ihn"><span data-custom-style="Hyperlink">6.2 Type System [IHN]</span> 6</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#bit-representations-str"><span data-custom-style="Hyperlink">6.3 Bit Representations [STR]</span> 7</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#floating-point-arithmetic-plf"><span data-custom-style="Hyperlink">6.4 Floating-point Arithmetic [PLF]</span> 8</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#enumerator-issues-ccb"><span data-custom-style="Hyperlink">6.5 Enumerator Issues [CCB]</span> 8</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc1165233"><span data-custom-style="Hyperlink">6.6 Conversion Errors [FLC]</span> 9</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#string-termination-cjm"><span data-custom-style="Hyperlink">6.7 String Termination [CJM]</span> 10</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc1165235"><span data-custom-style="Hyperlink">•</span> <span data-custom-style="Hyperlink">Use std::string or similar, in preference to C-style arrays of chars</span> 11</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#buffer-boundary-violation-hcb"><span data-custom-style="Hyperlink">6.8 Buffer Boundary Violation [HCB]</span> 11</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unchecked-array-indexing-xyz"><span data-custom-style="Hyperlink">6.9 Unchecked Array Indexing [XYZ]</span> 12</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unchecked-array-copying-xyw"><span data-custom-style="Hyperlink">6.10 Unchecked Array Copying [XYW]</span> 13</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#pointer-type-conversions-hfc"><span data-custom-style="Hyperlink">6.11 Pointer Type Conversions [HFC]</span> 13</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#pointer-arithmetic-rvg"><span data-custom-style="Hyperlink">6.12 Pointer Arithmetic [RVG]</span> 15</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#null-pointer-dereference-xyh"><span data-custom-style="Hyperlink">6.13 NULL Pointer Dereference [XYH]</span> 16</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dangling-reference-to-heap-xyk"><span data-custom-style="Hyperlink">6.14 Dangling Reference to Heap [XYK]</span> 16</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#arithmetic-wrap-around-error-fif"><span data-custom-style="Hyperlink">6.15 Arithmetic Wrap-around Error [FIF]</span> 18</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#using-shift-operations-for-multiplication-and-division-pik"><span data-custom-style="Hyperlink">6.16 Using Shift Operations for Multiplication and Division [PIK]</span> 18</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#choice-of-clear-names-nai"><span data-custom-style="Hyperlink">6.17 Choice of Clear Names [NAI]</span> 19</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dead-store-wxq"><span data-custom-style="Hyperlink">6.18 Dead Store [WXQ]</span> 19</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unused-variable-yzs"><span data-custom-style="Hyperlink">6.19 Unused Variable [YZS]</span> 20</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#identifier-name-reuse-yow"><span data-custom-style="Hyperlink">6.20 Identifier Name Reuse [YOW]</span> 20</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc310518176"><span data-custom-style="Hyperlink">6.21 Namespace Issues [BJL]</span> 21</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#initialization-of-variables-lav"><span data-custom-style="Hyperlink">6.22 Initialization of Variables [LAV]</span> 21</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#operator-precedence-and-associativity-jcw"><span data-custom-style="Hyperlink">6.23 Operator Precedence and Associativity [JCW]</span> 21</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#side-effects-and-order-of-evaluation-of-operands-sam"><span data-custom-style="Hyperlink">6.24 Side-effects and Order of Evaluation of Operands [SAM]</span> 21</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#likely-incorrect-expression-koa"><span data-custom-style="Hyperlink">6.25 Likely Incorrect Expression [KOA]</span> 22</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dead-and-deactivated-code-xyq"><span data-custom-style="Hyperlink">6.26 Dead and Deactivated Code [XYQ]</span> 24</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#switch-statements-and-static-analysis-cll"><span data-custom-style="Hyperlink">6.27 Switch Statements and Static Analysis [CLL]</span> 24</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#demarcation-of-control-flow-eoj"><span data-custom-style="Hyperlink">6.28 Demarcation of Control Flow [EOJ]</span> 25</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#loop-control-variables-tex"><span data-custom-style="Hyperlink">6.29 Loop Control Variables [TEX]</span> 26</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#off-by-one-error-xzh"><span data-custom-style="Hyperlink">6.30 Off-by-one Error [XZH]</span> 27</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#structured-programming-ewd"><span data-custom-style="Hyperlink">6.31 Structured Programming [EWD]</span> 28</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#passing-parameters-and-return-values-csj"><span data-custom-style="Hyperlink">6.32 Passing Parameters and Return Values [CSJ]</span> 28</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dangling-references-to-stack-frames-dcm"><span data-custom-style="Hyperlink">6.33 Dangling References to Stack Frames [DCM]</span> 29</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#subprogram-signature-mismatch-otr"><span data-custom-style="Hyperlink">6.34 Subprogram Signature Mismatch [OTR]</span> 30</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#recursion-gdl"><span data-custom-style="Hyperlink">6.35 Recursion [GDL]</span> 31</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#ignored-error-status-and-unhandled-exceptions-oyb"><span data-custom-style="Hyperlink">6.36 Ignored Error Status and Unhandled Exceptions [OYB]</span> 31</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#type-breaking-reinterpretation-of-data-amv"><span data-custom-style="Hyperlink">6.37 Type-breaking Reinterpretation of Data [AMV]</span> 32</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#deep-vs.-shallow-copying-yan"><span data-custom-style="Hyperlink">6.38 Deep vs. Shallow Copying [YAN]</span> 33</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#memory-leak-and-heap-fragmentation-xyl"><span data-custom-style="Hyperlink">6.39 Memory Leak and Heap Fragmentation [XYL]</span> 33</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#templates-and-generics-sym"><span data-custom-style="Hyperlink">6.40 Templates and Generics [SYM]</span> 34</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#inheritance-rip"><span data-custom-style="Hyperlink">6.41 Inheritance [RIP]</span> 35</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#applicability-to-language-39"><span data-custom-style="Hyperlink">6.41.1 Applicability to language</span> 35</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-37"><span data-custom-style="Hyperlink">6.41.2 Guidance to language users</span> 37</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#violations-of-the-liskov-substitution-principle-or-the-contract-model-blp"><span data-custom-style="Hyperlink">6.42 Violations of the Liskov Substitution Principle or the Contract Model [BLP]</span> 37</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#applicability-to-language-40"><span data-custom-style="Hyperlink">6.42.1 Applicability to language</span> 37</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-38"><span data-custom-style="Hyperlink">6.42.2 Guidance to language users</span> 38</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#redispatching-pph"><span data-custom-style="Hyperlink">6.43 Redispatching [PPH]</span> 38</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#applicability-to-language-41"><span data-custom-style="Hyperlink">6.43.1 Applicability to language</span> 38</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-39"><span data-custom-style="Hyperlink">6.43.2 Guidance to language users</span> 39</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#polymorphic-variables-bkk"><span data-custom-style="Hyperlink">6.44 Polymorphic variables [BKK]</span> 39</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#applicability-to-language-42"><span data-custom-style="Hyperlink">6.44.1 Applicability to language</span> 40</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-40"><span data-custom-style="Hyperlink">6.44.2 Guidance to language users</span> 41</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#extra-intrinsics-lrm"><span data-custom-style="Hyperlink">6.45 Extra Intrinsics [LRM]</span> 42</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#argument-passing-to-library-functions-trj"><span data-custom-style="Hyperlink">6.46 Argument Passing to Library Functions [TRJ]</span> 42</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#inter-language-calling-djs"><span data-custom-style="Hyperlink">6.47 Inter-language Calling [DJS]</span> 42</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#dynamically-linked-code-and-self-modifying-code-nyy"><span data-custom-style="Hyperlink">6.48 Dynamically-linked Code and Self-modifying Code [NYY]</span> 45</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#library-signature-nsq"><span data-custom-style="Hyperlink">6.49 Library Signature [NSQ]</span> 46</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unanticipated-exceptions-from-library-routines-hjw"><span data-custom-style="Hyperlink">6.50</span> <span data-custom-style="Hyperlink">Unanticipated Exceptions from Library Routines [HJW]</span> 47</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#pre-processor-directives-nmp"><span data-custom-style="Hyperlink">6.51 Pre-processor Directives [NMP]</span> 48</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#suppression-of-language-defined-run-time-checking-mxb"><span data-custom-style="Hyperlink">6.52 Suppression of Language-defined Run-time Checking [MXB]</span> 49</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#provision-of-inherently-unsafe-operations-skl"><span data-custom-style="Hyperlink">6.53 Provision of Inherently Unsafe Operations [SKL]</span> 49</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#obscure-language-features-brs"><span data-custom-style="Hyperlink">6.54 Obscure Language Features [BRS]</span> 49</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#unspecified-behaviour-bqf"><span data-custom-style="Hyperlink">6.55 Unspecified Behaviour [BQF]</span> 50</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#undefined-behaviour-ewf"><span data-custom-style="Hyperlink">6.56 Undefined Behaviour [EWF]</span> 50</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#implementationdefined-behaviour-fab"><span data-custom-style="Hyperlink">6.57 Implementation–defined Behaviour [FAB]</span> 51</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#deprecated-language-features-mem"><span data-custom-style="Hyperlink">6.58 Deprecated Language Features [MEM]</span> 52</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#concurrency-activation-cga"><span data-custom-style="Hyperlink">6.59 Concurrency – Activation [CGA]</span> 52</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#concurrency-directed-termination-cgt"><span data-custom-style="Hyperlink">6.60 Concurrency – Directed termination [CGT]</span> 52</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc1165297"><span data-custom-style="Hyperlink">6.60.1 Applicability to language</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#guidance-to-language-users-55"><span data-custom-style="Hyperlink">6.60.2 Guidance to language users</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#_Toc1165299"><span data-custom-style="Hyperlink">6.61 Concurrent Data Access [CGX]</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#concurrency-premature-termination-cgs"><span data-custom-style="Hyperlink">6.62 Concurrency – Premature Termination [CGS]</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#protocol-lock-errors-cgm"><span data-custom-style="Hyperlink">6.63 Protocol Lock Errors [CGM]</span> 53</a></p>
</div>
<div data-custom-style="toc 2">
<p><a href="#uncontrolled-format-string-shl"><span data-custom-style="Hyperlink">6.64 Uncontrolled Format String [SHL]</span> 54</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#language-specific-vulnerabilities-for-c"><span data-custom-style="Hyperlink">7. Language specific vulnerabilities for C</span> 54</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#implications-for-standardization"><span data-custom-style="Hyperlink">8. Implications for standardization</span> 54</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#bibliography"><span data-custom-style="Hyperlink">Bibliography</span> 57</a></p>
</div>
<div data-custom-style="toc 1">
<p><a href="#index"><span data-custom-style="Hyperlink">Index</span> 60</a></p>
</div>
<h1 id="foreword">Foreword</h1>
<p>ISO (the International Organization for Standardization) and IEC (the International Electrotechnical Commission) form the specialized system for worldwide standardization. National bodies that are members of ISO or IEC participate in the development of International Standards through technical committees established by the respective organization to deal with particular fields of technical activity. ISO and IEC technical committees collaborate in fields of mutual interest. Other international organizations, governmental and non-governmental, in liaison with ISO and IEC, also take part in the work. In the field of information technology, ISO and IEC have established a joint technical committee, ISO/IEC JTC 1.</p>
<p>International Standards are drafted in accordance with the rules given in the ISO/IEC Directives, Part 2.</p>
<p>The main task of the joint technical committee is to prepare International Standards. Draft International Standards adopted by the joint technical committee are circulated to national bodies for voting. Publication as an International Standard requires approval by at least 75 % of the national bodies casting a vote.</p>
<p>In exceptional circumstances, when the joint technical committee has collected data of a different kind from that which is normally published as an International Standard (“state of the art”, for example), it may decide to publish a Technical Report. A Technical Report is entirely informative in nature and shall be subject to review every five years in the same manner as an International Standard.</p>
<p>Attention is drawn to the possibility that some of the elements of this document may be the subject of patent rights. ISO and IEC shall not be held responsible for identifying any or all such patent rights.</p>
<p>ISO/IEC TR 24772-10, was prepared by Joint Technical Committee ISO/IEC JTC 1, <em>Information technology</em>, Subcommittee SC 22, <em>Programming languages, their environments and system software interfaces</em>.</p>
<h1 id="introduction">Introduction</h1>
<div data-custom-style="zzHelp">
<p>This Technical Report provides guidance for the programming language C++, so that application developers using or considering C++ will be better able to avoid the programming constructs that lead to vulnerabilities in software written in the C++ language and their attendant consequences. This guidance can also be used by developers to select source code evaluation tools that can discover and eliminate some constructs that could lead to vulnerabilities in their software. This report can also be used in comparison with companion Technical Reports and with the language-independent report, TR 24772–1, to select a programming language that provides the appropriate level of confidence that anticipated problems can be avoided.</p>
</div>
<div data-custom-style="zzHelp">
<p>This technical report part is intended to be used with TR 24772–1, which discusses programming language vulnerabilities in a language independent fashion. It is also intended to be used with TR 24772-3, which discusses how the vulnerabilities introduced in TR 24772-1 are manifested in C, which is a subset of C++.</p>
</div>
<p>It should be noted that this Technical Report is inherently incomplete. It is not possible to provide a complete list of programming language vulnerabilities because new weaknesses are discovered continually. Any such report can only describe those that have been found, characterized, and determined to have sufficient probability and consequence.</p>
<div data-custom-style="Bibliography1">
<p><strong>Information Technology — Programming Languages — Guidance to avoiding vulnerabilities in programming languages — Vulnerability descriptions for the programming language C++</strong></p>
</div>
<h1 id="scope">1. Scope</h1>
<p>This Technical Report specifies software programming language vulnerabilities to be avoided in the development of systems where assured behaviour is required for security, safety, mission-critical and business-critical software. In general, this guidance is applicable to the software developed, reviewed, or maintained for any application.</p>
<p>Vulnerabilities described in this Technical Report document the way that the vulnerability described in the language-independent TR 24772–1 are manifested in C++.</p>
<h1 id="normative-references">2. Normative references</h1>
<p>The following referenced documents are indispensable for the application of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.</p>
<p>ISO/IEC 14882:2014 — <em>Programming Languages—C</em> ++</p>
<p>ISO/IEC TR24772–3 -- Information Technology — Programming Languages — Guidance to avoiding vulnerabilities in programming languages — Vulnerability descriptions for the programming language C</p>
<h1 id="terms-and-definitions-symbols-and-conventions">3. Terms and definitions, symbols and conventions</h1>
<h2 id="terms-and-definitions">3.1 Terms and definitions</h2>
<!-- TODO: needs formatting adjustment as of ISO word template document -->
<p>For the purposes of this document, the terms and definitions given in ISO/IEC 2382, in TR 24772–1, in 14882:2014 and the following apply. Other terms are defined where they appear in <em>italic</em> type.</p>
<p>The following terms are in alphabetical order, with general topics referencing the relevant specific terms.</p>
<p><u>3.1.1</u></p>
<p><u>TBD</u></p>
<p><u>3.1.2</u></p>
<p><u>access</u>:</p>
<p>An execution-time action, to read or modify the value of an object.</p>
<blockquote>
<p>Note 1: Where only one of two actions is meant, read or modify. Modify includes the case where the new value being stored is the same as the previous value. Expressions that are not evaluated do not access objects</p>
</blockquote>
<p><strong><u>3.1.3</u></strong></p>
<p>access protection</p>
<p><strong><u>alignment</u></strong><br />
requirement that objects of a particular type be located on storage boundaries with addresses that are particular multiples of a byte address.</p>
<p><strong><u>3.1.3</u></strong></p>
<p><strong><u>argument</u></strong><br />
the expression in the comma-separated list bounded by the parentheses in a function call expression, or a sequence of preprocessing tokens in the comma-separated list bounded by the parentheses in a function-like macro invocation</p>
<blockquote>
<p>Note 1: Also called actual argument</p>
<p>Note 2: An argument replaces a <em>formal parameter</em> as the call is realized.</p>
</blockquote>
<p><strong><u>3.1.4</u></strong></p>
<p><strong><u>behaviour</u></strong><br />
an external appearance or action</p>
<blockquote>
<p>Note 3: See: implementation-defined behavior, locale-specific behavior, undefined behavior, unspecified behaviour</p>
</blockquote>
<p><strong><u>3.1.5</u></strong></p>
<p><strong><u>bit</u></strong><br />
the unit of data storage in the execution environment large enough to hold an object that may have one of two values</p>
<p>Note: It need not be possible to express the address of each individual bit of an object.</p>
<p><strong><u>3.1.6</u></strong></p>
<p><strong><u>byte</u></strong><br />
the addressable unit of data storage large enough to hold any member of the basic character set of the execution environment</p>
<blockquote>
<p>Note: It is possible to express the address of each individual byte of an object uniquely. A byte is composed of a contiguous sequence of bits, the number of which is implementation-defined. The least significant bit is called the low-order bit; the most significant bit is called the high-order bit.</p>
</blockquote>
<p><strong><u>3.1.7</u></strong></p>
<p><strong><u>character</u></strong><br />
abstract member of a set of elements used for the organization, control, or representation of data</p>
<blockquote>
<p>Note: See: single-byte character, multibyte character, wide character</p>
</blockquote>
<p><strong><u>correctly rounded result</u></strong><br />
representation in the result format that is nearest in value, subject to the current rounding mode, to what the result would be given unlimited range and precision.</p>
<p>3.1.8</p>
<p><strong><u>class</u></strong><br />
<u>TBD</u></p>
<p><strong><u>3.1.9</u></strong></p>
<p><strong><u>concrete</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.10</u></strong></p>
<p><strong><u>diagnostic message</u></strong><br />
</p>
<p>message belonging to an implementation-defined subset of the implementation’s message output</p>
<p>Note: The C Standard requires diagnostic messages for all constraint violations.</p>
<p><strong>[3.1.11]</strong>{.ul}**<br />
</p>
<p><strong><u>dynamic dispatch</u></strong><br />
</p>
<p><u>TBD</u></p>
<p>3.1.12</p>
<p><strong><u>encapsulation</u></strong><br />
</p>
<p><u>TBD</u></p>
<p><strong><u>3.1.13</u></strong><br />
</p>
<p><strong><u>formal parameter</u></strong><br />
</p>
<p>object declared as part of a function declaration or definition that acquires a value on entry to the function, or an identifier from the comma-separated list bounded by the parentheses immediately following the macro name in a function-like macro definition.</p>
<p><strong>[3.1.14] hidden friends</strong><br />
</p>
<p>an available function or object that can only be accessed … (needs completion)</p>
<p>Note: explain the difference between C++ “hidden friends” “[hidden.friends] in the C++ standard” and the usage in this document.</p>
<p><strong><u>3.1.14</u></strong><br />
</p>
<p><strong><u>Implementation</u></strong><br />
</p>
<p>particular set of software, running in a particular translation environment under particular control options, that performs translation of programs for, and supports execution of functions in, a particular execution environment.</p>
<p><strong><u>3.1.15</u></strong><br />
</p>
<p><strong><u>implementation-defined behaviour</u></strong><br />
</p>
<p>unspecified behaviour where each implementation documents how the choice is made</p>
<p>Note: An example of implementation-defined behaviour is the propagation of the high-order bit when a signed integer is shifted right.</p>
<p><strong><u>3.1.16</u></strong><br />
</p>
<p><strong><u>implementation-defined value</u></strong><br />
</p>
<p>unspecified value where each implementation documents how the choice for the value is selected.</p>
<p><strong><u>3.1.17</u></strong><br />
</p>
<p><strong><u>implementation limit</u></strong><br />
</p>
<p>restriction imposed upon programs by the implementation.</p>
<p><strong><u>3.1.18</u></strong><br />
</p>
<p><strong><u>indeterminate value</u></strong><br />
</p>
<p>unspecified value or a trap representation.</p>
<p><strong><u>3.1.19</u></strong><br />
</p>
<p><strong><u>Inheritance</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.20</u></strong><br />
</p>
<p><strong><u>language type</u></strong><br />
</p>
<p>see block-structured language, comb-structured language (Non-responsive)</p>
<p><strong><u>3.1.21</u></strong><br />
</p>
<p><strong><u>locale-specific behaviour</u></strong><br />
</p>
<p>behaviour that depends on local conventions of nationality, culture, and language that each implementation documents</p>
<p>Note: An example, locale-specific behaviour is whether the islower() function returns true for characters other than the 26 lower case Latin letters.</p>
<p><strong><u>3.1.22</u></strong><br />
</p>
<p><strong><u>memory location</u></strong><br />
</p>
<p>an object of scalar[^1] type, or a maximal sequence of adjacent bit-fields all having nonzero width (Non-responsive)</p>
<blockquote>
<p>Note: A bit-field and an adjacent non-bit-field member are in separate memory locations. The same applies to two bit-fields, if one is declared inside a nested structure declaration and the other is not, or if the two are separated by a zero-length bit-field declaration, or if they are separated by a non-bit-field member declaration. It is not safe to concurrently update two bit-fields in the same structure if all members declared between them are also bit-fields, no matter what the sizes of those intervening bit-fields happen to be. For example a structure declared as</p>
</blockquote>
<p>struct {</p>
<p>char a;</p>
<p>int b:5, c:11, :0, d:8;</p>
<p>struct { int ee:8; } e;</p>
<p>}</p>
<p>contains four separate memory locations: The member a, and bit-fields d and e.ee are separate memory locations, and can be modified concurrently without interfering with each other. The bit-fields b and c together constitute the fourth memory location. The bit-fields b and c can’t be concurrently modified, but b and a, can be concurrently modified.</p>
<p><strong><u>3.23</u></strong><br />
</p>
<p><strong><u>multibyte character</u></strong><br />
</p>
<p>sequence of one or more bytes representing a member of the extended character set of either the source or the execution environment.</p>
<p>Note: The extended character set is a superset of the basic character set.</p>
<p><strong><u>3.1.24</u></strong><br />
</p>
<p><strong><u>namespace</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.25</u></strong><br />
</p>
<p><strong><u>object</u></strong><br />
</p>
<p>region of data storage in the execution environment, the contents of which can represent values</p>
<p>Note: When referenced, an object may be interpreted as having a particular type.</p>
<p><strong><u>3.1.26</u></strong><br />
</p>
<p><strong><u>overload</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.27</u></strong><br />
</p>
<p><strong><u>override</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.28</u></strong><br />
</p>
<p><strong><u>parameter</u></strong><br />
</p>
<p>(rewrite) See actual argument, argument, formal parameter (Non-responsive, needs definition)</p>
<p><strong><u>3.1.29</u></strong><br />
</p>
<p><strong>{Protected]{.ul}</strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.30</u></strong><br />
</p>
<p><strong><u>private</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.31</u></strong><br />
</p>
<p><strong><u>Public</u></strong><br />
</p>
<p>TBD</p>
<p>3.1.32</p>
<p>Pure</p>
<p><u>TBD</u></p>
<p><strong><u>3.1.33</u></strong><br />
</p>
<p><strong><u>recommended practice</u></strong><br />
</p>
<p>specification that is strongly recommended as being in keeping with the intent of the language standard, but that may be impractical for some implementations</p>
<p>**<u>3.1.34</u>((<br />
</p>
<p><strong><u>runtime-constraint</u></strong><br />
</p>
<p>requirement on a program when calling a library function</p>
<p><strong><u>3.1.35</u></strong><br />
</p>
<p><strong><u>single-byte character</u></strong><br />
</p>
<p>bit representation that fits in a byte (binary representation?)</p>
<p><strong><u>3.1.36</u></strong><br />
</p>
<p><strong><u>static</u></strong><br />
</p>
<p><u>TBD</u></p>
<p>**<u>3.1.37</u></p>
<p><strong><u>STL</u></strong><br />
</p>
<p><u>TBD</u></p>
<p><strong><u>3.1.38</u></strong><br />
</p>
<p><strong><u>standard library</u></strong><br />
</p>
<p>[TBD]</p>
<p><strong><u>3.1.39</u></strong><br />
</p>
<p><strong><u>template</u></strong><br />
</p>
<p>TBD</p>
<p><strong><u>3.1.40</u></strong><br />
</p>
<p><strong><u>trap representation</u></strong><br />
</p>
<p>object representation that need not represent a value of the object type</p>
<p><strong><u>3.1.41</u></strong><br />
</p>
<p><strong><u>undefined behaviour</u></strong><br />
</p>
<p>use of a non-portable or erroneous program construct or of erroneous data, for which the language standard imposes no requirements</p>
<blockquote>
<p>Note: Undefined behaviour ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message). An example of, undefined behaviour is the behaviour on integer overflow.</p>
</blockquote>
<p><strong><u>3.1.42</u></strong><br />
</p>
<p><strong><u>unspecified behaviour</u></strong><br />
</p>
<p>use of an unspecified value, or other behaviour where the language standard provides two or more possibilities and imposes no further requirements on which is chosen in any instance</p>
<blockquote>
<p>Note: For example, unspecified behaviour is the order in which the arguments to a function are evaluated.</p>
</blockquote>
<p><strong><u>3.1.43</u></strong><br />
</p>
<p><strong><u>unspecified value</u></strong><br />
</p>
<p>valid value of the relevant type where the language standard imposes no requirements on which value is chosen in any instance</p>
<blockquote>
<p>Note: An unspecified value cannot be a trap representation.</p>
</blockquote>
<p><strong><u>3.1.44</u></strong><br />
</p>
<p><strong><u>value</u></strong><br />
</p>
<p>precise meaning of the contents of an object when interpreted as having a specific type (specific type or specified type?)</p>
<blockquote>
<p>Note: See implementation-defined value, indeterminate value, unspecified value, trap representation</p>
</blockquote>
<p><strong><u>3.1.45</u></strong><br />
</p>
<p><strong><u>virtual</u></strong><br />
</p>
<p><u>TBD</u></p>
<p><strong><u>3.1.45</u></strong><br />
</p>
<p><strong><u>wide character</u></strong><br />
</p>
<p>bit representation capable of representing any character in the current locale</p>
<p><span data-custom-style="annotation reference"></span></p>
<h1 id="language-concepts">4. Language concepts</h1>
<p><u><em>This clause requires a rewrite. See C++ Core Guidelines CPL for a good explanation of the differences</em>.</u></p>
<p>C++ is a strongly- and statically-typed language: all variables and expressions must have a type. C++ also permits implicit and explicit conversions between types.</p>
<p>C++ has a rich type system with many nuances. In addition to the C base types (int, long, float, double, char, and arrays with their C-style vulnerabilities), C++ provides the following:</p>
<ul>
<li><pre><code>Distinct types for char, signed char, unsigned char</code></pre></li>
<li><pre><code>bool with a true Boolean context</code></pre></li>
<li><pre><code>enum with fixed underlying type</code></pre></li>
<li><pre><code>Classes as the primary user-defined types</code></pre></li>
<li><pre><code>Arrays</code></pre></li>
<li><pre><code>References in addition to pointers</code></pre></li>
<li><pre><code>Parameterized types</code></pre></li>
</ul>
<p>Many vulnerabilities can be mitigated more easily by using library facilities rather than the base language types. (e.g. std::string rather than char*)</p>
<ul>
<li><pre><code>Use of the `explicit`{.cpp} keyword for constructors and conversion
operators</code></pre></li>
<li><pre><code>`operator bool()`{.cpp} discussion</code></pre></li>
<li><pre><code>many built-in implicit conversions, refer to TR 24772-3 clause 6.2
and other clauses (C)</code></pre></li>
<li><pre><code>conversion to bool and null pointer conversions</code></pre></li>
<li><pre><code>legacy code operator void\* - change to explicit operator bool</code></pre></li>
<li><pre><code>C-style casts break type safety.</code></pre></li>
<li><pre><code>static_cast</code></pre></li>
<li><pre><code>explicit casts highlight mismatches between the design and
implementation.</code></pre></li>
<li><pre><code>const and volatile</code></pre></li>
<li><pre><code>constexpr -- needs a writeup -- (in C++:11 , encouraged heavy stack
use and possible exhaustion).</code></pre></li>
</ul>
<p>Narrowly tailored number-like class types, such as time_point and duration, improve safety by providing only safe and appropriate operations. User-defined types tailored to a particular use case can provide additional safety.</p>
<p>C++ was initially defined as a syntactic superset of the C programming language: adding object oriented features such as classes, encapsulation, dynamic dispatch, namespaces and templates. It was a “syntactic superset” because whilst there is a core of C++ that is syntactically identical to C, it has always been the case that there are subtle semantic differences between the two, for example:</p>
<ul>
<li><p>Historically, C permitted the use of a function before its declaration (though this is now deprecated in C) . This is illegal in C++</p></li>
<li><p>Where a struct is defined within another struct, in C the inner declaration is in effect made at file scope, so the definition is available for use later in the program. In C++, the inner declaration name is qualified by that of the parent, so without qualification, the inner struct cannot be used later in the program, as in the following example</p></li>
</ul>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S1 {</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">struct</span> S2 {...} m1;</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>   ...</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S2 v1; /\* legal in C <span class="kw">not</span> C++ \*/</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>S1::S2 v2 <span class="co">// legal in C++ not C</span></span></code></pre></div>
<p>Subsequently, the two languages have diverged, both adding features not present in the other. Not withstanding that, there is still a significant syntactic and semantic overlap between C and C++, so the starting point for this report has been the equivalent for C. However, in many cases, the additional features of C++ provide mechanisms for avoiding the vulnerabilities inherited from C, and these are reflected in the following sections.</p>
<p><em>Include discussions of Object orientation, <strong>static</strong>, and <strong>const,</strong> scoped enumerations</em></p>
<!-- parts added -->
<p>4.1 Overview 4.2 Type system implicit conversions templates? 4.3 Symbol Lookup and resolution special members templates? 4.4 Lifetime initialization 4.4 Error handling (includes exceptions and undefined behaviour(?)) abstract machine standard library 4.5 Concurrency</p>
<p>$include parts/4.1.Lifetime.md $include parts/4.2.SymbolLookupResolution.md $include parts/4.3.Concurency.md</p>
<p>4.2 Type system A particular area that is misunderstood is integral promotion. It can be confusing because promotion can result in changing the internal representation of an unsigned type to/from a signed type. For expressions formed with operands of unscoped enumeration type or integral types with a conversion rank smaller. than <code class="sourceCode cpp"><span class="dt">int</span></code>, <em>integral promotion</em> occurs before further implicit conversions happen. <em>Integral promotion</em> on unsigned types can convert these to the signed type <code class="sourceCode cpp"><span class="dt">int</span></code>. Undefined behavior can occur due to signed integer arithmetic overflow even when the operands are of an unsigned type. Assume for example, - signed and unsigned short occupies 16 bits - signed and unsigned int occupies 32 bits then the following code causes undefined behavior:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">unsigned</span> <span class="dt">short</span> <span class="at">const</span> x = <span class="bn">0xfff0</span>;</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>   x * x;                           <span class="co">// signed integer overflow, result will not fit in signed 32 bit int</span></span></code></pre></div>
<p>Note: C++ also uses the term promotion to apply to a subset of conversion that apply to intergral and floating point types.</p>
<p>Implicit, i.e., automatic, conversions to a type <code>T</code> can be performed, for example, in the following situations:</p>
<ol type="a">
<li><p>If the declaration, <code class="sourceCode cpp">T t=e;</code>, is defined for some expression, <code>e</code>, and some invented variable, <code>t</code> [C++17, Clause 7 [conv], para 3];</p></li>
<li><p>In expressions involving operands of operators (e.g., <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, etc.) subject to the requirements of each operators' operands [C++20, Clause 7.3 [conv], para 2.1];</p></li>
<li><p>For example, the expression, <code>5 + 6.5</code>, has operands of type <code class="sourceCode cpp"><span class="dt">int</span></code> and <code class="sourceCode cpp"><span class="dt">double</span></code>. Per language rules, the integer operand will be implicitly converted to <code class="sourceCode cpp"><span class="dt">double</span></code>, i.e., the expression becomes <code class="sourceCode cpp"><span class="dt">double</span>(<span class="dv">5</span>) + <span class="fl">6.5</span></code>, i.e., <code>5.0 + 6.5</code>.</p></li>
<li><p>In boolean contexts, such as</p>
<ul>
<li>operands of logical operators,</li>
<li>the condition of the conditional operator, and</li>
<li>the condition of the if-statement or loop-statements, contextual conversion to bool implicitly happens from arithmetic types, pointers, and classes with a possibly explicit <code>operator bool()</code>. [C++17, Clause 7 [conv], para 4];</li>
</ul></li>
<li><p>In the expression of a switch statement: the implicit conversion will be to an integral type [C++17, Clause 7 [conv], para 2.3];</p></li>
<li><p>In an expression that initializes an object (e.g., an argument to a function call, the expression in a return statement) [C++17, Clause 7 [conv], para 2.4];</p></li>
<li><p>When a non-<code class="sourceCode cpp"><span class="kw">explicit</span></code> class/struct/union constructor can be invoked on an object resulting in some desired type, <code>T</code>, from initial objects passed to the constructor; and</p></li>
<li><p>When a conversion operator has not been declared <code class="sourceCode cpp"><span class="kw">explicit</span></code>, it can be implicitly invoked on an object resulting in some desired type, <code>T</code>, from an initial type.</p></li>
</ol>
<h1 id="avoiding-programming-language-vulnerabilities-in-c">5. Avoiding programming language vulnerabilities in C++</h1>
<blockquote>
<p>In addition to the generic programming rules from ISO/IECTR 24772-1 clause 5.4, additional rules from this section apply specifically to the C++ programming language. The recommendations of this section are restatements of recommendations from clause 6, but represent ones stated frequently, or that are considered as particularly noteworthy by the authors. Clause 6 of this document contains the full set of recommendations, as well as explanations of the problems that led to the recommendations made.</p>
</blockquote>
<blockquote>
<p>Every guidance provided in this section, and in the corresponding Part section, is supported by material in Clause 6 of this document, as well as other important recommendations.</p>
</blockquote>
<blockquote>
<p><strong><em>TBD</em></strong></p>
</blockquote>
<table style="width:94%;">
<colgroup>
<col style="width: 44%" />
<col style="width: 5%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th>Index</th>
<th></th>
<th>Reference[]{custom- style=“annotation reference”}</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>2</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>3</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>4</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>5</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>6</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Need to consider C++-11, 14 and 17.</p>
<h1 id="specific-guidance-for-c-vulnerabilities">6. Specific Guidance for C++ Vulnerabilities</h1>
<h2 id="general">6.1 General</h2>
<p>This clause contains specific advice for C++ about the possible presence of vulnerabilities as described in TR 24772-1, and provides specific guidance on how to avoid them in C++ code. This section mirrors TR 24772-1 clause 6 in that the vulnerability “Type System [IHN]” is found in 6.2 of TR 24772–1, and C++ specific guidance is found in clause 6.2 and subclauses in this TR.</p>
<p>As part of its design (and with few exceptions), C++ has a common subset with the complete C language. For code portions written in the common subset, the vulnerabilities described and the advice given in ISO/IEC TR 24772-3:2020, <em>Part 3 – Vulnerability descriptions for the programming language C</em>, apply, except when this document provides refined advice. The following subclauses usually do not further acknowledge the issues from the subset since those have been adequately addressed in the referenced document. However, C++ provides mechanisms to mitigate many of the problems that arise. Please refer to the respective clauses of this document for these mitigations and related guidelines.</p>
<h2 id="IHN">6.2 Type System [IHN]</h2>
<h3 id="applicability-to-language">6.2.1 Applicability to language</h3>
<p>C++ is a statically typed language. In some ways, C++ is both strongly and weakly typed, as it requires all objects/expressions to have a type, but allows for some implicit conversions of values from one type to another type. The following cases require special consideration:</p>
<ul>
<li><p>Most notably are the implicit conversions between arithmetic types (including <code class="sourceCode cpp"><span class="dt">bool</span></code>) that silently might truncate values or have loss of precision (for details see <a href="#FLC">Conversion Errors [FLC]</a>). This shared vulnerability includes <em>integral promotion</em> from small (unsigned) integer types (e.g. <code class="sourceCode cpp"><span class="dt">unsigned</span> <span class="dt">char</span></code>) to the signed integer type <code class="sourceCode cpp"><span class="dt">int</span></code> that can lead to operations with undefined behavior, where unsigned arithmetic is defined with modulo semantics.</p></li>
<li><p>The standard types used to represent text characters ( <code>char</code>, <code>char8_t</code>, <code>wchar_t</code>, <code>char16_t</code>, <code>char32_t</code>) are treated as arithmetic types even when used to represent text and thus are subject to implicit conversions to and from other arithmetic types. Using values of character types in arithmetic expressions, especially together with other types can be confusing. Furthermore, using values of such types or sequences of such values with their corresponding string types with relational operators might not provide an expected sorting order, depending on the language or the encoding the text represents. Libraries for text processing might take such locale-specific or text-representation-specific behavior into account, whereas the built-in operators of the language don’t.</p></li>
<li><p>C++ considers implicit conversions during function overload resolution, when there is not a direct match of argument type with parameter type. Sometimes such conversions lead to ambiguities, which result in a compile error. But there can also be a single best matching overload that does not correspond to developer’s expectation including conversion of argument types (see <a href="#YOW">Identifier Name Reuse [YOW]</a>)</p></li>
<li><p>Values of an unscoped enumeration convert to their underlying integral type in arithmetic expressions (see <a href="#CCB">Enumerator Issues [CCB]</a>).</p></li>
<li><p>Built-in array types as well as function types will decay to a pointer type. For array types this is problematic, because the array’s extent is lost (see <a href="#XYZ">Unchecked Array Indexing [XYZ]</a> and <a href="#RVG">Pointer Arithmetic [RVG]</a>)</p></li>
<li><p>Pointer types implicitly convert to pointer-to-void (see <a href="#HFC">Pointer Type Conversions [HFC]</a>).</p></li>
<li><p>Pointer and reference types referring a derived class object can implicitly convert to a pointer or reference to one of its public base classes respectively (see <a href="#BKK">Polymorphic Variables [BKK]</a>).</p></li>
<li><p>User-defined class types can define conversion operators and converting constructors that can be called with a single argument. If these member functions are not declared with the keyword <code class="sourceCode cpp"><span class="kw">explicit</span></code> they are eligible for use in implicit conversions.</p></li>
<li><p>Implicit conversions from an arithmetic type to <code class="sourceCode cpp"><span class="dt">bool</span></code> often indicate a missing comparison. Conversions from <code class="sourceCode cpp"><span class="dt">bool</span></code> in arithmetic expression can obfuscate code. For example, the following code relies on <code class="sourceCode cpp"><span class="kw">false</span></code> converting to/from zero and <code class="sourceCode cpp"><span class="kw">true</span></code> to one and from non-zero:</p></li>
</ul>
<div class="sourceCode" id="cb83"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> fluxcompensation(<span class="dt">double</span> flux, <span class="dt">bool</span> compensate){</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (flux) { <span class="co">// double to bool conversion</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> delta = compute_delta();</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="at">const</span> compensate_v = <span class="fl">1.4</span>;</span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> flux + delta * compensate; <span class="co">// bool to double conversion</span></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>  } </span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="fl">1.</span>;</span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<ul>
<li>In a boolean context, conversions that would not occur implicily can take place, specifically, a pointer-to-bool conversion and the application of an <code class="sourceCode cpp"><span class="kw">explicit</span> <span class="kw">operator</span> <span class="dt">bool</span>()</code> conversion operator. These conversions are idiomatic C++ in boolean contexts; however, some prefer explicit tests to show intent, for example, <code class="sourceCode cpp"><span class="cf">if</span> (p) { *p = <span class="dv">42</span>; }</code> vs. <code class="sourceCode cpp"><span class="cf">if</span> (p != <span class="kw">nullptr</span>) { *p = <span class="dv">42</span>; }</code>.</li>
</ul>
<p>Note that type aliases (<code class="sourceCode cpp"><span class="kw">using</span></code>, <code class="sourceCode cpp"><span class="kw">typedef</span></code>) do not define a different type from their alias just a different name and thus do not incur any conversion between the alias and the aliased type.</p>
<p>Instead of using the built-in arithmetic types or generic library types such as <code class="sourceCode cpp"><span class="bu">std::</span>string</code> for your domain values, C++ allows to wrap them in user-defined-class types as so-called <em>strong types</em>. For integral values, <code class="sourceCode cpp"><span class="kw">enum</span> <span class="kw">class</span></code> types can also be used. Strong types provide only those operator overloads and conversions for each such type that make sense in the application domain. User-defined-literal operators help with providing constants of appropriate strong types. Such strong types provide full control of conversions and operations available, avoiding semantically unsound operations that the built-in or other generic types might provide.</p>
<p>For example, a very simple strong type representation of temperature values can be implemented as follows:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Celsius {</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> value;</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Fahrenheit {</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> value;</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>Fahrenheit convert_to_fahrenheit(Celsius c){</span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> { <span class="dv">9</span>*c.value/<span class="dv">5</span>+<span class="dv">32</span>};</span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a><span class="co">//...</span></span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a>Celsius wrong = convert_to_fahrenheit({<span class="fl">20.</span>}); <span class="co">// doesn&#39;t compile</span></span></code></pre></div>
<p>In a realistic scenario using a library for strong type support eases the definition and use of strong types.</p>
<h3 id="guidance-to-language-users">6.2.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance contained in ISO/IEC TR 24772-1:2019, 6.2.5. and the guidance provided in the different related sections of this document.</p></li>
<li><p>Be aware of the rules of the type system, overload resolution, and implicit conversions to avoid vulnerabilities.</p></li>
<li><p>Enable compiler warnings regarding implicit conversions and/or use static analysis tools that provide such warnings.</p></li>
<li><p>Define any constructor of a class that can be called with a single argument of a different type as <code class="sourceCode cpp"><span class="kw">explicit</span></code>.</p></li>
<li><p>Define any conversion operator as <code class="sourceCode cpp"><span class="kw">explicit</span></code></p></li>
<li><p>Use strong types for domain values instead of the built-in types. On system boundaries, e.g., for input, convert a read value immediately to the appropriate strong type.</p></li>
<li><p>When defining variables of arithmetic type, use a braced-initializer to prevent a potential narrowing conversion from the initial value’s type.</p></li>
<li><p>Refrain from using character types in arithmetic or relational expressions. Use an appropriate text processing library instead for character classification, conversion, comparison, and further processing.</p></li>
<li><p>Use a consistent style in a project with respect to implicit pointer conversions in boolean contexts.</p></li>
</ul>
<h2 id="bit-representations-str">6.3 Bit Representations [STR]</h2>
<h3 id="applicability-to-language">6.3.1 Applicability to language</h3>
<p>This vulnerabilities described in TR24772-1 clause 6.3 is applicable to C++. The “endianness” of integer types and packing of bit fields are implementation-defined properties and not portable.</p>
<p>The standard library type <code class="sourceCode cpp"><span class="bu">std::</span>endian</code> allows to portably check the endianness of a platform and code can use this information to operate on individual bytes of a machine word in the correct order.</p>
<p>There is no portable mapping from bitfields in a struct to individual bits in a machine word. Therefore, C++ bitfields should not be used to directly map to bits in hardware, even though the compiler provides suitable mapping and manipulation operations. A further complication is that accessing a bitfield can often not easily be performed atomically, because the non-participating bits of a memory location need to be read before the relevant bits can be mutated through masking, and the whole memory location has to be written again. It is possible to simulate bitfields with a defined layout through library class types that implement the required masking operations.</p>
<p>For individual bits <code class="sourceCode cpp"><span class="bu">std::</span>bitset&lt;N&gt;</code> and <code class="sourceCode cpp"><span class="bu">std::</span>vector&lt;<span class="dt">bool</span>&gt;</code> can provide suitable representations at run time, but don’t support a direct mapping to machine words. However, be aware that <code class="sourceCode cpp"><span class="bu">std::</span>vector&lt;<span class="dt">bool</span>&gt;</code> does not in general behave like a <code>std::vector</code> which can cause generic code to misbehave.</p>
<p>C++ provides a rich set of bitwise operators that can be used to address the issues of bit manipulation in a portable way. However, the shift operation can result in undefined behavior when shifting by a negative or too large value, or when shifting a signed operand. It is advisable to use bit operations only on appropriate unsigned integral types with a known width while being careful of potential integral promotion that might change a small unsigned operand type to be promoted to a signed integer type. When bitwise memory operations are needed, it is good practice to encapsulate such operations in a class type’s member functions.</p>
<p>For representing individual bitmasks values employed in bit operations, it is advisable to put the corresponding named constants in an enumeration type with the appropriate underlying type for easier recall.</p>
<p>While a bit shift of an integral value can be viewed as a multiplication or division by a power of two, it should not be used in arithmetic expression to implement such an operation. Compilers will automatically implement such a multiplication in the most efficient way, there is no need to obfuscate multiplication and division as shift operations.</p>
<p>Except for specific situations (trivial types), objects of class type can not be assumed to have a layout appropriate to be manipulated on a byte or bitwise level. Depending on the size and alignment of its data members a class type might have padding bytes between members. The absence of padding in a trivially copyable type <code>T</code> can be checked with a <code>static_assert(std::has_unique_object_representations_v&lt;T&gt;)</code>.</p>
<p><code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code> can be used to reinterpret suitably sized trivial types on a bitwise level, i.e., for accessing the binary representation of a floating point value. However, for types with padding bits that do do not participate in an object’s value representation, the corresponding bits in a <code>bit_cast</code> result have indeterminate values. Malicious code could use such padding bits as a <em>secret channel</em>.</p>
<p>See C++ Core Guidelines ES101 use unsigned types for bit manipulation.</p>
<h3 id="guidance-to-language-users">6.3.2 Guidance to language users</h3>
<p>In addition to the advice of ISO/IEC TR 24772-3:2020 clause 6.3.2:</p>
<ul>
<li><p>Avoid the use of shift operations to implement multiplications or division by powers of two.</p></li>
<li><p>Use built-in bitwise operations only with operands of unsigned integral types or enums with an unsigned underlying type.</p></li>
<li><p>When performing bitwise operations on operands of an unsigned type that gets promoted to a signed integral type, cast the result to the corresponding unsigned type immediately.</p></li>
<li><p>Ensure that the right-hand operand of a shift operation is not negative or greater than the number of bits the left-hand operand. Use static analysis tools or other means to prove that the right hand operand of the shift is not out of bounds.</p></li>
<li><p>Prefer <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code> over other means such as <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> to access the binary representation of an object.</p></li>
<li><p>Prefer abstractions in a class type encapsulating bit manipulations using unsigned types of well-defined width, such as <code class="sourceCode cpp"><span class="bu">std::</span>bitset</code>, over non-portable bitfields.</p></li>
<li><p>Don’t use <code>std::memcpy</code> or <code>std::memmove</code> to copy objects. Those operations will copy padding bits, if present.</p></li>
</ul>
<h2 id="floating-point-arithmetic-plf">6.4 Floating-point Arithmetic [PLF]</h2>
<h3 id="applicability-to-language">6.4.1 Applicability to language</h3>
<p>C++ has the vulnerability as described in ISO/IEC TR 24772-1 clause 6.4. The C++ standard assumes IEC 60559 if <code class="sourceCode cpp"><span class="bu">std::</span>numeric_limits<span class="bu">\</span>&lt;T&gt;::is_iec559</code> is true for the types in use. In the absence of this, C++ makes few guarantees about the behaviour of floating point numbers.</p>
<p>Sorting floating point numbers with the built-in operators violates the preconditions of sorting predicates in the presence of NaN values and may raise floating point errors. The default sorting predicate <code>std::less</code> is suspect to this precondition violation, resulting in undefined behavior when sorting a range of floating point values that contains NaNs.</p>
<h3 id="guidance-to-language-users">6.4.2 Guidance to language users</h3>
<ul>
<li><p>Follow the general advice of ISO/IEC TR 24772-1:2019 clause 6.4.5</p></li>
<li><p>Verify compliance to ISO/IEC/IEEE 60559:2011 at compile time through <code class="sourceCode cpp"><span class="bu">std::</span>numeric_limits&lt;T&gt;::is_iec559</code>. Other numeric characteristics such as <code>min()</code>, <code>max()</code>, existence of NaNs, <code>has_denorm</code>, and infinities can be determined in this class template.</p></li>
<li><p>Be aware that the default comparisons in the standard library may produce wrong results when used on floating point members. In particular <code class="sourceCode cpp"><span class="bu">std::</span>less</code> is not a total order; <code class="sourceCode cpp"><span class="bu">std::</span>equal</code> is not equivalent to substitutability (NaNs compare unequal to themselves, but neither less nor greater, and negative zero compares equal to positive zero).</p></li>
</ul>
<h2 id="CCB">6.5 Enumerator Issues [CCB]</h2>
<h3 id="applicability-to-language">6.5.1 Applicability to language</h3>
<h4 id="references">6.5.1.1 References</h4>
<p>AUTOSAR A7-2-2 Enumeration base type shall be explicitly defined</p>
<h4 id="applicability">6.5.1.2 Applicability</h4>
<p>C++ offers enums for defining distinct types composed of sets of related named constants. The type of each enum is different from all other types. Each enum has an underlying integral type, which the user can specify. Since enums are distinct types, the user can only assign values to an object of enumerated type that are values of that enumerated type. C++ does not support implicit conversion of an int to an enum, therefore preventing <code>A = B + C</code> where <code>A</code>, <code>B</code> and <code>C</code> are variables of the same enum, unless an overloaded operator “<code>+</code>” is provided.</p>
<p>C++ enums can be scoped (<code>enum class</code>) or unscoped (<code>enum</code>). C++ supports implicit conversion of an unscoped enum to an integer by integral promotion</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Color : <span class="dt">short</span> {red, green, blue};</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="dt">short</span> i = red; <span class="co">// implicit conversion</span></span></code></pre></div>
<p>C++ does not support implicit conversion of a scoped enum to an int. Hence, operations such as <code>++</code>, <code>+</code>, <code>&lt;</code> and enums used as array indices require explicit definitions.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> Color : <span class="dt">short</span> {red, green, blue};</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="dt">short</span> i = red; <span class="co">// error -- no implicit conversion</span></span></code></pre></div>
<p>Where unscoped enums are used as array indexes and do not have a user-specified mapping to an underlying representation, there will be “holes” as documented in TR24772-1 clause 6.6.</p>
<p>Note that unscoped enumeration types implicitly promote their underlying type and can be used as the index of an array without a cast, with all of the issues described in TR 24772-1 clause 6.5.</p>
<p>From C++ 2017 forward, casting a value to an enumeration type is undefined behavior unless the source value is within the range of values of an enumeration type. See CERT INT50-CPP.</p>
<h3 id="guidance-to-language-users">6.5.2 Guidance to language users</h3>
<ul>
<li><p>Use <em>scoped enumerations</em> in preference to the C-style <em>unscoped enumerations</em> for related values, especially at namespace-level.</p>
<ul>
<li><pre><code>  See CPP Core Guidelines Enum.3 &quot;Prefer class enums over &#39;plain&#39;</code></pre>
<p>enums".</p></li>
<li><pre><code>  See AUTOSAR A7-2-3 &quot;Enumerations shall be declared as scoped</code></pre>
<p>enum classes"</p></li>
<li><pre><code>  See MISRA C++ 28.5.5</code></pre></li>
</ul></li>
<li><p>Use <code class="sourceCode cpp"><span class="kw">constexpr</span></code> to declare a set of unrelated values, such as <code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">size_t</span> bufferLen = <span class="dv">128</span>;</code> <code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">char</span> special_char = <span class="ch">&#39;a&#39;</span>;</code></p></li>
<li><p>Provide operators and functions that perform the arithmetic operations and conversions appropriate to the enumerated type. Outside those functions, avoid directly performing arithmetic or conversions on objects of the enumerated type.</p>
<ul>
<li><pre><code>  See CPP Core Guidelines Enum.4 &quot;Define operations on</code></pre>
enumerations for safe and simple use"</li>
</ul></li>
<li><p>If <em>unscoped enumerations</em> are used, follow the general advice of TR 24772-3 clause 6.5.2 as well as the following:</p>
<ul>
<li><pre><code>  Avoid casting arbitrary integer values to enumeration type. If it is</code></pre>
<p>unavoidable, use braced initialization instead of C-style or static casts<br />
<code>e_type{7};</code></p>
<pre><code>  &gt; See CERT INT50-CPP &quot;Do no Cast to an out-of-range-value&quot;</code></pre></li>
</ul></li>
<li><pre><code>Obtain the underlying enumeration value, by casting the enumeration</code></pre>
<p>to its underlying type, e.g.,</p>
<blockquote>
<p><code class="sourceCode cpp"><span class="kw">enum</span> <span class="dt">e_type</span>{A, B, C};</code></p>
</blockquote>
<blockquote>
<p><code class="sourceCode cpp"><span class="kw">auto</span> value = <span class="kw">static_cast</span>\&lt;<span class="bu">std::</span>underlying_type_t<span class="bu">\</span>&lt;<span class="dt">e_type</span>\&gt;\&gt;(B);</code></p>
</blockquote></li>
</ul>
<h2 id="FLC">6.6 Conversion Errors [FLC]</h2>
<h3 id="applicability-to-language">6.6.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO IEC 24772-1 clause 6.6 applies to C++. C++ includes some of the conversion mechanisms of C documented in TR 24772-3 clause 6.6.1, however C++ type conversion mechanisms differ from the mechanisms of C, as documented in ISO IEC 14882 Annex C. This subclause highlights differences where C++ provides mitigations of potential vulnerabilities found in C.</p>
<p>In C++, some conversions are explicit while others are implicit. Conversions can change the size of a type, whether or not the type is signed, and possibly other properties of the type. A narrowing conversion is when the target type cannot represent all the values of the original type. Many errors are associated with implicit conversions. For a comprehensive overview see clause 7.3 [conv] of [C++20]</p>
<p>Explicit conversions use one of the mechanisms provided by C++ through a</p>
<ul>
<li>type conversion operator
<ul>
<li><code class="sourceCode cpp"><span class="kw">static_cast</span></code>,</li>
<li><code class="sourceCode cpp"><span class="kw">const_cast</span></code>,</li>
<li><code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code>,</li>
<li><code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>),</li>
</ul></li>
<li>constructor notation with
<ul>
<li>parentheses (e.g., <code class="sourceCode cpp"><span class="dt">double</span>(<span class="dv">42</span>)</code>) or</li>
<li>braces (e.g., int{‘a’}) which prevents narrowing conversions, or</li>
</ul></li>
<li>a C-style cast (<code class="sourceCode cpp">(<span class="dt">int</span>)<span class="fl">3.14</span></code>).</li>
</ul>
<p>In C++, a C-style cast is defined in terms of the C++ cast operators <code class="sourceCode cpp"><span class="kw">const_cast</span></code>, <code class="sourceCode cpp"><span class="kw">static_cast</span></code>, and <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>. In some cases, it is unspecified which cast is used, for example when a cast operation involves an incomplete type, a <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> may be used for the conversion which can produce an incorrect result.</p>
<p>Unlike C++'s other cast notations, <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> relies on run-time type information generated by the compiler to ensure the requested conversion is valid. If it is not valid, then <code class="sourceCode cpp"><span class="kw">nullptr</span></code> is returned for pointer types, otherwise an exception is thrown. [C++17, Clause 8.2.7 [expr.dynamic.cast]] Thus, <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> is safer to use when converting down a hierarchy where the base class has virtual member functions. (see <a href="#HFC">Pointer Type Conversions [HFC]</a> and <a href="#BKK">Polymorphic Variables [BKK]</a>)</p>
<p>An implicit conversion to a class type can occur for a class with constructors that can be invoked with a single argument, as in the following example:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>      {<span class="kw">public</span>:</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>        C(<span class="dt">int</span> x=<span class="dv">10</span>, <span class="dt">float</span> y=<span class="dv">0</span>){...}</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>      };</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo(C param){...}</span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar( <span class="dt">bool</span> b){ foo(b);} </span></code></pre></div>
<p>In the example above, it can be surprising that foo() is called with a boolean.</p>
<p>Note that this implicit conversion to a class object is the default behaviour of constructors that can be called with a single parameter. The <code class="sourceCode cpp"><span class="kw">explicit</span></code> keyword can be used before the constructor to prevent this happening, as in:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">explicit</span> C(<span class="dt">int</span> x=<span class="dv">10</span>, <span class="dt">float</span> y=<span class="dv">0</span>){...}</span></code></pre></div>
<p>The call <code class="sourceCode cpp">foo(b)</code> would now not be legal.</p>
<p>Implications of casting away <code class="sourceCode cpp"><span class="at">const</span></code> using <code>const_cast</code> are described in section <a href="#UJO">Modifying Constants [UJO]</a>.</p>
<p>Other implicit conversions can sometimes result in data loss or erroneous values. This is an issue with implicit conversions since they are automatic: the programmer does not explicitly write code to do the conversion. For example, a common problem is mixing signed and unsigned integral types in arithmetic expressions. This can become a problem since the ranges of signed and unsigned integer types differ and the behaviour of signed integer arithmetic on overflow is undefined whereas unsigned integer arithmetic wraps on overflow. See subclause 4.2 for a discussion of integral promotions in C++.</p>
<p>The issue is not restricted to narrowing conversions, as shown below:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">long</span> l_64 = i_32 + i_32; <span class="co">// &#39;+&#39; operation preformed in 32 bits</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>                         <span class="co">// widened after the operation completes (and potentially overflows). </span></span></code></pre></div>
<p>This can be avoided by converting at least one operand to the wider type as part of the operation. Note that <code class="sourceCode cpp"><span class="kw">auto</span></code> directs the compiler to use the appropriate type based on the initializer expression. Subsequent use of the auto object (such as in standard mathematical operations) can lead to implicit conversions that are not obvious in the context local to the expression. Additional problems arise as a result of implicit conversions between <code>bool</code> and other types, thus hiding the fact when a wrong operator is used accidentally:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f(<span class="dt">unsigned</span> i, <span class="dt">unsigned</span> j)</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (i &gt; <span class="dv">1</span>) &amp; (j = <span class="dv">1</span>); <span class="co">// (&gt;&gt;, &amp;&amp;, ==) ?</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In the example above, all combinations of the corresponding operators will compile with different resulting types and results.</p>
<p>Similar issues arise in conversions between character types (char, char8_t, …) and other types. Character types are provided to represent text in whatever character representation is needed.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f(<span class="dt">char</span> c)</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (c &lt; <span class="dv">0</span>) <span class="co">// may be always false on some platforms.</span></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>    {}</span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In addition to the use of <em>strong types</em> (see <a href="#IHN">Type System [IHN]</a>), the implicit conversions and multitude of possible operations of integral types can be mitigated by using scoped enumeration types with the corresponding integer type as its underlying type. For example, <code class="sourceCode cpp"><span class="bu">std::</span>byte</code> is defined to address individual <code class="sourceCode cpp"><span class="dt">unsigned</span> <span class="dt">char</span></code> elements (bytes) in memory without participating in arithmetic or bitwise operations.</p>
<p>Because C++ allows function and operator overloading, the effect of implicit conversions provides an additional mechanism of failure, by selecting an unwanted overload during overload resolution due to implicit conversions. This can influence failure modes with lookup as described in section <a href="#BJL">Namespace Issues [BJL]</a>. // Add overload resolution reference!!</p>
<p>C++ also provides a library function <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code>. This function provides the ability to preserve the bit representation when converting between unrelated types. If such is meaningful, then <code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code> reduces the risk of some undefined behaviours compared with other type punning approaches such as casts or unions.</p>
<h3 id="guidance-to-language-users">6.6.2 Guidance to language users</h3>
<p>In addition to the general advice of ISO/IEC 24772-1 clause 6.6.5:</p>
<ul>
<li><p>Avoid casts and type punning (see C++ Core guidelines ES.48), treat every cast as a candidate for refactoring.</p></li>
<li><p>Avoid narrowing conversions. (see C++ Core Guidelines ES.46)</p></li>
<li><p>Prefer braces over parentheses for initialization or explicit conversions from numeric types to prevent narrowing. (see C++ Core Guidelines ES.23 and ES.64)</p></li>
<li><p>Avoid C-style casts. Use C++ type conversion operators instead, as they document intent and disallow some unsafe conversions. (see C++ Core Guidelines ES.49)</p></li>
<li><p>Declare <code class="sourceCode cpp"><span class="kw">explicit</span></code></p>
<ul>
<li>constructors callable with a single argument; and</li>
<li>conversion functions. (see C++ Core guidelines C.46 and C.164)</li>
</ul></li>
<li><p>Don’t cast away <code class="sourceCode cpp"><span class="at">const</span></code>. See subclause <a href="#UJO">Modifying Constants [UJO]</a><br />
(see C++ Core Guidelines ES.50)</p></li>
<li><p>Do not perform arithmetic operations on operands that can be promoted. In partcular, be aware of the arithmetic operators that promote their operands, and the types are subject to promotion.</p></li>
<li><p>Avoid widening the result of an arithmetic operation; prefer instead to widen the type of one or more of the operands</p></li>
<li><p>Don’t mix signed and unsigned arithmetic (see C++ Core Guidelines ES100)</p></li>
<li><p>Don’t rely on implicit conversions between <code>bool</code> and other types.</p></li>
<li><p>Don’t rely on implicit conversions between character types and other types.</p></li>
<li><p>Use <em>strong types</em> (see subclause <a href="#IHN">Type System [IHN]</a>) to limit implicit conversions and unwanted operations.</p></li>
<li><p>When using <code class="sourceCode cpp"><span class="kw">auto</span></code> ensure that you know the type that <code class="sourceCode cpp"><span class="kw">auto</span></code> deduces type and resist using <code class="sourceCode cpp"><span class="kw">auto</span></code> for the predefined types it for the predefined types.</p></li>
</ul>
<h2 id="CJM">6.7 String Termination [CJM]</h2>
<h3 id="applicability-to-language">6.7.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IECTR 24772-1:2019 exists in C++ when C-style strings are used. C++ provides the library class templates <code class="sourceCode cpp"><span class="bu">std::</span>basic_stringview</code> and <code class="sourceCode cpp"><span class="bu">std::</span>span</code> that implement reference semantics to non-owned buffers. These classes do not guarantee a string termination character and using their underlying raw pointer as a C-style string can result in this vulnerability. C++ provides alternative string processing capabilities that do not exhibit those vulnerabilities.</p>
<p>C++ provides a class template for string processing, <code class="sourceCode cpp"><span class="bu">std::</span>basic_string</code> that manages the space for the string and the string length and always includes a termination character. On concatenation, the string object will increase in size to contain the resulting string. The class <code class="sourceCode cpp"><span class="bu">std::</span>filesystem<span class="bu">::</span>path</code> also provides string processing capabilities among other facilities by wrapping <code class="sourceCode cpp"><span class="bu">std::</span>basic_string</code>.</p>
<p>Unlike C-style strings, the class templates <code class="sourceCode cpp"><span class="bu">std::</span>basic_string</code>, <code class="sourceCode cpp"><span class="bu">std::</span>basic_string_view</code>, and <code class="sourceCode cpp"><span class="bu">std::</span>span</code> permit embedded null characters to be used safely.</p>
<h3 id="guidance-to-language-users">6.7.2 Guidance to language users</h3>
<ul>
<li><p>Avoid C-style strings. Use <code class="sourceCode cpp"><span class="bu">std::</span>string</code> or corresponding instantiations of <code class="sourceCode cpp"><span class="bu">std::</span>basic_string</code> for the character type used.</p></li>
<li><p>If <code class="sourceCode cpp"><span class="bu">std::</span>basic_string</code> is not appropriate, provide your own encapsulation and perform the appropriate verifications.</p></li>
<li><p>If C-style strings are used, follow the guidance of ISO/IEC 24772-3 clause 6.7.2.</p></li>
<li><p>When calling interfaces that expect C-style strings as arguments, pass the result of a <code class="sourceCode cpp"><span class="bu">std::</span>string<span class="bu">::</span>c_str()</code> as an argument. Do not employ types that cannot guarantee the string termination.</p></li>
<li><p>When obtaining C-style strings via character pointers from interfaces, manage the string via a <code class="sourceCode cpp"><span class="bu">std::</span>string_view</code> only if lifetime and content of the underlying buffer is persistent, or store it in a <code class="sourceCode cpp"><span class="bu">std::</span>string</code> object otherwise.</p></li>
</ul>
<h2 id="HCB">6.8 Buffer Boundary Violation [HCB]</h2>
<h3 id="applicability-to-language">6.8.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1 clause 6.8 exists in C++ when arrays are managed using raw pointers or indexing. The range of valid raw pointers to a plain array <code>a</code> are from the first element to one past the last element of the array, i.e., in the range [<code class="sourceCode cpp"><span class="bu">std::</span>begin(a)</code>..<code class="sourceCode cpp"><span class="bu">std::</span>end(a)</code>). An object <code>o</code> can be treated as a single element array with respect to pointers referring to it.</p>
<p>C++ provides facilities to encapsulate code that is exposed to this vulnerability. The standard library defines features that mitigate or circumvent this vulnerability. For example, <code class="sourceCode cpp"><span class="bu">std::</span>string</code>, <code class="sourceCode cpp"><span class="bu">std::</span>vector</code>, <code class="sourceCode cpp"><span class="bu">std::</span>deque</code>, and <code class="sourceCode cpp">iostreams</code> manage buffers internally; using “range-for” such as <code class="sourceCode cpp"><span class="cf">for</span> (<span class="kw">auto</span> &amp;e :</code><em><code>some container</code></em><code class="sourceCode cpp">)</code> and the algorithm library to access elements <code>e</code> of the container without the possibility of a buffer boundary violation. When working directly with iterators referring a container, one need to ensure that those iterators are and remain valid. For example, for a container <code>c</code> incrementing an iterator beyond the <code>end(c)</code> iterator or dereferencing the iterator denoted by <code>end(c)</code> are undefined behavior.</p>
<p>In general, validity of iterators requires programmer care to prevent out-of-bounds access of the underlying container:</p>
<p>For example, using algorithms and iterators correctly to convert an input string to lower case:</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string to_lowercase(<span class="bu">std::</span>string_view s){</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string result{};</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>    transform(</span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>        begin(s), end(s), <span class="co">// input range #1</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>back_inserter(result), <span class="co">// output iterator #2</span></span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a>        [](<span class="dt">char</span> c){ <span class="cf">return</span> <span class="bu">std::</span>tolower(c);});</span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result;</span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The above example, passes two ranges of characters to the transform algorithm. Potential errors due to a boundary violation could be caused by the following changes:</p>
<ul>
<li>wrong input range #1, e.g., passing unrelated iterators,</li>
<li>insufficient space in output range #2, e.g., passing <code class="sourceCode cpp">begin(result)</code> instead of <code class="sourceCode cpp">back_inserter(result)</code>,</li>
</ul>
<p>The second problem occurs in the following code if the length of s is longer than 31:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string to_lowercase(<span class="bu">std::</span>string_view s){</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string result{<span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span>, <span class="dv">31</span>};</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>    transform(</span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>        begin(s), end(s), </span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a>        begin(result), <span class="co">// error, only space for 31 characters </span></span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a>        [](<span class="dt">char</span> c){ <span class="cf">return</span> <span class="bu">std::</span>tolower(c);});</span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result; <span class="co">// size(result) == 31</span></span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>An additional problem occurs when performing an operation that invalidates an in-use iterator, such as the iterator internally used by the range-for statement below:</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string to_lowercase(<span class="bu">std::</span>string s){</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (<span class="kw">auto</span> &amp;c:s){</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>       s.append(<span class="bu">std::</span>tolower(c)); <span class="co">// error, invalidates in-use iterator</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s;</span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Another way that overflows can occur is through the use of C-style strings, which can be treated as arrays of characters, but mishandling of the <code>nul</code> termination can make overflows possible. See clause <span id="CJM">6.7 String Termination[CJM]</span>.</p>
<p>Since plain (C-style) arrays when passed as function arguments decay to pointers the array dimension is lost. C++ provides several means of keeping the array dimension available to the called function:</p>
<ul>
<li>use <code>std::array</code> as parameter type,</li>
<li>use <code>std::views::counted</code> or another view as parameter type,</li>
<li>use <code>std::span</code> as parameter type for plain arrays,</li>
<li>use <code>std::string_view</code> as parameter type in favour of <code>char const*</code>, or</li>
<li>pass plain arrays by reference to a function template and deduce the dimension.</li>
</ul>
<p>For further explanation and examples, see</p>
<ul>
<li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR50-CPP.+Guarantee+that+container+indices+and+iterators+are+within+the+valid+range">SEI CTR50-CPP</a></li>
<li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR53-CPP.+Use+valid+iterator+ranges">SEI CTR53-CPP</a></li>
<li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR55-CPP.+Do+not+use+an+additive+operator+on+an+iterator+if+the+result+would+overflow">SEI CTR55-CPP</a></li>
<li><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#i13-do-not-pass-an-array-as-a-single-pointer">C++ core guidelines I.13</a></li>
</ul>
<h3 id="guidance-to-language-users">6.8.2 Guidance to language users</h3>
<ul>
<li><p>Follow the advice provided in ISO/IEC 24772-1:2022 clause 6.8.5.</p></li>
<li><p>Avoid C-style arrays. If unavoidable, guidance for the use of C-style arrays is provided in TR 24772-3 clause 6.8.2.</p></li>
<li><p>To model a fixed-size array, use a library class such as <code>std::array</code>.</p></li>
<li><p>To model arrays with dynamically changing size, use containers of the standard library, such as <code>std::vector</code> or <code>std::deque</code>.</p></li>
<li><p>Avoid using a pointer paramter or a pointer-and-size parameter pair for representing a contiguous buffer. Prefer the library classes <code>std::views::counted</code>, <code>std::span</code> or <code>std::string_view</code> for such parameters.</p></li>
<li><p>Prefer using range-based or iterator-based algorithms, such as those of the standard library, over pointer-manipulating or indexing loops.</p></li>
<li><p>Use the range-based for loop construct to iterate within the defined bounds of a range.</p></li>
<li><p>Ensure that ranges and iterators used by range-for or passed to algorithms are and remain valid.</p></li>
<li><p>When performing random access by indexing, follow the guidance of clause 6.9.2 [#XYZ]. When performing other forms of random access, follow the guidance of clause 6.12.2 [#RVG].</p></li>
<li><p>Use static analysis tools to detect buffer boundary violations.</p></li>
</ul>
<h2 id="XYZ">6.9 Unchecked Array Indexing [XYZ]</h2>
<h3 id="applicability-to-language">6.9.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2022 6.9 exists in C++ when an access is performed using <code class="sourceCode cpp"><span class="kw">operator</span>[]</code>.</p>
<p>C-style arrays, C-style pointers, random-access iterators, and some standard library containers allow element access via <code class="sourceCode cpp"><span class="kw">operator</span>[]</code> which is unchecked. However, those standard library containers also provide an access function <code>at()</code> that behaves like <code class="sourceCode cpp"><span class="kw">operator</span>[]</code>, but performs a check that the access is within the bounds of the container and throws an exception otherwise. For issues associated with exception handling and error handling, see clause <a href="#OYB">6.36</a> Ignored error status and unhandled exceptions.</p>
<p>The parameter type for contiguous sequences <code class="sourceCode cpp"><span class="bu">std::</span>span</code> does not provide a checked version of indexing and therefore should only be used via its iterator/range API.</p>
<h3 id="guidance-to-language-users">6.9.2 Guidance to language users</h3>
<ul>
<li><p>Follow the advice provided in ISO/IEC 24772-1:2022 clause 6.9.5.</p></li>
<li><p>Follow the advice from clause <a href="#HCB">6.8.2</a>.</p></li>
<li><p>Implement your own indexable containers with an overload of <code class="sourceCode cpp"><span class="kw">operator</span>[]</code> that actually does a bounds check.</p></li>
<li><p>Prefer the <code class="sourceCode cpp">at()</code> member function of the standard library containers over <code class="sourceCode cpp"><span class="kw">operator</span>[]</code> and handle the bounds violation exceptions.</p></li>
<li><p>If indexing cannot be avoided, use static analysis or explicit checks to establish that bounds violations do not occur.</p></li>
</ul>
<h2 id="XYW">6.10 Unchecked Array Copying [XYW]</h2>
<h3 id="applicability-to-language">6.10.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC 24772-1:2022 exists in C++, but can be mitigated using features provided by the language.</p>
<p>A buffer overflow occurs when some number of elements is copied from one buffer to another and the amount being copied is greater than is allocated for the destination buffer. This is a special case of <span id="HCB">6.8 Buffer Boundary Violation [HCB]</span>. The C library functions or hand-written loops for copying bytes or C-style strings are especially prone to this vulnerability.</p>
<p>As with clause 6.8 [HCB], in most cases the vulnerability can be avoided by using library classes, such as <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> or <code class="sourceCode cpp"><span class="bu">std::</span>string</code>, which provide a copy operations operator that adjust the size of the target to fit the object being copied.</p>
<p>The standard library algorithms that copy into a target range can suffer from this vulnerability. In the case of potential overflow, the programmer must either ensure automatic extension of the underlying container, such as by using <code class="sourceCode cpp"><span class="bu">std::</span>back_inserter(container)</code> as the output iterator, or ensure that the output range has sufficient space available. In the case of overlapping input and output ranges, the suitable copying algorithm must be selected, depending on the relative ordering of the ranges. In general, this situation can be avoided by using a more appropriate algorithm, for example, <code class="sourceCode cpp"><span class="bu">std::</span>rotate</code>.</p>
<p>For arrays with fixed sizes the assignment operator or copy-constructor of <code class="sourceCode cpp"><span class="bu">std::</span>array</code> is the means of safe array copying.</p>
<p>If a system requires its own container types with dynamic size, a naïve implementation might attempt to keep the copying external, like with C-style arrays. Such external copying should be avoided.</p>
<h3 id="guidance-to-language-users">6.10.2 Guidance to language users</h3>
<ul>
<li><p>Follow the advice provided in ISO/IEC 24772-1:2022 clause 6.10.5.</p></li>
<li><p>Use standard library containers instead of C-style arrays, such as <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> or <code class="sourceCode cpp"><span class="bu">std::</span>array</code>, that provide copying mechanisms that ensure the target array is large enough for the indicated source.</p></li>
<li><p>When using standard library algorithms that copy into an output range, ensure that either the output range is extended automatically or has sufficient space available.</p></li>
<li><p>Sidestep the need to use a copy algorithm on overlapping ranges, by selecting a more appropriate algorithm, such as <code class="sourceCode cpp"><span class="bu">std::</span>rotate</code>.</p></li>
<li><p>If a system requires its own container types with dynamic size, ensure that their copy operations are correct and do not require loops or algorithms for copying their content.</p></li>
<li><p>If copying C-style arrays is unavoidable, statically show that an access outside of the array cannot occur, or alternatively perform range checking before copying the array.</p></li>
<li><p>Avoid using the copying functions from the headers <cstring></p></li>
</ul>
<h2 id="HFC">6.11 Pointer Type Conversions [HFC]</h2>
<h3 id="applicability-to-language">6.11.1 Applicability to language</h3>
<p>The vulnerabilites as described in ISO/IEC TR 24772-1:2019 clause 6.11.1 applies to C++. In addition to pointers, C++ references are also vulnerable and the issues below include references when pointers are mentioned. In places where references cannot be substituted the corresponding code won’t compile.</p>
<p>In general casting pointers breaks the type system and should be avoided.</p>
<p>In C++, a C-style cast is defined in terms of the C++ cast operators <code class="sourceCode cpp"><span class="kw">const_cast</span></code>, <code class="sourceCode cpp"><span class="kw">static_cast</span></code>, and <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>. In some cases, it is unspecified which cast is used, for example, when a cast operation involves an incomplete type, a <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> may be used for the conversion which can produce an incorrect result.</p>
<p>Especially, <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> has the problem that it takes the original pointer value as a pointer of the target type rather than the original type. The C++ standard defines most cases where that happens as undefined behavior. For example, the lifetime model of C++ might result in accessing the target type object outside of its lifetime. Other run-time issues can be caused by alignment violations. Using <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span>&lt;<span class="bu">std::</span>byte*&gt;</code> to access the underlying memory of an object by casting its address permits access to the raw memory. However, casting the address of a piece of raw memory with the correct alignment and size to an object pointer and accessing that object is undefined behavior for most types, because doing so, will not start the lifetime of the object.</p>
<p><code class="sourceCode cpp"><span class="kw">static_cast</span></code> only works, where conversion of the source type to the target type are related. However, with pointer types the compiler cannot always check that the actual object type corresponds to the desired target type, causing invalid casts. Naïvely assuming that addresses of a derived object and its base object are identical is wrong in most cases. For example, with multiple inheritance, the address of an object may be different than one of its base class sub-objects. Using the generic pointer type <code class="sourceCode cpp"><span class="dt">void</span>*</code> (which is common in C APIs) allows converting between arbitrary pointer types using <code class="sourceCode cpp"><span class="kw">static_cast</span></code>. Most conversions via <code class="sourceCode cpp"><span class="dt">void</span> *</code> where the originial object type and the final target type are different are undefined behavior in C++. C++ allows <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> to a pointer to an incomplete type or a <code class="sourceCode cpp"><span class="kw">static_cast</span></code> from <code class="sourceCode cpp"><span class="dt">void</span> *</code> to a pointer to an incomplete type. The underlying object must have the suitable type matching the incomplete type.</p>
<p>Casting along the inheritance relationships with <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> is safe, but it requires the dynamic type is known, which is the case when the types declare virtual member functions. Within a constructor or destructor only the static type of the current class is relevant, because the lifetime of any derived class object hasn’t started or has already ended. See subclause <a href="#BKK">Polymorphic Variables [BKK]</a>.</p>
<p>Conversions involving <code class="sourceCode cpp"><span class="at">const</span></code> and/or <code class="sourceCode cpp"><span class="at">volatile</span></code> properties of a type are permitted using <code class="sourceCode cpp"><span class="kw">const_cast</span></code> (see <a href="#UJO">Modifying constants [UJO]</a>). Adding <code class="sourceCode cpp"><span class="at">const</span></code> with <code class="sourceCode cpp"><span class="kw">const_cast</span></code> is safe.</p>
<h3 id="guidance-to-language-users">6.11.2 Guidance to language users</h3>
<ul>
<li><p>Follow the advice provided in ISO/IEC TR 24772-1:2019 clause 6.11.5.</p></li>
<li><p>Avoid the C-style cast, <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>, and casts to and from <code>void*</code>.</p></li>
<li><p>For conversions that remove the <code class="sourceCode cpp"><span class="at">const</span></code> qualification, see the guidance in clause <a href="#UJO">Modifying constants [UJO]</a>.</p></li>
<li><p>When downcasting or crosscasting see the guidance in clause <a href="#BKK">Polymorphic Variables [BKK]</a>.</p></li>
<li><p>If pointer and reference conversions cannot be avoided, treat compiler warnings that are issued for such conversions as hard errors.</p></li>
</ul>
<h2 id="RVG">6.12 Pointer Arithmetic [RVG]</h2>
<p>TODO</p>
<h3 id="applicability-to-language">6.12.1 Applicability to language</h3>
<p>The vulnerabilites described in ISO/IEC 24772-1:2022 clause 6.12.1 also apply to C++ pointers. Analogous vulnerabilities can also apply to C++ iterators. Especially, comparing with a relational operator or substracting pointers or iterators of compatible types that refer to different arrays or ranges is undefined behavior. The vulnerabilities caused by out-of-bounds access are covered in clause <a href="#HCB">6.8</a>. The standard library function objects for comparison, like <code>std::less&lt;&gt;</code>, provide a total order of pointers of a given type.</p>
<p>It is defined behavior to reinterpret cast to a pointer from the integral types std::uintptr_t/std::intptr_t, but only if the value of the integer value was previously obtained by converting a valid pointer to said integral type. Casting an arbitrary integral value to a pointer is undefined behavior.</p>
<p>Pointers to functions and pointers to members and pointerst to void do not allow pointer arithmetic.</p>
<p>Pointers to objects can implicitly convert to <code class="sourceCode cpp"><span class="dt">void</span> *</code> (cv-qualified accordingly), it is only defined to reinterpret cast the obtained pointer back to the original type. It is implementation-defined if that bidirectional <code class="sourceCode cpp"><span class="dt">void</span> *</code> conversion also works for function pointers.</p>
<h3 id="guidance-to-language-users">6.12.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance of clause 6.8.2. with respect to ordinary pointer arithmetic of a pointer to object.</p></li>
<li><p>Avoid using reinterpret_cast&lt;&gt;() or pointer conversions to or from <code class="sourceCode cpp"><span class="dt">void</span> *</code>. Do not use C-style casts to achieve reinterpret_cast functionality.</p></li>
<li><p>Compare pointers of unknown realm with the standard library comparison function objects instead of relational operators.</p></li>
<li><p>Consider an outright ban on pointer arithmetic due to the error-prone nature of pointer arithmetic.</p></li>
<li><p>Verify that all pointers are assigned a valid memory address for use.</p></li>
</ul>
<h2 id="null-pointer-dereference-xyh">6.13 NULL Pointer Dereference [XYH]</h2>
<h3 id="applicability-to-language">6.13.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.13 exists in C++. Dereferencing a pointer with the value of <code class="sourceCode cpp"><span class="kw">nullptr</span></code> is undefined behavior <a href="#EWF">[EWF]</a>.</p>
<p>C++ does, however, provide references that cannot be null and can be used in most places instead of pointers. In addition the standard library type <code class="sourceCode cpp"><span class="bu">std::</span>optional</code> can be used in place of pointers in many cases but requires similar diligence when it is empty.</p>
<p>As a historical programming convention a return value of <code class="sourceCode cpp"><span class="kw">nullptr</span></code> is used to denote tha absence of a result. This mechanism lead to a style where pointer returns are very common and magnify potential dereference problems. Instead of returning a pointer, <code class="sourceCode cpp"><span class="bu">std::</span>optional</code> can be used to denote the absence of a result an still return a result by value. In addition, passing pointers as function arguments places the burden of checking for a <code class="sourceCode cpp"><span class="kw">nullptr</span></code> value on the called function. Using pointers as return values and function parameters is inherently problematic, due to the following issues:</p>
<ul>
<li>is a <code class="sourceCode cpp"><span class="kw">nullptr</span></code> value valid in context?</li>
<li>is it a single object or an array of objects? (<code class="sourceCode cpp">T[]</code> as a function parameter type is identical to <code class="sourceCode cpp">T*</code>)</li>
<li>what is the lifetime of the pointee?</li>
<li>who has ownership of the pointee?</li>
<li>is there protection against dereference of a <code class="sourceCode cpp"><span class="kw">nullptr</span></code> value?</li>
</ul>
<p>Using a reference as a function parameter instead of a pointer has none of these issues. Using a reference as function return type requires the caller to avoid accessing an object outisde of its lifetime (see <a href="#XYK">[XYK]</a>, <a href="#DCM">[DCM]</a>).</p>
<p>Using a <code class="sourceCode cpp"><span class="bu">std::</span>optional</code> as a function parameter or function return value instead of a pointer addresses all of these issues, except for the last. Accessing the content of a <code class="sourceCode cpp"><span class="bu">std::</span>optional</code> requires a check for <code class="sourceCode cpp">has_value{}</code>, which happens implicitly when using <code class="sourceCode cpp"><span class="bu">std::</span>optional<span class="bu">::</span>value()</code> instead of its overloaded dereference-operator.</p>
<p>Note: Be aware that <code class="sourceCode cpp">optional&lt;T&amp;&gt;</code> is not supported by the standard library. In that case either use <code class="sourceCode cpp"><span class="bu">std::</span>optional&lt;<span class="bu">std::</span>reference_wrapper&lt;T&gt;&gt;</code> or another implementation of <code class="sourceCode cpp">optional</code> supporting holding references.</p>
<p>The language provided dynamic memory management functionionality might return a <code class="sourceCode cpp"><span class="kw">nullptr</span></code> value in case of a failed allocation. Employing the smart pointer factories <code class="sourceCode cpp">make_unique</code> or <code class="sourceCode cpp">make_shared</code> will return a non-null smart pointer managing the lifetime of the underlying memory or throw <code class="sourceCode cpp"><span class="bu">std::</span>bad_alloc</code> on a failed allocation.</p>
<p>See C++ Core Guidelines ES.65 and section R: Resource Management, and CERT EXP34-C “Do not dereference null pointers”</p>
<h3 id="guidance-to-language-users">6.13.2 Guidance to language users</h3>
<ul>
<li><p>If using objects of pointer-like types that may contain a <code class="sourceCode cpp"><span class="kw">nullptr</span></code> value is unavoidable, follow the guidance from TR 24772-3 clause 6.13.2.</p></li>
<li><p>Use references to reduce the number of places where pointers are dereferenced.</p></li>
<li><p>Use <code class="sourceCode cpp"><span class="bu">std::</span>optional</code> instead of a pointer to denote a potentially missing function argument or result.</p></li>
<li><p>Use containers instaed of arrays such as <code class="sourceCode cpp"><span class="bu">std::</span>array</code>, <code class="sourceCode cpp"><span class="bu">std::</span>vector</code>, and <code class="sourceCode cpp"><span class="bu">std::</span>span</code>.</p></li>
<li><p>Use <code class="sourceCode cpp">make_unique()</code> or <code class="sourceCode cpp">make_shared()</code> for allocating objects on the heap.</p></li>
<li><p>Do not suppress exceptions on memory allocation and handle any exceptions that arise. If exceptions are suppressed, follow the guidance of TR 24772-3:2020 clause 6.13.2.</p></li>
<li><p>Use static and dynamic analysis tools to detect potential violations of this guideline.</p></li>
</ul>
<h2 id="XYK">6.14 Dangling Reference to Heap [XYK]</h2>
<h3 id="applicability-to-language">6.14.1 Applicability to language</h3>
<p>The vulnerability as expressed in ISO/IEC TR 24772-1:2019 and ISO/IEC TR 24772-3:2020 C exists in C++. C++, however, provides mechanisms to mitigate the vulnerability.</p>
<p>C++ provides a rich set of types whose objects may dangle, e.g.</p>
<ul>
<li><p>References</p></li>
<li><p>Pointers</p></li>
<li><p>Iterators</p></li>
<li><p><code class="sourceCode cpp"><span class="bu">std::</span>string_view</code></p></li>
<li><p><code class="sourceCode cpp"><span class="bu">std::</span>span</code></p></li>
<li><p><code class="sourceCode cpp"><span class="bu">std::</span>reference_wrapper</code></p></li>
</ul>
<p>This document calls these <em>potentially dangling types</em> since an attempt to access an object outside of its lifetime through a <em>potentially dangling object</em> is <em>undefined behaviour</em> (see [EWF]). In addition, user-defined class types can be <em>potentially dangling types</em>, if a subobject is of <em>potentially dangling type</em> and it refers to an object who’s lifetime is different from and not managed by the current object.</p>
<p>If the lifetime of a <em>potentially dangling object</em> ends before its referent’s lifetime ends, then the vulnerability does not apply to that potentially dangling object. This is the primary C++ strategy for avoiding vulnerabilities due to potentially dangling objects. For example, using a <em>potentially dangling type</em> as a function parameter and passing an argument that refers to an object (referent) in the scope of the function call, and the function does not take ownership of the referent (for example, by deleting the referent), then the language guarantees that the lifetime of the referent is longer than the lifetime of the parameter, even if the referent is a temporary object created within the function call expression. This lifetime guarantee does not apply to further copies made to potentially dangling objects that outlive the function call, or if the function is a coroutine.</p>
<p>In general, a temporary object is destroyed at the end of the surrounding full expression. However, in certain specific circumstances the language guarantees that a const-lvalue-reference or an rvalue-reference that is bound to a (member of a) temporary object extends the lifetime of the temporary until the reference goes out of scope. This lifetime extension is not transitive across function calls, therefore, changes in the code, such as replacing a data member access with an accessor member function, can silently lead to dangling in such lifetime-extension situations.</p>
<p>A simple example is where the temporary <code class="sourceCode cpp"><span class="bu">std::</span>string</code> object constructed by the suffix <code class="sourceCode cpp"><span class="st">&quot;&quot;</span><span class="bu">s</span></code> is passed as a constructor argument:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string_view bad(<span class="st">&quot;a temporary string&quot;</span><span class="bu">s</span>); <span class="co">// \&quot;bad\&quot; holds a dangling pointer</span></span></code></pre></div>
<p>Note: technically in this example the vulnerability exists in the conversion operator <code class="sourceCode cpp"><span class="bu">std::</span>string<span class="bu">::</span>operator string_view()</code> of <code class="sourceCode cpp"><span class="bu">std::</span>string</code>, that returns a potentially dangling type from a member function callable on a temporary object.</p>
<p>Functions returning <em>potentially dangling types</em> are vulnerable, when the caller is not copying the resulting referent, but just stores the <em>potentially dangling object</em>. For example, the <em>range-for statement</em> uses the above mentioned lifetime extension for the range object to be iterated upon. If that range object itself is given as a reference already, the loop will access the elements through dangling iterators.</p>
<pre class="{cpp}"><code>extern std::vector&lt;std::string&gt; make(); // creates a vector

for(char c: make().front()) { // attempt to iterate over first string in vector
   // vector and thus contained string is already destroyed
}</code></pre>
<p>For objects directly allocated on the heap C++ provides smart pointers and corresponding factory functions (e.g., <code class="sourceCode cpp">make_unique()</code>) that allow transferring ownership or shared ownership to reduce the risk for dangling.</p>
<h3 id="guidance-to-language-users">6.14.2 Guidance to language users</h3>
<p>In addition to the guidance provided in TR 24772-1 clause 6.14.5:</p>
<ul>
<li><p>Do not rely on lifetime extension of temporaries by binding them to named references. Use (local) variables instead.</p></li>
<li><p>Prefer value types that manage heap memory, for example, <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> or <code class="sourceCode cpp"><span class="bu">std::</span>string</code>, and pass by value/return by value over the use of <em>potentially dangling types</em>.</p></li>
<li><p>If value types are not feasible, adopt a style that makes explicit the ownership and lifetime of heap resources, by using <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr</code> or <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr</code> or similar RAII/SBRM types and allocate heap memory exclusively with their corresponding factory functions <code class="sourceCode cpp"><span class="bu">std::</span>make_unique/<span class="bu">std::</span>make_shared</code>.</p></li>
<li><p>Adopt a style that ensures all copies of any potentially dangling objects are guaranteed to be cleaned up before the referent’s lifetime ends or never accessed afterwards. For example, do not store the raw pointers managed by smart pointers, e.g., by calling their <code class="sourceCode cpp">get()</code> member function.</p></li>
<li><p>Consider making member functions ref-qualified, that return potentially dangling types to members or heap allocated objects managed by the class,<br />
to avoid being called on temporary objects. Note: An rvalue-ref-qualified overload should either return a copy by value, or be defined as <code class="sourceCode cpp">=<span class="kw">delete</span></code> to prevent calling it on a temporary that would lead to returning an immediately dangling object.</p></li>
<li><p>Show that the <em>range-for</em> dangling vulnerability does not apply or take steps to avoid it, for example, use a variable representing the range and not an expression that yields a reference to a temporary.</p></li>
</ul>
<p>$incldue 6.15.ArithmeticWrap-aroundError-FIF.md</p>
<h2 id="PIK">6.16 Using Shift Operations for Multiplication and Division [PIK]</h2>
<h3 id="applicability-to-language">6.16.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC 24772-1 clause 6.16 exists in C++. C++ complicates the discussion in 24772-1 clause 6.16 as a result of the integral promotion (see clause 6.06 [FLC]). A left-shift on an operand that gets promoted can result in a value outside the operand’s unpromoted type’s range.</p>
<p>Not every use of a shift operator is a bit-shift due to operator overloading.</p>
<h3 id="guidance-to-language-users">6.16.2 Guidance to language users</h3>
<ul>
<li>Follow the advice of ISO/IEC TR 24772-1:2019 clause 6.16 *Using Shift Operations for Multiplication and Division [PIK].</li>
<li>For promoted operands, consider converting the result of a shift operation back to the original type of the left hand operand (say using a static cast or an assignment to an object of that type) before using the result in further operations.</li>
</ul>
<h2 id="choice-of-clear-names-nai">6.17 Choice of Clear Names [NAI]</h2>
<h3 id="applicability-to-language">6.17.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.17 is applicable to C++.</p>
<p>’’’ <!--
This subclause requires a complete rewrite to have it reflect C++
issues.. TBD!!!

Think about discussing reserved names. Maybe also in Part 1.
--></p>
<pre><code>
C++ is susceptible to errors resulting from the use of similarly
appearing names. C++ does require the declaration of variables before they
are used, however, C++ allows scoping so that a variable that is not
declared locally may be resolved to some outer block or namespace or included file and a human
reviewer may not notice that resolution. Variable name length is effectively unlimited and all characters are significant.

As with the general case, calls to the wrong subprogram or references to
the wrong data element (when missed by human review) can result in
unintended behaviour. ISO/IEC 14882:2017 C++ clause 20.5.4
\[constraints\] -- reserved names, from C++, also from C, deprecated
names

`Numeric_limits`{.cpp} are in std namespace,

To Do *(Paul)*

-   One can add names to a templates as part of specialization.

-   Example extending a hash function from std::

-   Also inline namespaces.

-   Also the use of underscores in symbol names.

-   Also Unicode in identfiers.

### 6.17.2 Guidance to language users

-   Follow the guidance of ISO/IEC 148822017 clause 20.5.4 regarding
    names to refrain from usage.

-   Use names that are clear and non-confusing.

-   Use consistency in choosing names.

-   Keep the scope of names as small as reasonable.

-   Keep names short and concise in order to make the code easier to
    understand.

-   Use longer names for longer-lived objects.

-   Choose names that are appropriately rich in meaning for the context.

-   When choosing names, keep in mind that code will be reused and
    combined in ways that the original developers never imagined.

-   Do not differentiate names through only a mixture of case or the
    presence/absence of an underscore character. (this is in Part 1?)

-   Do not choose names that conflict with (unreserved) keywords or
    language-defined library names for the language being used, as
    follows:

    -       Names that begin with two or more underscore;
    
    -       Names that begin with a single underscore followed by an
        uppercase letter;
    
    -   Contextual keywords such as module, final and override;

    -   In the global namespace, identifiers commencing with std
        followed by any string of digits;

&gt; Follow common conventions for naming macros:

-   Avoid names for macros that are not all uppercase;

-   Avoid names that are all uppercase not used for macros;

```{=html}
&lt;!-- --&gt;</code></pre>
<ul>
<li><p>Avoid differentiating through characters that are commonly confused visually such as ‘O’ and ‘0’, ‘l’ (lower case ‘L’), ‘I’ (capital ‘I’) and ‘1’, ‘S’ and ‘5’, ‘Z’ and ‘2’, and ‘n’ and ‘h’.</p></li>
<li><p>Adopt or develop coding guidelines to define a common coding style and to avoid the above dangerous practices.</p></li>
</ul>
<h2 id="WXQ">6.18 Dead Store [WXQ]</h2>
<h3 id="applicability-to-language">6.18.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 clause 6.18 exists in C++.</p>
<p>The language definition permits the compiler to eliminate effects of the abstract machine that are not observable, in particular, dead stores. For example, the often-attempted write operations to non-volatile member variables in a destructor that are not subsequently used can be elided by the compiler.</p>
<p>C++ compilers and static analysis tools do exist that detect and generate warnings for dead stores.</p>
<p>The error in ISO/IEC 24772-1:2019 subclause 6.18.3 that the planned reader misspells the name of the store is possible but unlikely in C++ since the language specifies that all objects shall be declared and typed, and the existence of two objects with almost identical names and compatible types (for assignment) in the same scope would be readily detectable. See 6.17 [NAI] Choice of clear names, 6.20 Identifier name reuse [YOW], and 6.21 Namespace issues [BJL]</p>
<h3 id="guidance-to-language-users">6.18.2 Guidance to language users</h3>
<ul>
<li><p>Follow the advice of ISO/IEC 24772-1 clause 6.18.</p></li>
<li><p>Use compilers and static analysis tools to identify dead stores in the program.</p></li>
<li><p>Provide sufficient synchronization to non-const variables that are accessed by multiple execution agents. See clause 6.61 Concurrent data access [CGX]</p></li>
</ul>
<h2 id="YZS">6.19 Unused Variable [YZS]</h2>
<h3 id="applicability-to-language">6.19.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC 24772-1 clause 6.19 exists in C++.</p>
<p>A common practice for resource management in C++ relies on what is called “RAII” or “SBRM” (scope-based resource management): employing a class’ destructor to release resources managed by the object. This can lead to code without visible use of a variable being present in the source code, because all work is done by the variable’s constructor and/or destructor.</p>
<h3 id="guidance-to-language-users">6.19.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance of ISO/IEC 24772-1 clause 6.19.5.</p></li>
<li><p>Use compiler warnings and/or static analysis tools to indicate and eliminate unused variables.</p></li>
</ul>
<h2 id="identifier-name-reuse-yow">6.20 Identifier Name Reuse [YOW]</h2>
<h3 id="applicability-to-language">6.20.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.20 exists in C++, except for the second issue of limited identifier length. In C++ all characters in an identifier are significant.</p>
<p>C++ provides the scope resolution operator <code>::{.cpp}</code> to access identifiers from non-local scopes.</p>
<p>Overloading and specialization of functions is a cornerstone of C++ generic programming. In this context, the reuse of function names is essential. See clause 6.41 for inheritance issues associated with name reuse.</p>
<p>Overloaded function names and operators considered in an expression are not restricted to a simple scope hierarchy, because of argument-dependent lookup (ADL). In generic code the unqualified function or operator selected can come from a scope based on the type of the arguments and not from the current scope hierarchy. The rules for which namespaces are eligible for lookup of unqualified functions and operators are intricate, but required to make overloaded operators work.</p>
<p>In addition, if implicit conversions can happen on arguments, the overload selected by ADL can be different from programmer expectation even in non-generic code, especially when an argument is of a type that can be implicitly converted to another type where a corresponding overload is defined. Visibility on a namespace-level of such an operator overload may make it eligible, even if neither argument matches the parameter types directly. In the best case this leads to a compile error due to ambiguities, but it can also result in perfectly compiling code executing an unexcepted overload.</p>
<p>The following example demonstrates part of the problem:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;typeinfo&gt;</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> Y {</span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print(T i){</span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">typeid</span>(T).name()&lt;&lt; <span class="st">&quot;:&quot;</span> &lt;&lt; i ;</span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb105-10"><a href="#cb105-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> println(T x){</span>
<span id="cb105-11"><a href="#cb105-11" aria-hidden="true" tabindex="-1"></a>    print(x); <span class="co">// expects to call Y::print</span></span>
<span id="cb105-12"><a href="#cb105-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout&lt;&lt;<span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb105-13"><a href="#cb105-13" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb105-14"><a href="#cb105-14" aria-hidden="true" tabindex="-1"></a>} </span>
<span id="cb105-15"><a href="#cb105-15" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> X {</span>
<span id="cb105-16"><a href="#cb105-16" aria-hidden="true" tabindex="-1"></a>   <span class="kw">struct</span> A{</span>
<span id="cb105-17"><a href="#cb105-17" aria-hidden="true" tabindex="-1"></a>        A(<span class="dt">double</span>){}</span>
<span id="cb105-18"><a href="#cb105-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="co">// make this a hidden friend</span></span>
<span id="cb105-19"><a href="#cb105-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ostream &amp; <span class="kw">operator</span> &lt;&lt; (<span class="bu">std::</span>ostream &amp; out, A <span class="at">const</span> &amp;a){</span>
<span id="cb105-20"><a href="#cb105-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> out &lt;&lt; <span class="st">&quot;An A as expected</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb105-21"><a href="#cb105-21" aria-hidden="true" tabindex="-1"></a>        } </span>
<span id="cb105-22"><a href="#cb105-22" aria-hidden="true" tabindex="-1"></a>    };</span>
<span id="cb105-23"><a href="#cb105-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> print(A a){ <span class="co">// not expected to be called by println</span></span>
<span id="cb105-24"><a href="#cb105-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Surprise happens!&quot;</span>;</span>
<span id="cb105-25"><a href="#cb105-25" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb105-26"><a href="#cb105-26" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb105-27"><a href="#cb105-27" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main(){</span>
<span id="cb105-28"><a href="#cb105-28" aria-hidden="true" tabindex="-1"></a>    X::A a{<span class="fl">3.14</span>};</span>
<span id="cb105-29"><a href="#cb105-29" aria-hidden="true" tabindex="-1"></a>    Y::println(<span class="dv">42</span>); <span class="co">// i:42 - calls Y::print</span></span>
<span id="cb105-30"><a href="#cb105-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; a; <span class="co">// An A as expected - calls X::operator&lt;&lt;</span></span>
<span id="cb105-31"><a href="#cb105-31" aria-hidden="true" tabindex="-1"></a>    Y::println(a);  <span class="co">// Surprise happens! - calls X::print</span></span>
<span id="cb105-32"><a href="#cb105-32" aria-hidden="true" tabindex="-1"></a>    Y::println(<span class="dv">42</span><span class="bu">u</span>);<span class="co">// u:42 - calls Y::print</span></span>
<span id="cb105-33"><a href="#cb105-33" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The above code calls the overload <code>print(A)</code> from println since it is pulled in by ADL. On the other hand, ADL is required to work to allow the output operator for type <code>X::A</code> to work.</p>
<p>The consideration of implicit conversions together with ADL can be suppressed by defining operator overloads as class members or as <em>hidden friends</em>. The latter is achieved by declaring all corresponding overloads as <code class="sourceCode cpp"><span class="kw">friend</span></code> functions in the class that take the class’ objects as arguments. Generic base classes can provide mix-in facilities for <em>hidden friends</em> by taking the argument type that is the derived class as template parameter.</p>
<h3 id="guidance-to-language-users">6.20.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance of ISO/IEC TR 24772-1:2019 clause 6.20, with the exclusion of guidance related to truncated identifiers.</p></li>
<li><p>Qualify names to disambiguate potential conflicts between names introduced from different scopes.</p></li>
<li><p>Document argument-dependent lookup usage where name qualification is not desirable.</p></li>
<li><p>Limit the visibility of overloaded operators or functions for class types by defining them as member functions or <em>hidden friends</em>.</p></li>
<li><p>Place overloaded operators that are not class members and cannot be provided as <em>hidden friends</em> together with their argument type in a namespace that is not the global namespace,so that they are picked up by ADL.</p></li>
<li><p>Use modern integrated development environments that inform about the declaration of any identifier occurrence.</p></li>
<li><p>Enable compiler diagnostics that inform about the hiding of declarations.</p>
<ul>
<li><pre><code>  DCL60-CPP. Obey the one-definition</code></pre>
<p>rule (6.21)</p></li>
<li><pre><code>  DCL40-C. Do not create incompatible declarations of the same</code></pre>
<p>function or object (6.21)</p></li>
</ul></li>
</ul>
<h2 id="BJL">6.21 Namespace Issues [BJL]</h2>
<h3 id="applicability-to-language">6.21.1 Applicability to language</h3>
<p>The vulnerability described in ISO/IEC TR 24772-1:2019 clause 6.21 exists in C++. It can occur in particular when a used library changes its API. The situations where it exists are related to the following cases:</p>
<ul>
<li>Template specialization, where clause 6.40 [#SYM] applies;</li>
<li>Overloading, where clause 6.20 [#YOW] applies;</li>
<li>Overriding, where clause 6.41 [#RIP] applies.</li>
</ul>
<p>In the case of template specialization or non-identical definitions of the same entity in different translation units (ODR-violation), ill-formed code might be the result, however, a C++ compiler is not obliged to diagnose that situation, leading to undefined behaviour.</p>
<p>In the case of overloading and overriding cases, C++ compilers are required to diagnose an ambiguity if it exists.</p>
<p>However, overload resolution applies preference rules in order to select among multiple matching functions or function templates as a means to resolve the ambiguity among these functions. Hence, for calls that are not perfect matches, the user cannot guarantee in the presence of later changes which function is called, as another, better match can be introduced subsequently. The call in question then changes its binding without warning upon its next compilation. For cases, where the preference rules do not resolve the ambiguity, the resulting error message by the compiler avoids the vulnerability. Function template specializations are not considered during overload resolution, only the base template is considered.</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo (<span class="dt">long</span>);</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a><span class="co">// void foo (int);</span></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar ()</span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a>  foo (<span class="dv">0</span>);         <span class="co">// The call to &#39;foo(long)&#39; requires implicitly conversion</span></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a>                   <span class="co">// from &#39;int&#39; to &#39;long&#39;.   The function &#39;foo(int)&#39; </span></span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a>                   <span class="co">// would be a &quot;better match&quot; and so would silently</span></span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a>                   <span class="co">// be chosen when subsequently introduced</span></span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>A new declaration can impact existing code in a number of situations involving the addition of:</p>
<ul>
<li>an overload,</li>
<li>a using directive,</li>
<li>a declaration into a namespace that is searched as part of “Argument-Dependent Lookup”,</li>
<li>a non-template function that is preferred to a function template,</li>
<li>a template specialization.</li>
</ul>
<p>A <code class="sourceCode cpp"><span class="kw">using</span></code> directive broadens the possible scopes that will be examined for names during lookup. Where lookup searches a namespace referred to by a <code class="sourceCode cpp"><span class="kw">using</span></code> directive, all names in that namespace will be visible some of which may be unwanted. A using declaration, on the other hand, declares only the specified name into the scope of the <code class="sourceCode cpp"><span class="kw">using</span></code> declaration.</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> NS1</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f1 (<span class="dt">int</span>);</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f2 (<span class="dt">int</span>);        <span class="co">// Added later</span></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> NS2</span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> <span class="kw">namespace</span> NS1;  <span class="co">// &#39;f1&#39; needed</span></span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f2 (<span class="dt">long</span>);</span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> bar ()</span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a>    f1(<span class="dv">0</span>);              <span class="co">// Calls &#39;NS1::f1&#39;</span></span>
<span id="cb109-13"><a href="#cb109-13" aria-hidden="true" tabindex="-1"></a>    f2(<span class="dv">0</span>);              <span class="co">// Unintentionally calls &#39;NS1::f2&#39;</span></span>
<span id="cb109-14"><a href="#cb109-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb109-15"><a href="#cb109-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb109-16"><a href="#cb109-16" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> NS3</span>
<span id="cb109-17"><a href="#cb109-17" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb109-18"><a href="#cb109-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> NS1::f1;        <span class="co">// &#39;f1&#39; needed</span></span>
<span id="cb109-19"><a href="#cb109-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f2 (<span class="dt">long</span>);</span>
<span id="cb109-20"><a href="#cb109-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> bar ()</span>
<span id="cb109-21"><a href="#cb109-21" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb109-22"><a href="#cb109-22" aria-hidden="true" tabindex="-1"></a>    f1(<span class="dv">0</span>);              <span class="co">// Calls &#39;NS1::f1&#39;</span></span>
<span id="cb109-23"><a href="#cb109-23" aria-hidden="true" tabindex="-1"></a>    f2(<span class="dv">0</span>);              <span class="co">// Calls &#39;NS3::f2&#39; as expected</span></span>
<span id="cb109-24"><a href="#cb109-24" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb109-25"><a href="#cb109-25" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<!-- from 6.40: -->
<p>Overload resolution only considers conversions for the explicitly specified arguments and does not take default parameters into account:</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">short</span>, <span class="dt">int</span> = <span class="dv">0</span>);</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">int</span>, <span class="dt">short</span> = <span class="dv">0</span>);</span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f2 ()</span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>);       <span class="co">// calls &#39;f1(1, 0)&#39; as &#39;1 -&gt; int&#39; is better match than &#39;1 -&gt; short&#39;</span></span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>, <span class="dv">0</span>);    <span class="co">// ambiguous, ill-formed, won&#39;t compile</span></span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The following example demonstrates a situation where the late addition of a better matching overload causes a silent change in the semantics of an existing program.</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> NS</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> A</span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a>  };</span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt; T foo ( T t )</span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> t;</span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb111-11"><a href="#cb111-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb111-12"><a href="#cb111-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-13"><a href="#cb111-13" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> NS2 <span class="co">// separately developed and included from a header file</span></span>
<span id="cb111-14"><a href="#cb111-14" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb111-15"><a href="#cb111-15" aria-hidden="true" tabindex="-1"></a>   <span class="kw">struct</span> B</span>
<span id="cb111-16"><a href="#cb111-16" aria-hidden="true" tabindex="-1"></a>   {</span>
<span id="cb111-17"><a href="#cb111-17" aria-hidden="true" tabindex="-1"></a>   };</span>
<span id="cb111-18"><a href="#cb111-18" aria-hidden="true" tabindex="-1"></a><span class="co">// This code will be added later</span></span>
<span id="cb111-19"><a href="#cb111-19" aria-hidden="true" tabindex="-1"></a><span class="co">//  template &lt; typename T &gt; T * foo ( T * t )</span></span>
<span id="cb111-20"><a href="#cb111-20" aria-hidden="true" tabindex="-1"></a><span class="co">//  {</span></span>
<span id="cb111-21"><a href="#cb111-21" aria-hidden="true" tabindex="-1"></a><span class="co">//    return t;</span></span>
<span id="cb111-22"><a href="#cb111-22" aria-hidden="true" tabindex="-1"></a><span class="co">//  }</span></span>
<span id="cb111-23"><a href="#cb111-23" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb111-24"><a href="#cb111-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-25"><a href="#cb111-25" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> NS2;</span>
<span id="cb111-26"><a href="#cb111-26" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> NS;</span>
<span id="cb111-27"><a href="#cb111-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-28"><a href="#cb111-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar()</span>
<span id="cb111-29"><a href="#cb111-29" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb111-30"><a href="#cb111-30" aria-hidden="true" tabindex="-1"></a>  A * a;</span>
<span id="cb111-31"><a href="#cb111-31" aria-hidden="true" tabindex="-1"></a>  B * b;</span>
<span id="cb111-32"><a href="#cb111-32" aria-hidden="true" tabindex="-1"></a>  foo (a); <span class="co">// After the commented-out code is added to NS2, the binding of foo changes silently from NS::foo to NS2::foo</span></span>
<span id="cb111-33"><a href="#cb111-33" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>This issue can be avoided by avoiding <code>using namespace xxx{.cpp}</code> and explicitly qualifying each call, such as <code>NS::foo(a){.cpp}</code>;</p>
<p>A similar situation can occur when a conflict arises between compiler-synthesized or rewritten operators and explicitly created versions of those operators. For example:</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span>==(A <span class="at">const</span> &amp;) <span class="at">const</span> { <span class="cf">return</span> <span class="kw">true</span>; }   </span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Evil hijacking of !=</span></span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a><span class="co">// bool operator != (A const &amp;, A const &amp;) { return true; } // #1</span></span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar (A <span class="at">const</span> &amp; a) {</span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a>  a != a;                                                    <span class="co">// #2</span></span>
<span id="cb112-11"><a href="#cb112-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In the above example, the declaration of <code class="sourceCode cpp"><span class="kw">operator</span>==</code> will have a corresponding synthesised <code class="sourceCode cpp"><span class="kw">operator</span>!=</code> generated by the compiler, since there is no suitable user-declared <code class="sourceCode cpp">!=</code>. If the <code class="sourceCode cpp"><span class="kw">operator</span>!=</code> becomes visible, then the code at #2 uses the user-declared <code class="sourceCode cpp"><span class="kw">operator</span>!=</code> instead of the synthesized one, which can lead to a silent and unexpected change of behaviour. This is particularly risky when the operator is declared outside of the immediate visibility of the original definition.</p>
<h3 id="guidance-to-language-users">6.21.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance of clauses 6.20.2, 6.40.2, and 6.41.2 as applicable.</p></li>
<li><p>Consider using fully qualified names for calls that rely on an implicit conversions.</p></li>
<li><p>Arguments to called functions should not be subject to implicit conversions.</p></li>
<li><p>Prefer using declarations to using directives.</p></li>
<li><p>Do not overload and use default arguments for the same set of functions.</p></li>
<li><p>Do not specialize function templates.</p></li>
<li><p>For template specialization, ensure that specializations are declared as follows:</p>
<ol type="1">
<li><p>In the same file as the primary template; or</p></li>
<li><p>In the same file as the user-defined type for which the specialization is declared.</p></li>
</ol></li>
<li><p>Define an entity in only one file to prevent ODR-violations.</p></li>
<li><p>Ensure that no ODR-violations occur, i.e., through a static analysis tool.</p></li>
<li><p>Only declare equaility or relational operators as member functions or friend functions of the class</p></li>
</ul>
<h2 id="initialization-of-variables-lav">6.22 Initialization of Variables [LAV]</h2>
<h3 id="applicability-to-language">6.22.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 exists in C++.</p>
<p>For local objects and dynamically allocated objects with trivial type, defining/allocating the object without initialization leaves the object with an indeterminate value. A subsequent read of such a variable, before it has been written is undefined behavior.</p>
<p>An object with trivial type that was dynamically allocated with <code class="sourceCode cpp">malloc</code>, or some other C-style equivalent, will have an indeterminate value.</p>
<p>An object that does not have a trivial type requires a constructor to be called in order for its lifetime to start correctly. Allocating space for such an object using <code class="sourceCode cpp">malloc</code> and attempting to cast and use it is undefined behavior, see Conversion Errors [FLC].</p>
<p><em>TBD: Sentence highlighting that this problem doesn’t occur with <code class="sourceCode cpp"><span class="kw">new</span></code> + equivalent guidance</em></p>
<p>Defining local variables as <code class="sourceCode cpp"><span class="at">const</span></code>, enforces initialization by the compiler. If determining the initial value of a variable requires complex logic, putting that logic into an immediately-invoked lambda expression that provides the initial value, permits the variable to be initialized when defined.</p>
<p>Furthermore, a class with a user-defined constructor can choose to leave non-static data members of trivial type uninitialized. If such a class does not prevent access to such a member with indeterminate value, using the class can cause undefined behavior. This even happens when an object of that class is a subobject of another class that does not define a constructor.</p>
<p>In addition some of the rules of initialization in C++ are complicated. For example, there are the following initialization cases: - no initialization (see above), - zero-initialization, - value-initialization, - default-initialization, - list initialization, - aggregate inialization, - member initialization, - base-class initialization, - constant initialization (<code class="sourceCode cpp"><span class="kw">constexpr</span></code> and <code class="sourceCode cpp"><span class="kw">constinit</span></code>), - static initialization, - dynamic initialization, - etc…</p>
<p>Namespace-scope variables with dynamic initialization can cause undefined behavior if the initialization depends on other such variables. If the dependency is in the same translation unit the sequencing is defined in definition order, however, there is no sequencing across translation unit boundaries.</p>
<p>Consider:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A {</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>  A (<span class="dt">int</span> i ) : <span class="va">i_</span> { i }  {  }</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> <span class="va">i_</span>;</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> B {</span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>  B (A <span class="at">const</span> &amp; a) : <span class="va">j_</span>{a.<span class="va">i_</span>} { }</span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> <span class="va">j_</span>;</span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> A a;</span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-13"><a href="#cb113-13" aria-hidden="true" tabindex="-1"></a>B b (a);     <span class="co">//  #1</span></span>
<span id="cb113-14"><a href="#cb113-14" aria-hidden="true" tabindex="-1"></a>A a { <span class="dv">42</span> };  <span class="co">//  #2</span></span></code></pre></div>
<p>If #1 and #2 are in the same translation unit, then <code>a</code> in #1 is incompletely initialized (zero initailized). If #1 and #2 are in different translation units, then the order of initialization of <code>a</code>(#2) relative to <code>b</code>(#1) is unspecified.</p>
<p>Note, however, that the initialization order for function local statics is defined.</p>
<p>Consider:</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>A &amp; getA ();Conversion Errors \[FLC\]</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>B b (getA());</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>A &amp; getA ()</span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">static</span> A a { <span class="dv">42</span> }; </span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> a; <span class="co">// can cause data races</span></span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>See C++ Core Guidelines ES.20 and CERT C++ Coding Guidelines EXP53-CPP. Note that ES.20 and EXP53 are complementary. Both point out that you should always initialize before reading, but ES.20 uses the narrow sense of initialize while EXP53 includes assignment.</p>
<h3 id="guidance-to-language-users">6.22.2 Guidance to language users</h3>
<ul>
<li>Follow the guidance provided in ISO IEC 24772-1 subclause 6.22.5</li>
<li>Initialize every object defined, including data members.</li>
<li>Do not depend on the order of dynamic initialization of namespace-scope variables, unless the initialization order is guaranteed by the language.</li>
<li>Consider not using namespace-scope variables (see <span id="CGA">6.61</span>).</li>
<li>If the use of uninitialized variables is unavoidable, employ tools, including the compiler, that detect reads of variables with indeterminate values.</li>
</ul>
<h2 id="operator-precedence-and-associativity-jcw">6.23 Operator Precedence and Associativity [JCW]</h2>
<h3 id="applicability-to-language">Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.23 is applicable to C++.</p>
<p>Operator precedence and associativity in C++ are determined by the C++ grammar. There are four operators that cannot be overloaded (user-defined):</p>
<ul>
<li><p><code class="sourceCode cpp">::</code> ;</p></li>
<li><p><code class="sourceCode cpp">.</code> ;</p></li>
<li><p><code class="sourceCode cpp">.*</code> ; and</p></li>
<li><p><code class="sourceCode cpp">?:</code> .</p></li>
</ul>
<p>Due to the large number of operators, one is recommended to consult an operator precedence table when needed, e.g., <a href="https://en.cppreference.com/w/cpp/language/operator_precedence">[https://en.cppreference.com/w/cpp/language/operator_precedence]</a>. For example, in C++, the bitwise logical and shift operators are sometimes incorrectly treated as having the same precedence as arithmetic operations even though the bitwise operators have lower precedence. For example, the following (correct) expression subtracts one from <code class="sourceCode cpp">x</code> and then checks if the result is zero:</p>
<p><code class="sourceCode cpp">x - <span class="dv">1</span> == <span class="dv">0</span></code></p>
<p>which is equivalent to <code class="sourceCode cpp">(x - <span class="dv">1</span>) == <span class="dv">0</span></code>,i.e., <code class="sourceCode cpp">x - <span class="dv">1</span></code> is done first, then that result is compared to <code class="sourceCode cpp"><span class="dv">0</span></code>. Programmers mistakenly thinking the bitwise operations have the same precedence as arithmetic ones might write:</p>
<p><code class="sourceCode cpp">x &amp; <span class="dv">1</span> == <span class="dv">0</span></code></p>
<p>intending to perform <code class="sourceCode cpp">(x &amp; <span class="dv">1</span>) == <span class="dv">0</span></code>, but precedence rules result in this evaluating <code class="sourceCode cpp">x &amp; (<span class="dv">1</span> == <span class="dv">0</span>)</code> instead. This would have been easily fixed by using parenthesis to ensure the proper evaluation of an expression.</p>
<p>In addition to the aforementioned, C++ also permits operators to be overloaded when used with user-defined types. While it is not possible to change the precedence, associativity, and number of operands of overloaded operators [C++17, Clause 16.5 [over.oper], para. 6], overloaded operators can be executed differently than built-in operators. For example, overloaded operators lose any built-in operator short-circuiting properties and sequence order guarantees. Similarly overloaded operators and their arguments' evaluations behave as normal function calls, differing from built-in operator evaluation.</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A {  };</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span>&amp;&amp;(A <span class="at">const</span> &amp;, <span class="dt">int</span>);</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> foo ();</span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar (A <span class="at">const</span> &amp; a)</span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (a     &amp;&amp; foo());  <span class="co">// &#39;foo()&#39; always evaluated</span></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="kw">false</span> &amp;&amp; foo());  <span class="co">// &#39;foo()&#39; never evaluated</span></span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (a.<span class="kw">operator</span>&amp;&amp; (<span class="kw">false</span>,foo())); <span class="co">// &#39;foo()&#39; always evaluated</span></span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Note that overloaded assignment falls into this category.</p>
<p>For issues related to the declaration of equality and relational operators see Clause 6.25 [KOA].</p>
<h3 id="guidance-to-language-users">6.23.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance provided in ISO/IEC TR 24772-1:2019 Clause 6.23.5 [JCW].</p></li>
<li><p>Enable all C++ compiler/tool warnings and static analysis tool diagnostics concerning possible issues with precedence and associativity to help detect and avoid mistakes.</p></li>
<li><p>Even if technically unnecessary, use parentheses around operator (sub)expressions that are known to be or felt likely to be sources of error.</p></li>
<li><p>Avoid overloading the following operators <code class="sourceCode cpp">&amp;&amp;</code>, <code class="sourceCode cpp">||</code>, <code class="sourceCode cpp">,</code> and their alternative spellings.</p></li>
<li><p>Break up complex expressions and use temporary variables to make complex expressions easier to understand and maintain.</p></li>
</ul>
<h2 id="side-effects-and-order-of-evaluation-of-operands-sam">6.24 Side-effects and Order of Evaluation of Operands [SAM]</h2>
<h3 id="applicability-to-language">6.24.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.24 exists in C++.</p>
<p>The evaluation of an expression includes: (i) its value computation; and (ii) its side-effects. The value computation is the value returned by the expression, e.g., the valuation of <code>3 * 2 + 1</code> is <code>7</code>. The side-effect of an expression are</p>
<ul>
<li><p>Write accesses to objects in that expression,</p></li>
<li><p>Reading a volatile object,</p></li>
<li><p>Calling a library I/O function, and</p></li>
<li><p>Calling a function that does any of the above.</p></li>
</ul>
<p>For example consider:</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i = <span class="dv">2</span>;</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> j = i++;</span></code></pre></div>
<p>the evaluation of i++ is 2 and the side-effects are the writing of 3 to i and the initialization of j.</p>
<p>Within an expression, one must ensure an object is stored only once to avoid undefined behaviour, e.g.,</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>i = i++ + <span class="dv">5</span>; <span class="co">// undefined behaviour (before C++17)</span></span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>k = i++ + i\--; <span class="co">// undefined behaviour in all versions of C++</span></span></code></pre></div>
<p>and expressions modifying objects can only read the object to determine the value to be stored (e.g., ++i requires reading the value), i.e., other accesses are undefined behaviour, e.g.,</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a>my_array\[i\] = i++; <span class="co">// undefined behaviour (before C++17)</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>Starting with C++<span class="dv">17</span>, the evaluation order of an expression involving</span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>overloaded operators preserves the sequenced before behaviour of the</span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a>built-in <span class="kw">operator</span>:</span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a><span class="er">```</span>{.cpp}</span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a>my_array[i] = i++;</span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a>my_array[i++] = i++;</span></code></pre></div>
<p>say <code class="sourceCode cpp">i = <span class="dv">10</span></code> before the expression</p>
<p>evaluate RHS <code>i++</code> – <code>i</code> is <code>11</code></p>
<p>evaluate <code>my_array[i++]</code> //evaluates <code>my_array\[11\]</code>, then assigns <code>i</code> to <code>12</code></p>
<p><code>my_array[11]</code> is assigned <code>10</code></p>
<p>This occurs because assignment is sequenced after the value computation of the right and left operands and before the value computation of the assignment expression and, the right operand is sequenced before the left operand. [C++17, Clause 8.18 [expr.ass], para. 1] Since this is the built-in operator, this statement can be thought of as:</p>
<blockquote>
<p>Compute value of right-hand-side: <code>i++</code> (e.g., integer value).</p>
<p>Compute value of left-hand-side: <code>my_array[i]</code> (e.g., memory address).</p>
<p>Apply side-effects of <code>i++</code>.</p>
<p>Apply side-effects of the assignment.</p>
</blockquote>
<p>In general, one should follow commonly-stated C/C++ advice of never reading from and writing to the same object within an expression to avoid potential vulnerabilities. Often breaking the expression into separate statements achieves clear and clean semantics, e.g.,</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>++i;</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>my_array[i] = i;</span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>my_array[i] = i;</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>++i;</span></code></pre></div>
<p>makes it unambiguous what the value of i is during the array assignment and eliminates the possibility of vulnerabilities.</p>
<p>In addition, it is important to note that overloading an operator disables short-circuiting behaviours (e.g., built-in boolean operators): those operators' operands are all evaluated before the operator itself.</p>
<p>The C++ built-in (two-argument) Boolean operators (e.g., <code class="sourceCode cpp">&amp;&amp;</code> and <code class="sourceCode cpp">\|\|</code>)as well as <code>&lt;type_traits&gt;</code>’s <code class="sourceCode cpp"><span class="bu">std::</span>conjunction</code> and <code class="sourceCode cpp"><span class="bu">std::</span>disjunction</code> operations are all short-circuiting, i.e., if the value of an earlier (from left-to-right) operand of an operation determines the result of the operation, then all remaining arguments are not evaluated.</p>
<pre><code>&lt;!--
Conjunction and disjunction operate at compile time and the short-circuiting is about template instantiations that might lead to compile errors otherwiese. This is not a runtime safety issue. I suggest dropping that (Peter)_
--&gt;</code></pre>
<p>Typically this allows one to write code like this, e.g.,</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> *p;</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (p != <span class="kw">nullptr</span> &amp;&amp; *p != <span class="dv">0</span>) {</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* do something */</span></span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>i.e., if <code class="sourceCode cpp">p</code> is <code class="sourceCode cpp"><span class="kw">nullptr</span></code>, then <code class="sourceCode cpp">*p != <span class="dv">0</span></code> is never executed, thus, avoiding undefined behaviour. Only when <code>p</code> is not <code class="sourceCode cpp"><span class="kw">nullptr</span></code> is *p != 0 is evaluated. It must be stressed that this only applies to the built-in <code class="sourceCode cpp">&amp;&amp;</code> and <code>||</code> operators: user-defined operator overloads as functions always evaluate all operands first.</p>
<p>Consequently should one want to always evaluate all operands of a boolean expression, one should not write code like this:</p>
<p><code class="sourceCode cpp"><span class="dt">bool</span> x = foo() &amp;&amp; bar();</code></p>
<p>where <code>foo()</code> and <code>bar()</code> are functions that return something convertible to <code>bool</code>. In this expression, if <code>foo()</code> returns <code class="sourceCode cpp"><span class="kw">false</span></code>, then <code>bar()</code> will never be executed; –only when <code>foo()</code> returns <code class="sourceCode cpp"><span class="kw">true</span></code> will <code>bar()</code> be executed. Similarly for <code>||</code>:</p>
<p><code class="sourceCode cpp"><span class="dt">bool</span> y = foo() || bar();</code></p>
<p>i.e., only when <code class="sourceCode cpp">foo()</code> returns <code class="sourceCode cpp"><span class="kw">false</span></code> will <code class="sourceCode cpp">bar()</code> be executed if <code class="sourceCode cpp">foo()</code> returns <code class="sourceCode cpp"><span class="kw">true</span></code> then <code class="sourceCode cpp">bar()</code> will never be executed. Thus, if both <code class="sourceCode cpp">foo()</code> and <code class="sourceCode cpp">bar()</code> are both required to be executed, then execute them in separate statements first, e.g.,</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> foo_result = foo();</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> bar_result = bar();</span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> x = foo_result &amp;&amp; bar_result;</span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> y = foo_result \|\| bar_result;</span></code></pre></div>
<pre><code>&lt;!--
Stephen: My write-up here is lengthy but should help get more terse
wording\... but I note this: C++ operator information is in C++17 Clause
8 and Clause 16.5, \... Also per 16.5.1 para 2. unary and binary forms
of the same operator are considered to have the same name so one can
hide another from an enclosing scope. Thus, this is also another
possible vulnerability.\]
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.24.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance provided in ISO/IEC TR 24772-1:2019 Clause 6.24.5.</p></li>
<li><p>Write expressions so that the same effects will occur under any order of evaluation that C++ permits since side effects can be dependent on an implementation specific order of evaluation.</p></li>
<li><p>Avoid overloading logical operators (&amp;&amp; and ||), as these overloaded versions will not short-circuit.</p></li>
<li><p><em>Ensure that</em> ++, --, @= <em>are used as solitary items in a statement.</em></p></li>
<li><p>Be aware to which C++ standard a compiler is compiling code against. This determines the semantics of all operator (overloaded and built-in) expressions.</p></li>
<li><p>Avoid placing multiple operations with side effects in a single expression.</p></li>
<li><p>Write simple code expressions and statements so that within any expression or statement an object is one of:</p>
<ul>
<li><pre><code>  Read from;</code></pre></li>
<li><pre><code>  Only modified once; or</code></pre></li>
<li><pre><code>  Only read and modified by: a single increment; a single</code></pre>
decrement; a single simple assignment; or a single compound assignment.</li>
</ul></li>
<li><p>Be aware that different versions of C++ have different evaluation order specifications and program accordingly.</p></li>
</ul>
<h2 id="KOA">6.25 Likely Incorrect Expression [KOA]</h2>
<h3 id="applicability-to-language">6.25.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.25 exists in C++.</p>
<p>C++ has several instances of operators which are similar in structure, but different in meaning. Examples of operators in C-based languages that can cause confusion are:</p>
<ul>
<li><code class="sourceCode cpp">==</code> and <code class="sourceCode cpp">=</code>;</li>
<li><code class="sourceCode cpp">&amp;&amp;</code> and <code class="sourceCode cpp">&amp;</code>;</li>
<li><code class="sourceCode cpp">||</code> and <code class="sourceCode cpp">|</code>;</li>
<li><code class="sourceCode cpp">&lt;</code>, <code class="sourceCode cpp">&lt;&lt;</code>, and <code class="sourceCode cpp">&lt;&lt;=</code>; and</li>
<li><code class="sourceCode cpp">&gt;</code>, <code class="sourceCode cpp">&gt;&gt;</code>, and <code class="sourceCode cpp">&gt;&gt;=</code>.</li>
</ul>
<p>The typographical similarity can lead to code like the following, where it is unclear if the expression as spelled is actually intended, or if the author has typos in it, meaning a different operator instead:</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f(<span class="dt">unsigned</span> i, <span class="dt">unsigned</span> j)</span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (i &gt; <span class="dv">1</span>) &amp; (j = <span class="dv">1</span>); <span class="co">// (&gt;&gt;, &amp;&amp;, ==) ?</span></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The following code in a production phone OS caused the “bricking” of many users phones:</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="va">key_data_</span>.has_value() &amp; !<span class="va">key_data_</span>-&gt;label().empty())</span></code></pre></div>
<p>instead of</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="va">key_data_</span>.has_value() &amp;&amp; !<span class="va">key_data_</span>-&gt;label().empty())</span></code></pre></div>
<p>or the even clearer using the alternative operator representation <code class="sourceCode cpp"><span class="kw">and</span></code> for <code class="sourceCode cpp">&amp;&amp;</code></p>
<div class="sourceCode" id="cb132"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="va">key_data_</span>.has_value() <span class="kw">and</span> !<span class="va">key_data_</span>-&gt;label().empty())</span></code></pre></div>
<p>As a general rule, the use of <code>=</code>, <code>+=</code>, <code>-=</code> in an expression when the operator is not the final assignment to a variable is unsafe since the assignment operator creates side-effects within the expression which are difficult to analyze by a human reader and can be have different results depending upon the order of evaluation of terms within the expression.</p>
<p>But even in assignment expression flipping the assignment symbol with the operator can itself lead to valid code that was not intended:</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i{<span class="dv">42</span>};</span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>i += <span class="dv">22</span>; <span class="co">// i becomes 64</span></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a>i =+ <span class="dv">22</span>; <span class="co">// i becomes 22</span></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a>i =- <span class="dv">22</span>; <span class="co">// i becomes -22</span></span></code></pre></div>
<p>C++ provides significant freedom in constructing statements. This freedom, if misused, can result in unexpected results and potential vulnerabilities.</p>
<p>Since the order of evaluation within expressions is only partially defined, sub-expressions with side effects on variables used within the overall expression can result in undefined behaviour.</p>
<p>The flexibility of C++ can obscure the intent of a programmer. Consider:</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x,y;</span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a><span class="co">/* ... */</span></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (x = y){</span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* ... */</span></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>A fair amount of analysis may need to be done to determine whether the programmer intended to do an assignment as part of the <code class="sourceCode cpp"><span class="cf">if</span></code> statement (valid in C++) or whether the programmer made the common mistake of using an <code class="sourceCode cpp">=</code> (assignment) instead of a <code class="sourceCode cpp">==</code> (equality).</p>
<p>This confusion can be corrected by moving assignments outside of Boolean contexts. This would change the example code to:</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x,y;</span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a><span class="co">/* … */</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>x = y;</span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (x == <span class="dv">0</span>) {</span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* ... */</span></span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>This would clearly state what the programmer meant and that the assignment of y to x was intended.</p>
<p>Additional confusion occurs in the use of the logical <code class="sourceCode cpp">&amp;&amp;</code> or <code class="sourceCode cpp">||</code> operators and the bitwise <code class="sourceCode cpp">&amp;</code> or <code class="sourceCode cpp">|</code> operators. The compiler will implicitly convert arithmetic expressions to <code class="sourceCode cpp"><span class="dt">bool</span></code> for operands of the logical operators. Similarly, operands of <code class="sourceCode cpp"><span class="dt">bool</span></code> type will be promoted to <code class="sourceCode cpp"><span class="dt">int</span></code> for operands of the bitwise operators (see <a href="#FLC">Conversion Errors [FLC]</a>).<br />
It may not be clear whether the programmer intended to use the logical operator <code class="sourceCode cpp">&amp;&amp;</code> or bitwise operator <code class="sourceCode cpp">&amp;</code> instead:</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> f(<span class="dt">unsigned</span> i, <span class="dt">unsigned</span> j)</span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (i &gt; <span class="dv">0</span>) &amp; j;</span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Using the alternative tokens <code class="sourceCode cpp"><span class="kw">and</span></code> / <code class="sourceCode cpp"><span class="kw">or</span></code> in lieu of <code class="sourceCode cpp">&amp;&amp;</code> and <code class="sourceCode cpp">||</code> reduces the possibility of confusion.</p>
<p>Programmers can easily get in the habit of inserting the <code class="sourceCode cpp">;</code> statement terminator at the end of statements. However, inadvertently doing this can drastically alter the meaning of code, even though the code is valid as in the following example:</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a,b;</span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* … */</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (a == b);  <span class="co">// the semi-colon will make the following code always execute</span></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>    {             </span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* ... */</span></span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>Because of the misplaced semi-colon, the code block following the if will always be executed. In this case, it is extremely likely that the programmer did not intend to put the semi-colon there.</p>
<p>Unary ‘<code>+</code>’{.cpp} on a variable is (almost) a no-op, and is possibly a mistype of ‘<code>++</code>’{.cpp}. A unary ‘<code>-</code>’{.cpp} on a variable will switch its sign, unless applied to a variable of an unsigned type, in which case the result is the value subtracted from 2^n where n is the number of bits in the unsigned type.</p>
<p>C++ overloading of operators can also cause confusion. When overloaded, related operators like the compound assignment with their base operator, or comparison operators are not longer guaranteed to keep their behavioral relationship that they have for built-in types. For example, <code class="sourceCode cpp">a += b</code> is not guaranteed to behave like <code class="sourceCode cpp">a = a + b</code>, or being defined at all. Similarly, for <code class="sourceCode cpp">a == b</code> (before C++20), there is no guarantee that <code class="sourceCode cpp">a != b</code> is equivalent to <code class="sourceCode cpp">!(a == b)</code>.</p>
<p>Unless the all relational operators are defined either explicitly or implicitly, unexpected results can occur. From C++20 onwards, a user-declared three-way comparison operator (<code class="sourceCode cpp">&lt;=&gt;</code>) is used by the compiler to synthesize the relational operator consistently. If <code class="sourceCode cpp"><span class="kw">operator</span>&lt;=&gt;</code> is defined as =default, the equality comparison operators will also be defined; and if <code class="sourceCode cpp"><span class="kw">operator</span>==</code> with return type <code class="sourceCode cpp"><span class="dt">bool</span></code> is defined, a corresponding inequality <code class="sourceCode cpp"><span class="kw">operator</span>!=</code> is also defined implicitly.</p>
<h3 id="guidance-to-language-users">6.25.2 Guidance to language users</h3>
<p>— Follow the guidance contained in ISO/IEC TR 24772-1:2019, 6.25.5.</p>
<ul>
<li><p>Simplify expressions to aid in code readability and help future maintainers understand the intent and nuances of the code. For example,</p>
<ul>
<li>by extracting intermediate results into const variables with a meaningful name, or</li>
<li>by extracting a subexpression into a function with a meaningful name.</li>
</ul></li>
<li><p>Avoid assignments embedded within other statements and expressions.</p></li>
<li><p>Spell unary operators (e.g., <code>-</code>) with a leading blank in expressions to avoid them being misread as combined operators. In addition avoid the use of unary plus, since it is almost always a no-op for built-in types.</p></li>
<li><p>Consider using alternative tokens for the logical operators.</p></li>
<li><p>If your code structure requires an empty statement <code class="sourceCode cpp">;</code> use an empty code block instead <code class="sourceCode cpp">{}</code>.</p></li>
<li><p>Do not have conflicting side-effects in sub-expressions.</p></li>
<li><p>Follow the following C++ Core guidelines:</p>
<ul>
<li>ES 40 Avoid complicated expressions</li>
<li>ES 41 If in doubt about operator precedence, parenthesize</li>
<li>ES 44 Do not depend on order of evaluation</li>
</ul></li>
<li><p>Rely on C++20’s synthesized or rewritten comparison operators to ensure that all of the related comparison operators behave consistently.</p></li>
</ul>
<h2 id="XYQ">6.26 Dead and Deactivated Code [XYQ]</h2>
<h3 id="applicability-to-language">6.26.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC 24772-1 clause 6.26 exists in C++.</p>
<p>The language mechanisms around templates and overload resolution can require definitions to exist that are not part of the executable program. But the mechanisms at compile time guarantee that the corresponding code never becomes part of the executable program. However, a programmer might be unaware of all details with respect to the language mechnisms and thus make subtle errors leading to code selected for the executable program that was unintended.</p>
<p>If there is code that was once needed or might be needed in the future, programmers might opt to comment or use preprocessor conditional compilation to exclude such parts. The latter might even be confusing, because an intentionally undefined macro might be defined for a specific compilation outside of the program source text. Modern version control systems are better places to keep unused code in a revision or branch and ressurect it if needed through a merge.</p>
<h3 id="guidance-to-language-users">6.26.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance of ISO/IEC 24772-1 clause 6.26.5.</p></li>
<li><p>Use IDEs or similar tools that visualize the code that gets selected for the executable program.</p></li>
<li><p>Use modern version control to manage unused code.</p></li>
</ul>
<h2 id="switch-statements-and-static-analysis-cll">6.27 Switch Statements and Static Analysis [CLL]</h2>
<h3 id="applicability-to-language">6.27.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.27 exists in C++.</p>
<p>Because of the way in which the switch-case statement in C++ is structured, it can be relatively easy to unintentionally omit the break statement between cases causing unintended execution of statements for some cases.</p>
<p>The switch statement has the form:</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> abc = someExpression();</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* … */</span></span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> (abc) {</span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a>       <span class="cf">case</span> <span class="dv">1</span>:</span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a>          sval = “a”;</span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true" tabindex="-1"></a>           <span class="cf">break</span>;</span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true" tabindex="-1"></a>       <span class="cf">case</span> <span class="dv">2</span>:</span>
<span id="cb138-8"><a href="#cb138-8" aria-hidden="true" tabindex="-1"></a>           sval = “b”;</span>
<span id="cb138-9"><a href="#cb138-9" aria-hidden="true" tabindex="-1"></a>           <span class="cf">break</span>;</span>
<span id="cb138-10"><a href="#cb138-10" aria-hidden="true" tabindex="-1"></a>       <span class="cf">case</span> <span class="dv">3</span>:</span>
<span id="cb138-11"><a href="#cb138-11" aria-hidden="true" tabindex="-1"></a>           sval = “c”;</span>
<span id="cb138-12"><a href="#cb138-12" aria-hidden="true" tabindex="-1"></a>           <span class="cf">break</span>;</span>
<span id="cb138-13"><a href="#cb138-13" aria-hidden="true" tabindex="-1"></a>       <span class="cf">default</span>:</span>
<span id="cb138-14"><a href="#cb138-14" aria-hidden="true" tabindex="-1"></a>           <span class="cf">throw</span> SomeException();</span>
<span id="cb138-15"><a href="#cb138-15" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>If there isn’t a default case and the switched expression doesn’t match any of the cases, then control simply shifts to the next statement after the switch statement block. Unintentionally omitting a break statement between two cases will cause subsequent cases to be executed until a break or the end of the switch block is reached. This could cause unexpected results.</p>
<p>The attribute <code class="sourceCode cpp">[[<span class="at">fallthrough</span>]]</code> expresses the programmer’s intent that the code where it is placed is intended to fall through. If this attribute is not used, compilers typically diagnose the absence of a break statement.</p>
<h3 id="guidance-to-language-users">6.27.2 Guidance to language users</h3>
<ul>
<li><p>Apply the guidance provided in ISO/IEC TR 24772-1:2019 clause 6.27.5</p></li>
<li><p>Use <code class="sourceCode cpp">[[<span class="at">fallthrough</span>]]</code> wherever fall-through is intended.</p></li>
<li><p>Terminate every case with either a flow control transfer or <code class="sourceCode cpp">[[<span class="at">fallthrough</span>]]</code> as illustrated in the following example:</p>
<pre><code>```{.cpp}
int i;
. . .
switch (i) {
       case 1: 
                     [[fallthrough]]; // documents the intended fallthrough.
       case 2:
            i++;    
            break;
        case 3: 
            j++; 
          [[fallthrough]]; // documents the intended fallthrough.
       case 4: //other code
            return 42;
       default: throw CaseNotFound();   
      }
```</code></pre></li>
<li><p>Adopt a style that permits your language processor and analysis tools to verify that all cases are covered. Where this is not possible, use a default clause that diagnoses the error.</p></li>
</ul>
<blockquote>
<p>See also the C++ Core Guidelines ES.78</p>
</blockquote>
<h2 id="demarcation-of-control-flow-eoj">6.28 Demarcation of Control Flow [EOJ]</h2>
<h3 id="applicability-to-language">6.28.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.28 exists in C++.</p>
<p>C++ lacks a keyword to be used as an explicit terminator. Therefore, it may not be readily apparent which statements are part of a loop construct or an if statement.</p>
<p>Consider the following sections of code:</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foo(<span class="dt">int</span> a, <span class="at">const</span> <span class="dt">int</span> *b) {</span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i=<span class="dv">0</span>;</span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// . . .</span></span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a>        a = <span class="dv">0</span>;</span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">10</span>; i++); <span class="co">// notice the &#39;;&#39; !!</span></span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a>        {</span>
<span id="cb140-7"><a href="#cb140-7" aria-hidden="true" tabindex="-1"></a>            a = a + b[i];</span>
<span id="cb140-8"><a href="#cb140-8" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb140-9"><a href="#cb140-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> c = <span class="dv">0</span>;</span>
<span id="cb140-10"><a href="#cb140-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x = <span class="dv">0</span>;</span>
<span id="cb140-11"><a href="#cb140-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (<span class="dt">int</span> j=<span class="dv">0</span>; j&lt;<span class="dv">10</span>; j++)</span>
<span id="cb140-12"><a href="#cb140-12" aria-hidden="true" tabindex="-1"></a>            c = c + b[j];</span>
<span id="cb140-13"><a href="#cb140-13" aria-hidden="true" tabindex="-1"></a>            x += c; </span>
<span id="cb140-14"><a href="#cb140-14" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>At first it may appear that, after the first loop, <code class="sourceCode cpp">a</code> will be a sum of the numbers <code class="sourceCode cpp">b[<span class="dv">0</span>]</code> to <code class="sourceCode cpp">b[<span class="dv">9</span>]</code>. However, even though the code is laid out so that the <code class="sourceCode cpp">a = a + b[i]</code> code appears to be within the for loop, the “<code class="sourceCode cpp">;</code>” at the end of the for statement causes the loop to be on a null statement (the “<code class="sourceCode cpp">;</code>”) and the</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a>a = a + b[i];</span></code></pre></div>
<p>statement to only be executed once. Similarly, the indentation leads us to believe that that assignment to x is part of the second loop, but it is not. These mistakes may be readily apparent during development or testing. More subtle cases may not be as readily apparent leading to unexpected results.</p>
<p><code class="sourceCode cpp"><span class="cf">if</span></code> statements in C++ are also susceptible to control flow problems since there isn’t a requirement in C++ for there to be an else statement for every if statement. An <code class="sourceCode cpp"><span class="cf">else</span></code> statement in C++ always belong to the most recent <code class="sourceCode cpp"><span class="cf">if</span></code> statement without an <code class="sourceCode cpp"><span class="cf">else</span></code>. However, the situation could occur where it is not readily apparent to which <code class="sourceCode cpp"><span class="cf">if</span></code> statement an <code class="sourceCode cpp"><span class="cf">else</span></code> belongs due to the way the code is indented or aligned.</p>
<p>Similar issues arise for <code class="sourceCode cpp"><span class="cf">if</span></code>-statements, particularly during maintenance, for example:</p>
<pre><code>```{.cpp}
int a,b,i;
// . . . 
if (i == 10){
       a = 5;       
       b = 10; // added later, but correct since within the {…}
      }
      else 
          a = 10;   
          b = 5;    // added later, intended to be part 
                        // of the else clause
```</code></pre>
<p>If the assignments to b were added later and were expected to be part of each <code class="sourceCode cpp"><span class="cf">if</span></code> and <code class="sourceCode cpp"><span class="cf">else</span></code> clause (they are indented as such), the above code is incorrect: the assignment to <code class="sourceCode cpp">b</code> that was intended to be in the <code class="sourceCode cpp"><span class="cf">else</span></code> clause is unconditionally executed.</p>
<h3 id="guidance-to-language-users">6.28.2 Guidance to language users</h3>
<ul>
<li><p>Follow the rules provided in ISO/IEC TR 24772-1:2019 clause 6.28.5.</p></li>
<li><p>Enclose the bodies of <code class="sourceCode cpp"><span class="cf">if</span></code>, <code class="sourceCode cpp"><span class="cf">else</span></code>, <code class="sourceCode cpp"><span class="cf">while</span></code>, <code class="sourceCode cpp"><span class="cf">for</span></code>, and similar in braces. This will reduce confusion and potential problems when modifying the software.</p></li>
<li><p>Declare loop variables in the initializer of the loop statement</p></li>
<li><p>Prefer the standard library algorithms over hand-crafted loops.</p></li>
<li><p>Consider the use of source code auto-formatters before code reviews.</p></li>
</ul>
<blockquote>
<p>See also the C++ Core Guidelines ES.85, ES.71, ES.74, ES.1 and ES.2</p>
</blockquote>
<h2 id="loop-control-variables-tex">6.29 Loop Control Variables [TEX]</h2>
<h3 id="applicability-to-language">6.29.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.29 exists in C++.</p>
<p>C++ allows the modification of loop control variables within non range-based loops. This is usually not considered good programming practice as it can cause unexpected problems. The flexibility of C++ expects the programmer to use this capability responsibly.</p>
<p>Since the modification of a loop control variable within a loop is infrequently encountered, reviewers of C++ code may not expect it and hence miss noticing the modification. Modifying the loop control variable can cause unexpected results if not carefully done. In C++, the following is semantically correct, but is error-prone:</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a;</span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; <span class="dv">10</span>; i++){</span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (a &gt; <span class="dv">7</span>)</span>
<span id="cb143-5"><a href="#cb143-5" aria-hidden="true" tabindex="-1"></a>        i = <span class="dv">10</span>;</span>
<span id="cb143-6"><a href="#cb143-6" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb143-7"><a href="#cb143-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>which will cause the for loop to exit once <code class="sourceCode cpp">a</code> is greater than <code class="sourceCode cpp"><span class="dv">7</span></code> regardless of the number of iterations that have occurred.</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">int</span> i : <span class="bu">std::</span>ranges<span class="bu">::</span>iota_view{<span class="dv">1</span>,<span class="dv">10</span>})</span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (a &gt; <span class="dv">7</span>) {</span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a>       i = <span class="dv">10</span>;   <span class="co">// This changes the local variable for this loop iteration&#39;s execution</span></span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>                 <span class="co">// but subsequent iterations are not affected</span></span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a>       }</span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb144-8"><a href="#cb144-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb144-9"><a href="#cb144-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">int</span> <span class="at">const</span> i : <span class="bu">std::</span>ranges<span class="bu">::</span>iota_view{<span class="dv">1</span>,<span class="dv">10</span>})</span>
<span id="cb144-10"><a href="#cb144-10" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb144-11"><a href="#cb144-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (a &gt; <span class="dv">7</span>) {</span>
<span id="cb144-12"><a href="#cb144-12" aria-hidden="true" tabindex="-1"></a>       i = <span class="dv">10</span>;   <span class="co">// This is now illegal since the &#39;const int&#39; prevents assign</span></span>
<span id="cb144-13"><a href="#cb144-13" aria-hidden="true" tabindex="-1"></a>       }</span>
<span id="cb144-14"><a href="#cb144-14" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>The range for example immediately above does not have the vulnerability of the C-like for loop above.</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">1</span>; i &lt; <span class="dv">10</span>; ++i) ...</span></code></pre></div>
<p>In a range-based for loop, the control variable is not available.</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>array a {<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">5</span>};</span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="kw">auto</span> <span class="at">const</span> x : a) {</span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h3 id="guidance-to-language-users">6.29.2 Guidance to language users</h3>
<ul>
<li><p>Apply the guidance of ISO/IEC TR 24772-1:2019 clause 6.29.5.</p></li>
<li><p>Do not modify a loop control variable within a loop.</p></li>
<li><p>Use a range-for loop in preference to general loops.</p></li>
<li><p>Alternatively, use standard library generic algorithm functions like <code>copy</code>, <code>reduce</code>, <code>transform</code>, <code>inner_product</code>, etc. in preference to general loops.</p></li>
</ul>
<p>Note: See also the C++ Core Guidelines ES.71, ES.86.</p>
<h2 id="off-by-one-error-xzh">6.30 Off-by-one Error [XZH]</h2>
<h3 id="applicability-to-language">6.30.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.30 exists in C++.</p>
<p>Arrays are a common place for off by one errors to manifest. In C++, arrays are indexed starting at 0, causing the common mistake of looping from 0 to the size of the array as in:</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> foo() {</span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a[<span class="dv">10</span>];</span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i;</span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i=<span class="dv">0</span>, i&lt;=<span class="dv">10</span>, i++)</span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>      ...</span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="dv">0</span>);</span>
<span id="cb147-7"><a href="#cb147-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>C++ mitigates the issue of sentinel values in strings document in TR 24772-1 by providing the <code class="sourceCode cpp">string</code> class and the <code class="sourceCode cpp">string_view</code> class.</p>
<p>C++ does not flag accesses outside of array bounds, so an off by one error may not be as detectable in C++ as in some other languages. Several good and freely available tools can be used to help detect accesses beyond the bounds of arrays that are caused by an off by one error. However, such tools will not help in the case where only a portion of the array is used, and the access is still within the bounds of the array.</p>
<p>C++ mitigates these issues by providing</p>
<ul>
<li><p>Range-based for loops</p></li>
<li><p><code class="sourceCode cpp">std</code> algorithms</p></li>
<li><p>Iterator style loops terminated by <code class="sourceCode cpp">!=</code></p></li>
<li><p>Container classes</p></li>
<li><p><code class="sourceCode cpp">gsl::span</code> (soon to be <code class="sourceCode cpp"><span class="bu">std::</span>span</code>)</p></li>
</ul>
<h3 id="guidance-to-language-users">6.30.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance of ISO/IEC TR 24772-1:2019 clause 6.30.5.</p></li>
<li><p>Use careful programming, testing of border conditions, and static analysis tools to detect off-by-one errors in C++.</p></li>
<li><p>Use range-based for loops, std algorithms, iterator style loops terminated by !=, or container classes in preference to C-style arrays and structures.</p></li>
</ul>
<blockquote>
<p>See also the C++ Core guidelines ES.1, ES.42, ES.71, SL.con.3 (more to come)</p>
</blockquote>
<h2 id="structured-programming-ewd">6.31 Structured Programming [EWD]</h2>
<h3 id="applicability-to-language">6.31.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.31 exists in C++.</p>
<p>It is as easy to write structured programs in C++ as it is not to. C++ contains the <code class="sourceCode cpp"><span class="cf">goto</span></code> statement, which can create unstructured code. It also has <code class="sourceCode cpp"><span class="cf">continue</span></code>, <code class="sourceCode cpp"><span class="cf">break</span></code>, and <code class="sourceCode cpp"><span class="cf">return</span></code> that can create a complicated control flow, when used in an undisciplined manner. Spaghetti code can be more difficult for static analyzers to analyze and is sometimes used on purpose to intentionally obfuscate the functionality of software. Code that has been modified multiple times by an assortment of programmers to add or remove functionality or to fix problems can be prone to become unstructured.</p>
<p>Because unstructured code in can cause problems for analyzers, both automated and human, of code, problems with the code may not be detected as readily or at all as would be the case if the software was written in a structured manner.</p>
<p>In C++, the <code class="sourceCode cpp"><span class="cf">break</span></code> and <code class="sourceCode cpp"><span class="cf">continue</span></code> operations only act on the innermost loop. At times, escape from nested loops is required. In such cases, the use of <code class="sourceCode cpp"><span class="cf">goto</span></code> may be simpler and easier to verify than a series of tests with <code class="sourceCode cpp"><span class="cf">break</span></code> and/or <code class="sourceCode cpp"><span class="cf">continue</span></code> operations.</p>
<p>The <code class="sourceCode cpp">setjmp</code> macro sets the current execution context into a variable, which can be use later to return to that current context using <code class="sourceCode cpp">longjmp</code> call. These calls originated from the C standard library to mimic <code class="sourceCode cpp"><span class="cf">goto</span></code> across the call stack. They do not support the relevant additions to C++ such as destructors for automatic objects, exceptions, and concurrency, and hence are incompatible with modern C++ programming.</p>
<p>A coroutine is a function that can suspend execution for later resumption (optional).</p>
<h3 id="guidance-to-language-users">6.31.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance of ISO/IEC 24772-1 clause 6.31.5.</p></li>
<li><p>Write clear and concise structured code to make code as understandable as possible.</p></li>
<li><p>Avoid the use of <code class="sourceCode cpp">setjmp</code> and <code class="sourceCode cpp">longjmp</code></p></li>
<li><p>Consider the use of coroutines as an alternative to <code class="sourceCode cpp"><span class="cf">goto</span></code> and <code class="sourceCode cpp">setjmp/longjmp</code></p></li>
</ul>
<p>See also the C++ Core guidelines ES.76, ES.77, SL.C.1</p>
<h2 id="passing-parameters-and-return-values-csj">6.32 Passing Parameters and Return Values [CSJ]</h2>
<h3 id="applicability-to-language">6.32.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.32 exists in C++. However, the language also provides appropriate mitigation.</p>
<p>C++ provides both <em>call by copy</em> (aka <em>call by value</em>) and <em>call by reference</em> parameter passing. The argument is evaluated to initialize the formal parameter (in the first case) or bound to the formal parameter (in the second case) of the function that is being called. A formal parameter behaves like a local variable, however, changes to a non-const reference parameter affect the bound object.</p>
<p>The rich type system of C++ allows types that when passed by value still have <em>call by reference</em> semantics, for example, pointer types, <code>std::reference_wrapper</code>, or class types with pointer or reference member variables.</p>
<p>C++ assumes that pointer or reference parameters of different types never alias, even if the underlying object representations are identical, i.e., for a function declared as <code class="sourceCode cpp"><span class="dt">void</span> f(<span class="dt">int</span> *pi, <span class="dt">long</span> *pl)</code> the compiler will assume that <code>pi</code> and <code>pl</code> always refer to different objects, even if <code class="sourceCode cpp"><span class="kw">sizeof</span>(<span class="dt">int</span>) == <span class="kw">sizeof</span>(<span class="dt">long</span>)</code>. Two parameters may refer to the same object if they have pointer or reference type, and the target types are the same or related. This means, aliasing between reference parameters or with a reference result needs to be taken into account in user code. For example, in an assignment expression the left and right hand side can refer to the same object. This implies that user-defined assignment operators must take precautions against self-assignment or document that it is forbidden.</p>
<p>Modern C++ ensures that in many cases the need for and overhead of copying value arguments or results is elided by the compiler, especially from temporary objects.</p>
<p>The use of <code class="sourceCode cpp"><span class="at">const</span></code> lvalue-reference parameters combines the efficiency of <em>call by reference</em> with the guarantee that the underlying input parameter is not changed (marking it as an <em>in</em> parameter). A non-const reference parameter must be considered an <em>inout</em> parameter. Rvalue-reference parameters are <em>inout</em> parameters that allow <em>transfer-of-ownership</em> semantics. At their call site it is best to assume that the argument object is in an indeterminate state and has to be reassigned before subsequent use. There is no language mechanism for marking <em>out</em> parameters, one would use the return mechanism. Instead of multiple <em>out</em> parameters a <code class="sourceCode cpp"><span class="kw">struct</span></code>, <code class="sourceCode cpp"><span class="bu">std::</span>pair</code>, or <code class="sourceCode cpp"><span class="bu">std::</span>tuple</code> can be used as a return type and eventually decomposed at the call site to its constituents via a <em>structured binding</em>.</p>
<p>Member functions take the <code class="sourceCode cpp">*<span class="kw">this</span></code> object as an implicit reference parameter. The kind of reference can be specified through qualification of the member function. However, in addition to lvalue-reference, const-lvalue-reference, and rvalue-reference qualification, there exists an oddity with respect to normal reference parameters:</p>
<ul>
<li>without a qualification a member function can be called on rvalues and non-const lvalues, and</li>
<li>with a const-qualification a member function can be called on const lvalues and rvalues.</li>
</ul>
<p>This means, unqualified member functions are callable on temporaries (rvalues) and thus can have side effects, but also can return an lvalue-reference to said temporary by returning <code>*this</code> (or members of <code>*this</code>), which can lead to dangling if such a reference is used beyond the expression of the function call returning it. For example, the compiler-provided assignment operators of a class are unqualified member functions that return an lvalue-reference to <code class="sourceCode cpp">*<span class="kw">this</span></code>.</p>
<p>Rvalue-reference parameters in a context where their actual type is deduced from the call site, are called <em>forwarding references</em>. A forwarding references will either be deduced to an lvalue-reference or an rvalue-reference depending on the argument at the call site.</p>
<p>The C++ preprocessor macros use a <em>call by name</em> parameter passing; a call to the macro replaces the macro by the body of the macro. This is called <em>macro expansion</em>. Macro expansion is applied to the program source text and amounts to the substitution of the formal parameters with the actual parameter expressions. Formal parameters are often parenthesized to avoid syntax issues after the expansion. Call by name parameter passing reevaluates the actual parameter expression each time the formal parameter is read.</p>
<h3 id="guidance-to-language-users">6.32.2 Guidance to language users</h3>
<ul>
<li><p>Follow the advice of ISO/IEC TR 24772-1:2019 clause 6.32.5.</p></li>
<li><p>Prefer pass-by-value and pass-by-const-reference over other means of parameter declaration.</p></li>
<li><p>Prefer reference parameters over corresponding pointer parameters.</p></li>
<li><p>Use pass by non-const reference only when side-effects on the argument are intended (<em>inout</em>-parameter).</p></li>
<li><p>Always reassign a variable passed by rvalue-reference before subsequent use after the call.</p></li>
<li><p>Use forwarding reference parameters only, if perfect forwarding is needed in the body of a function template or generic lambda.</p></li>
<li><p>Define member functions that have side effects on <code class="sourceCode cpp">*<span class="kw">this</span></code> or return a potentially dangling object referring to <code>*this</code> or its members with the appropriate lvalue-ref-qualification. Either delete the rvalue-ref-qualified overload if a const-ref-qualified overload exists to avoid calling the function on temporary objects, or define the rvalue-ref-qualified overload as returning by value.</p></li>
<li><p>Document the referents of potentially dangling objects created by or modified by a function if any potentially dangling object outlives the invocation of that function.</p></li>
<li><p>Document any allowable aliasing between the referents of function parameters of potentially dangling type. Absent such documentation, avoid passing aliased parameters. In particular, aliasing is expected and allowed in these classes of functions:</p>
<ul>
<li><p>Assignment and compound assignment operators: the right parameter may alias the left parameter. The function result always refers to the left parameter unless overloaded differently. In the case of self-assignment the stored value should not change.</p></li>
<li><p>Functions named <code class="sourceCode cpp">swap</code>: The two parameters to be swapped may refer to the same object.</p></li>
<li><p>Shift operators used for input and output: the result always refers to the left parameter.</p></li>
<li><p>Prefix increment and decrement operators: the result always refers to the parameter.</p></li>
</ul></li>
<li><p>Do not use function-like macros. If used, surround all macro parameters in the replacement text with parenthesis.</p></li>
</ul>
<h2 id="dangling-references-to-stack-frames-dcm">6.33 Dangling References to Stack Frames [DCM]</h2>
<h3 id="applicability-to-language">6.33.1 Applicability to language</h3>
<p>C++ allows one variable to refer to another variable. For example, a pointer variable can contain the address of another variable; a reference can be bound to a variable; and an iterator can point to a portion of a variable (in this case a container). Should the referencing variable outlive the referenced variable, the subsequent operations through the referencing variable will have undefined behavior.</p>
<p>For example</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> *bad_pointer() {</span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a = <span class="dv">0</span>;</span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> &amp;a;      <span class="co">// Error. Returning the address of a local variable - Undefined Behaviour.</span></span>
<span id="cb148-4"><a href="#cb148-4" aria-hidden="true" tabindex="-1"></a> }</span>
<span id="cb148-5"><a href="#cb148-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-6"><a href="#cb148-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-7"><a href="#cb148-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span>&amp; bad_reference() {</span>
<span id="cb148-8"><a href="#cb148-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a = <span class="dv">0</span>;</span>
<span id="cb148-9"><a href="#cb148-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> a;      <span class="co">// Error, returning a reference to a local variable.</span></span>
<span id="cb148-10"><a href="#cb148-10" aria-hidden="true" tabindex="-1"></a> }</span>
<span id="cb148-11"><a href="#cb148-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-12"><a href="#cb148-12" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">3</span>&gt;::iterator bad_iterator()</span>
<span id="cb148-13"><a href="#cb148-13" aria-hidden="true" tabindex="-1"></a> {</span>
<span id="cb148-14"><a href="#cb148-14" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>array&lt;<span class="dt">int</span>,<span class="dv">3</span>&gt; a = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };</span>
<span id="cb148-15"><a href="#cb148-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> a.begin();  <span class="co">// Error, returning an iterator object that contains a pointer to first element of the local array &quot;a&quot;.</span></span>
<span id="cb148-16"><a href="#cb148-16" aria-hidden="true" tabindex="-1"></a> }</span>
<span id="cb148-17"><a href="#cb148-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-18"><a href="#cb148-18" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> bad_lambda() {</span>
<span id="cb148-19"><a href="#cb148-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x = <span class="dv">0</span>;</span>
<span id="cb148-20"><a href="#cb148-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [&amp;] { x = <span class="dv">1</span>; };   <span class="co">// Error, &#39;&amp;&#39; causes x to be captured by reference</span></span>
<span id="cb148-21"><a href="#cb148-21" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb148-22"><a href="#cb148-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-23"><a href="#cb148-23" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> erroneous_use() {</span>
<span id="cb148-24"><a href="#cb148-24" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; *bad_pointer();</span>
<span id="cb148-25"><a href="#cb148-25" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; bad_reference();</span>
<span id="cb148-26"><a href="#cb148-26" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; *bad_iterator();</span>
<span id="cb148-27"><a href="#cb148-27" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; bad_lambda()();</span>
<span id="cb148-28"><a href="#cb148-28" aria-hidden="true" tabindex="-1"></a> }</span></code></pre></div>
<p>C++ provides the ability to extend the lifetime of a temporary. Issues are below.</p>
<pre><code>#include &lt;array&gt;
struct A
{
 std::array&lt;int, 2&gt; const &amp; getArray () const {
   return m_array;
 }
 std::array&lt;int, 2&gt; m_array;
};
A getA ();

void foo1 ()
{
 for (auto i : getA ().getArray ())  // The initialization of i causes Undefined Behaviour
 {
 }
}

void foo2 ()
{
  auto const &amp; arr2 = getA();  // arr is a variable declaration that extends the lifetime of the return from getA
  for ( auto i : arr2.getArray ())
  {
  }
}

void foo3 ()
{
  auto &amp;&amp; arr3 = getA();  // arr is a variable declaration that extends the lifetime of the return from getA
  for ( auto i : arr3.getArray ())
  {
  }
}

</code></pre>
<p>In the example above for <code>foo1()</code>, there is no lifetime extension of the temporary returned from <code>getA()</code>, therefore <code>m_array</code> is destroyed before it is used, resulting in undefined behaviour. However, in <code>foo2()</code> and <code>foo3 ()</code>, the temporaries are extended because the declarations of the variables <code>arr2</code> and <code>arr3</code> receive the returns of <code>getA()</code> are bound to a const Lvalue reference and an Rvalue reference respectively.</p>
<p><em>need to say something about lifetime extension , returning references , ‘range for’ vulnerability with dangling references from temporaries. Peter</em> (Group thinks it is covered.)</p>
<p>_Remaining scenarios on lifetime extension: The lifetime of a temporary object created when evaluating the default arguments of a default or copy constructor used to initialize an element of an array ends before the next element of the array begins initialization. (Candidate for deletion unless we can create a scenario.)</p>
<p>Subtle text from [class.temporary] para 5 in C++17 or C++20</p>
<p>The temporary object to which the reference is bound or the temporary object that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference [Needs addressing with an example]</p>
<h3 id="guidance-to-language-users">6.33.2 Guidance to language users</h3>
<ul>
<li><p>Do not assign the address of an object, or reference to any entity where the referencing entity persists after the object has ceased to exist, in order to avoid the possibility of a dangling reference.</p></li>
<li><p>Do not returning the address or reference of a local variable as the result of a function call.</p></li>
<li><p>Avoid capturing by reference in lambdas that will be used non-locally, including return, or passing it to another thread, or stored in dynamic memory.</p></li>
<li><p>If attempting to bind a reference to a temporary object, … thinking …</p></li>
</ul>
<p>See also C++ Core Guidelines F.53, …</p>
<h2 id="OTR">6.34 Subprogram Signature Mismatch [OTR]</h2>
<h3 id="applicability-to-language">6.34.1 Applicability to language</h3>
<p>In general, there must be a match between the number of parameters in a function call and the number of arguments in the function definition. For issues related to macro signatures, see subclause <a href="NMP">Pre-processor directives[NMP]</a>.</p>
<p>The number of arguments can be different to the number of parameters in a function where: - a function template includes a <em>function parameter pack</em>, or - a function parameter includes a default argument, or - a function parameter-declaration-clause ends with an ellipsis, <code>f(\...)</code>.</p>
<p>Calling a function template with a <em>function parameter pack</em> results in a specialization of the function with the parameter types matching the corresponding argument types.</p>
<p>The compiler will ensure for variadic templates that the type and number of arguments is correct.</p>
<p>A call to a function with default arguments can provide fewer arguments than parameters as long as the parameters for which no explicit argument is provided include a default argument.</p>
<p>Where a function parameter-declaration-clause ends with an ellipsis, additional arguments can be accessed through the mechanisms provided by <code>&lt;cstdarg&gt;</code>. No information about the number or types of the parameters is supplied by the compiler. The use of this feature outside of special situations can be the basis for vulnerabilities.</p>
<p>Undefined behavior can arise, for example:</p>
<ul>
<li>Arguments with integral or enumeration type that are passed to an ellipsis parameter will undergo integral promotions, and so the type of the parameter is <code>int</code> and not <code>short</code>. The use of <code>short</code> with <code>va_arg</code> is therefore invalid.</li>
</ul>
<div class="sourceCode" id="cb150"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;cstdarg&gt;</span></span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">int</span> cnt, ...)</span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb150-5"><a href="#cb150-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">va_list</span> ap;</span>
<span id="cb150-6"><a href="#cb150-6" aria-hidden="true" tabindex="-1"></a>  va_start (ap, cnt);</span>
<span id="cb150-7"><a href="#cb150-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-8"><a href="#cb150-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">short</span> i = va_arg (ap, <span class="dt">short</span>);  <span class="co">// Invalid type</span></span>
<span id="cb150-9"><a href="#cb150-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-10"><a href="#cb150-10" aria-hidden="true" tabindex="-1"></a>  va_end(ap);</span>
<span id="cb150-11"><a href="#cb150-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<ul>
<li>In the following case, <code>f1</code> assumes that there will be two parameters after the named parameter.</li>
</ul>
<div class="sourceCode" id="cb151"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstdarg&gt;</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f1 (<span class="dt">int</span> cnt, ...)</span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">va_list</span> ap;</span>
<span id="cb151-6"><a href="#cb151-6" aria-hidden="true" tabindex="-1"></a>  va_start (ap, cnt);</span>
<span id="cb151-7"><a href="#cb151-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-8"><a href="#cb151-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i = va_arg (ap, <span class="dt">int</span>);</span>
<span id="cb151-9"><a href="#cb151-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> j = va_arg (ap, <span class="dt">int</span>);</span>
<span id="cb151-10"><a href="#cb151-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-11"><a href="#cb151-11" aria-hidden="true" tabindex="-1"></a>  va_end(ap);</span>
<span id="cb151-12"><a href="#cb151-12" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb151-13"><a href="#cb151-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-14"><a href="#cb151-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f2 ()</span>
<span id="cb151-15"><a href="#cb151-15" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb151-16"><a href="#cb151-16" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>);  <span class="co">// OK</span></span>
<span id="cb151-17"><a href="#cb151-17" aria-hidden="true" tabindex="-1"></a>  f1 (<span class="dv">1</span>, <span class="dv">2</span>);     <span class="co">// results in undefined behaviour</span></span>
<span id="cb151-18"><a href="#cb151-18" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>These issues cannot occur where default arguments or variadic function templates are used.</p>
<p>The C++ Name mangling ensures that function signatures match accross translation units.</p>
<p>This does not apply to other mangling schemes. For example, parameters do not form part of the mangled name for functions declared with the <code>extern "C"</code> linkage specification. Thus such a function can be invoked with incorrect parameter types due to an incorrect redeclaration of the function:</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="co">// library.cc</span></span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> <span class="dt">void</span> foo (<span class="dt">unsigned</span>, <span class="dt">unsigned</span>)</span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb152-5"><a href="#cb152-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb153"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="co">// main.cc</span></span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> <span class="dt">void</span> foo (<span class="dt">unsigned</span>);</span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main ()</span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a>  foo (<span class="bn">0xffffffff</span>);  <span class="co">// Calling function that is</span></span>
<span id="cb153-8"><a href="#cb153-8" aria-hidden="true" tabindex="-1"></a>                     <span class="co">// defined to take 2 parameters</span></span>
<span id="cb153-9"><a href="#cb153-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h3 id="guidance-to-language-users">6.34.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1:2019 clause 6.34.5.</p></li>
<li><p>Do not use functionality from <code>&lt;cstdarg&gt;</code>; use variadic function templates instead.</p></li>
<li><p>When using functions declared with <code>extern "C"</code> linkage specifications, use static analysis tools to ensure that all such declarations of equally named functions have identical signatures.</p></li>
</ul>
<p>Note: See also C++ Core Guidelines F.55.</p>
<h2 id="GDL">6.35 Recursion [GDL]</h2>
<h3 id="applicability-to-language">6.35.1 Applicability to language</h3>
<p>C++ permits recursion, hence is subject to the problems described in ISO/IEC 24772-1 clause 6.35.</p>
<p>C++ allows recursive <code class="sourceCode cpp"><span class="kw">constexpr</span></code> functions and <code class="sourceCode cpp"><span class="kw">consteval</span></code> functions that are evaluated at compile time where such calls don’t contribute to the vulnerability.</p>
<h3 id="guidance-to-language-users">6.35.2 Guidance to language users</h3>
<ul>
<li>Apply the guidance described in ISO/IEC 24772-1 clause 6.35.5.</li>
</ul>
<h2 id="ignored-error-status-and-unhandled-exceptions-oyb">6.36 Ignored Error Status and Unhandled Exceptions [OYB]</h2>
<h3 id="applicability-to-language">6.36.1 Applicability to language</h3>
<p>The vulnerabilities described in ISO/IEC 24772-1:2019 clause 6.36 exist in C++, however, C++ provides a mitigation.</p>
<p>C++ includes the C library, especially the header <code>&lt;cerrno&gt;</code> and thus shares C’s issues with the global error-reporting variable <code>errno</code>. See ISO/IEC TR 24772-3:2020, clause 6.36 for details and guidance.</p>
<p>In addition to <code>errno</code> some C++ library features expose error conditions indirectly via a side-effect on the object the operation failed with or via side-effect on a reference parameter. For example, input stream objects will go into a <code>fail</code> state, when formatted input cannot be performed. Without resetting that fail-state of a stream, further input will continue to fail, that can cause further failures when a failure is ignored. Streams provide a non-default mode to throw exceptions on failure. Another example of error reporting via a side-effect is the filesystem library that provides overloads that take a non-const reference of <code>std::error_code</code>.</p>
<p>In general, reporting errors as side-effects, in the worst case via a global state, is too easy to accidentally ignore by developers, leading to further consistency problems in the continued execution of the program.</p>
<p>By default, C++ has the C weakness of permitting the call to a function that returns an error code without capturing the return value in a variable.</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a>errnum foo( <span class="dt">int</span> a, <span class="dt">int</span> b);</span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a>. . .</span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a>foo(x, y); <span class="co">// failure to capture the return error code.</span></span></code></pre></div>
<p>C++ offers as a mitigating mechanism the <code class="sourceCode cpp">[[<span class="at">nodiscard</span>]]</code> attribute. This attribute indicates that the function result must not be discarded. Ignoring the result of a function marked <code class="sourceCode cpp">[[<span class="at">nodiscard</span>]]</code> causes a compiler warning.</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a>[[<span class="at">nodiscard</span>]] errnum foo( <span class="dt">int</span> a, <span class="dt">int</span> b);</span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a>. . .</span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a>foo(x, y);  <span class="co">// compile error.</span></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb155-5"><a href="#cb155-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>( <span class="kw">auto</span> e = foo(a,b); e == <span class="dv">0</span>) { <span class="co">// no compile error</span></span>
<span id="cb155-6"><a href="#cb155-6" aria-hidden="true" tabindex="-1"></a><span class="co">// success</span></span>
<span id="cb155-7"><a href="#cb155-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb155-8"><a href="#cb155-8" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> {</span>
<span id="cb155-9"><a href="#cb155-9" aria-hidden="true" tabindex="-1"></a><span class="co">// handle errors</span></span>
<span id="cb155-10"><a href="#cb155-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In addition, the C++ library provides mechanism to extend the return type of a function with extra values for denoting an error. The simplest case is <code class="sourceCode cpp"><span class="bu">std::</span>optional&lt;T&gt;</code> that extends <code class="sourceCode cpp">T</code> with an “empty” state. Callers must check the result of functions returning an <code class="sourceCode cpp">optional</code> for the empty state, before accessing its value. This increases the chances that a reported error is detected by the caller. If additional information of the error has to be returned to the caller <code class="sourceCode cpp"><span class="bu">std::</span>variant&lt;T,AnErrorCode&gt;</code> can be used instead.</p>
<p>C++ offers a set of library-defined exceptions for error conditions that may be detected by checks that are performed by the standard library. In addition, the programmer may define exceptions that are appropriate for their application. These exceptions are handled using an exception handler. Exceptions may be handled in the environment where the exception occurs or may be propagated out to an enclosing scope. Exceptions that are never handled in the program result in abnormal termination of the application. In this case, it is implementation-defined whether the destruction of local objects (stack unwinding) occurs. An unhandled exception that occurs in a thread also results in the abnormal termination of the application. See 6.62 Concurrency - Premature Termination [CGS] for issues related to thread or process termination.</p>
<h3 id="guidance-to-language-users">6.36.2 Guidance to language users</h3>
<ul>
<li><p>Follow the mitigation mechanisms of subclause 6.36.5 of ISO/IEC TR 24772-1:2019.</p></li>
<li><p>With respect to <code>errno</code> follow the mitigation mechanisms of subclause 6.36.5 of ISO/IEC TR 24772-3:2020.</p></li>
<li><p>Avoid error handling based on global state.</p></li>
<li><p>Use static analysis tools to detect and report missing or ineffective error detection or handling.</p></li>
<li><p>Use <code class="sourceCode cpp">[[<span class="at">nodiscard</span>]]</code> to prevent callers from ignoring error values and configure your compiler to report violations as errors (<code>-Werror</code>).</p></li>
<li><p>Consider <code>std::optional</code> or <code>std::variant</code> or similar mechanisms to extend a return type with an error status.</p></li>
<li><p>Handle errors at each function where an alternative strategy for mitigations of the error is available. In functions where no local mitigation strategy is available, pass on the error indication or ignore the exception, respectively, so that the error will be handled up the call chain.</p></li>
<li><p>Use a <code>try-catch</code> function body for <code>main</code> or any thread-entry function with a <code>catch(...)</code> handler to guarantee stack unwinding, that guarantees the destruction of all local objects.</p></li>
<li><p>Consider controlled termination as a last resort strategy for main or for <code class="sourceCode cpp"><span class="kw">noexcept</span></code> functions.</p></li>
<li><p>Consider the use of <code class="sourceCode cpp"><span class="bu">std::</span>exception_ptr</code> or an object encapsulating its mechanics like <code class="sourceCode cpp"><span class="bu">std::</span>future</code> to transport an exception from one thread to another thread for further processing.</p></li>
</ul>
<p>See also C++ Core Guidelines E.1, E.2, E.5, E.6, E.13, E.17, E.19, E.25, and E.28.</p>
<h2 id="type-breaking-reinterpretation-of-data-amv">6.37 Type-breaking Reinterpretation of Data [AMV]</h2>
<h3 id="applicability-to-language">6.37.1 Applicability to language</h3>
<p><em>This subclause requires a complete rewrite to have it reflect C++ issues.</em></p>
<p>The primary way in C that a reinterpretation of data is accomplished is through a union which may be used to interpret the same piece of memory in multiple ways. If the use of the union members is not managed carefully, then unexpected and erroneous results may occur.</p>
<p>C allows the use of pointers to memory so that an integer pointer could be used to manipulate character data. This could lead to a mistake in the logic that is used to interpret the data leading to unexpected and erroneous results.</p>
<p>C Part says</p>
<p><em>Wait for Gabriel</em> <em>to help analyze this.</em></p>
<h3 id="guidance-to-language-users">6.37.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1:2019 clause 6.38.5.</p></li>
<li><p>When using unions, implement an explicit discriminant and check its value before accessing the data in the union.</p></li>
<li><p>Ensure through static analysis that arbitrary pointer casts return a type compatible with the source.<span data-custom-style="annotation reference"></span></p></li>
<li><p>Avoid the use of C-style casts and reinterpret_cast</p></li>
</ul>
<h2 id="deep-vs.-shallow-copying-yan">6.38 Deep vs. Shallow Copying [YAN]</h2>
<h3 id="applicability-to-language">6.38.1 Applicability to Language</h3>
<p>The vulnerability described in ISO/IEC TR 24772-1:2019 clause 6.38 exists in C++ and only arises in C++ when there is a mismatch between the type’s copy semantics and the programmer’s intent.</p>
<p>On the language level, reference semantics, that can lead to shallow copies, usually requires the use of pointer or reference types, however, an integral type can also have reference semantics, for example, when it is used as an index or as an operating system handle.</p>
<p>Such types with reference semantics are also called <em>relationship types</em> and they will suffer from the aliasing problematic of this vulnerability and additionally from potential dangling due to expired lifetime of referred objects (see <a href="#XYK">[XYK]</a>).</p>
<p>In general, relationship types with an immutable referent, such as a const-reference, do not suffer the deep vs. shallow copying semantics problem, unless mixed with relationship types with a mutable reference to the same object. However, the lifetime of a const referent is still an issue to manage (see <a href="#XYK">[XYK]</a>).</p>
<p>The standard library type <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr&lt;T&gt;</code> has shallow copy semantics when the managed type is non-const, but in contrast to other relationship types guarantees the lifetime of the referent.</p>
<p>Class types that have <em>relationship type</em> members will become <em>relationship types</em> themselves, unless the class provides deep copy semantics or disables it and manages the lifetime of the referred object (<em>manager type</em>). Such <em>relationship types</em> and <em>manager types</em> will refer to their referred/managed resources via a data member with reference semantics.</p>
<p>A <em>manager type</em> defines a non-empty, non-deleted destructor in addition to providing appropriate copy and move operations. Examples of a <em>manager types</em> are the standard library container types such as <code class="sourceCode cpp"><span class="bu">std::</span>vector</code> that use pointers to the allocated space of their elements and copying a vector will also copy all contained elements not just the pointers. This management is achieved by replacing the compiler-provided copy-constructor and copy-assignment operator with implementations providing value semantics that perform the deep copy (<em>general manager</em>). An alternative to potentially expensive deep copies for <em>manager types</em> is the prevention of copying, either by defining move operations that transfer the ownership of a managed resources, like <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr</code> does (<em>unique manager</em>), or by preventing both copy and move operations (<em>scoped manager</em>), for example, by defining the move-assignment operator as deleted.</p>
<p>Without such replacement of copy and move operations a class type with <em>relationship type</em> members suffers from the potential confusion due to shallow copies. For example, the standard library types <code class="sourceCode cpp"><span class="bu">std::</span>span</code>, <code class="sourceCode cpp"><span class="bu">std::</span>string_view</code>, iterators, and the views of the standard ranges library are relationship types. Care must be taken to not only understand implications of their shallow copy semantics, but also about their validity depending on the lifetime of the referred ranges.</p>
<p>Using <em>relationship types</em> as function parameter types is usually safe, because language semantics guarantee the lifetime of parameter objects. Exceptions exists for thread functions and coroutines, where the initial calling context is not guaranteed to exist when parameters of relationship type are accessed.</p>
<p>Returning a relationship type from a function can be problematic, unless the lifetime of the referred object is clear. For example, returning a reference to a local variable will return a dangling reference (see <a href="#XYK">[XYK]</a> and <a href="#XYH">[XYH]</a>).</p>
<p>See also Core Guidelines C.20, C.22, C.32, C.67.</p>
<h3 id="guidance-to-language-users">6.38.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance given in ISO/IEC 24772-1 clause 6.38.5.</p></li>
<li><p>Prefer to use and create value types.</p></li>
<li><p>Consider relationship types only when the lifetime of the referent can be ensured, and</p>
<ul>
<li>when reference semantics is required, e.g., for side effects, or</li>
<li>when copying is prohibitively expensive.</li>
</ul></li>
<li><p>Be aware of <em>relationship types</em> and document the reference semantics of user-defined class types.</p></li>
<li><p>For <em>manager types</em>, define copy constructor, copy assignment operator, move constructor, move assignment operator, and their destructor appropriately.</p></li>
<li><p>Prefer value parameters to thread functions and coroutines.</p></li>
</ul>
<h2 id="memory-leak-and-heap-fragmentation-xyl">6.39 Memory Leak and Heap Fragmentation [XYL]</h2>
<h3 id="applicability-to-language">6.39.1 Applicability to language</h3>
<p>The memory leak vulnerability documented in ISO/IEC TR24772-1:2019 clause 6.39 exists in C++, unless the programmer takes steps to avoid it.</p>
<p>C++ uses destructors, and a pattern called <em>Resource Acquisition Is Initialization (RAII)</em> which performs recovery of resources. Destructors (and therefore memory and resource releases) are deterministically ordered with respect to other events on their thread. Object destructors will not be called</p>
<ul>
<li><p>When an unhandled exception escapes its thread of execution</p></li>
<li><p>Under conditions of abnormal termination</p></li>
</ul>
<p>See CERT ERR50-CPP for list of cases.</p>
<p>The steps mentioned above will mitigate most memory leak issues.</p>
<p>The mechanisms <code class="sourceCode cpp"><span class="bu">std::</span>shared_ptr</code> and <code class="sourceCode cpp"><span class="bu">std::</span>shared_future</code> and similarly constructed reference-counting user code do not detect cycles which will cause leaks because the shared pointers (and hence what they point to) will not be destroyed.</p>
<pre><code>&lt;!--
need to clarify to rely on memory managing types, containers, and unique ptr, shared ptr is often bad , Peter
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.39.2 Guidance to language users</h3>
<ul>
<li><p>Use containers and smart pointers in preference to direct (manual) memory management.</p></li>
<li><p>Follow C++ Core guidelines section R and CERT MEM51.</p></li>
<li><p>For heap fragmentation issues, follow the guidance of ISO/IEC TR 24772-1:2019 clause 6.39.5. In particular, create pools of fixed size with user-defined operators new and operators delete.</p></li>
<li><p>Use dynamic analysis tools to detect cycles.</p></li>
<li><p>Break cycles, for example by using <code class="sourceCode cpp"><span class="bu">std::</span>weak_ptr</code> or appropriate weak pointers.</p></li>
<li><p>Use <code class="sourceCode cpp"><span class="bu">std::</span>abort()</code> or <code class="sourceCode cpp"><span class="bu">std::</span>terminate()</code> and related functions only in extreme situations. See CERT ERR50-CPP for list of cases.</p></li>
<li><p>Use debugging tools such as leak detectors to help identify unreachable memory.</p></li>
</ul>
<h2 id="SYM">6.40 Templates and Generics [SYM]</h2>
<h3 id="applicability-to-language">6.40.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1 clause 6.40 exists in C++. C++ provides the facility <em>Templates</em> to support the generic programming methodology. C++ provides templates for functions, classes(types), and variables (constants). In addition one can form alias templates for class templates. Template parameters can be types, values (including addresses of global variables), and templates. C++ Templates can have variadic template parameters, that mean any number of arguments of a given kind can be used. Concepts are templates that describe constraints on template arguments and can be used to define template parameters or other deduced contexts. In the case of value template parameters using the keyword <code class="sourceCode cpp"><span class="kw">auto</span></code> allows deducing the parameter’s type from the argument given at instantiation time.</p>
<p>At compile-time, templates are instantiated with concrete template arguments. Function templates as well as class template constructors can deduce the concrete template argument from the types of the function arguments used in a call. For class templates in addition to the implicit deduction guides provided by its constructors, explicit deduction guides can be specified. This mechanism of template-argument deduction allows one to use templates without explicitly mentioning a template argument for each template parameter. For class templates, only those member functions get instantiated that are actually used. Each template instantiation is checked for syntax, concept and type errors.</p>
<p>Similar to function overloads, in the case of multiple possible instantiations from a template usage, templates are ordered. In case a “better matching” template fails its instantiation check, another alternative is chosen along the ordering of possible template specializations or overloads (SFINAE - substitution failure is not an error). This can be the source of programmer confusion but also provides a lot of power to the feature.</p>
<p>In case of a function overload set that includes function templates, overload resolution happens before template specialization. This means, any desired behaviour through explicit function template specialization is not considered during overload resolution, only the primary template is used there.</p>
<p>Class template and variable template specializations can provide specific code for a given set of template arguments. Such specializations must be defined in the namespace of the primary template. To prevent confusion and different compilation of identical looking template instantiations, a specialization should either be defined in the same file as the generic template, or in case of a specialization for a specific template argument type, in the file of the definition of that type.</p>
<p>Functions and lambdas that define parameters with the use of <code class="sourceCode cpp"><span class="kw">auto</span></code> are implicitly templates without using the <code class="sourceCode cpp"><span class="kw">template</span></code> keyword.</p>
<p>Variables defined with the use of <code>auto</code> keyword get their concrete type deduced from their initializer, as if they were function template parameters.</p>
<p>A constructor template or assignment operator template is never a copy or move operation and hence does not prevent the implicit definition of a copy or move operations even if it looks similar.</p>
<p>Due to the two phase compilation model of templates, name lookup can be surprising in class templates with dependent base classes. A name used in the derived class that is defined in the base might be found in an outer namespace instead.</p>
<pre><code>double foo{0};
template &lt;typename T&gt; 
struct base {
    int foo;
};
template &lt;typename T&gt; 
struct d : base&lt;T&gt;{
auto bar() {
return foo; // matches global foo not base&lt;T&gt;::foo
}
};</code></pre>
<p>In the above example using either <code class="sourceCode cpp"><span class="kw">this</span>-&gt;foo</code> or <code class="sourceCode cpp">d::foo</code> the member of the base class will be used.</p>
<p>When used appropriately, templates are suitable for embedded and safety critical systems;</p>
<ul>
<li>They provide type-safe generics in contrast to legacy <code class="sourceCode cpp"><span class="dt">void</span> *</code>-based or macro-based genericity;</li>
<li>They have no runtime overhead;</li>
<li>They do not have any implicit run-time memory usage; and</li>
<li>They do not generate code for unused operations.</li>
</ul>
<p>While using template greatly increases type safety, there can be requirements on template arguments that can neither be specified by concepts nor checked by a compiler. For example, sorting elements requires the comparison function to provide a <em>strict weak ordering</em> which is a property of the values of the type to be sorted by which are impossible to check at compile time for all possible value combinations.</p>
<p>C++ provides means to restrict template arguments. One is to use concepts, that can prevent instantiating a template, but allow for substituting it with an alternative. A second means is to use <code class="sourceCode cpp"><span class="kw">static_assert</span></code> in a template’s definition to prevent certain instantiations.</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> wrapper {</span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>T x;</span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span>(<span class="kw">not</span> (<span class="bu">std::</span>is_pointer_v&lt;T&gt; || <span class="bu">std::</span>is_reference_v&lt;T&gt;));</span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb158-6"><a href="#cb158-6" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb158-7"><a href="#cb158-7" aria-hidden="true" tabindex="-1"></a>wrapper(T )-&gt;wrapper&lt;T&gt;;</span>
<span id="cb158-8"><a href="#cb158-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-9"><a href="#cb158-9" aria-hidden="true" tabindex="-1"></a>wrapper&lt;<span class="dt">int</span>&gt; w{<span class="dv">42</span>};</span>
<span id="cb158-10"><a href="#cb158-10" aria-hidden="true" tabindex="-1"></a>wrapper x{&amp;w}; <span class="co">// compile error due to static_assert</span></span>
<span id="cb158-11"><a href="#cb158-11" aria-hidden="true" tabindex="-1"></a>wrapper&lt;<span class="dt">int</span>&amp;&gt;{}; <span class="co">// compile error due to static_assert</span></span></code></pre></div>
<p>The generic nature of templates require a more elaborate approach to unit tests. Such tests should provide instantiations of the base template and all provided explicit template specializations to ensure that each code path is actually tested. Tests for non-compilability of suppressed instantiations, i.e., through concepts or static_assert, are also beneficial.</p>
<p>Templates allow to reduce the amount of boilerplate code to write, e.g., by providing consistent definitions of operators. However, defining operator function templates in namespace scope can greatly influence compile times due to potential participation in the overload set, whenever the operator is used in code. In addition such generic operator functions might be picked up in inappropriate places causing programmer confusion. Implementing them as hidden friends in a CRTP base class instead makes using operator function templates feasible (see <a href="#YOW">6.20 Identifier Name Reuse [YOW]</a>).</p>
<pre><code>template &lt;typename T&gt;
struct Plus {
friend constexpr auto operator+(T l, T const &amp;r) {
  return l += r;
}
};
struct Int: Plus&lt;Int&gt; {
constexpr auto operator+=(Int const &amp;r) {
  val += r.val;
  return *this;
}
constexpr Int(int v):val{v}{}
int val;
};
struct Short: Plus&lt;Short&gt; {
constexpr auto operator+=(Short const &amp;r) {
  val += r.val;
  return *this;
}
constexpr Short(short v):val{v}{}
short val;
};
auto x = Int{4} + Int{38};
auto y = Short{4} + Short{2};</code></pre>
<pre><code>&lt;!--
Core guidelines (fill in references)

I.9 T.10, T.11, 12, 13, T.20, T.21, T.22, T.23, T.24, T.25, T.26, T.30,
T.31 -- forward to Clive.

(*We may wish to summarize)*
--&gt;</code></pre>
<h3 id="guidance-to-language-users">6.40.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance contained in ISO/IEC TR 24772-1:2019, 6.40.5. and the guidance provided in the different related sections of this document.</p></li>
<li><p>Use <code>static_assert</code> to prevent the use of inappropriate template arguments.</p></li>
<li><p>Consider using <em>concepts</em> to constrain template parameters.</p></li>
<li><p>Be aware that a constructor template or assignment operator function template will not replace compiler-provided special member functions.</p></li>
<li><p>For generic operator functions, consider providing them as hidden friends through mix-in class templates.</p></li>
<li><p>Use <em>qualified-id</em> or <code class="sourceCode cpp"><span class="kw">this</span>-&gt;</code> to refer to names that may be found in a dependent base class.</p></li>
<li><p>For template specialization, ensure that specializations are declared as follows:</p>
<ol type="1">
<li><p>In the same file as the primary template; or</p></li>
<li><p>In the same file as the user-defined type for which the specialization is declared.</p></li>
</ol></li>
<li><p>Do not specialize function templates.</p></li>
</ul>
<h2 id="RIP">6.41 Inheritance [RIP]</h2>
<h2 id="applicability-to-language">6.41.1 Applicability to language</h2>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.41 is applicable to C++.</p>
<p>Inheritance as a mechanism in C++ serves multiple purposes and is defined differently than in most other languages supporting inheritance.</p>
<ul>
<li>There is no implicit common base class.</li>
<li>Defining a member with a name that is defined in a base class causes hiding the base class member in the derived class including all overloads with that name. Full qualification via the base class name is required to access these hidden members.</li>
<li>A base class that declares virtual member functions defines inheritance in the classic object-oriented programming way. To employ the dynamic polymorphism in that case, requires the use of references or pointers to the base type. Such a base type needs to be public base class to obtain the ‘is-a’-relationship of the derived class. Multiple such bases complicate lookup and can yield ambiguities, causing code not to compile. Even private virtual member functions can be overridden in derived classes.</li>
<li>C++ allows base classes that don’t have virtual member functions. That means, the derived class cannot change the behavior of the base, but still inherits all features. To prevent accidentally using a derived class object via a base class reference, such bases could be defined as protected or private. However, that has other side effects, such as losing the “aggregate” property of a type with only public members and bases otherwise.</li>
<li>Inheriting from a non-polymorphic base class can be used to implement adaptor types, i.e., by limiting or extending the base’s functionality. Using private inheritance can be prevent treating the derived type object as a base type object. Inheriting constructors and using declarations ease re-promoting the scope of otherwise hidden members of the base.<br />
</li>
<li>Multiple inheritance adds additional dimension, because a class can inherit the same base class <code>A</code> indirectly via different direct base classes. Without any special preparation, this means the base class <code>A</code> object exists multiple times. Addressing members of <code>A</code> explicitly requires to specify the differentiating base class as a prefix, otherwise the code will be ambiguous. If all classes in such a multiple inheritance hierarchy that directly inherit from <code>A</code> use the keyword <code class="sourceCode cpp"><span class="kw">virtual</span></code> when inheriting from <code>A</code>, there will be only one object of type <code>A</code> in the most derived object. Inconsistently inheriting from <code>A</code> with and without <code>virtual</code> might lead to confusing behavior, because still multiple base objects of type <code>A</code> exist. Inheriting from base classes without virtual member functions and without non-static data members (empty bases) does not suffer from the multiple object problem of multiple inheritance, because the empty base class object will be omitted (elided) by the compiler (empty base class optimization). Such empty bases are often used to <em>mix-in</em> functionality into derived classes.</li>
</ul>
<p>The compiler-provided default behaviour for copy and move operations as well as destruction favors value semantics which conflicts with object-oriented polymorphic behaviour.</p>
<ul>
<li><p><strong>Virtual Destructor</strong>: This means, base classes that define virtual member functions will need to also define a virtual destructor and in addition need to care about the copy and move operations, otherwise deleting a dynamically-allocated derived object via a base class pointer will cause undefined behaviour.</p></li>
<li><p><strong>Slicing</strong>: A common failure is to not eliminate implicitly callable copy and move operations in base classes which will lead to accidental copying of a base class suboject via a base class reference that actually refers to a derived object. Preventing implicit copy and move operations in base classes defining virtual member functions is a common mitigation.</p></li>
<li><p><strong>Incomplete Copy</strong>: When a derived class defines its own non-defaulted, non-deleted copy or move operations, care must be taken to actually copy and move all base class subobjects as well. Omitting a base class when defining copy or move constructors means the default construction of a base class object happens. Not invoking a base class assignment in the definition of copy and move assignment operators will cause the base class retaining its previous members and not obtaining the source object’s base members. None of these omissions are a compile error and none are an issue for empty bases.</p></li>
</ul>
<p>If a base class overloads <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">new</span></code> and <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">delete</span></code>, dynamically allocting a derived class object that does not provide its own overloads of these dynamic allocation functions risks undefined behavior.</p>
<p>TODO: Paul give example.</p>
<p>The mechanisms of failure from ISO/IEC TR 24772-1:2019 clause 6.41 manifest and can be mitigated in C++ as follows:</p>
<ul>
<li><p><em>Execution of malicious redefinitions</em> can be prevented by use of <code class="sourceCode cpp"><span class="kw">final</span></code> on each member function to generate compiler diagnostics when overriding is not permitted.</p></li>
<li><p><em>Accidental redefinition</em> can be mitigated by a project mandate to use the <code class="sourceCode cpp"><span class="kw">override</span></code> or <code class="sourceCode cpp"><span class="kw">final</span></code> special identifiers when overriding a virtual member functions.</p></li>
<li><p><em>Accidental failure of redefinition</em> can be prevented by using <code class="sourceCode cpp"><span class="kw">override</span></code> on each member function intended to be redefined to generate compiler diagnostics when overriding does not apply.</p></li>
<li><p><em>Breaking of class invariants</em> can be avoided by proper initialization even with the default constructor and by defining data members private if the class invariant depends on them. If copy and move operations are user-defined in a derived class they must ensure to call the corresponding base class operations.</p></li>
<li><p><em>Direct reading and writing of visible class members</em> of a base class can be avoided by declaring the data members private and only allowing the class-invariant-preserving member functions in the derived classes. If those member functions are not part of the public API, they can be declared as <code class="sourceCode cpp"><span class="kw">protected</span></code>.</p></li>
</ul>
<h2 id="guidance-to-language-users">6.41.2 Guidance to language users</h2>
<ul>
<li><p>Follow the guidance of ISO/IEC TR 24772-1:2019 clause 41.5.</p></li>
<li><p>Except for <em>mix-in empty bases</em> avoid multiple inheritance.</p></li>
<li><p>Don’t define copy or move operations (see clause 6.38 Deep vs. Shallow Copying [YAN]). If you must implement copy- or move-operations in a derived class then always call the corresponding base classes’ operations.</p></li>
<li><p>Prefer composition over inheritance, in general keep inheritance hierarchies shallow.</p></li>
<li><p>Restrict the use of virtual member functions to situations where unbounded run-time polymorphism is beneficial.</p></li>
<li><p>Use <code class="sourceCode cpp"><span class="kw">override</span></code> when overriding a virtual member function to generate compiler diagnostics for failures to override.</p></li>
<li><p>Ensure re-compilation of all derived classes when a base class changes.</p></li>
<li><p>Consider using fully-qualified names to address members of a base class.</p></li>
<li><p>When defining a potentially hiding overload in a derived class, consider adding a <em>using declaration</em> of the base class name.</p></li>
<li><p>Prohibit the use of public inheritance for “has-a” relationships. Prefer composition or private/protected inheritance instead for “has-a”-relationships.</p></li>
<li><p>Don’t mix virtual and non-virtual inheritance of the same base class in a hierarchy.</p></li>
</ul>
<h2 id="BLP">6.42 Violations of the Liskov Substitution Principle or the Contract Model [BLP]</h2>
<h3 id="applicability-to-language">6.42.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC 24772-1 clause 6.42 applies to C++. C++ leaves verification of the correctness of an overridden call to the programmer.</p>
<p>The vulnerability can be mitigated by a style of programming that uses wrapper functions to check preconditions, calls a virtual function to perform the required functionality and subsequently checks the postconditions before returning. An example is provided below.</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Base  {</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">private</span>:</span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>     <span class="kw">virtual</span> <span class="dt">int</span> function_to_override( <span class="dt">int</span> x ) = <span class="dv">0</span>;</span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">// ...</span></span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span>:</span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a>     <span class="dt">int</span> interface_to_overridden_function( <span class="dt">int</span> x ) {</span>
<span id="cb161-8"><a href="#cb161-8" aria-hidden="true" tabindex="-1"></a>           check_preconditions( x );</span>
<span id="cb161-9"><a href="#cb161-9" aria-hidden="true" tabindex="-1"></a>           <span class="at">const</span> <span class="kw">auto</span> saved = data_saved_for_postcondition( x );</span>
<span id="cb161-10"><a href="#cb161-10" aria-hidden="true" tabindex="-1"></a>           <span class="kw">auto</span> result = function_to_override( x );</span>
<span id="cb161-11"><a href="#cb161-11" aria-hidden="true" tabindex="-1"></a>           check_postconditions( x, saved, result );</span>
<span id="cb161-12"><a href="#cb161-12" aria-hidden="true" tabindex="-1"></a>           <span class="cf">return</span> result;</span>
<span id="cb161-13"><a href="#cb161-13" aria-hidden="true" tabindex="-1"></a>         }</span>
<span id="cb161-14"><a href="#cb161-14" aria-hidden="true" tabindex="-1"></a>     <span class="co">// ...      </span></span>
<span id="cb161-15"><a href="#cb161-15" aria-hidden="true" tabindex="-1"></a> };</span></code></pre></div>
<h3 id="guidance-to-language-users">6.42.2 Guidance to language users</h3>
<ul>
<li><p>Obey all preconditions and postconditions of each member function, whether they are specified in the language or not.</p></li>
<li><p>Prohibit the strengthening of preconditions (specified or not) by overriding member functions.</p></li>
<li><p>Prohibit the weakening of postconditions (specified or not) by overriding member functions.</p></li>
<li><p>Prohibit the use of public inheritance for “has-a” relationships. Use composition for “has-a”-relationships instead.</p></li>
<li><p>Use static analysis tools that identify misuse of inheritance in the contract model.</p></li>
<li><p>Ensure that all invariants of a derived class are preserved by all public operations on its public base classes. If this cannot be ensured, make the base class private, or avoid inheritance.</p></li>
</ul>
<blockquote>
<p>See also C++ Core Guidelines C.120, C.121, C.122, C.126, C.127, and C.129 through C.133.</p>
</blockquote>
<h2 id="redispatching-pph">6.43 Redispatching [PPH]</h2>
<h3 id="applicability-to-language">6.43.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.43 exists in C++ for virtual functions, except for constructors and destructors which are not dispatching. An example of the infinite recursion is:</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A {</span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb162-5"><a href="#cb162-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A::f()</span><span class="sc">\n</span><span class="st">&quot;</span>; }</span>
<span id="cb162-6"><a href="#cb162-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> g() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A::g()</span><span class="sc">\n</span><span class="st">&quot;</span>; A::f(); }  <span class="co">//call to f() will not dispatch.</span></span>
<span id="cb162-7"><a href="#cb162-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> h() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A::h()</span><span class="sc">\n</span><span class="st">&quot;</span>; }</span>
<span id="cb162-8"><a href="#cb162-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> i() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A::i()</span><span class="sc">\n</span><span class="st">&quot;</span>; h(); } <span class="co">//call to h() will dispatch</span></span>
<span id="cb162-9"><a href="#cb162-9" aria-hidden="true" tabindex="-1"></a>                                                      <span class="co">//showing the vulnerability</span></span>
<span id="cb162-10"><a href="#cb162-10" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb162-11"><a href="#cb162-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-12"><a href="#cb162-12" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B : <span class="kw">public</span> A {</span>
<span id="cb162-13"><a href="#cb162-13" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb162-14"><a href="#cb162-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f() <span class="kw">override</span> { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;B::f()</span><span class="sc">\n</span><span class="st">&quot;</span>; g(); }</span>
<span id="cb162-15"><a href="#cb162-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> h() <span class="kw">override</span> { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;B::h()</span><span class="sc">\n</span><span class="st">&quot;</span>; i(); }</span>
<span id="cb162-16"><a href="#cb162-16" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb162-17"><a href="#cb162-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-18"><a href="#cb162-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main() {</span>
<span id="cb162-19"><a href="#cb162-19" aria-hidden="true" tabindex="-1"></a>    B b;</span>
<span id="cb162-20"><a href="#cb162-20" aria-hidden="true" tabindex="-1"></a>    A * pA = &amp;b;</span>
<span id="cb162-21"><a href="#cb162-21" aria-hidden="true" tabindex="-1"></a>    pA-&gt;f(); <span class="co">// no problem</span></span>
<span id="cb162-22"><a href="#cb162-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;---</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb162-23"><a href="#cb162-23" aria-hidden="true" tabindex="-1"></a>    pA-&gt;h(); <span class="co">// infinite recursion</span></span>
<span id="cb162-24"><a href="#cb162-24" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In C++, the call to a member function can be qualified, as shown in the above example, and avoids the vulnerability.</p>
<h3 id="guidance-to-language-users">6.43.2 Guidance to language users</h3>
<ul>
<li><p>At a call site, consider whether virtual dispatch is desired. If not, construct the call using the qualified name.</p></li>
<li><p>Be suspicious of any call from a virtual member function of the derived class to any member function of any of its base classes.</p></li>
</ul>
<h2 id="BKK">6.44 Polymorphic variables [BKK]</h2>
<h3 id="applicability-to-language">6.44.1 Applicability to language</h3>
<p>This vulnerability as described in ISO/IEC TR 24772-1:2019 applies to C++. In addition to the upcast and downcast issues addressed in that document, this clause also addresses cross-casting, which is unique to C++. For further type system related issues see subclause <a href="#IHN">Type System[IHN]</a>.</p>
<p>C++ provides language mitigations to help avoid the problems as follows:</p>
<p>Since C++ supports multiple inheritance, up-casting, down-casting, and cross-casting operations can be used to switch to different (pointer/reference) types in the inheritance hierarchy of a specific object, i.e.,</p>
<ul>
<li><p><em>up-casting</em> is casting an object to an ancestor type in the object's type inheritance hierarchy.</p></li>
<li><p><em>down-casting</em> is casting an object to a descendent type in the object's type inheritance hierarchy, and,</p></li>
<li><p><em>cross-casting</em> is casting an object to a sibling/cousin (possibly removed) type in the object's type inheritance hierarchy with multiple inheritance.</p></li>
<li><p>Unsafe casts, which include C-style casts and <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>, can cast to unrelated arbitrarily structured types. This allows reading and modifying arbitrary memory areas. See subclause [[6.11 Pointer Casting and Pointer Type Changes] [HFC](#HFC) for more details.</p></li>
</ul>
<blockquote>
<p>Developers should be aware that virtual member functions can be overridden in derived classes, even if they are private.</p>
</blockquote>
<p>Given the following:</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Z { <span class="dt">int</span> z; <span class="kw">virtual</span> ~Z() { } };</span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Y { <span class="dt">int</span> y; <span class="kw">virtual</span> ~Y() { } };</span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A : Z { <span class="dt">int</span> a; };</span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> B : <span class="kw">virtual</span> A { <span class="dt">int</span> b; };</span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> C : <span class="kw">virtual</span> A, Y { <span class="dt">int</span> c; };</span>
<span id="cb163-6"><a href="#cb163-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> D : B, C { <span class="dt">int</span> d; };</span>
<span id="cb163-7"><a href="#cb163-7" aria-hidden="true" tabindex="-1"></a>D d_inst;</span></code></pre></div>
<p>then these examples demonstrate upcasts, downcasts, and crosscasts:</p>
<p><strong>Upcasts:</strong></p>
<div class="sourceCode" id="cb164"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a>B* b_ptr = &amp;d_inst; <span class="co">// implicit</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a>C&amp; c_ref = d_inst; <span class="co">// implicit</span></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a>Z* z_ptr = <span class="kw">static_cast</span>&lt;Z*&gt;(&amp;d_inst);</span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a>Y* y_ptr = <span class="kw">dynamic_cast</span>&lt;Y*&gt;(&amp;d_inst);</span></code></pre></div>
<p><strong>Downcasts:</strong></p>
<div class="sourceCode" id="cb165"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a>D&amp; d_ref = <span class="kw">dynamic_cast</span>&lt;D&amp;&gt;(*y_ptr);</span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a>D* d_ptr = <span class="kw">static_cast</span>&lt;D*&gt;(b_ptr);</span></code></pre></div>
<p><strong>Crosscasts:</strong></p>
<div class="sourceCode" id="cb166"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a>C* c_ptr = <span class="kw">dynamic_cast</span>&lt;C*&gt;(b_ptr);</span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a>Y* y_ptr2 = <span class="kw">dynamic_cast</span>&lt;Y*&gt;(b_ptr);</span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a>C* c_ptr = <span class="kw">static_cast</span>&lt;C*&gt; (<span class="kw">static_cast</span>&lt;D*&gt;(b_ptr));</span></code></pre></div>
<p>and notes the following about such:</p>
<p>Upcasts:</p>
<ul>
<li><p>are the only ones that can be performed implicitly</p></li>
<li><p>can cause object slicing when a copy of a base class object is created from a derived class object.</p></li>
<li><p>can also be done with <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> or <code class="sourceCode cpp"><span class="kw">static_cast</span></code></p></li>
</ul>
<p>Downcasts</p>
<ul>
<li><p>are explicit;</p></li>
<li><p>can be done safely with <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code></p></li>
<li><p><code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> requires appropriate portions of inheritance to be polymorphic (i.e. has <code class="sourceCode cpp"><span class="kw">virtual</span></code> members);</p></li>
<li><p>can be done using <code class="sourceCode cpp"><span class="kw">static_cast</span></code> which is unchecked and may be unsafe;</p></li>
</ul>
<p>Crosscasts:</p>
<ul>
<li><p>are explicit</p></li>
<li><p>can be done safely with a single call to <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> which requires appropriate portions of inheritance to be polymorphic (i.e. has <code class="sourceCode cpp"><span class="kw">virtual</span></code> members).</p></li>
<li><p>can often be done with a chain of <code class="sourceCode cpp">static_casts</code> traversing the inheritance hierarchy, which is almost always unsafe.</p></li>
</ul>
<p>Deleting derived objects via a base class pointer is undefined behavior, unless the base class declares a virtual destructor.</p>
<h3 id="guidance-to-language-users">6.44.2 Guidance to language users</h3>
<ul>
<li><p>Follow the advice provided in ISO/IEC 24772-1 clause 6.44.5.</p></li>
<li><p>In a base class declaring virtual member functions, define a virtual defaulted destructor (Core Guidelines C.35) and make the class non-copyable (Core Guidelines C.130).</p></li>
<li><p>Avoid designs relying on downcasts or crosscasts; rely on proper virtual member functions in the base classes instead.</p></li>
<li><p>Avoid explicit upcast, rely on implicit conversion.</p></li>
<li><p>If a downcast or a crosscast is needed, prefer using <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> since it is checked.</p></li>
<li><p>Ensure that all invariants of a derived class are preserved by all public operations on its public base classes. If this cannot be ensured, make the base class private, or avoid inheritance.</p></li>
<li><p>Do not attempt to navigate class hierarchies using C-style casts or <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>.</p></li>
<li><p>Do not delete a polymorphic object without a virtual destructor. This includes using <code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr&lt;base&gt;</code> from a unique pointer allocated with <code class="sourceCode cpp"><span class="bu">std::</span>make_unique&lt;derived&gt;()</code></p></li>
</ul>
<blockquote>
<p>See also C++ Core Guidelines ES.48, ES.49, C.146, C.147, C.148 and C.153. source: OOP52-CPP?</p>
</blockquote>
<h2 id="LRM">6.45 Extra Intrinsics [LRM]</h2>
<h3 id="applicability-to-the-language">6.45.1 Applicability to the language</h3>
<p>The vulnerability as described in ISO/IEC 24772-1 clause 6.45 applies to C++ to some extent, as explained below.</p>
<p>C++ implementations are allowed to provide built-in functionality but are restricted to a specific naming schema reserved by the standard. For example, names containing a double underscore or that begin with an underscore and a capital letter are reserved for that purpose. See ISO/IEC 14882:2020 clause 5.10 [Lex.name]. The use of such names by the programmer is forbidden by the language. Language processors are not required to prohibit such usage, hence the vulnerability exists.</p>
<h3 id="avoiding-the-vulnerability-or-mitigating-its-effects">6.45.2 Avoiding the vulnerability or mitigating its effects</h3>
<p>Avoid the use of any name that is not allowed by the standard.</p>
<h2 id="argument-passing-to-library-functions-trj">6.46 Argument Passing to Library Functions [TRJ]</h2>
<h3 id="applicability-to-language">6.46.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.46 is applicable to C++.</p>
<p>Libraries that supply objects or functions are in most cases not required to check the validity of parameters passed to them. In those cases where parameter validation is required there might not be adequate parameter validation.</p>
<p>When calling a library, either the calling function or the library may make assumptions about parameters. For example, it may be assumed by a library that a parameter is non-zero so division by that parameter is performed without checking the value. Sometimes some validation is performed by the calling function, but the library may use the parameters in ways that were unanticipated by the calling function resulting in a potential vulnerability. Even when libraries do validate parameters, their response to an invalid parameter is usually undefined and can cause unanticipated results.</p>
<p>This vulnerability applies in particular to C++ libraries which are designed for high efficiency; responsibility for satisfying the preconditions for most functions rests with the caller. When these preconditions are not met, the result will be undefined behaviour. In addition, error conditions are specified by the language for specific functions, such as raising an exception, returning an error code or a known value, such as NaN.</p>
<h3 id="guidance-to-language-users">6.46.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1 clause 6.47.5.</p></li>
<li><p>Use translation modes provided the implementation to perform addition analysis or checking, such as contracts checks, or instrumentation of executing code.</p></li>
<li><p>Pay attention to the distinction between precondition violation and error conditions in library documentation. The former results in undefined behaviour; the latter results in defined but possibly unwanted behaviour.</p></li>
</ul>
<h2 id="inter-language-calling-djs">6.47 Inter-language Calling [DJS]</h2>
<h3 id="applicability-to-language">6.47.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.47 is applicable to C++.</p>
<p>C++ is a multi-paradigm language with a number of features that do not interface simply with other language systems. It is left to the implementation team the task of converting the results of these paradigms to constructs that can cross an interface for further processing in other languages.</p>
<p>C++ compilers provide an application binary interface (ABI) that delineates areas of interoperability with other languages or other C++ compiler/runtime systems. An ABI includes calling conventions, data layout, error and exception handling and return conventions, name mangling, data model, initialization of memory, and linkage to operating systems and libraries.</p>
<p>C++ compilers implement a C++ language linkage and a C language linkage. It is implementation-defined what other languages the implementation supports. Alternatively, other language systems provide linkages to C systems[^3](Ada has developed a standard for interfacing with C. Fortran has included a Clause 15 that explains how to call C functions.), leaving the developer the task of channeling everything through this common language system.</p>
<h3 id="guidance-to-language-users">6.47.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance contained in ISO/IEC TR 24772-1:2019 clause 6.47.5</p></li>
<li><p>Use standard layout types for the interoperable interfaces.</p>
<ul>
<li><pre><code>  Use language linkage facilities that support the languages being</code></pre>
<p>used.</p></li>
<li><pre><code>  EXP56-CPP. Do not call a function with a mismatched language</code></pre>
<p>linkage (-&gt; 6.47)</p></li>
<li><pre><code>  EXP60-CPP. Do not pass a nonstandard-layout type object across</code></pre>
<p>(-&gt; 6.47 ?)<br />
execution boundaries</p></li>
</ul></li>
<li><p>Be aware that the static initialization phase and dynamic initialization for every language system are required before the system begins execution</p></li>
<li><p>Be aware that C++ exceptions are not usually compatible with exceptions in other languages.</p></li>
<li><p>Segregate outgoing cross-language interfacing code into functions that present a C++ interface to the C++ code and implements that interface by calling code compatible with the other language system. Similarly implement incoming cross-language interfaces by providing simplified functions that presents a simplified (C or other language) interface and is implemented by calling C++ code with the correct style.</p></li>
<li><p>Separate the interfacing code from the code containing the main functionality</p></li>
</ul>
<p>See also the C++ Core Guidelines CPL.3.</p>
<p><em>AI 63-6 – group – add the guidance from 6.47.2 Interoperability into the Core Guidelines.</em></p>
<h2 id="NYY">6.48 Dynamically-linked Code and Self-modifying Code [NYY]</h2>
<h3 id="applicability-to-language">6.48.1 Applicability to language</h3>
<p>Most loaders allow dynamically linked libraries also known as shared libraries. Code is designed and tested using a suite of shared libraries which are loaded at execution time. The process of linking and loading is outside the scope of the C++ standard.</p>
<p>C++ prevents data pointers to be reinterpreted as function pointers and vice versa. Reinterpreting a pointer via a void pointer or <code class="sourceCode cpp"><span class="bu">std::</span>intptr_t</code> to a pointer of different type is undefined behaviour (with very few defined exceptions of data pointers to pointer to its raw bytes).</p>
<h3 id="guidance-to-language-users">6.48.2 Guidance to language users</h3>
<p>Follow the guidance of ISO/IEC 24772-1 clause 6.48.5.</p>
<ul>
<li>Rely on compiler warnings and analysis tools to prevent reinterpreting a data pointer as function pointer or vice versa.</li>
</ul>
<h2 id="NSQ">6.49 Library Signature [NSQ]</h2>
<h3 id="applicability-to-language">6.49.1 Applicability to language</h3>
<p>The vulnerability as enumerated in ISO/IEC 24772-1 clause 6.49 applies to C++.</p>
<p>As a mitigation, the C++ <code class="sourceCode cpp"><span class="at">extern</span> <span class="st">&quot;C&quot;</span></code> linkage specifier usually provides simple interoperability with libraries using the C application binary interface (ABI).</p>
<h3 id="guidance-to-language-users">6.49.2 Guidance to language users</h3>
<ul>
<li><p>Follow the advice of ISO/IEC 24772-1 clause 6.49.5.</p></li>
<li><p>Follow the advice of clause <a href="#DJS">6.47 Inter-language Calling [DJS]</a> as applicable.</p></li>
</ul>
<h2 id="unanticipated-exceptions-from-library-routines-hjw">6.50. Unanticipated Exceptions from Library Routines [HJW]</h2>
<h3 id="applicability-to-language">6.50.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 clause 6.50 exists for C++. In particular the issue of the failing dynamic initialization of namespace-scope objects exists in C++.</p>
<p>When dynamic initialization of a namespace-scope object fails with an exception, the exception cannot be caught and the program is terminated. Function-scope static objects, in contrast, are initialized the first time execution passes through the declaration. Using function-scope static objects in preference to dynamic initialization ensures that there is always an enclosing function that could catch the exception.</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="dt">exception_prone_type</span> troubling_object;</span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a><span class="co">// An exception from the constructor could cause termination.</span></span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a><span class="co">// The following function always returns a reference to the same object,</span></span>
<span id="cb170-4"><a href="#cb170-4" aria-hidden="true" tabindex="-1"></a><span class="co">// which is initialized the first time this function is called.</span></span>
<span id="cb170-5"><a href="#cb170-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-6"><a href="#cb170-6" aria-hidden="true" tabindex="-1"></a><span class="co">// If initialization fails, it will be retried on the next call.</span></span>
<span id="cb170-7"><a href="#cb170-7" aria-hidden="true" tabindex="-1"></a><span class="dt">exception_prone_type</span>&amp; safer_object()</span>
<span id="cb170-8"><a href="#cb170-8" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb170-9"><a href="#cb170-9" aria-hidden="true" tabindex="-1"></a>   <span class="at">static</span> <span class="dt">exception_prone_type</span> the_safer_object;</span>
<span id="cb170-10"><a href="#cb170-10" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> the_safer_object;</span>
<span id="cb170-11"><a href="#cb170-11" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<h3 id="guidance-to-language-users">6.50.2 Guidance to language users</h3>
<ul>
<li><p>Expect functions not marked <code class="sourceCode cpp"><span class="kw">noexcept</span></code> to throw exceptions of arbitrary type. Note that all destructors are implicitly <code class="sourceCode cpp"><span class="kw">noexcept</span></code>.</p></li>
<li><p>Follow the advice of clause 6.36.2 for catching and handling exceptions.</p></li>
<li><p>Prefer function-scope static objects to namespace-scope objects for objects needing dynamic initialization.</p></li>
</ul>
<h2 id="NMP">6.51 Pre-processor Directives [NMP]</h2>
<h3 id="applicability-to-language">6.51.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.51 applies to C++.</p>
<p>The C++ pre-processor allows the use of macros that are text-replaced before compilation.</p>
<p>Function-like macros look similar to functions but have different semantics. Because the arguments are text-replaced, expressions passed to a function-like macro may be evaluated multiple times. This can result in unintended and undefined behaviour if the arguments have side effects or are pre-processor directives. Additionally, the arguments and body of function-like macros should be fully parenthesized to avoid unintended and undefined behaviour.</p>
<p>The following code example demonstrates undefined behaviour when a function-like macro is called with arguments that have side-effects (in this case, the increment operator) .</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CUBE</span>(X)<span class="pp"> </span>((X)<span class="pp"> </span><span class="er">\</span>*<span class="pp"> </span>(X)<span class="pp"> </span><span class="er">\</span>*<span class="pp"> </span>(X))</span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i = <span class="dv">2</span>;</span>
<span id="cb171-4"><a href="#cb171-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a = <span class="dv">81</span> / CUBE(++i);</span></code></pre></div>
<p>The above example could expand to:</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a = <span class="dv">81</span> / ((++i) * (++i) * (++i));</span></code></pre></div>
<p>which has undefined behaviour so this macro expansion is difficult to predict.</p>
<p>Another mechanism of failure can occur when the arguments within the body of a function-like macro are not fully parenthesized. The following example shows the CUBE macro without parenthesized arguments.</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CUBE</span>(X)<span class="pp"> </span>(X<span class="pp"> </span><span class="er">\</span>*<span class="pp"> </span>X<span class="pp"> </span><span class="er">\</span>*<span class="pp"> </span>X)</span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a = CUBE(<span class="dv">2</span> + <span class="dv">1</span>);</span></code></pre></div>
<p>This example expands to:</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a = (<span class="dv">2</span> + <span class="dv">1</span> * <span class="dv">2</span> + <span class="dv">1</span> * <span class="dv">2</span> + <span class="dv">1</span>)</span></code></pre></div>
<p>which evaluates to 7 instead of the intended 27.</p>
<h3 id="guidance-to-language-users">6.51.2 Guidance to language users</h3>
<ul>
<li><p>Replace function-like macros with <code class="sourceCode cpp"><span class="kw">constexpr</span></code> inline functions where possible.</p></li>
<li><p>Replace normal macros with <code class="sourceCode cpp"><span class="kw">constexpr</span></code> variables where possible.</p></li>
<li><p>Replace conditional compilation with the preprocessor with <code class="sourceCode cpp"><span class="cf">if</span> <span class="kw">constexpr</span></code> where possible, e.g., in function bodies. This includes cases, where compile-time define of a macro (as empty) controls if a macro definition is used to expand to an empty statement or another statement.</p></li>
<li><p>Replace preprocessor include directives with module <code class="sourceCode cpp"><span class="kw">import</span></code> where possible.</p></li>
<li><p>Prefer <code class="sourceCode cpp"><span class="bu">std::</span>source_location</code> mechanisms over employing macros that use <code class="sourceCode cpp"><span class="ot">__LINE__</span></code>, <code class="sourceCode cpp"><span class="ot">__FILE__</span></code>, or <code class="sourceCode cpp"><span class="ot">__func__</span></code>.</p></li>
<li><p>If a function-like macro must be used, ensure that its parameters and body are parenthesized.</p></li>
<li><p>In a function-like macro, ensure that each argument is evaluated at most once.</p></li>
<li><p>Do not embed pre-processor directives or side-effects such as an assignment, increment/decrement, volatile access, or function call in a function-like macro.</p></li>
<li><p>Macros should only be used for <em>include guards</em>, to control conditional compilation, or when the macro’s definition requires token pasting (<code>##</code>.{.cpp}) or stringification (<code class="sourceCode cpp"><span class="er">#</span></code>) of macro arguments.</p></li>
<li><p>Macro paramters that are used as argument for <code class="sourceCode cpp"><span class="pp">#</span><span class="er">#</span></code> or <code class="sourceCode cpp"><span class="er">#</span></code> should not be used otherwise in the macro.</p></li>
</ul>
<h2 id="suppression-of-language-defined-run-time-checking-mxb">6.52 Suppression of Language-defined Run-time Checking [MXB]</h2>
<h3 id="applicability-to-language">6.52.1 Applicability to language</h3>
<p>With the exception of the macro <code>assert</code>, the vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.52 does not apply to C++, because there is no language-defined runtime checking. Macro assert is defined by the standard but is invoked by the programmer, hence is not a language-defined check.</p>
<p>C++ libraries, however, often provide run-time checks which meet the criteria of this vulnerability. Also, compilers and other tools commonly provide means to perform such runtime checks.</p>
<h3 id="guidance-to-language-users">6.51.2 Guidance to language users</h3>
<p>Follow the advice provided in ISO/IEC TR 24772-1:2019 clause 6.52.5 with respect to library and compiler-provided checks. Note that this will almost always require explicitly enabling the checks.</p>
<h2 id="provision-of-inherently-unsafe-operations-skl">6.53 Provision of Inherently Unsafe Operations [SKL]</h2>
<h3 id="applicability-to-language">6.53.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.53 applies to C++. In particular, anything described by ISO/IEC 14882:2017 as “undefined behaviour” is unsafe.</p>
<h3 id="guidance-to-language-users">6.53.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1:2019 clause 6.53.5.</p></li>
<li><p>Enable checks that warn about unsafe operations.</p></li>
<li><p>Use static analysis tools to detect unsafe constructs.</p></li>
</ul>
<h2 id="BRS">6.54 Obscure Language Features [BRS]</h2>
<h3 id="applicability-of-language">6.54.1 Applicability of language</h3>
<p>The vulnerability as described in ISO/IEC 24772-1 clause 6.54 applies to C++.</p>
<p>C++ is a rich language and provides facilities for a wide range of application areas with a long history of evolution. The latter means that evolution of the language also means an evolution of best and safe practices. This means that code can look obscure, because it either uses obsolete or very modern language idioms.</p>
<h3 id="guidance-to-language-users">6.54.2 Guidance to language users</h3>
<ul>
<li>Follow the advice of ISO/IEC 24772-1 clause 6.54.5.</li>
</ul>
<p>$incldue 6.55.UnspecifiedBehaviour-BQF.md</p>
<h2 id="EWF">6.56 Undefined Behaviour [EWF]</h2>
<h3 id="applicability-to-language">6.56.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.56 applies to C++. In ISO/IEC 14882:2017, the terms “undefined behaviour” and “ill-formed, no diagnostic required” expose situations to be avoided.</p>
<h3 id="guidance-to-language-users">6.56.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1:2019 clause 6.56.5.</p></li>
<li><p>Use static analysis tools to help identify occurrences of undefined behaviour.</p></li>
<li><p>Augment static analysis tool usage with runtime tools such as ASAN (address sanitizer) and related tools.</p></li>
<li><p>Use multiple compilers/tools and different optimization levels to increase your chance of identifying constructs that have undefined behaviours.</p></li>
<li><p>Where the language provides defined behaviour mechanisms and undefined behaviour mechanisms, ensure that you use the ones with defined behaviours.</p></li>
</ul>
<pre><code>&lt;!--
    Note: This document is dedicated to explaining these issues.
--&gt;</code></pre>
<h2 id="implementationdefined-behaviour-fab">6.57 Implementation–defined Behaviour [FAB]</h2>
<h3 id="applicability-to-language">6.57.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1:2019 clause 6.57 applies to C++. In ISO/IEC 14882, the term “implementation-defined” is used to describe implementation-defined behaviour. In addition, the C++ standard provides a dedicated index titled, “Index of implementation-defined behavior”.</p>
<h3 id="guidance-to-language-users">6.57.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1:2019 clause 6.57.5.</p></li>
<li><p>Eliminate to the extent possible any reliance on implementation-defined behaviour from programs in order to increase portability. Even programs that are specifically intended for a particular implementation may in the future be ported to another environment or sections reused for future implementations.</p></li>
<li><p>Use multiple compilers/tools to increase your chance of identifying constructs that have implementation-defined behaviours.</p></li>
<li><p>Refer to “Index of implementation-defined behavior” for the definitive list of C++ implementation-defined behaviours and understand the relevant compiler documentation for each of these behaviours.</p></li>
</ul>
<h2 id="deprecated-language-features-mem">6.58 Deprecated Language Features [MEM]</h2>
<h3 id="applicability-to-language">6.58.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1 clause 6.58 applies to C++. Appendix D “Compatibility features” of ISO/IEC 14882:2020 enumerates the deprecated features. The C++ attribute <code class="sourceCode cpp">[[<span class="at">deprecated</span>]]</code> allows library writers and users to mark deprecated declarations.</p>
<p>Although backward compatibility is sometimes offered as an option for compilers so one can avoid changes to code to be compliant with current language specifications, updating the legacy software to the current standard is a better option.</p>
<h3 id="guidance-to-language-users">6.58.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of ISO/IEC TR 24772-1 clause 6.58.5.</p></li>
<li><p>Enable compiler options or static analysis tools that identify the use of deprecated features.</p></li>
<li><p>Apply the <code class="sourceCode cpp">[[<span class="at">deprecated </span>(<span class="st">&quot;*reason*&quot;</span>)]]</code> attribute to obsolete declarations that exist only for backward compatibility.</p></li>
</ul>
<h2 id="concurrency-activation-cga">6.59 Concurrency – Activation [CGA]</h2>
<h3 id="applicability-to-language">6.59.1 Applicability to language</h3>
<p>This vulnerability does not apply to C++, as long as the standard library facilities for creating threads are used.</p>
<p>Creating a thread using <code class="sourceCode cpp"><span class="bu">std::</span>thread</code> or <code class="sourceCode cpp"><span class="bu">std::</span>jthread</code> is synchronized with the thread creation site.</p>
<p>Other vulnerabilities can be created when creating a thread object:</p>
<ul>
<li>6.61 Concurrent Data Access,</li>
<li>6.14 and 6.33 dangling of data reference, if data is passed to the thread function as reference or pointer, instead of passing a copy.</li>
<li>6.36 undhandle exception leading to premature termination of the program, if the thread object is destroyed and the spawned thread is neither joined nor detached. Creating a new thread through <code class="sourceCode cpp"><span class="bu">std::</span>async</code> will implicitly join.</li>
</ul>
<h3 id="guidance-to-language-users">6.59.2 Guidance to language users</h3>
<ul>
<li><p>If you are using a non-standard thread facilities, e.g., by making use of <code>std::thread::native_handle</code> follow the guidelines of TR 24772-1 clause 6.60.5.</p></li>
<li><p>Use <code class="sourceCode cpp"><span class="bu">std::</span>jthread</code> for thread creation, or always <code>.join()</code> or <code>.detach()</code> a created <code>std::thread</code>.</p></li>
<li><p>Pass all thread function arguments by value, or ensure their lifetime outlasts the running thread. In the latter case proper synchronization is required.</p></li>
</ul>
<h2 id="concurrency-directed-termination-cgt">6.60 Concurrency – Directed termination [CGT]</h2>
<h3 id="applicability-to-language">6.60.1 Applicability to language</h3>
<p>What about tasks? Explain std::function A functor is a class that can be called like a throw-away parallel object. Can also use in lambda expressions. The creating thread can only retrieve results by using a shared variable or using explicit thread calls to</p>
<p>A thread in C++ runs until completion, either a normal completion or as the result of an unhandled exception. There is no mechanism in the language to terminate another thread. If the threading model is POSIX or some other underlying paradigm, the underlying threading service calls can be used to terminate a thread.</p>
<p>C++ threads use a fork-join model. This means that the initiating thread will wait for the completion of the initiated thread at the join place at the end of the scope that created the initiated thread if a call to join the terminating thread has been made; otherwise the initiating task will have no indication of when the created thread completes.</p>
<p>Programmed mechanisms can be constructed to cause another thread to complete or to raise an exception, such as setting a shared variable to a known state that the target thread reads and then terminates itself.</p>
<p>Are there any language-defined ways to check on the progress of a thread or know if it is executable? Can always use underlying mechanism where available. Future mechanism provides for communication with the spawned thread to know if it terminated returning a value or returning an exception.</p>
<h2 id="guidance-to-language-users">6.60.2 Guidance to language users</h2>
<p>Follow the guidance of 24772-1 Clause 6.59.5</p>
<h2 id="CGX">6.61 Concurrent Data Access [CGX]</h2>
<h3 id="applicability-to-language">6.61.1 Applicability to language</h3>
<p>C++ has threading and shared access to variables which have the vulnerabilities described in ISO/IEC TR 24772-1:2019 clause 6.61.1. C++ provides features such as atomic (type template) that guarantee the internal consistency of the data and to prevent corruption of data due to potentially interleaved updates to data elements.</p>
<p>What about concurrent data access between tasks?</p>
<p>Programmers should be aware that conversions or manipulations of data items are not always atomic, such as the conversion of an object as part of a computation</p>
<p><em>Need the C++ definition of atomic (indivisible access and memory ordering)</em></p>
<p><em>and volatile.</em></p>
<p>The C++ <span data-custom-style="typ">atomic</span> capability can be applied to any basic data type equivalent to <span data-custom-style="typ">char</span>, <span data-custom-style="typ">short</span>, <span data-custom-style="typ">int</span>, <span data-custom-style="typ">long</span>, and <span data-custom-style="typ">long</span> <span data-custom-style="typ">long</span>. When the C++ <span data-custom-style="typ">std::atomic</span> facilities are used, the language guarantees that simultaneous updates and reads to an atomic element will be well-behaved. Atomic does not guarantee the order in which competing reads and/or updates will occur. In order to manage order of access, synchronized locks are required. In order to use the atomic capabilities, each variable must be declared to be of one of the <span data-custom-style="typ">std::atomic</span> types, and the member functions used to compare, load, store or exchange values in an atomic variable.</p>
<p>We also need to move the notion of creating SHARED POINTERS FROM 6.13 TO HERE.</p>
<p>A volatile qualifier on a variable is used to indicate that updates to the variable may happen at any time and outside of program control, hence two subsequent reads on such a variable may return different results.</p>
<p>Programmers should be aware that even simple data accesses on modern architectures can involve instruction reordering, cache issues, and data alignment issues, hence the acquisition time and order are highly nondeterministic, especially when being accessed by concurrent threads. Any data structure that can be shared between threads should be shown to be accessed by at most one thread at a time or should be protected by synchronization mechanisms such as locks (see <a href="#CGM">Lock Protocol Errors [CGM]</a>) or atomicity.</p>
<p>Most concurrent programming algorithms require some level of synchronization between threads or tasks when exchanging information, synchronization that “<span data-custom-style="typ">atomic</span>” does not provide. Mechanisms such as monitors, mailboxes, or mutexes (lock with a queue), futures, condition variables, and locks control scheduling of threads or tasks to control order-of-access and to enforce higher levels of cooperation between schedulable entities<span data-custom-style="annotation reference"></span>.</p>
<p>Atomic tied to memory orders.</p>
<p>Mutexes provide mutual exclusion and guaranteed visibility (consistency) of the shared data.</p>
<p>Mutex is a lock-and-release that is usually hidden.</p>
<p>Encapsulate mutexes and data</p>
<p>Thread-level storage (official term thread_local) has lifetime of the thread. Can exist at local scope or global scope.</p>
<p>For massively parallel concurrency – concurrent access mechanisms not applicable.</p>
<p>No resource management</p>
<p>Exception and exception handling (has some impact on threading)</p>
<p>Memory management issues more complex under concurrency</p>
<p>Volatile should be used for signal handlers to prevent the optimization of replicated accesses to volatile memory. (other) and does not guarantee that the object value will be available to other threads.</p>
<p>Controlling access to shared data (protected or including</p>
<p>Use of volatile (keyword type qualifier) for signal handlers (communicating with hardware?). Prefer volatile for communicating with hardware?</p>
<p>For signal handling, <code class="sourceCode cpp"><span class="at">volatile</span> <span class="dt">sig_atomic_t</span></code> or atomic variables can be used to prevent this vulnerability.</p>
<h3 id="guidance-to-language-users">6.61.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidance of ISO/IEC TR 24772-1 clause 6.62.5.</p></li>
<li><p>Use mutexes, condition variables (convar) in preference to atomic variables to protect data from simultaneous access.</p></li>
<li><p>Use volatile only for synchronizing abstract machine state from memory.</p></li>
<li><p>Avoid the use of volatile for synchronizing access to shared memory between threads (which needs mutex, condvar, or atomics)</p>
<ul>
<li><pre><code>  See C++ Core guidelines CP.8, CP.200,</code></pre>
CP.111,<span data-custom-style="annotation reference"></span></li>
</ul></li>
<li><p>Avoid relaxed atomic operations whenever possible. Prefer the sequentially consistent std::memory_order_seq_cst instead .</p></li>
<li><p>Use mutexes appropriately to protect accesses to non-atomic shared objects.</p></li>
<li><p>Use <code class="sourceCode cpp"><span class="at">volatile</span> <span class="dt">sig_atomic_t</span></code> to protect data shared with signal handlers in a single-threaded environment.</p></li>
</ul>
<h2 id="concurrency-premature-termination-cgs">6.62 Concurrency – Premature Termination [CGS]</h2>
<h3 id="applicability-to-language">6.62.1 Applicability to language</h3>
<h3 id="section"></h3>
<p>A thread will terminate when it completes its assigned method, or when it raises an exception, or when it has been explicitly terminated (how is this done)</p>
<p>Joining a thread causes the joining thread to await the joined thread’s termination before continue. Useful for executing in parallel and then proceeding after the dispatched work is complete, but does not notify the joining task if the termination was premature.</p>
<p>In C++ 2020, methods are provided to instruct one or more threads to terminate. This is not premature termination since the requested thread terminates itself.</p>
<p>C++ 2020 provides callbacks in the form of stop_callback to notify the setting thread when a thread of interest has been terminated. It also provides stop_token for a thread to query it is being instructed to terminate.</p>
<p>Any thread can re-throw an exception to be caught by the creator of the terminating thread, (but the parent may have terminated first).</p>
<p>The semantics of C++ is that all children of the main program will terminate if the main program terminates. It is necessary to join the main program to all its children to ensure that children are not silently terminated prematurely.</p>
<h3 id="guidance-to-language-users">6.62.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of TR 24772-1 clause 6.63.5.</p></li>
<li><p>Use low-level operating system primitives or other APIs where available to check that a required thread is still active.</p></li>
<li><p>Make the main program join all created threads that need to complete normally.</p></li>
</ul>
<h2 id="CGM">6.63 Protocol Lock Errors [CGM]</h2>
<h3 id="applicability-to-language">6.63.1 Applicability to language</h3>
<p>The vulnerability as described in ISO/IEC TR 24772-1 clause 6.63 is applicable to C++.</p>
<p>This subclause requires a complete rewrite to have it reflect C++ issues.</p>
<p>Difference between threads and tasks. Can threads and tasks coexist?</p>
<p>Deadlock with single mutex,</p>
<p>The C standard does not provide hidden protocols. Although the vulnerability does not apply to the C language, there could exist an application vulnerability if a program uses synchronization mechanisms incorrectly. For example:</p>
<p>atomic int a;</p>
<p>int b;</p>
<p>/* . . . */</p>
<p>a += b; // This operation is an atomic read-modify-write of the variable ‘a’.</p>
<p>a = a + b; // This statement contains two accesses to ‘a’ and is not atomic.</p>
<h3 id="guidance-to-language-users">6.63.2 Guidance to language users</h3>
<ul>
<li><p>Follow the guidelines of TR 24772-1 clause 6.63.5.</p></li>
<li><p>Be aware of the operation of each synchronization mechanism, such as the cases where accesses to atomic variables may occur more than once in a statement.</p></li>
<li><p>Use higher level building blocks (such as TBB) in preference to …</p></li>
<li><p>Use the C++ Task mechanism in preference to threads …</p></li>
<li><p>Always put the acquisition and release of mutexes and the data access in a wrapper function. (i.e. <em>Do not call member functions of std::mutex, std::timed_mutex, std::recursive_mutex, std::recursive_timed_mutex, std::shared_mutex and std::shared_timed_mutex objects directly.)</em></p></li>
<li><p><em>Use std::lock(), std::try_lock() or std::scoped_lock to acquire multiple mutexes in same scope. (std::lock() permits multiple mutexes at the same time).</em></p></li>
<li><p>Use std::lock() only where multiple locks must be locked together and use std::lock_guard with the std::adopt_lock argument for all mutexes (needs example) see std::lock() example on cppreference.com.</p></li>
<li><p><em>Wrap mutex locks std::lock or std::try_lock with std<strong>::</strong>lock_guard, std::unique_lock or std::shared_lock with adopt_lock tag within the same scope</em></p></li>
<li><p>If explicit locking are used, ensure that the lock is released on every exit path, including exceptions. Use lock_guard, scope_lock and unique_lock in preference to lock(), unlock(), and try_lock(),</p></li>
<li><p><strong><em>Do not use platform specific multi-threading facilities</em></strong></p></li>
<li><p><strong><em>A thread shall not access objects whose lifetime has expired</em></strong></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.kj1vcao94oy1"><u>0.4.4 [12] Do not destroy objects of the following types std::mutex, std::timed_mutex, std::recursive_mutex, std::recursive_timed_mutex, std::shared_mutex, std::shared_timed_mutex if object is in locked or shared locked state Do not destroy a mutex while it is locked</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.1kfv9jdgd8ib"><u>0.4.5 [13] Mutexes locked with std::lock or std::try_lock shall be wrapped with std::lock_guard, std::unique_lock or std::shared_lock with adopt_lock tag within the same scope Ensure actively held locks are released on exceptional conditions</u> <u>12</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.729gvquxakq8"><u>0.4.6 [14] Do not call virtual functions and callable objects passed by argument of the function within the scope of locked mutex Never call unknown code while holding a lock (e.g., a callback)</u> <u>12</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.920crsa3sscx"><u>0.4.7 [15] Avoid deadlock by locking in a predefined order</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.xufkh9tsiuk8"><u>0.4.8 [16] Objects of std::lock_guards, std::unique_locks, std::shared_lock and std::scoped_lock classes shall always be named Remember to name your lock_guards and unique_locks</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.d6qklu5mi3fn"><u>0.4.9 [17] Define a mutex together with the data it guards. Use synchronized_value&lt;T&gt; where possible</u> <u>13</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.isn3bwogdp97"><u>0.4.10 [18] Do not speculatively lock a non-recursive mutex that is already owned by the calling thread</u> <u>14</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.einwxosnxvhf"><u>0.4.11 [19] There shall be no code path which results in locking of the non-recursive mutex within the scope when this mutex is already locked Within the scope of a lock, ensure that no static path results in a lock of the same mutex</u> <u>14</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.vq776pxv4nn5"><u>0.4.12 [20] The order of nested locks unlock shall form a DAG Ensure that order of nesting of locks in a project forms a DAG</u> <u>15</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.7pf8azwmy8l4"><u>0.4.13 [21] std::recursive_mutex and std::recursive_timed_mutex should not be used Do not use std::recursive_mutex</u> <u>17</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.z9k66jbl65u6"><u>0.4.14 [22] There should be a code path, where at least one member functions is called for std::unique_lock objects Only use std::unique_lock when std::lock_guard cannot be used</u> <u>18</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.3icrgfn0r3ae"><u>0.5 Conditional variable</u> <strong><u>19</u></strong></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.g0cdm0bk7l9l"><u>0.5.1 [23] std::condition_variable::wait, std::condition_variable::wait_for, std::condition_variable::wait_until shall always be called with a condition predicate</u> <u>19</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.ul4y0p7eoih1"><u>0.5.2 [24] Wrap functions that can spuriously wake up in a loop</u> <u>20</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.13kr181fh926"><u>0.5.3 [25] std::conditional_variable::notify_one() can be used if all threads must perform the same set of operations after waking up Preserve thread safety and liveness when using condition variables</u> <u>21</u></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.yt0hxah53p9e"><u>0.5.4 [26] Do not use std::condition_variable_any on a std::mutex</u></a></p></li>
<li><p>[<span data-custom-style="Hyperlink">0.10.1 [35] Source CCG Rule CP.100: Don't use lock-free programming unless you absolutely have to</span></p>
<p><span data-custom-style="Hyperlink">27</span>](https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.3hq5f8vdw7d)</p></li>
<li><p>0.10.2 [36] Source CCG Rule CP.101: Distrust your hardware/compiler combination</p></li>
<li><p>0.10.3 [37] Source CCG Rule CP.102: Carefully study the literature</p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.ca8el9ehijae"><span data-custom-style="Hyperlink">0.10.4 [38] Source CCG Rule CP.110: Do not write your own double-checked locking for initialization</span></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.9syx86lze887"><span data-custom-style="Hyperlink">0.10.5 [39] Source HIC Rule 18.2.4 Use std::call_once to ensure a function is called exactly once (rather than the Double-Checked Locking pattern)</span></a></p></li>
<li><p><a href="https://docs.google.com/document/d/14E0BYqsH_d7fMKvXvaZWoNWtIC65cYBw0aZp4dlev0Q/edit#heading=h.gg4jn12ygzi5"><span data-custom-style="Hyperlink">0.10.6 [40] Source CCG Rule CP.111: Use a conventional pattern if you really need double-checked locking</span></a></p></li>
<li></li>
</ul>
<h2 id="uncontrolled-format-string-shl">6.64 Uncontrolled Format String [SHL]</h2>
<h3 id="applicability-to-language">6.64.1 Applicability to language</h3>
<p>C++ inherits the C libraries which provide a large family of input and output functions that use a control string to interpret the data read or format the output. These strings include all the feature described in ISO/IEC TR 24772-1:2019 clause 6.64.1.</p>
<p>C++ provides type-safe alternatives for input/output, which do not use format strings and which should be used in preference, such as</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> aNumber{};</span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span>(<span class="bu">std::</span>cin){ <span class="co">// is input still available</span></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Enter a whole number, please:&quot;</span>;</span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="bu">std::</span>cin &gt;&gt; aNumber) { <span class="co">// no format string needed</span></span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &gt;&gt; <span class="st">&quot;Thank you, the number can be represented as &quot;</span></span>
<span id="cb177-6"><a href="#cb177-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>format(<span class="st">&quot;0b</span><span class="sc">{0:b}</span><span class="st"> </span><span class="sc">{0:d}</span><span class="st"> 0</span><span class="sc">{0:o}</span><span class="st"> 0x</span><span class="sc">{0:x}</span><span class="st">&quot;</span>, aNumber);</span>
<span id="cb177-7"><a href="#cb177-7" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> { <span class="co">// input failed</span></span>
<span id="cb177-8"><a href="#cb177-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin.clear();  <span class="co">// re-enable input</span></span>
<span id="cb177-9"><a href="#cb177-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string line;</span>
<span id="cb177-10"><a href="#cb177-10" aria-hidden="true" tabindex="-1"></a>    getline(<span class="bu">std::</span>cin,line); <span class="co">// skip to eol</span></span>
<span id="cb177-11"><a href="#cb177-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb177-12"><a href="#cb177-12" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In addition, operator overloading of output operators allows to extend formatting abilities to user-defined types.</p>
<h3 id="guidance-to-language-users">6.64.2 Guidance to language users</h3>
<p>Avoid the C library facilities provided by <strong><code>&lt;cstdio&gt;</code></strong>.</p>
<p>Use the mechanisms provided by the standard library as described in ISO/IEC 14882 20.20 Formatting [format] or similar libraries, if <em>printf-style</em> formatting of output or strings is desired, or when the formatting facilities of <code>std::ostream</code> are inadequate.</p>
<p>Read untrusted input as plain characters and then check for validity, before any conversion to numbers or program entities occurs, using facilities that do not require format strings and that check and report error conditions.</p>
<h1 id="UJO">6.65 Modifying constants [UJO]</h1>
<h3 id="applicability-to-language">6.65.1 Applicability to language</h3>
<p>The vulnerability as documented in ISO/IEC TR 24772-1:2019 clause 6.65 exists in C++.</p>
<p>An object can be declared as <code class="sourceCode cpp"><span class="at">const</span></code>, denoting that its value will not change in its lifetime:</p>
<p><code class="sourceCode cpp"><span class="dt">int</span> <span class="at">const</span> i = <span class="dv">0</span>;</code></p>
<p>A object that is not <code class="sourceCode cpp"><span class="at">const</span></code>-qualified can be accessed through a path that is <code class="sourceCode cpp"><span class="at">const</span></code>-qualified:</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a>  T k = <span class="dv">0</span>;</span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a>  T <span class="at">const</span> &amp; j = k;                <span class="co">// &#39;j&#39; is a const reference to &#39;k&#39;</span></span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a>  T <span class="at">const</span> * p = &amp;k;               <span class="co">// &#39;p&#39; is a pointer to const &#39;k&#39;</span></span>
<span id="cb178-4"><a href="#cb178-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const_cast</span>&lt;T <span class="at">const</span> &amp;&gt;(k);       <span class="co">// The type of the expression is const</span></span></code></pre></div>
<p>The checking for the correctness of <code class="sourceCode cpp"><span class="at">const</span></code> is enforced based on the access-path and not the type of the target object. For example, the following are ill-formed as the access path of the left-hand expression is <code class="sourceCode cpp"><span class="at">const</span></code>-qualified:</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a>  i = <span class="dv">0</span>; <span class="co">// T const i;</span></span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a>  j = <span class="dv">0</span>; <span class="co">// T const &amp;j</span></span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a>  *p = <span class="dv">0</span>; <span class="co">// T const *p</span></span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const_cast</span>&lt;T <span class="at">const</span> &amp;&gt;(k) = <span class="dv">0</span>; <span class="co">// T k i.e. not const</span></span></code></pre></div>
<p>Note that the object <code class="sourceCode cpp">k</code> referred to by <code class="sourceCode cpp">j</code>, <code class="sourceCode cpp">*p</code> and the <code class="sourceCode cpp"><span class="kw">const_cast</span>,</code> is not constant. In each case the access path could be changed to remove <code class="sourceCode cpp"><span class="at">const</span></code> making the program well-formed: <code class="sourceCode cpp"><span class="kw">const_cast</span>&lt;T&amp;&gt; (j) = <span class="dv">0</span>; <span class="co">// well-formed</span></code></p>
<p>While it is possible to remove the const-qualification for an access path, attempting to modify a const object this way is undefined-behavior(see <span id="EWF">Undefined Behavior [EWF]</span>) : <code class="sourceCode cpp"><span class="kw">const_cast</span>&lt;T&amp;&gt; (i) = <span class="dv">0</span>; <span class="co">// undefined behavior</span></code></p>
<p>We distinguish between qualifications on the pointer’s type (pointer type) and qualifications on the type being referenced (pointer type).</p>
<p>A pointer type can be qualified as <code class="sourceCode cpp"><span class="at">const</span></code>, however the qualification only applies to the pointer type and not the pointee’s type. A reference type is implicitly immutable, only the referred type can be <code class="sourceCode cpp"><span class="at">const</span></code> qualified.</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> T = <span class="dt">int</span>;</span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> T1 = T &amp;;</span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> T2 = T *;</span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> S1 = T1 <span class="at">const</span>;  <span class="co">// The const is ignored, S1 has type &#39;T &amp;&#39;</span></span>
<span id="cb180-5"><a href="#cb180-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> S2 = T2 <span class="at">const</span>;  <span class="co">// The const applies to the pointer type,</span></span>
<span id="cb180-6"><a href="#cb180-6" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// S2 has type &#39;T * const&#39;</span></span>
<span id="cb180-7"><a href="#cb180-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-8"><a href="#cb180-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> foo (S1 s1, S2 s2)</span>
<span id="cb180-9"><a href="#cb180-9" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb180-10"><a href="#cb180-10" aria-hidden="true" tabindex="-1"></a>    s1 = <span class="dv">0</span>;            <span class="co">// well-formed</span></span>
<span id="cb180-11"><a href="#cb180-11" aria-hidden="true" tabindex="-1"></a>    *s2 = <span class="dv">0</span>;           <span class="co">// well-formed</span></span>
<span id="cb180-12"><a href="#cb180-12" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>A common misconception is that a member function qualified with <code class="sourceCode cpp"><span class="at">const</span></code> cannot modify any of its members. The following badly defined class introduces a non-<code class="sourceCode cpp"><span class="at">const</span></code> access path to a potentially const object:</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> A</span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a>    A * pA;                <span class="co">// Pointer to non-const A</span></span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a>    T array[<span class="dv">2</span>];            <span class="co">// Array of type T</span></span>
<span id="cb181-5"><a href="#cb181-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-6"><a href="#cb181-6" aria-hidden="true" tabindex="-1"></a>    A () : pA{<span class="kw">this</span>}{}      <span class="co">// pA provides access path to non-const</span></span>
<span id="cb181-7"><a href="#cb181-7" aria-hidden="true" tabindex="-1"></a>                           <span class="co">// this.</span></span>
<span id="cb181-8"><a href="#cb181-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-9"><a href="#cb181-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f () <span class="at">const</span></span>
<span id="cb181-10"><a href="#cb181-10" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb181-11"><a href="#cb181-11" aria-hidden="true" tabindex="-1"></a>      <span class="co">// pA = nullptr;     // ill-formed</span></span>
<span id="cb181-12"><a href="#cb181-12" aria-hidden="true" tabindex="-1"></a>      <span class="co">// array[0] = 0;     // ill-formed</span></span>
<span id="cb181-13"><a href="#cb181-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-14"><a href="#cb181-14" aria-hidden="true" tabindex="-1"></a>      pA-&gt;array[<span class="dv">0</span>] = <span class="dv">0</span>;    <span class="co">// compiles, but undefined behavior</span></span>
<span id="cb181-15"><a href="#cb181-15" aria-hidden="true" tabindex="-1"></a>                           <span class="co">// if executed on a const object</span></span>
<span id="cb181-16"><a href="#cb181-16" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb181-17"><a href="#cb181-17" aria-hidden="true" tabindex="-1"></a>  };</span></code></pre></div>
<p>In the const member function f, naming array directly results in a const-qualified access path and so an attempt to modify it is ill-formed. However, the type of pA is <code class="sourceCode cpp">A * <span class="at">const</span></code>, that is a <code class="sourceCode cpp"><span class="at">const</span></code> pointer to a non-const <code class="sourceCode cpp">A</code>. An attempt to modify <code class="sourceCode cpp">pA</code> is ill-formed, however, modification of the value pointed to by <code class="sourceCode cpp">pA</code> is not a const-qualified access path and so is not ill-formed.</p>
<p>It is undefined behavior to attempt to modify a const object. The programmer can incorrectly assume that a call to a const member function will not modify the object. However, as has been shown above, there is no guarantee that this is the case. The following example, therefore, will compile but has undefined behavior as a result of the modification of the const object:</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> foo ()</span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a>  { </span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a>     A a1 {} ;</span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true" tabindex="-1"></a>     A <span class="at">const</span> a2 {} ;</span>
<span id="cb182-5"><a href="#cb182-5" aria-hidden="true" tabindex="-1"></a>     a1.f();           <span class="co">// OK - &#39;a1&#39; is not const</span></span>
<span id="cb182-6"><a href="#cb182-6" aria-hidden="true" tabindex="-1"></a>     a2.f();           <span class="co">// compiles but has undefined behavior</span></span>
<span id="cb182-7"><a href="#cb182-7" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>C++ classes wrapping pointer or reference members can be used to provide transitivity of <code class="sourceCode cpp"><span class="at">const</span></code> within <code class="sourceCode cpp"><span class="at">const</span></code> member functions. This is shown by the <code class="sourceCode cpp">MyRef</code> type in the following example:</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; </span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MyRef</span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb183-4"><a href="#cb183-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb183-5"><a href="#cb183-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">operator</span> T&amp;() &amp;;</span>
<span id="cb183-6"><a href="#cb183-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">operator</span> T <span class="at">const</span> &amp;() <span class="at">const</span> &amp;;</span>
<span id="cb183-7"><a href="#cb183-7" aria-hidden="true" tabindex="-1"></a>  MyRef &amp; <span class="kw">operator</span>=(T <span class="at">const</span> &amp;) &amp;;</span>
<span id="cb183-8"><a href="#cb183-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-9"><a href="#cb183-9" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span>:</span>
<span id="cb183-10"><a href="#cb183-10" aria-hidden="true" tabindex="-1"></a>  T &amp; <span class="va">m_t</span>;</span>
<span id="cb183-11"><a href="#cb183-11" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb183-12"><a href="#cb183-12" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb183-13"><a href="#cb183-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A {</span>
<span id="cb183-14"><a href="#cb183-14" aria-hidden="true" tabindex="-1"></a>  A();</span>
<span id="cb183-15"><a href="#cb183-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-16"><a href="#cb183-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f1() {</span>
<span id="cb183-17"><a href="#cb183-17" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_i</span> = <span class="dv">0</span>;</span>
<span id="cb183-18"><a href="#cb183-18" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_j</span> = <span class="dv">0</span>;</span>
<span id="cb183-19"><a href="#cb183-19" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_j</span> ++;</span>
<span id="cb183-20"><a href="#cb183-20" aria-hidden="true" tabindex="-1"></a>    ++<span class="va">m_j</span>;</span>
<span id="cb183-21"><a href="#cb183-21" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb183-22"><a href="#cb183-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-23"><a href="#cb183-23" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> f() <span class="at">const</span> {</span>
<span id="cb183-24"><a href="#cb183-24" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_i</span> = <span class="dv">0</span>;     <span class="co">// compiles, but undefined behavior</span></span>
<span id="cb183-25"><a href="#cb183-25" aria-hidden="true" tabindex="-1"></a>                 <span class="co">// if &#39;m_i&#39; refers to a const object</span></span>
<span id="cb183-26"><a href="#cb183-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-27"><a href="#cb183-27" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_j</span> = <span class="dv">0</span>;     <span class="co">// ill-formed</span></span>
<span id="cb183-28"><a href="#cb183-28" aria-hidden="true" tabindex="-1"></a>    ++ <span class="va">m_j</span>;      <span class="co">// ill-formed</span></span>
<span id="cb183-29"><a href="#cb183-29" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb183-30"><a href="#cb183-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-31"><a href="#cb183-31" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> &amp; <span class="va">m_i</span>;</span>
<span id="cb183-32"><a href="#cb183-32" aria-hidden="true" tabindex="-1"></a>  MyRef&lt;<span class="dt">int</span>&gt; <span class="va">m_j</span>;</span>
<span id="cb183-33"><a href="#cb183-33" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div>
<p>Attempts to modify the object referenced by <code class="sourceCode cpp"><span class="va">m_j</span></code> are ill-formed when they occur in the const member function <code class="sourceCode cpp">f2</code>.</p>
<p>C++ container iterator types, <code class="sourceCode cpp">iterator</code> and <code class="sourceCode cpp">const_iterator</code>, are examples of use of this pattern.</p>
<p>If a member variable is declared with the <code class="sourceCode cpp"><span class="at">mutable</span></code> keyword, then it can still be modified, even if the containing object is <code class="sourceCode cpp"><span class="at">const</span></code>. This is preferable to use <code class="sourceCode cpp"><span class="at">mutable</span></code> rather than removing the constness of the containing object (see <span id="FLC">Conversion Errors [FLC]</span>).<br />
Members declared <code class="sourceCode cpp"><span class="at">mutable</span></code> typically should not contribute to the value of the object. The following is a common example where a mutex member is declared <code class="sourceCode cpp"><span class="at">mutable</span></code> to allow locking in a <code class="sourceCode cpp"><span class="at">const</span></code> member function:</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;mutex&gt;</span></span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MyQueue</span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb184-5"><a href="#cb184-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb184-6"><a href="#cb184-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> empty () <span class="at">const</span> </span>
<span id="cb184-7"><a href="#cb184-7" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb184-8"><a href="#cb184-8" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>lock_guard sg (<span class="va">m_mutex</span>); <span class="co">// lock the mutex, which requires m_mutex to be writable</span></span>
<span id="cb184-9"><a href="#cb184-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="va">m_head</span> != <span class="kw">nullptr</span>;</span>
<span id="cb184-10"><a href="#cb184-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb184-11"><a href="#cb184-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-12"><a href="#cb184-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb184-13"><a href="#cb184-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-14"><a href="#cb184-14" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span>:</span>
<span id="cb184-15"><a href="#cb184-15" aria-hidden="true" tabindex="-1"></a>  <span class="at">mutable</span> <span class="bu">std::</span>mutex <span class="va">m_mutex</span>;</span>
<span id="cb184-16"><a href="#cb184-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> * <span class="va">m_head</span> { <span class="kw">nullptr</span> };</span>
<span id="cb184-17"><a href="#cb184-17" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div>
<h3 id="guidance-to-language-users">6.65.2 Guidance to language users</h3>
<p>In addition to the general advice of TR 24772-1 clause 6.65:</p>
<ul>
<li><p>Do not cast-away <code class="sourceCode cpp"><span class="at">const</span></code>.</p></li>
<li><p>Leverage the C++ type system to restrict the operations on a type in a way that emulates <em>logical const</em> and document where used</p></li>
<li><p>Be aware that, while <code class="sourceCode cpp"><span class="at">const</span></code> means “read only”, C++ permits <code class="sourceCode cpp"><span class="at">const</span></code> values to be modified as shown in clause 6.65.1; and</p></li>
<li><p>Consider the use of <code class="sourceCode cpp"><span class="kw">constexpr</span></code> wherever possible to move the detection to compile time</p></li>
<li><p>Apply <code class="sourceCode cpp"><span class="at">mutable</span></code> only to member variables that do not influence the external behavior of an object.</p></li>
</ul>
<!-- -->
<h1 id="language-specific-vulnerabilities-for-c">7. Language specific vulnerabilities for C</h1>
<p>7.2 Copy/move semantics from Classes. (Peter Sommerlad’s paper at http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1412r0.pdf</p>
<h1 id="implications-for-standardization">8. Implications for standardization</h1>
<p>Future standardization efforts should consider:</p>
<ul>
<li><pre><code>Moving in the direction over time to being a more strongly typed</code></pre>
<p>language. Much of the use of weak typing is simply convenience to the developer in not having to fully consider the types and uses of variables. Stronger typing forces good programming discipline and clarity about variables while at the same time removing many unexpected run time errors due to implicit conversions. This is not to say that C should be strictly a strongly typed language – some advantages of C are due to the flexibility that weaker typing provides. It is suggested that when enforcement of strong typing does not detract from the good flexibility that C offers (for example, adding an integer to a character to step through a sequence of characters) and is only a convenience for programmers (for example, adding an integer to a floating-point number), then the standard should specify the stronger typed solution.</p></li>
<li><pre><code>A common warning in Annex I should be added for floating-point</code></pre>
<p>expressions being used in a Boolean test for equality.</p></li>
<li><pre><code>Modifying or deprecating many of the C standard library functions</code></pre>
<p>that make assumptions about the occurrence of a string termination character.</p></li>
<li><pre><code>Define a string construct that does not rely on the null termination</code></pre>
<p>character.</p></li>
<li><pre><code>Defining an array type that does automatic bounds checking.</code></pre></li>
<li><pre><code>Deprecating less safe functions such as strcpy() and strcat() where</code></pre>
<p>a more secure alternative is available.<span data-custom-style="annotation reference"></span></p></li>
<li><pre><code>Defining safer and more secure replacement functions such as</code></pre>
<p>memncpy() and memncmp() to complement the memcpy() and memcmp() functions (see <em>6.11.6 Implications for standardization</em>)</p></li>
<li><pre><code>Defining an array type that does automatic bounds checking.</code></pre></li>
<li><pre><code>Defining functions that contain an extra parameter in memcpy() and</code></pre>
<p>memmove() for the maximum number of bytes to copy. In the past, some have suggested that the size of the destination buffer be used as an additional parameter. Some critics state that this solution is easy to circumvent by simply repeating the parameter that was used for the number of bytes to copy as the parameter for the size of the destination buffer. This analysis and criticism is correct. What is needed is a failsafe check as to the maximum number of bytes to copy. There are several reasons for creating new functions with an additional parameter. This would make it easier for static analysis to eliminate those cases where the memory copy could not be a problem (such as when the maximum number of bytes is demonstrably less than the capacity of the receiving buffer). Manual analysis or more involved static analysis could then be used for the remaining situations where the size of the destination buffer may not be sufficient for the maximum number of bytes to copy. This extra parameter may also help in determining which copies could take place among objects that overlap. Such copying is undefined according to the C standard. It is suggested that safer versions of functions that include a restriction max_n on the number of bytes n to copy (for example, void *memncpy(void * restrict s1,const void * restrict s2,size_t n), const size_t max_n) be added to the standard in addition to retaining the current corresponding functions (for example, memcpy(void * restrict s1,const void * restrict s2,size_t n))). The additional parameter would be consistent with the copying function pairs that have already been created such as strcpy()/strncpy() and strcat()/strncat(). This would allow a safer version of memory copying functions for those applications that want to use them in to facilitate both safer and more secure code and more efficient and accurate static code reviews<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p></li>
<li><pre><code>Restrictions on pointer arithmetic that could eliminate common</code></pre>
<p>pitfalls. Pointer arithmetic is error-prone and the flexibility that it offers is useful, but some of the flexibility is simply a shortcut that if restricted could lessen the chance of a pointer arithmetic based error.</p></li>
<li><pre><code>Defining a standard way of declaring an attribute to indicate that a</code></pre>
<p>variable is intentionally unused.</p></li>
<li><pre><code>A common warning in Annex I should be added for variables with the</code></pre>
<p>same name in nested scopes.</p></li>
<li><pre><code>Creating a few standardized precedence orders. Standardizing on a</code></pre>
<p>few precedence orders will help to eliminate the confusing intricacies that exist between languages. This would not affect current languages as altering precedence orders in existing languages is too onerous. However, this would set a basis for the future as new languages are created and adopted. Stating that a language uses “ISO precedence order A” would be useful rather than having to spell out the entire precedence order that differs in a conceptually minor way from some other languages, but in a major way when programmers attempt to switch between languages.</p></li>
<li><pre><code>Deprecating the goto statement. The use of the goto construct is</code></pre>
<p>often spotlighted as the antithesis of good structured programming. Though its deprecation will not instantly make all C code structured, deprecating the goto and leaving in place the restricted goto variations (for example, break and continue) and possibly adding other restricted goto’s could assist in encouraging safer and more secure C programming in general.</p></li>
<li><pre><code>Defining a &quot;fallthru&quot; construct that will explicitly bind multiple</code></pre>
<p>switch cases together and eliminate the need for the break statement. The default would be for a case to break instead of falling through to the next case. Granted this is a major shift in concept, but if it could be accomplished, less unintentional errors would occur.</p></li>
<li><pre><code>Defining an identifier type for loop control that cannot be modified</code></pre>
<p>by anything other than the loop control construct would be a relatively minor addition to C that could make C code safer and encourage better structured programming.</p></li>
<li><pre><code>Defining a standardized interface package for interfacing C with</code></pre>
<p>many of the top programming languages and a reciprocal package should be developed of the other top languages to interface with C.</p></li>
<li><pre><code>Joining with other languages in developing a standardized set of</code></pre>
<p>mechanisms for detecting and treating error conditions so that all languages to the extent possible could use them. Note that this does not mean that all languages should use the same mechanisms as there should be a variety ( label parameters, auxiliary status variables), but each of the mechanisms should be standardized.</p></li>
<li><pre><code>Since fault handling and exiting of a program is common to all</code></pre>
<p>languages, it is suggested that common terminology such as the meaning of fail safe, fail hard, fail soft, and so on along with a core API set such as exit, abort, and so on be standardized and coordinated with other languages.</p></li>
<li><pre><code>Deprecating unions. The primary reason for the use of unions to save</code></pre>
<p>memory has been diminished considerably as memory has become cheaper and more available. Unions are not statically type safe and are historically known to be a common source of errors, leading to many C programming guidelines specifically prohibiting the use of unions.</p></li>
<li><pre><code>Creating a recognizable naming standard for routines such that one</code></pre>
<p>version of a library does parameter checking to the extent possible and another version does no parameter checking. The first version would be considered safer and more secure and the second could be used in certain situations where performance is critical and the checking is assumed to be done in the calling routine. A naming standard could be made such that the library that does parameter checking could be named as usual, say “library_xyz” and an equivalent version that does not do checking could have a “_p” appended, such as “library_xyz_p”. Without a naming standard such as this, a considerable number of wasted cycles will be conducted doing a double check of parameters or even worse, no checking will be done in both the calling and receiving routines as each is assuming the other is doing the checking.</p></li>
<li><pre><code>Creating an Annex that lists deprecated features.</code></pre></li>
</ul>
<h1 id="bibliography">Bibliography</h1>
<div data-custom-style="Bibliography1">
<p>[1] ISO/IEC Directives, Part 2, <em>Rules for the structure and drafting of International Standards</em>, 2004</p>
</div>
<div data-custom-style="Bibliography1">
<p>[2] ISO/IEC TR 10000‑1, <em>Information technology — Framework and taxonomy of International Standardized Profiles — Part 1: General principles and documentation framework</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[3] ISO 10241 (all parts), <em>International terminology standards</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[4] ISO/IEC 9899:2011, <em>Information technology</em> — <em>Programming languages —</em> C</p>
</div>
<div data-custom-style="Bibliography1">
<p>[5] ISO/IEC 9899:2011/Cor.1:2012, <em>Technical Corrigendum 1</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[6] ISO/IEC 30170:2012, <em>Information technology</em> — <em>Programming languages —</em> Ruby</p>
</div>
<div data-custom-style="Bibliography1">
<p>[7] ISO/IEC/IEEE 60559:2011, <em>Information technology – Microprocessor Systems – Floating-Point arithmetic</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[8] ISO/IEC 1539-1:2010, <em>Information technology — Programming languages —</em> Fortran — Part 1: Base language</p>
</div>
<div data-custom-style="Bibliography1">
<p>[9] ISO/IEC 8652:1995, <em>Information technology — Programming languages —</em> Ada</p>
</div>
<div data-custom-style="Bibliography1">
<p>[10] ISO/IEC 14882:2011, <em>Information technology</em> — <em>Programming languages —</em> C++</p>
</div>
<div data-custom-style="Bibliography1">
<p>[11] R. Seacord, <em>The CERT C Secure Coding Standard</em>. Boston,MA: Addison-Westley, 2008.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[12] Motor Industry Software Reliability Association. <em>Guidelines for the Use of the C Language in Vehicle Based Software</em>, 2012 (third edition)16F<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[13] ISO/IEC TR24731–1, <em>Information technology — Programming languages, their environments and system software interfaces — Extensions to the C library — Part 1: Bounds-checking interfaces</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[14] ISO/IEC TR 15942:2000, <em>Information technology — Programming languages — Guide for the use of the Ada programming language in high integrity systems</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[15] Joint Strike Fighter Air Vehicle: C++ Coding Standards for the System Development and Demonstration Program. Lockheed Martin Corporation. December 2005.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[16] Motor Industry Software Reliability Association. <em>Guidelines for the Use of the C++ Language in critical systems</em>, June 2008</p>
</div>
<div data-custom-style="Bibliography1">
<p>[17] ISO/IEC TR 24718: 2005, <em>Information technology — Programming languages — Guide for the use of the Ada Ravenscar Profile in high integrity systems</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[18] L. Hatton, Safer C: developing software for high-integrity and safety-critical systems. McGraw-Hill 1995</p>
</div>
<div data-custom-style="Bibliography1">
<p>[19] ISO/IEC 15291:1999, <em>Information technology — Programming languages — Ada Semantic Interface Specification (ASIS)</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[20] Software Considerations in Airborne Systems and Equipment Certification. Issued in the USA by the Requirements and Technical Concepts for Aviation (document RTCA SC167/DO-178B) and in Europe by the European Organization for Civil Aviation Electronics (EUROCAE document ED-12B).December 1992.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[21] IEC 61508: Parts 1-7, Functional safety: safety-related systems. 1998. (Part 3 is concerned with software).</p>
</div>
<div data-custom-style="Bibliography1">
<p>[22] ISO/IEC 15408: 1999 Information technology. Security techniques. Evaluation criteria for IT security.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[23] J Barnes, High Integrity Software - the SPARK Approach to Safety and Security. Addison-Wesley. 2002.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[25] Steve Christy, <em>Vulnerability Type Distributions in CVE</em>, V1.0, 2006/10/04</p>
</div>
<div data-custom-style="Bibliography1">
<p>[26] <em>ARIANE 5: Flight 501 Failure</em>, Report by the Inquiry Board, July 19, 1996 <a href="http://esamultimedia.esa.int/docs/esa-x-1819eng.pdf"><span data-custom-style="Hyperlink">http://esamultimedia.esa.int/docs/esa-x-1819eng.pdf</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[27] Hogaboom, Richard, <em>A Generic API Bit Manipulation in C</em>, Embedded Systems Programming, Vol 12, No 7, July 1999 <a href="http://www.embedded.com/1999/9907/9907feat2.htm"><span data-custom-style="Hyperlink">http://www.embedded.com/1999/9907/9907feat2.htm</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[28] Carlo Ghezzi and Mehdi Jazayeri, Programming Language Concepts, 3<sup>rd</sup> edition, ISBN-0-471-10426-4, John Wiley &amp; Sons, 1998</p>
</div>
<div data-custom-style="Bibliography1">
<p>[29] Lions, J. L. <a href="http://en.wikisource.org/wiki/Ariane_501_Inquiry_Board_report"><span data-custom-style="Hyperlink">ARIANE 5 Flight 501 Failure Report</span></a>. Paris, France: European Space Agency (ESA) &amp; National Center for Space Study (CNES) Inquiry Board, July 1996.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[30] Seacord, R. <em>Secure Coding in C and C++</em>. Boston, MA: Addison-Wesley, 2005. See <a href="http://www.cert.org/books/secure-coding"><span data-custom-style="Hyperlink">http://www.cert.org/books/secure-coding</span></a> for news and errata.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[31] John David N. Dionisio. Type Checking. <a href="http://myweb.lmu.edu/dondi/share/pl/type-checking-v02.pdf"><span data-custom-style="Hyperlink">http://myweb.lmu.edu/dondi/share/pl/type-checking-v02.pdf</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[32] MISRA Limited. "<a href="http://www.misra.org.uk/"><span data-custom-style="Hyperlink">MISRA C</span></a>: 2012 Guidelines for the Use of the C Language in Critical Systems." Warwickshire, UK: MIRA Limited, March 2013 (ISBN 978-1-906400-10-1 and 978-1-906400-11-8).</p>
</div>
<div data-custom-style="Bibliography1">
<p>[33] The Common Weakness Enumeration (CWE) Initiative, MITRE Corporation, (<a href="http://cwe.mitre.org/"><span data-custom-style="Hyperlink">http://cwe.mitre.org/</span></a>)</p>
</div>
<div data-custom-style="Bibliography1">
<p>[34] Goldberg, David, <em>What Every Computer Scientist Should Know About Floating-Point Arithmetic</em>, ACM Computing Surveys, vol 23, issue 1 (March 1991), ISSN 0360-0300, pp 5-48.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[35] IEEE Standards Committee 754. IEEE Standard for Binary Floating-Point Arithmetic, ANSI/IEEE Standard 754-2008. Institute of Electrical and Electronics Engineers, New York, 2008.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[36] Robert W. Sebesta, Concepts of Programming Languages, 8<sup>th</sup> edition, ISBN-13: 978-0-321-49362-0, ISBN-10: 0-321-49362-1, Pearson Education, Boston, MA, 2008</p>
</div>
<div data-custom-style="Bibliography1">
<p>[37] Bo Einarsson, ed. Accuracy and Reliability in Scientific Computing, SIAM, July 2005 <a href="http://www.nsc.liu.se/wg25/book"><span data-custom-style="Hyperlink">http://www.nsc.liu.se/wg25/book</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[38] GAO Report, Patriot <em>Missile Defense: Software Problem Led to System Failure at Dhahran, Saudi Arabia</em>, B-247094, Feb. 4, 1992, <a href="http://archive.gao.gov/t2pbat6/145960.pdf"><span data-custom-style="Hyperlink">http://archive.gao.gov/t2pbat6/145960.pdf</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[39] Robert Skeel, <em>Roundoff Error Cripples Patriot Missile</em>, SIAM News, Volume 25, Number 4, July 1992, page 11, <a href="http://www.siam.org/siamnews/general/patriot.htm"><span data-custom-style="HTML Typewriter"><u>http://www.siam.org/siamnews/general/patriot.htm</u></span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[40] CERT. <em>CERT C++ Secure Coding Standard</em>.  <a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637%20"><span data-custom-style="Hyperlink">https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637</span></a> (2009).</p>
</div>
<div data-custom-style="Bibliography1">
<p>[41] Holzmann, Garard J., Computer, vol. 39, no. 6, pp 95-97, Jun., 2006, <em>The Power of 10: Rules for Developing Safety-Critical Code</em></p>
</div>
<div data-custom-style="Bibliography1">
<p>[42] P. V. Bhansali, A systematic approach to identifying a safe subset for safety-critical software, ACM SIGSOFT Software Engineering Notes, v.28 n.4, July 2003</p>
</div>
<div data-custom-style="Bibliography1">
<p>[43] Ada 95 Quality and Style Guide, SPC-91061-CMC, version 02.01.01. Herndon, Virginia: Software Productivity Consortium, 1992. Available from: <a href="http://www.adaic.org/docs/95style/95style.pdf"><span data-custom-style="Hyperlink">http://www.adaic.org/docs/95style/95style.pdf</span></a></p>
</div>
<div data-custom-style="Bibliography1">
<p>[44] Ghassan, A., &amp; Alkadi, I. (2003). Application of a Revised DIT Metric to Redesign an OO Design. <em>Journal of Object Technology</em> , 127-134.</p>
</div>
<div data-custom-style="Bibliography1">
<p>[45] Subramanian, S., Tsai, W.-T., &amp; Rayadurgam, S. (1998). Design Constraint Violation Detection in Safety-Critical Systems. The 3rd IEEE International Symposium on High-Assurance Systems Engineering , 109 - 116.</p>
</div>
<p>[46] Lundqvist, K and Asplund, L., “<em>A Formal Model of a Run-Time Kernel for Ravenscar</em>”, The 6th International Conference on Real-Time Computing Systems and Applications – RTCSA 1999</p>
<p>[47] ISO/IEC TS 17961, <em>Information technology – Programming languages, their environments and system software interfaces – C secure coding rules</em></p>
<p>[48] GNU Project. GCC Bugs “Non-bugs” http://gcc.gnu.org/bugs.html#nonbugs_c (2009).</p>
<h1 id="index">Index</h1>
<div data-custom-style="Bibliography1">
<p>LHS (left-hand side), 22</p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>::: {custom-style=“footnote text”} <span data-custom-style="footnote reference"></span> This has been addressed by WG 14 in an optionally normative annex in the current working paper<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>::: {custom-style=“footnote text”} <span data-custom-style="footnote reference"></span> The first edition should not be used or quoted in this work.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
