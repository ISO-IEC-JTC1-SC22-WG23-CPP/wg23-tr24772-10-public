<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>parts/6.06.ConversionErrors-FLC.md</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">parts/6.06.ConversionErrors-FLC.md</h1>
</header>
<h2 id="FLC">6.6 Conversion Errors [FLC]</h2>
<h3 id="applicability-to-language">6.6.1 Applicability to language</h3>
<p>C++ includes some of the conversion mechanisms of C, as documented in TR 24772-3 clause 6.6.1.</p>
<p>C++ type conversion mechanisms differ from the mechanisms of C, as documented in ISO IEC 14882 Annex C. This subclause highlights those differences where C++ eliminates potential vulnerabilities found in C.</p>
<p>Because C++ allows function and operator overloading, the effect of implicit conversions provides an additional mechanism of failure, by selecting an unwanted overload during overload resolution due to one implicit conversion being favoured over another. This can influence failure modes with lookup as described in section <a href="#BJL">Namespace Issues [BJL]</a>.</p>
<p>In most expressions formed with operands of integral or unscoped enumeration type, <em>integral promotion</em> occurs before further implicit conversions happen. <em>Integral promotion</em> on unsigned types with a conversion rank smaller than <code class="sourceCode cpp"><span class="dt">int</span></code> converts these to the signed type <code class="sourceCode cpp"><span class="dt">int</span></code>. This means undefined behavior can occur due to signed integer arithmetic overflow when a programmer assumes unsigned arithmetic with modulo semantics to be happening. For example, the following code causes undefined behavior on a 32 bit machine:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">short</span> <span class="at">const</span> x = <span class="bn">0xfff0</span>;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout &lt;&lt; x * x; <span class="co">// signed integer overflow</span></span></code></pre></div>
<p>Implicit, i.e., automatic, conversions to a type <code>T</code> can be performed, for example, in the following situations:</p>
<ol type="a">
<li><p>If the declaration, <code class="sourceCode cpp">T t=e;</code>, is defined for some expression, <code>e</code>, and some invented variable, <code>t</code> [C++17, Clause 7 [conv], para 3];</p></li>
<li><p>In expressions involving operands of operators (e.g., <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, etc.) subject to the requirements of each operators' operands [C++17, Clause 7 [conv], para 2.1];</p></li>
<li><p>For example, the expression, <code>5 + 6.5</code>, has operands of type <code class="sourceCode cpp"><span class="dt">int</span></code> and <code class="sourceCode cpp"><span class="dt">double</span></code>. Per language rules, the integer operand will be implicitly converted to <code class="sourceCode cpp"><span class="dt">double</span></code>, i.e., the expression becomes <code class="sourceCode cpp"><span class="dt">double</span>(<span class="dv">5</span>) + <span class="fl">6.5</span></code>, i.e., <code>5.0 + 6.5</code>.</p></li>
<li><p>In boolean contexts, i.e., operands of logical operators or conditions of conditional operator and if or loop statements, contextual conversion to bool implicitly happens from arithmetic types, pointers and classes with a <code>operator bool()</code> conversion operator, even if the latter is declared as explicit. [C++17, Clause 7 [conv], para 4];</p></li>
<li><p>In the expression of a switch statement: the implicit conversion will be to an integral type [C++17, Clause 7 [conv], para 2.3];</p></li>
<li><p>In an expression that initializes an object (e.g., an argument to a function call, the expression in a return statement) [C++17, Clause 7 [conv], para 2.4];</p></li>
<li><p>When a non-<code class="sourceCode cpp"><span class="kw">explicit</span></code> class/struct/union constructor can be invoked on an object resulting in some desired type, <code>T</code>, from initial objects passed to the constructor; and</p></li>
<li><p>When a conversion operator has not been declared <code class="sourceCode cpp"><span class="kw">explicit</span></code>, it can be implicitly invoked on an object resulting in some desired type, <code>T</code>, from an initial type.</p></li>
</ol>
<p>Explicit conversions use one of the mechanisms provided by C++ through a type conversion operator (<code class="sourceCode cpp"><span class="kw">static_cast</span></code>, <code class="sourceCode cpp"><span class="kw">const_cast</span></code>, <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code>, <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code>), constructor notation with parentheses (e.g., <code class="sourceCode cpp"><span class="dt">double</span>(<span class="dv">42</span>)</code>) or braces(e.g., int{‘a’}), or a C-style cast (<code>(int)3.14</code>). The constructor notation with braces prevents narrowing conversions.</p>
<p>Unlike C++'s other cast notations, <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> relies on run-time type information generated by the compiler to ensure the requested conversion is valid. If it is not valid, then <code class="sourceCode cpp"><span class="kw">nullptr</span></code> is returned for pointer types, otherwise an exception is thrown. [C++17, Clause 8.2.7 [expr.dynamic.cast]] Thus, <code class="sourceCode cpp"><span class="kw">dynamic_cast</span></code> is safer to use when converting down a hierarchy where the base class has virtual member functions.</p>
<p>Implications of casting away <code class="sourceCode cpp"><span class="at">const</span></code> using <code>const_cast</code> are described in section <a href="#UJO">Modifying Constants [UJO]</a>.</p>
<p>Implicit casting to a class type occurs when a class has a constructor that can take a single parameter, as in the following example:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>      {<span class="kw">public</span>:</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        C(<span class="dt">int</span> x=<span class="dv">10</span>, <span class="dt">float</span> y=<span class="dv">0</span>){...}}</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>      };</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo(C param){...}</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>...  foo(<span class="dv">21</span>); ...</span></code></pre></div>
<p>The call to <code class="sourceCode cpp">foo</code> requires a parameter of type <code class="sourceCode cpp">C</code>, but is provided with an int. However, as <code class="sourceCode cpp">C</code> has a constructor that can take an <code class="sourceCode cpp"><span class="dt">int</span></code> parameter (the float parameter is ignored because it has a default value), a temporary object of type <code class="sourceCode cpp">C</code> is constructed using <code class="sourceCode cpp"><span class="dv">21</span></code> as the <code class="sourceCode cpp">x</code> parameter. This is passed to <code class="sourceCode cpp">foo</code>. The temporary object is destroyed when foo returns.</p>
<p>Note that this implicit conversion to a class object is the default behavior of constructors that can be called with a single parameter. To prevent this happening, the keyword <code class="sourceCode cpp"><span class="kw">explicit</span></code> is used before the constructor, as in:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">explicit</span> C(<span class="dt">int</span> x=<span class="dv">10</span>, <span class="dt">float</span> y=<span class="dv">0</span>){...}</span></code></pre></div>
<p>The call <code class="sourceCode cpp">foo(<span class="dv">21</span>)</code> would now not be legal.</p>
<p>All other conversions are not necessarily "safe" as they can sometimes yield to data loss or erroneous values. This is an issue with implicit conversions since they are automatic: the programmer does not explicitly write code to do the conversion. For example, a common problem is mixing signed and unsigned integral types in arithmetic expressions. This can become a problem since the ranges of signed and unsigned integer types differ and the behavior of signed integer arithmetic on overflow is undefined whereas unsigned integer arithmetic wraps on overflow.</p>
<p>Additional problems arise as a result of implicit conversions to and from <code>bool</code> of arithmetic types, thus hiding the fact when a wrong operator symbol is used accidentally:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f(<span class="dt">unsigned</span> i, <span class="dt">unsigned</span> j)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (i &gt; <span class="dv">1</span>) &amp; (j = <span class="dv">1</span>); <span class="co">// (&gt;&gt;, &amp;&amp;, ==) ?</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In the example above, all combinations of the corresponding operators will compile with different resulting types and results.</p>
<p>The implicit conversions and multitude of possible operations of integral types can be mitigated by using scoped enumeration types with the corresponding integer type as its underlying type. For example, <code class="sourceCode cpp"><span class="bu">std::</span>byte</code> is defined to address individual <code class="sourceCode cpp"><span class="dt">unsigned</span> <span class="dt">char</span></code> elements (bytes) in memory without participating in arithmetic or bitwise operations. User-defined scoped enumerations can define corresponding operator overloads to sidestep implicit conversion of the built-in integral types and eliminate the risks of unwanted mixing of signed and unsigned operands as well as avoiding unwanted conversions.</p>
<h3 id="guidance-to-language-users">6.6.2 Guidance to language users</h3>
<p>In addition to the general advice of TR 24772-1 clause 6.6.5:</p>
<ul>
<li><p>Avoid casts (see C++ Core guidelines ES.48), treat every cast as a candidate for refactoring.</p></li>
<li><p>Avoid narrowing conversions. (see C++ Core Guidelines ES.46)</p></li>
<li><p>Prefer braces over parentheses for initialization or explicit conversions for numeric types to prevent narrowing. (see C++ Core Guidelines ES.23 and ES.64)</p></li>
<li><p>Prefer C++ type conversion operators over C-style casts, as they document intent and disallow some unsafe conversions. (see C++ Core Guidelines ES.49)</p></li>
<li><p>Declare constructors of a class that can be called with a single argument and conversion operators with the keyword ‘explicit’{.cpp}. (see C++ Core guidelines C.46 and C.164)</p></li>
<li><p>Don’t cast away <code class="sourceCode cpp"><span class="at">const</span></code>. See section<a href="#UJO">Modifying Constants [UJO]</a><br />
(see C++ Core Guidelines ES.50)</p></li>
<li><p>Don’t mix signed and unsigned arithmetic (see C++ Core Guidelines ES100)</p></li>
<li><p>Don’t rely on implicit conversions between arithmetic types and <code>bool</code>.</p></li>
<li><p>Use <em>strong types</em> (see section <a href="#IHN">Type System [IHN]</a> and scoped enumerations with corresponding operator overloads to limit implicit conversions and unwanted operations.</p></li>
</ul>
</body>
</html>
