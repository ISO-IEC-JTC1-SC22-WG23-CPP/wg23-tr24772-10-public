<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>parts/6.05.EnumeratorIssues-CCB.md</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">parts/6.05.EnumeratorIssues-CCB.md</h1>
</header>
<h2 id="CCB">6.5 Enumerator Issues [CCB]</h2>
<h3 id="applicability-to-language">6.5.1 Applicability to language</h3>
<h4 id="references">6.5.1.1 References</h4>
<p>AUTOSAR A7-2-2 Enumeration base type shall be explicitly defined</p>
<h4 id="applicability">6.5.1.2 Applicability</h4>
<p>The vulnerability documented in ISO IEC 24772-1 clause 6.5 applies to C++. C++ offers alternative mechanims for the C-based definition and use of enums for defining distinct types composed of sets of related named constants.</p>
<p>The type of each enum is different from all other types. Each enum has an underlying integral type, which the user can specify. Since enums are distinct types, the user can only assign values to an object of enumerated type that are values of that enumerated type. C++ does not support implicit conversion of an int to an enum, therefore preventing <code>A = B + C</code> where <code>A</code>, <code>B</code> and <code>C</code> are variables of the same enum, unless an overloaded operator “<code>+</code>” is provided.</p>
<p>C++ enums can be scoped (<code>enum class</code>) or unscoped (<code>enum</code>). C++ supports implicit conversion of an unscoped enum to an integer by integral promotion</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Color : <span class="dt">short</span> {red, green, blue};</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">short</span> i = red; <span class="co">// implicit conversion</span></span></code></pre></div>
<p>C++ does not support implicit conversion of a scoped enum to an int, hence, operations such as <code>++</code>, <code>+</code>, <code>&lt;</code> and enums used as array indices require explicit definitions.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> Color : <span class="dt">short</span> {red, green, blue};</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">short</span> i = red; <span class="co">// error -- no implicit conversion</span></span></code></pre></div>
<p>Where unscoped enums are used as array indexes and do not have a user-specified mapping to an underlying representation, there will be “holes” as documented in TR24772-1 clause 6.6.</p>
<p>Note that unscoped enumeration types implicitly promote their underlying type and can be used as the index of an array without a cast, with all of the issues described in TR 24772-1 clause 6.5.</p>
<p>From C++ 2017 forward, casting a value to an enumeration type is undefined behavior unless the source value is within the range of values of an enumeration type. See CERT INT50-CPP.</p>
<h3 id="avoidance-mechanisms-for-language-users">6.5.2 Avoidance mechanisms for language users</h3>
<p>C++ software developers can avoid the vulnerability or mitigate its ill effects in the following ways. They can:</p>
<ul>
<li><p>Use <em>scoped enumerations</em> in preference to the C-style <em>unscoped enumerations</em> for related values, especially at namespace-level.</p>
<ul>
<li><pre><code>  See CPP Core Guidelines Enum.3 &quot;Prefer class enums over &#39;plain&#39;</code></pre>
<p>enums".</p></li>
<li><pre><code>  See AUTOSAR A7-2-3 &quot;Enumerations shall be declared as scoped</code></pre>
<p>enum classes"</p></li>
<li><pre><code>  See MISRA C++ 28.5.5</code></pre></li>
</ul></li>
<li><p>Use <code class="sourceCode cpp"><span class="kw">constexpr</span></code> to declare a set of unrelated values, such as <code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">size_t</span> bufferLen = <span class="dv">128</span>;</code> <code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">char</span> special_char = <span class="ch">&#39;a&#39;</span>;</code></p></li>
<li><p>Provide operators and functions that perform the arithmetic operations and conversions appropriate to the enumerated type. Outside those functions, avoid directly performing arithmetic or conversions on objects of the enumerated type.</p>
<ul>
<li><pre><code>  See CPP Core Guidelines Enum.4 &quot;Define operations on</code></pre>
enumerations for safe and simple use"</li>
</ul></li>
<li><p>If <em>unscoped enumerations</em> are used, follow the general advice of TR 24772-3 clause 6.5.2 as well as the following:</p>
<ul>
<li><pre><code>  Avoid casting arbitrary integer values to enumeration type. If it is</code></pre>
<p>unavoidable, use braced initialization instead of C-style or static casts<br />
<code>e_type{7};</code></p>
<pre><code>  &gt; See CERT INT50-CPP &quot;Do no Cast to an out-of-range-value&quot;</code></pre></li>
</ul></li>
<li><pre><code>Obtain the underlying enumeration value, by casting the enumeration</code></pre>
<p>to its underlying type, e.g.,</p>
<blockquote>
<p><code class="sourceCode cpp"><span class="kw">enum</span> <span class="dt">e_type</span>{A, B, C};</code></p>
</blockquote>
<blockquote>
<p><code class="sourceCode cpp"><span class="kw">auto</span> value = <span class="kw">static_cast</span>\&lt;<span class="bu">std::</span>underlying_type_t<span class="bu">\</span>&lt;<span class="dt">e_type</span>\&gt;\&gt;(B);</code></p>
</blockquote></li>
</ul>
</body>
</html>
